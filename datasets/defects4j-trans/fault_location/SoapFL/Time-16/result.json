{
    "buggy_classes": [
        "org.joda.time.format.DateTimeParserBucket"
    ],
    "buggy_methods": [
        {
            "method_name": "org.joda.time.format.DateTimeParserBucket::computeMillis(boolean,String)",
            "method_code": "```java\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iOffset != null) {\n            millis -= iOffset;\n        } else if (iZone != null) {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n\n```",
            "method_doc": " Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.  @param resetFields false by default, but when true, unsaved field values are cleared @param text optional text being parsed, to be included in any error message @return milliseconds since 1970-01-01T00:00:00Z @throws IllegalArgumentException if any field is out of range @since 1.3 ",
            "class_name": "org.joda.time.format.DateTimeParserBucket",
            "class_doc": " DateTimeParserBucket is an advanced class, intended mainly for parser implementations. It can also be used during normal parsing operations to capture more information about the parse. <p> This class allows fields to be saved in any order, but be physically set in a consistent order. This is useful for parsing against formats that allow field values to contradict each other. <p> Field values are applied in an order where the \"larger\" fields are set first, making their value less likely to stick.  A field is larger than another when it's range duration is longer. If both ranges are the same, then the larger field has the longer duration. If it cannot be determined which field is larger, then the fields are set in the order they were saved. <p> For example, these fields were saved in this order: dayOfWeek, monthOfYear, dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek. <p> DateTimeParserBucket is mutable and not thread-safe.  @since 1.0 ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All tests involve parsing operations** using `parseInto()` method with month-related patterns (\"M\" or \"M d\")\n2. **Year field is unexpectedly changing** from 2004 to 2000 in most failures\n3. **The failures occur specifically when parsing partial dates** (month-only or month-day without year)\n4. **The time, day, and timezone components are preserved correctly** - only the year is affected\n5. **Both with and without default year configurations** are failing\n\n## Root Cause Analysis:\n\nThe consistent pattern across all failures is that when parsing partial date information (month-only or month-day), the year component of the `MutableDateTime` is being reset to **2000** instead of preserving the original year (2004) or using the expected default year.\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **`DateTimeFormatter.parseInto()` method implementation**, specifically in the logic that handles partial date parsing. When parsing patterns that don't include year information, the method is incorrectly defaulting to year 2000 instead of:\n\n1. Preserving the original year from the input `MutableDateTime` object (as expected in tests 1, 3, 4, 5)\n2. Using the configured default year when available (as expected in test 2)\n\nThe bug likely resides in the date field resolution logic where missing fields are being populated with hardcoded defaults rather than respecting the existing date context or properly configured default values.\n\n**Specific area to investigate**: The production code responsible for filling in missing date fields during partial parsing, particularly the year field initialization logic when year is not specified in the parsed pattern.",
            "test_suite": "org.joda.time.format.TestDateTimeFormatter",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it contains logic that automatically adds a default year field when the first parsed field is a month or day, which directly explains why the year is being reset to 2000 (iDefaultYear) instead of preserving the original year from the MutableDateTime. The recursive call to computeMillis after adding the year field causes the year to override the existing year value, matching exactly the pattern observed in all test failures."
        },
        {
            "method_name": "org.joda.time.format.DateTimeParserBucket$SavedField::set(long,boolean)",
            "method_code": "```java\n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n\n```",
            "method_doc": "Sets the field value on the given milliseconds, optionally resetting to the field's floor value, handling both numeric and text values.",
            "class_name": "org.joda.time.format.DateTimeParserBucket",
            "class_doc": " DateTimeParserBucket is an advanced class, intended mainly for parser implementations. It can also be used during normal parsing operations to capture more information about the parse. <p> This class allows fields to be saved in any order, but be physically set in a consistent order. This is useful for parsing against formats that allow field values to contradict each other. <p> Field values are applied in an order where the \"larger\" fields are set first, making their value less likely to stick.  A field is larger than another when it's range duration is longer. If both ranges are the same, then the larger field has the longer duration. If it cannot be determined which field is larger, then the fields are set in the order they were saved. <p> For example, these fields were saved in this order: dayOfWeek, monthOfYear, dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek. <p> DateTimeParserBucket is mutable and not thread-safe.  @since 1.0 ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All tests involve parsing operations** using `parseInto()` method with month-related patterns (\"M\" or \"M d\")\n2. **Year field is unexpectedly changing** from 2004 to 2000 in most failures\n3. **The failures occur specifically when parsing partial dates** (month-only or month-day without year)\n4. **The time, day, and timezone components are preserved correctly** - only the year is affected\n5. **Both with and without default year configurations** are failing\n\n## Root Cause Analysis:\n\nThe consistent pattern across all failures is that when parsing partial date information (month-only or month-day), the year component of the `MutableDateTime` is being reset to **2000** instead of preserving the original year (2004) or using the expected default year.\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **`DateTimeFormatter.parseInto()` method implementation**, specifically in the logic that handles partial date parsing. When parsing patterns that don't include year information, the method is incorrectly defaulting to year 2000 instead of:\n\n1. Preserving the original year from the input `MutableDateTime` object (as expected in tests 1, 3, 4, 5)\n2. Using the configured default year when available (as expected in test 2)\n\nThe bug likely resides in the date field resolution logic where missing fields are being populated with hardcoded defaults rather than respecting the existing date context or properly configured default values.\n\n**Specific area to investigate**: The production code responsible for filling in missing date fields during partial parsing, particularly the year field initialization logic when year is not specified in the parsed pattern.",
            "test_suite": "org.joda.time.format.TestDateTimeFormatter",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it directly handles field value setting during date parsing operations. The method processes both numeric and text field values and applies rounding logic, which could explain why the year is being incorrectly reset to 2000 when parsing partial dates. The reset parameter and roundFloor operation may be causing unintended year changes when month or day fields are set without preserving the original year context."
        },
        {
            "method_name": "org.joda.time.format.DateTimeParserBucket::saveField(DateTimeFieldType,int)",
            "method_code": "```java\n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n\n```",
            "method_doc": " Saves a datetime field value.  @param fieldType  the field type @param value  the value ",
            "class_name": "org.joda.time.format.DateTimeParserBucket",
            "class_doc": " DateTimeParserBucket is an advanced class, intended mainly for parser implementations. It can also be used during normal parsing operations to capture more information about the parse. <p> This class allows fields to be saved in any order, but be physically set in a consistent order. This is useful for parsing against formats that allow field values to contradict each other. <p> Field values are applied in an order where the \"larger\" fields are set first, making their value less likely to stick.  A field is larger than another when it's range duration is longer. If both ranges are the same, then the larger field has the longer duration. If it cannot be determined which field is larger, then the fields are set in the order they were saved. <p> For example, these fields were saved in this order: dayOfWeek, monthOfYear, dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek. <p> DateTimeParserBucket is mutable and not thread-safe.  @since 1.0 ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All tests involve parsing operations** using `parseInto()` method with month-related patterns (\"M\" or \"M d\")\n2. **Year field is unexpectedly changing** from 2004 to 2000 in most failures\n3. **The failures occur specifically when parsing partial dates** (month-only or month-day without year)\n4. **The time, day, and timezone components are preserved correctly** - only the year is affected\n5. **Both with and without default year configurations** are failing\n\n## Root Cause Analysis:\n\nThe consistent pattern across all failures is that when parsing partial date information (month-only or month-day), the year component of the `MutableDateTime` is being reset to **2000** instead of preserving the original year (2004) or using the expected default year.\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **`DateTimeFormatter.parseInto()` method implementation**, specifically in the logic that handles partial date parsing. When parsing patterns that don't include year information, the method is incorrectly defaulting to year 2000 instead of:\n\n1. Preserving the original year from the input `MutableDateTime` object (as expected in tests 1, 3, 4, 5)\n2. Using the configured default year when available (as expected in test 2)\n\nThe bug likely resides in the date field resolution logic where missing fields are being populated with hardcoded defaults rather than respecting the existing date context or properly configured default values.\n\n**Specific area to investigate**: The production code responsible for filling in missing date fields during partial parsing, particularly the year field initialization logic when year is not specified in the parsed pattern.",
            "test_suite": "org.joda.time.format.TestDateTimeFormatter",
            "score": 8,
            "reason": "#8# The saveField method is highly suspicious because it's responsible for storing parsed field values, and the test failures consistently show year values being incorrectly set to 2000 when parsing partial dates. Since this method handles how field values are saved during parsing operations, any bug in how it processes or prioritizes year-related fields could explain why the year is being reset incorrectly instead of preserving the original year or using configured defaults."
        },
        {
            "method_name": "org.joda.time.format.DateTimeParserBucket::DateTimeParserBucket(long,Chronology,Locale,Integer,int)",
            "method_code": "```java\n    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iZone = chrono.getZone();\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n```",
            "method_doc": " Constructs a bucket, with the option of specifying the pivot year for two-digit year parsing.  @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time @param chrono  the chronology to use @param locale  the locale to use @param pivotYear  the pivot year to use when parsing two-digit years @since 2.0 ",
            "class_name": "org.joda.time.format.DateTimeParserBucket",
            "class_doc": " DateTimeParserBucket is an advanced class, intended mainly for parser implementations. It can also be used during normal parsing operations to capture more information about the parse. <p> This class allows fields to be saved in any order, but be physically set in a consistent order. This is useful for parsing against formats that allow field values to contradict each other. <p> Field values are applied in an order where the \"larger\" fields are set first, making their value less likely to stick.  A field is larger than another when it's range duration is longer. If both ranges are the same, then the larger field has the longer duration. If it cannot be determined which field is larger, then the fields are set in the order they were saved. <p> For example, these fields were saved in this order: dayOfWeek, monthOfYear, dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek. <p> DateTimeParserBucket is mutable and not thread-safe.  @since 1.0 ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All tests involve parsing operations** using `parseInto()` method with month-related patterns (\"M\" or \"M d\")\n2. **Year field is unexpectedly changing** from 2004 to 2000 in most failures\n3. **The failures occur specifically when parsing partial dates** (month-only or month-day without year)\n4. **The time, day, and timezone components are preserved correctly** - only the year is affected\n5. **Both with and without default year configurations** are failing\n\n## Root Cause Analysis:\n\nThe consistent pattern across all failures is that when parsing partial date information (month-only or month-day), the year component of the `MutableDateTime` is being reset to **2000** instead of preserving the original year (2004) or using the expected default year.\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **`DateTimeFormatter.parseInto()` method implementation**, specifically in the logic that handles partial date parsing. When parsing patterns that don't include year information, the method is incorrectly defaulting to year 2000 instead of:\n\n1. Preserving the original year from the input `MutableDateTime` object (as expected in tests 1, 3, 4, 5)\n2. Using the configured default year when available (as expected in test 2)\n\nThe bug likely resides in the date field resolution logic where missing fields are being populated with hardcoded defaults rather than respecting the existing date context or properly configured default values.\n\n**Specific area to investigate**: The production code responsible for filling in missing date fields during partial parsing, particularly the year field initialization logic when year is not specified in the parsed pattern.",
            "test_suite": "org.joda.time.format.TestDateTimeFormatter",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed, because it initializes the iDefaultYear field which is being incorrectly used as 2000 in all the failing tests. The constructor receives a defaultYear parameter and stores it in iDefaultYear, and based on the test failures where the year consistently changes to 2000 instead of preserving the original year or using the configured default year, this suggests that the defaultYear value being passed to this constructor is incorrectly set to 2000 when it should be using the original year from the MutableDateTime or the properly configured default year."
        }
    ],
    "buggy_codes": {
        "org.joda.time.format.DateTimeParserBucket::computeMillis(boolean,String)": {
            "method_name": "org.joda.time.format.DateTimeParserBucket::computeMillis(boolean,String)",
            "method_code": "```java\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n            if (resetFields) {\n                for (int i = 0; i < count; i++) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n        \n        if (iOffset != null) {\n            millis -= iOffset;\n        } else if (iZone != null) {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }\n\n```",
            "method_doc": " Computes the parsed datetime by setting the saved fields. This method is idempotent, but it is not thread-safe.  @param resetFields false by default, but when true, unsaved field values are cleared @param text optional text being parsed, to be included in any error message @return milliseconds since 1970-01-01T00:00:00Z @throws IllegalArgumentException if any field is out of range @since 1.3 "
        },
        "org.joda.time.format.DateTimeParserBucket$SavedField::set(long,boolean)": {
            "method_name": "org.joda.time.format.DateTimeParserBucket$SavedField::set(long,boolean)",
            "method_code": "```java\n        long set(long millis, boolean reset) {\n            if (iText == null) {\n                millis = iField.set(millis, iValue);\n            } else {\n                millis = iField.set(millis, iText, iLocale);\n            }\n            if (reset) {\n                millis = iField.roundFloor(millis);\n            }\n            return millis;\n        }\n\n```",
            "method_doc": "Sets the field value on the given milliseconds, optionally resetting to the field's floor value, handling both numeric and text values."
        },
        "org.joda.time.format.DateTimeParserBucket::saveField(DateTimeFieldType,int)": {
            "method_name": "org.joda.time.format.DateTimeParserBucket::saveField(DateTimeFieldType,int)",
            "method_code": "```java\n    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }\n\n```",
            "method_doc": " Saves a datetime field value.  @param fieldType  the field type @param value  the value "
        },
        "org.joda.time.format.DateTimeParserBucket::DateTimeParserBucket(long,Chronology,Locale,Integer,int)": {
            "method_name": "org.joda.time.format.DateTimeParserBucket::DateTimeParserBucket(long,Chronology,Locale,Integer,int)",
            "method_code": "```java\n    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iZone = chrono.getZone();\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }\n\n```",
            "method_doc": " Constructs a bucket, with the option of specifying the pivot year for two-digit year parsing.  @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time @param chrono  the chronology to use @param locale  the locale to use @param pivotYear  the pivot year to use when parsing two-digit years @since 2.0 "
        }
    }
}