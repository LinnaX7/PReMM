{
    "buggy_classes": [
        "org.apache.commons.math.optimization.direct.BOBYQAOptimizer"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::prelim(double[],double[])",
            "method_code": "```java\n    private void prelim(double[] TransVarUpperBound,\n                        double[] TransVarLowerBound) {\n        if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n        printMethod(); // XXX\n\n        final int TransVarDimension = currentBest.getDimension();\n        final int TransVarNumberOfPoints = numberOfInterpolationPoints;\n        final int TransVarRows = bMatrix.getRowDimension();\n\n        final double TransVarTrustRegionRadiusSquared = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double TransVarReciprocalRhosq = 1d / TransVarTrustRegionRadiusSquared;\n        final int TransVarN2 = TransVarDimension + 1;\n\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n        int TransVarI = 0;\n        while (!(!(TransVarI < TransVarDimension))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            originShift.setEntry(TransVarI, currentBest.getEntry(TransVarI));\n            int TransVarIndex = 0;\n            while (!(!(TransVarIndex < TransVarNumberOfPoints))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n            }\n                interpolationPoints.setEntry(TransVarIndex, TransVarI, ZERO);\n                TransVarIndex++;\n        }\n            int TransVarIi = 0;\n            while (!(!(TransVarIi < TransVarRows))) {\n                bMatrix.setEntry(TransVarIi, TransVarI, ZERO);\n                TransVarIi++;\n        }\n            TransVarI++;\n            }\n        int TransVarCount = 0, TransVarMaxPoints = TransVarDimension * TransVarN2 / 2;\n        while (!(!(TransVarCount < TransVarMaxPoints))) {\n            modelSecondDerivativesValues.setEntry(TransVarCount, ZERO);\n            TransVarCount++;\n        }\n        int TransVarNewK = 0;\n        while (!(!(TransVarNewK < TransVarNumberOfPoints))) {\n            modelSecondDerivativesParameters.setEntry(TransVarNewK, ZERO);\n            int TransVarJj = 0, TransVarMaxNumberOfPoints = TransVarNumberOfPoints - TransVarN2;\n            while (!(!(TransVarJj < TransVarMaxNumberOfPoints))) {\n                zMatrix.setEntry(TransVarNewK, TransVarJj, ZERO);\n                TransVarJj++;\n            }\n            TransVarNewK++;\n        }\n\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n        int TransVarIp = 0;\n        int TransVarIpt = 0;\n        double TransVarBeg = Double.NaN;\n        do {\n            final int TransVarEvaluations = getEvaluations();\n            final int TransVarNf = TransVarEvaluations - TransVarDimension;\n            final int TransVarNfmmm = TransVarEvaluations - 1;\n            final int TransVarNfx = TransVarNf - 1;\n            double TransVarStep = 0;\n            double TransVarStepa = 0;\n            if (!(!(TransVarEvaluations <= 2 * TransVarDimension))) {\n                if (!(!(TransVarEvaluations >= 1 && TransVarEvaluations <= TransVarDimension))) {\n                    TransVarStep = initialTrustRegionRadius;\n                    if (!(!(upperDifference.getEntry(TransVarNfmmm) == ZERO))) {\n                        TransVarStep = -TransVarStep;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(TransVarEvaluations, TransVarNfmmm, TransVarStep);\n                } else if (!(!(TransVarEvaluations > TransVarDimension))) {\n                    TransVarStep = interpolationPoints.getEntry(TransVarNf, TransVarNfx);\n                    TransVarStepa = -initialTrustRegionRadius;\n                    if (!(!(lowerDifference.getEntry(TransVarNfx) == ZERO))) {\n                        TransVarStepa = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(TransVarNfx));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (!(!(upperDifference.getEntry(TransVarNfx) == ZERO))) {\n                        TransVarStepa = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(TransVarNfx));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(TransVarEvaluations, TransVarNfx, TransVarStepa);\n                }\n            } else {\n                final int TransVarTmp2 = (TransVarEvaluations - TransVarN2) / TransVarDimension;\n                TransVarIpt = TransVarEvaluations - TransVarTmp2 * TransVarDimension - TransVarDimension;\n                TransVarIp = TransVarIpt + TransVarTmp2;\n                if (!(!(TransVarIp > TransVarDimension))) {\n                    final int TransVarTmp = TransVarIpt;\n                    TransVarIpt = TransVarIp - TransVarDimension;\n                    TransVarIp = TransVarTmp;\n                    throw new PathIsExploredException(); // XXX\n                }\n                final int TransVarIMinus1 = TransVarIp;\n                final int TransVarJpt = TransVarIpt;\n                interpolationPoints.setEntry(TransVarEvaluations, TransVarIMinus1, interpolationPoints.getEntry(TransVarIp, TransVarIMinus1));\n                interpolationPoints.setEntry(TransVarEvaluations, TransVarJpt, interpolationPoints.getEntry(TransVarIpt, TransVarJpt));\n            }\n\n            // Calculate the next value of F. The least function value so far and\n            // its index are required.\n\n            int TransVarJ1 = 0;\n            while (!(!(TransVarJ1 < TransVarDimension))) {\n                currentBest\n                        .setEntry(TransVarJ1,\n                                Math.min(\n                                        Math.max(TransVarUpperBound[TransVarJ1],\n                                                originShift.getEntry(TransVarJ1) + interpolationPoints\n                                                        .getEntry(TransVarEvaluations, TransVarJ1)),\n                                        TransVarLowerBound[TransVarJ1]));\n                if (!(!(interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1) == lowerDifference\n                        .getEntry(TransVarJ1)))) {\n                    currentBest.setEntry(TransVarJ1, TransVarUpperBound[TransVarJ1]);\n                }\n                if (!(!(interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1) == upperDifference\n                        .getEntry(TransVarJ1)))) {\n                    currentBest.setEntry(TransVarJ1, TransVarLowerBound[TransVarJ1]);\n                }\n                TransVarJ1++;\n            }\n\n            final double TransVarValue = computeObjectiveValue(currentBest.toArray());\n            final double TransVarMaximization = isMinimize ? TransVarValue : -TransVarValue;\n            final int TransVarNum = getEvaluations(); // nfm + 1\n            fAtInterpolationPoints.setEntry(TransVarEvaluations, TransVarMaximization);\n\n            if (!(!(TransVarNum == 1))) {\n                TransVarBeg = TransVarMaximization;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (!(!(TransVarMaximization < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)))) {\n                trustRegionCenterInterpolationPointIndex = TransVarEvaluations;\n            }\n\n            // Set the nonzero initial elements of BMAT and the quadratic model in the\n            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n            // order that the function value at the first of them contributes to the\n            // off-diagonal second derivative terms of the initial quadratic model.\n\n            if (!(!(TransVarNum <= 2 * TransVarDimension + 1))) {\n                if (!(!(TransVarNum >= 2 && TransVarNum <= TransVarDimension + 1))) {\n                    gradientAtTrustRegionCenter.setEntry(TransVarNfmmm, (TransVarMaximization - TransVarBeg) / TransVarStep);\n                    if (!(!(TransVarNumberOfPoints < TransVarNum + TransVarDimension))) {\n                        final double TransVarOos = ONE / TransVarStep;\n                        bMatrix.setEntry(0, TransVarNfmmm, -TransVarOos);\n                        bMatrix.setEntry(TransVarEvaluations, TransVarNfmmm, TransVarOos);\n                        bMatrix.setEntry(TransVarNumberOfPoints + TransVarNfmmm, TransVarNfmmm, -HALF * TransVarTrustRegionRadiusSquared);\n                        throw new PathIsExploredException(); // XXX\n                    }\n                } else if (!(!(TransVarNum >= TransVarDimension + 2))) {\n                    final int TransVarIj = TransVarNf * (TransVarNf + 1) / 2 - 1;\n                    final double TransVarFNew = (TransVarMaximization - TransVarBeg) / TransVarStepa;\n                    final double TransVarH = TransVarStepa - TransVarStep;\n                    modelSecondDerivativesValues.setEntry(TransVarIj, TWO * (TransVarFNew - gradientAtTrustRegionCenter.getEntry(TransVarNfx)) / TransVarH);\n                    gradientAtTrustRegionCenter.setEntry(TransVarNfx, (gradientAtTrustRegionCenter.getEntry(TransVarNfx) * TransVarStepa - TransVarFNew * TransVarStep) / TransVarH);\n                    if (!(!(TransVarStep * TransVarStepa < ZERO))) {\n                        if (!(!(TransVarMaximization < fAtInterpolationPoints\n                                .getEntry(TransVarEvaluations - TransVarDimension)))) {\n                            fAtInterpolationPoints.setEntry(TransVarEvaluations, fAtInterpolationPoints.getEntry(TransVarEvaluations - TransVarDimension));\n                            fAtInterpolationPoints.setEntry(TransVarEvaluations - TransVarDimension, TransVarMaximization);\n                            if (!(!(trustRegionCenterInterpolationPointIndex == TransVarEvaluations))) {\n                                trustRegionCenterInterpolationPointIndex = TransVarEvaluations - TransVarDimension;\n                            }\n                            interpolationPoints.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx, TransVarStepa);\n                            interpolationPoints.setEntry(TransVarEvaluations, TransVarNfx, TransVarStep);\n                        }\n                    }\n                    bMatrix.setEntry(0, TransVarNfx, -(TransVarStep + TransVarStepa) / (TransVarStep * TransVarStepa));\n                    bMatrix.setEntry(TransVarEvaluations, TransVarNfx, -HALF / interpolationPoints.getEntry(TransVarEvaluations - TransVarDimension, TransVarNfx));\n                    bMatrix.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx,\n                                  -bMatrix.getEntry(0, TransVarNfx) - bMatrix.getEntry(TransVarEvaluations, TransVarNfx));\n                    zMatrix.setEntry(0, TransVarNfx, Math.sqrt(TWO) / (TransVarStep * TransVarStepa));\n                    zMatrix.setEntry(TransVarEvaluations, TransVarNfx, Math.sqrt(HALF) / TransVarTrustRegionRadiusSquared);\n                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    zMatrix.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx,\n                                  -zMatrix.getEntry(0, TransVarNfx) - zMatrix.getEntry(TransVarEvaluations, TransVarNfx));\n                }\n\n                // Set the off-diagonal second derivatives of the Lagrange functions and\n                // the initial quadratic model.\n\n            } else {\n                zMatrix.setEntry(0, TransVarNfx, TransVarReciprocalRhosq);\n                zMatrix.setEntry(TransVarEvaluations, TransVarNfx, TransVarReciprocalRhosq);\n                zMatrix.setEntry(TransVarIp, TransVarNfx, -TransVarReciprocalRhosq);\n                zMatrix.setEntry(TransVarIpt, TransVarNfx, -TransVarReciprocalRhosq);\n\n                final int TransVarIpIndex = TransVarIp * (TransVarIp - 1) / 2 + TransVarIpt - 1;\n                final double TransVarTemp = interpolationPoints.getEntry(TransVarEvaluations, TransVarIp - 1) * interpolationPoints.getEntry(TransVarEvaluations, TransVarIpt - 1);\n                modelSecondDerivativesValues.setEntry(TransVarIpIndex, (TransVarBeg - fAtInterpolationPoints.getEntry(TransVarIp) - fAtInterpolationPoints.getEntry(TransVarIpt) + TransVarMaximization) / TransVarTemp);\n                throw new PathIsExploredException(); // XXX\n            }\n        } while (!(!(getEvaluations() < TransVarNumberOfPoints)));\n    } // prelim\n\n```",
            "method_doc": " SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, BMAT and ZMAT for the first iteration, and it maintains the values of NF and KOPT. The vector X is also changed by PRELIM.  The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the same as the corresponding arguments in SUBROUTINE BOBYQA. The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU are the same as the corresponding arguments in BOBYQB, the elements of SL and SU being set in BOBYQA. GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but it is set by PRELIM to the gradient of the quadratic model at XBASE. If XOPT is nonzero, BOBYQB will change it to its usual value later. NF is maintaned as the number of calls of CALFUN so far. KOPT will be such that the least calculated value of F so far is at the point XPT(KOPT,.)+XBASE in the space of the variables.  @param lowerBound Lower bounds. @param upperBound Upper bounds. ",
            "class_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer",
            "class_doc": " Powell's BOBYQA algorithm. This implementation is translated and adapted from the Fortran version available <a href=\"http://plato.asu.edu/ftp/other_software/bobyqa.zip\">here</a>. See <a href=\"http://www.optimization-online.org/DB_HTML/2010/05/2616.html\"> this paper</a> for an introduction. <br/> BOBYQA is particularly well suited for high dimensional problems where derivatives are not available. In most cases it outperforms the {@link PowellOptimizer} significantly. Stochastic algorithms like {@link CMAESOptimizer} succeed more often than BOBYQA, but are more expensive. BOBYQA could also be considered as a replacement of any derivative-based optimizer when the derivatives are approximated by finite differences.  @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Patterns\n\n**Test Behavior Pattern:**\n- The test fails when the number of additional interpolation points exceeds 47 (i.e., total interpolation points > 48)\n- The failure occurs specifically in constrained optimization scenarios\n- The test comment mentions there should be a hard limit of 78 interpolation points, but failures occur much earlier\n\n**Stack Trace Pattern:**\n- The exception originates from `BOBYQAOptimizer.prelim()` at line 1780\n- The exception type is `PathIsExploredException`, which appears to be a debugging aid\n- The stack trace shows the failure occurs during the preliminary phase of the optimization algorithm\n\n## Step 2: Identify the Root Cause\n\nThe key insight comes from understanding the relationship between:\n- **Problem dimension (DIM = 9)**\n- **Interpolation points calculation**: `2*dim + 1 + additionalInterpolationPoints`\n- **Theoretical hard limit**: `((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) = 78`\n\nWhen `additionalInterpolationPoints = 48`:\n- Total interpolation points = `2*9 + 1 + 48 = 67`\n- This exceeds some internal constraint in the `prelim()` method\n\n## Step 3: Recommend Possible Production Code Defect\n\n**Defect Location**: `org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim()` method\n\n**Probable Cause**: The `prelim()` method contains incorrect bounds checking or array sizing logic that fails when the number of interpolation points exceeds a certain threshold that is **lower than the theoretical maximum**.\n\n**Specific Issues**:\n1. **Array Bounds Violation**: The method likely allocates arrays based on incorrect size calculations for interpolation points\n2. **Insufficient Validation**: Missing or incorrect validation of interpolation point count against internal constraints\n3. **Algorithmic Constraint**: The implementation may have a practical limit lower than the theoretical limit due to implementation details\n\n**Expected Behavior**: The optimizer should handle up to 78 interpolation points for this 9-dimensional problem, but fails at 67 points, indicating a ~14% reduction in the effective capacity.\n\nThe defect appears to be in the production code's handling of interpolation point allocation or validation within the preliminary setup phase of the BOBYQA algorithm.",
            "test_suite": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest",
            "score": 9,
            "reason": "#9# The method is highly suspicious because it contains multiple PathIsExploredException throws that appear to be debugging artifacts, and the test specifically fails when the number of interpolation points exceeds 47, which triggers a code path in prelim that throws one of these exceptions. The method handles interpolation point initialization and contains complex logic for managing point allocation that likely has incorrect bounds checking or array sizing when dealing with higher numbers of interpolation points."
        },
        {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::bobyqb(double[],double[])",
            "method_code": "```java\n    private double bobyqb(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int np = n + 1;\n        final int nptm = npt - np;\n        final int nh = n * np / 2;\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(npt);\n        final ArrayRealVector work3 = new ArrayRealVector(npt);\n\n        double cauchy = Double.NaN;\n        double alpha = Double.NaN;\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        // Set some constants.\n        // Parameter adjustments\n\n        // Function Body\n\n        // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n        // BMAT and ZMAT for the first iteration, with the corresponding values of\n        // of NF and KOPT, which are the number of calls of CALFUN so far and the\n        // index of the interpolation point at the trust region centre. Then the\n        // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n        // less than NPT. GOPT will be updated if KOPT is different from KBASE.\n\n        trustRegionCenterInterpolationPointIndex = 0;\n\n        prelim(lowerBound, upperBound);\n        double xoptsq = ZERO;\n        for (int i = 0; i < n; i++) {\n            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n            // Computing 2nd power\n            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n            xoptsq += deltaOne * deltaOne;\n        }\n        double fsave = fAtInterpolationPoints.getEntry(0);\n        final int kbase = 0;\n\n        // Complete the settings that are required for the iterative procedure.\n\n        int ntrits = 0;\n        int itest = 0;\n        int knew = 0;\n        int nfsav = getEvaluations();\n        double rho = initialTrustRegionRadius;\n        double delta = rho;\n        double diffa = ZERO;\n        double diffb = ZERO;\n        double diffc = ZERO;\n        double f = ZERO;\n        double beta = ZERO;\n        double adelt = ZERO;\n        double denom = ZERO;\n        double ratio = ZERO;\n        double dnorm = ZERO;\n        double scaden = ZERO;\n        double biglsq = ZERO;\n        double distsq = ZERO;\n\n        // Update GOPT if necessary before the first iteration and after each\n        // call of RESCUE that makes a call of CALFUN.\n\n        int state = 20;\n        for(;;) switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}\n    } // bobyqb\n\n```",
            "method_doc": " The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN are identical to the corresponding arguments in SUBROUTINE BOBYQA. XBASE holds a shift of origin that should reduce the contributions from rounding errors to values of the model and Lagrange functions. XPT is a two-dimensional array that holds the coordinates of the interpolation points relative to XBASE. FVAL holds the values of F at the interpolation points. XOPT is set to the displacement from XBASE of the trust region centre. GOPT holds the gradient of the quadratic model at XBASE+XOPT. HQ holds the explicit second derivatives of the quadratic model. PQ contains the parameters of the implicit second derivatives of the quadratic model. BMAT holds the last N columns of H. ZMAT holds the factorization of the leading NPT by NPT submatrix of H, this factorization being ZMAT times ZMAT^T, which provides both the correct rank and positive semi-definiteness. NDIM is the first dimension of BMAT and has the value NPT+N. SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. All the components of every XOPT are going to satisfy the bounds SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when XOPT is on a constraint boundary. XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the vector of variables for the next call of CALFUN. XNEW also satisfies the SL and SU constraints in the way that has just been mentioned. XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW in order to increase the denominator in the updating of UPDATE. D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. VLAG contains the values of the Lagrange functions at a new point X. They are part of a product that requires VLAG to be of length NDIM. W is a one-dimensional array that is used for working space. Its length must be at least 3*NDIM = 3*(NPT+N).  @param lowerBound Lower bounds. @param upperBound Upper bounds. @return the value of the objective at the optimum. ",
            "class_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer",
            "class_doc": " Powell's BOBYQA algorithm. This implementation is translated and adapted from the Fortran version available <a href=\"http://plato.asu.edu/ftp/other_software/bobyqa.zip\">here</a>. See <a href=\"http://www.optimization-online.org/DB_HTML/2010/05/2616.html\"> this paper</a> for an introduction. <br/> BOBYQA is particularly well suited for high dimensional problems where derivatives are not available. In most cases it outperforms the {@link PowellOptimizer} significantly. Stochastic algorithms like {@link CMAESOptimizer} succeed more often than BOBYQA, but are more expensive. BOBYQA could also be considered as a replacement of any derivative-based optimizer when the derivatives are approximated by finite differences.  @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Patterns\n\n**Test Behavior Pattern:**\n- The test fails when the number of additional interpolation points exceeds 47 (i.e., total interpolation points > 48)\n- The failure occurs specifically in constrained optimization scenarios\n- The test comment mentions there should be a hard limit of 78 interpolation points, but failures occur much earlier\n\n**Stack Trace Pattern:**\n- The exception originates from `BOBYQAOptimizer.prelim()` at line 1780\n- The exception type is `PathIsExploredException`, which appears to be a debugging aid\n- The stack trace shows the failure occurs during the preliminary phase of the optimization algorithm\n\n## Step 2: Identify the Root Cause\n\nThe key insight comes from understanding the relationship between:\n- **Problem dimension (DIM = 9)**\n- **Interpolation points calculation**: `2*dim + 1 + additionalInterpolationPoints`\n- **Theoretical hard limit**: `((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) = 78`\n\nWhen `additionalInterpolationPoints = 48`:\n- Total interpolation points = `2*9 + 1 + 48 = 67`\n- This exceeds some internal constraint in the `prelim()` method\n\n## Step 3: Recommend Possible Production Code Defect\n\n**Defect Location**: `org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim()` method\n\n**Probable Cause**: The `prelim()` method contains incorrect bounds checking or array sizing logic that fails when the number of interpolation points exceeds a certain threshold that is **lower than the theoretical maximum**.\n\n**Specific Issues**:\n1. **Array Bounds Violation**: The method likely allocates arrays based on incorrect size calculations for interpolation points\n2. **Insufficient Validation**: Missing or incorrect validation of interpolation point count against internal constraints\n3. **Algorithmic Constraint**: The implementation may have a practical limit lower than the theoretical limit due to implementation details\n\n**Expected Behavior**: The optimizer should handle up to 78 interpolation points for this 9-dimensional problem, but fails at 67 points, indicating a ~14% reduction in the effective capacity.\n\nThe defect appears to be in the production code's handling of interpolation point allocation or validation within the preliminary setup phase of the BOBYQA algorithm.",
            "test_suite": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest",
            "score": 8,
            "reason": "#8# The bobyqb method is highly suspicious because it contains the call to prelim() method where the PathIsExploredException is thrown, and the test failure occurs specifically when the number of interpolation points exceeds 47. The method handles the core optimization logic including interpolation point management, and the stack trace shows the failure path goes through bobyqb -> prelim. The issue appears to be related to how the method handles the increasing number of interpolation points beyond a certain threshold."
        },
        {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::bobyqa(double[],double[])",
            "method_code": "```java\n    private double bobyqa(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n\n        // Return if there is insufficient space between the bounds. Modify the\n        // initial X if necessary in order to avoid conflicts between the bounds\n        // and the construction of the first quadratic model. The lower and upper\n        // bounds on moves from the updated X are set now, in the ISL and ISU\n        // partitions of W, in order to provide useful and exact information about\n        // components of X that become within distance RHOBEG from their bounds.\n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    // Computing MAX\n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    // Computing MIN\n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n        // Make the call of BOBYQB.\n\n        return bobyqb(lowerBound, upperBound);\n    } // bobyqa\n\n```",
            "method_doc": " This subroutine seeks the least value of a function of many variables, by applying a trust region method that forms quadratic models by interpolation. There is usually some freedom in the interpolation conditions, which is taken up by minimizing the Frobenius norm of the change to the second derivative of the model, beginning with the zero matrix. The values of the variables are constrained by upper and lower bounds. The arguments of the subroutine are as follows.  N must be set to the number of variables and must be at least two. NPT is the number of interpolation conditions. Its value must be in the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not recommended. Initial values of the variables must be set in X(1),X(2),...,X(N). They will be changed to the values that give the least calculated F. For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper bounds, respectively, on X(I). The construction of quadratic models requires XL(I) to be strictly less than XU(I) for each I. Further, the contribution to a model from changes to the I-th variable is damaged severely by rounding errors if XU(I)-XL(I) is too small. RHOBEG and RHOEND must be set to the initial and final values of a trust region radius, so both must be positive with RHOEND no greater than RHOBEG. Typically, RHOBEG should be about one tenth of the greatest expected change to a variable, while RHOEND should indicate the accuracy that is required in the final values of the variables. An error return occurs if any of the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. MAXFUN must be set to an upper bound on the number of calls of CALFUN. The array W will be used for working space. Its length must be at least (NPT+5)*(NPT+N)+3*N*(N+5)/2.  @param lowerBound Lower bounds. @param upperBound Upper bounds. @return the value of the objective at the optimum. ",
            "class_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer",
            "class_doc": " Powell's BOBYQA algorithm. This implementation is translated and adapted from the Fortran version available <a href=\"http://plato.asu.edu/ftp/other_software/bobyqa.zip\">here</a>. See <a href=\"http://www.optimization-online.org/DB_HTML/2010/05/2616.html\"> this paper</a> for an introduction. <br/> BOBYQA is particularly well suited for high dimensional problems where derivatives are not available. In most cases it outperforms the {@link PowellOptimizer} significantly. Stochastic algorithms like {@link CMAESOptimizer} succeed more often than BOBYQA, but are more expensive. BOBYQA could also be considered as a replacement of any derivative-based optimizer when the derivatives are approximated by finite differences.  @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Patterns\n\n**Test Behavior Pattern:**\n- The test fails when the number of additional interpolation points exceeds 47 (i.e., total interpolation points > 48)\n- The failure occurs specifically in constrained optimization scenarios\n- The test comment mentions there should be a hard limit of 78 interpolation points, but failures occur much earlier\n\n**Stack Trace Pattern:**\n- The exception originates from `BOBYQAOptimizer.prelim()` at line 1780\n- The exception type is `PathIsExploredException`, which appears to be a debugging aid\n- The stack trace shows the failure occurs during the preliminary phase of the optimization algorithm\n\n## Step 2: Identify the Root Cause\n\nThe key insight comes from understanding the relationship between:\n- **Problem dimension (DIM = 9)**\n- **Interpolation points calculation**: `2*dim + 1 + additionalInterpolationPoints`\n- **Theoretical hard limit**: `((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) = 78`\n\nWhen `additionalInterpolationPoints = 48`:\n- Total interpolation points = `2*9 + 1 + 48 = 67`\n- This exceeds some internal constraint in the `prelim()` method\n\n## Step 3: Recommend Possible Production Code Defect\n\n**Defect Location**: `org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim()` method\n\n**Probable Cause**: The `prelim()` method contains incorrect bounds checking or array sizing logic that fails when the number of interpolation points exceeds a certain threshold that is **lower than the theoretical maximum**.\n\n**Specific Issues**:\n1. **Array Bounds Violation**: The method likely allocates arrays based on incorrect size calculations for interpolation points\n2. **Insufficient Validation**: Missing or incorrect validation of interpolation point count against internal constraints\n3. **Algorithmic Constraint**: The implementation may have a practical limit lower than the theoretical limit due to implementation details\n\n**Expected Behavior**: The optimizer should handle up to 78 interpolation points for this 9-dimensional problem, but fails at 67 points, indicating a ~14% reduction in the effective capacity.\n\nThe defect appears to be in the production code's handling of interpolation point allocation or validation within the preliminary setup phase of the BOBYQA algorithm.",
            "test_suite": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest",
            "score": 3,
            "reason": "#3# The bobyqa method itself appears to handle bounds checking and initial point adjustment correctly. The actual failure occurs in the prelim method called by bobyqb, which is invoked at the end of bobyqa. The stack trace shows PathIsExploredException thrown from prelim at line 1780, indicating the issue is deeper in the call chain, likely in the interpolation point handling logic within prelim or related methods."
        },
        {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::doOptimize()",
            "method_code": "```java\n    @Override\n    protected RealPointValuePair doOptimize() {\n        final double[] lowerBound = getLowerBound();\n        final double[] upperBound = getUpperBound();\n\n        // Validity checks.\n        setup(lowerBound, upperBound);\n\n        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n        currentBest = new ArrayRealVector(getStartPoint());\n\n        final double value = bobyqa(lowerBound, upperBound);\n\n        return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);\n    }\n\n```",
            "method_doc": "{@inheritDoc} */",
            "class_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer",
            "class_doc": " Powell's BOBYQA algorithm. This implementation is translated and adapted from the Fortran version available <a href=\"http://plato.asu.edu/ftp/other_software/bobyqa.zip\">here</a>. See <a href=\"http://www.optimization-online.org/DB_HTML/2010/05/2616.html\"> this paper</a> for an introduction. <br/> BOBYQA is particularly well suited for high dimensional problems where derivatives are not available. In most cases it outperforms the {@link PowellOptimizer} significantly. Stochastic algorithms like {@link CMAESOptimizer} succeed more often than BOBYQA, but are more expensive. BOBYQA could also be considered as a replacement of any derivative-based optimizer when the derivatives are approximated by finite differences.  @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Patterns\n\n**Test Behavior Pattern:**\n- The test fails when the number of additional interpolation points exceeds 47 (i.e., total interpolation points > 48)\n- The failure occurs specifically in constrained optimization scenarios\n- The test comment mentions there should be a hard limit of 78 interpolation points, but failures occur much earlier\n\n**Stack Trace Pattern:**\n- The exception originates from `BOBYQAOptimizer.prelim()` at line 1780\n- The exception type is `PathIsExploredException`, which appears to be a debugging aid\n- The stack trace shows the failure occurs during the preliminary phase of the optimization algorithm\n\n## Step 2: Identify the Root Cause\n\nThe key insight comes from understanding the relationship between:\n- **Problem dimension (DIM = 9)**\n- **Interpolation points calculation**: `2*dim + 1 + additionalInterpolationPoints`\n- **Theoretical hard limit**: `((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1) = 78`\n\nWhen `additionalInterpolationPoints = 48`:\n- Total interpolation points = `2*9 + 1 + 48 = 67`\n- This exceeds some internal constraint in the `prelim()` method\n\n## Step 3: Recommend Possible Production Code Defect\n\n**Defect Location**: `org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim()` method\n\n**Probable Cause**: The `prelim()` method contains incorrect bounds checking or array sizing logic that fails when the number of interpolation points exceeds a certain threshold that is **lower than the theoretical maximum**.\n\n**Specific Issues**:\n1. **Array Bounds Violation**: The method likely allocates arrays based on incorrect size calculations for interpolation points\n2. **Insufficient Validation**: Missing or incorrect validation of interpolation point count against internal constraints\n3. **Algorithmic Constraint**: The implementation may have a practical limit lower than the theoretical limit due to implementation details\n\n**Expected Behavior**: The optimizer should handle up to 78 interpolation points for this 9-dimensional problem, but fails at 67 points, indicating a ~14% reduction in the effective capacity.\n\nThe defect appears to be in the production code's handling of interpolation point allocation or validation within the preliminary setup phase of the BOBYQA algorithm.",
            "test_suite": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest",
            "score": 3,
            "reason": "#3# The doOptimize() method itself appears to be a high-level orchestrator that calls bobyqa(), but the actual failure occurs deeper in the call stack within the prelim() method. While doOptimize() initiates the optimization process, the specific bug related to interpolation point limits is likely in the underlying bobyqa() or prelim() methods where the interpolation point validation and array allocations occur."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::prelim(double[],double[])": {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::prelim(double[],double[])",
            "method_code": "```java\n    private void prelim(double[] TransVarUpperBound,\n                        double[] TransVarLowerBound) {\n        if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n        printMethod(); // XXX\n\n        final int TransVarDimension = currentBest.getDimension();\n        final int TransVarNumberOfPoints = numberOfInterpolationPoints;\n        final int TransVarRows = bMatrix.getRowDimension();\n\n        final double TransVarTrustRegionRadiusSquared = initialTrustRegionRadius * initialTrustRegionRadius;\n        final double TransVarReciprocalRhosq = 1d / TransVarTrustRegionRadiusSquared;\n        final int TransVarN2 = TransVarDimension + 1;\n\n        // Set XBASE to the initial vector of variables, and set the initial\n        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n        int TransVarI = 0;\n        while (!(!(TransVarI < TransVarDimension))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            originShift.setEntry(TransVarI, currentBest.getEntry(TransVarI));\n            int TransVarIndex = 0;\n            while (!(!(TransVarIndex < TransVarNumberOfPoints))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n            }\n                interpolationPoints.setEntry(TransVarIndex, TransVarI, ZERO);\n                TransVarIndex++;\n        }\n            int TransVarIi = 0;\n            while (!(!(TransVarIi < TransVarRows))) {\n                bMatrix.setEntry(TransVarIi, TransVarI, ZERO);\n                TransVarIi++;\n        }\n            TransVarI++;\n            }\n        int TransVarCount = 0, TransVarMaxPoints = TransVarDimension * TransVarN2 / 2;\n        while (!(!(TransVarCount < TransVarMaxPoints))) {\n            modelSecondDerivativesValues.setEntry(TransVarCount, ZERO);\n            TransVarCount++;\n        }\n        int TransVarNewK = 0;\n        while (!(!(TransVarNewK < TransVarNumberOfPoints))) {\n            modelSecondDerivativesParameters.setEntry(TransVarNewK, ZERO);\n            int TransVarJj = 0, TransVarMaxNumberOfPoints = TransVarNumberOfPoints - TransVarN2;\n            while (!(!(TransVarJj < TransVarMaxNumberOfPoints))) {\n                zMatrix.setEntry(TransVarNewK, TransVarJj, ZERO);\n                TransVarJj++;\n            }\n            TransVarNewK++;\n        }\n\n        // Begin the initialization procedure. NF becomes one more than the number\n        // of function values so far. The coordinates of the displacement of the\n        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n        int TransVarIp = 0;\n        int TransVarIpt = 0;\n        double TransVarBeg = Double.NaN;\n        do {\n            final int TransVarEvaluations = getEvaluations();\n            final int TransVarNf = TransVarEvaluations - TransVarDimension;\n            final int TransVarNfmmm = TransVarEvaluations - 1;\n            final int TransVarNfx = TransVarNf - 1;\n            double TransVarStep = 0;\n            double TransVarStepa = 0;\n            if (!(!(TransVarEvaluations <= 2 * TransVarDimension))) {\n                if (!(!(TransVarEvaluations >= 1 && TransVarEvaluations <= TransVarDimension))) {\n                    TransVarStep = initialTrustRegionRadius;\n                    if (!(!(upperDifference.getEntry(TransVarNfmmm) == ZERO))) {\n                        TransVarStep = -TransVarStep;\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(TransVarEvaluations, TransVarNfmmm, TransVarStep);\n                } else if (!(!(TransVarEvaluations > TransVarDimension))) {\n                    TransVarStep = interpolationPoints.getEntry(TransVarNf, TransVarNfx);\n                    TransVarStepa = -initialTrustRegionRadius;\n                    if (!(!(lowerDifference.getEntry(TransVarNfx) == ZERO))) {\n                        TransVarStepa = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(TransVarNfx));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    if (!(!(upperDifference.getEntry(TransVarNfx) == ZERO))) {\n                        TransVarStepa = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(TransVarNfx));\n                        throw new PathIsExploredException(); // XXX\n                    }\n                    interpolationPoints.setEntry(TransVarEvaluations, TransVarNfx, TransVarStepa);\n                }\n            } else {\n                final int TransVarTmp2 = (TransVarEvaluations - TransVarN2) / TransVarDimension;\n                TransVarIpt = TransVarEvaluations - TransVarTmp2 * TransVarDimension - TransVarDimension;\n                TransVarIp = TransVarIpt + TransVarTmp2;\n                if (!(!(TransVarIp > TransVarDimension))) {\n                    final int TransVarTmp = TransVarIpt;\n                    TransVarIpt = TransVarIp - TransVarDimension;\n                    TransVarIp = TransVarTmp;\n                    throw new PathIsExploredException(); // XXX\n                }\n                final int TransVarIMinus1 = TransVarIp;\n                final int TransVarJpt = TransVarIpt;\n                interpolationPoints.setEntry(TransVarEvaluations, TransVarIMinus1, interpolationPoints.getEntry(TransVarIp, TransVarIMinus1));\n                interpolationPoints.setEntry(TransVarEvaluations, TransVarJpt, interpolationPoints.getEntry(TransVarIpt, TransVarJpt));\n            }\n\n            // Calculate the next value of F. The least function value so far and\n            // its index are required.\n\n            int TransVarJ1 = 0;\n            while (!(!(TransVarJ1 < TransVarDimension))) {\n                currentBest\n                        .setEntry(TransVarJ1,\n                                Math.min(\n                                        Math.max(TransVarUpperBound[TransVarJ1],\n                                                originShift.getEntry(TransVarJ1) + interpolationPoints\n                                                        .getEntry(TransVarEvaluations, TransVarJ1)),\n                                        TransVarLowerBound[TransVarJ1]));\n                if (!(!(interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1) == lowerDifference\n                        .getEntry(TransVarJ1)))) {\n                    currentBest.setEntry(TransVarJ1, TransVarUpperBound[TransVarJ1]);\n                }\n                if (!(!(interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1) == upperDifference\n                        .getEntry(TransVarJ1)))) {\n                    currentBest.setEntry(TransVarJ1, TransVarLowerBound[TransVarJ1]);\n                }\n                TransVarJ1++;\n            }\n\n            final double TransVarValue = computeObjectiveValue(currentBest.toArray());\n            final double TransVarMaximization = isMinimize ? TransVarValue : -TransVarValue;\n            final int TransVarNum = getEvaluations(); // nfm + 1\n            fAtInterpolationPoints.setEntry(TransVarEvaluations, TransVarMaximization);\n\n            if (!(!(TransVarNum == 1))) {\n                TransVarBeg = TransVarMaximization;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (!(!(TransVarMaximization < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)))) {\n                trustRegionCenterInterpolationPointIndex = TransVarEvaluations;\n            }\n\n            // Set the nonzero initial elements of BMAT and the quadratic model in the\n            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n            // order that the function value at the first of them contributes to the\n            // off-diagonal second derivative terms of the initial quadratic model.\n\n            if (!(!(TransVarNum <= 2 * TransVarDimension + 1))) {\n                if (!(!(TransVarNum >= 2 && TransVarNum <= TransVarDimension + 1))) {\n                    gradientAtTrustRegionCenter.setEntry(TransVarNfmmm, (TransVarMaximization - TransVarBeg) / TransVarStep);\n                    if (!(!(TransVarNumberOfPoints < TransVarNum + TransVarDimension))) {\n                        final double TransVarOos = ONE / TransVarStep;\n                        bMatrix.setEntry(0, TransVarNfmmm, -TransVarOos);\n                        bMatrix.setEntry(TransVarEvaluations, TransVarNfmmm, TransVarOos);\n                        bMatrix.setEntry(TransVarNumberOfPoints + TransVarNfmmm, TransVarNfmmm, -HALF * TransVarTrustRegionRadiusSquared);\n                        throw new PathIsExploredException(); // XXX\n                    }\n                } else if (!(!(TransVarNum >= TransVarDimension + 2))) {\n                    final int TransVarIj = TransVarNf * (TransVarNf + 1) / 2 - 1;\n                    final double TransVarFNew = (TransVarMaximization - TransVarBeg) / TransVarStepa;\n                    final double TransVarH = TransVarStepa - TransVarStep;\n                    modelSecondDerivativesValues.setEntry(TransVarIj, TWO * (TransVarFNew - gradientAtTrustRegionCenter.getEntry(TransVarNfx)) / TransVarH);\n                    gradientAtTrustRegionCenter.setEntry(TransVarNfx, (gradientAtTrustRegionCenter.getEntry(TransVarNfx) * TransVarStepa - TransVarFNew * TransVarStep) / TransVarH);\n                    if (!(!(TransVarStep * TransVarStepa < ZERO))) {\n                        if (!(!(TransVarMaximization < fAtInterpolationPoints\n                                .getEntry(TransVarEvaluations - TransVarDimension)))) {\n                            fAtInterpolationPoints.setEntry(TransVarEvaluations, fAtInterpolationPoints.getEntry(TransVarEvaluations - TransVarDimension));\n                            fAtInterpolationPoints.setEntry(TransVarEvaluations - TransVarDimension, TransVarMaximization);\n                            if (!(!(trustRegionCenterInterpolationPointIndex == TransVarEvaluations))) {\n                                trustRegionCenterInterpolationPointIndex = TransVarEvaluations - TransVarDimension;\n                            }\n                            interpolationPoints.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx, TransVarStepa);\n                            interpolationPoints.setEntry(TransVarEvaluations, TransVarNfx, TransVarStep);\n                        }\n                    }\n                    bMatrix.setEntry(0, TransVarNfx, -(TransVarStep + TransVarStepa) / (TransVarStep * TransVarStepa));\n                    bMatrix.setEntry(TransVarEvaluations, TransVarNfx, -HALF / interpolationPoints.getEntry(TransVarEvaluations - TransVarDimension, TransVarNfx));\n                    bMatrix.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx,\n                                  -bMatrix.getEntry(0, TransVarNfx) - bMatrix.getEntry(TransVarEvaluations, TransVarNfx));\n                    zMatrix.setEntry(0, TransVarNfx, Math.sqrt(TWO) / (TransVarStep * TransVarStepa));\n                    zMatrix.setEntry(TransVarEvaluations, TransVarNfx, Math.sqrt(HALF) / TransVarTrustRegionRadiusSquared);\n                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    zMatrix.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx,\n                                  -zMatrix.getEntry(0, TransVarNfx) - zMatrix.getEntry(TransVarEvaluations, TransVarNfx));\n                }\n\n                // Set the off-diagonal second derivatives of the Lagrange functions and\n                // the initial quadratic model.\n\n            } else {\n                zMatrix.setEntry(0, TransVarNfx, TransVarReciprocalRhosq);\n                zMatrix.setEntry(TransVarEvaluations, TransVarNfx, TransVarReciprocalRhosq);\n                zMatrix.setEntry(TransVarIp, TransVarNfx, -TransVarReciprocalRhosq);\n                zMatrix.setEntry(TransVarIpt, TransVarNfx, -TransVarReciprocalRhosq);\n\n                final int TransVarIpIndex = TransVarIp * (TransVarIp - 1) / 2 + TransVarIpt - 1;\n                final double TransVarTemp = interpolationPoints.getEntry(TransVarEvaluations, TransVarIp - 1) * interpolationPoints.getEntry(TransVarEvaluations, TransVarIpt - 1);\n                modelSecondDerivativesValues.setEntry(TransVarIpIndex, (TransVarBeg - fAtInterpolationPoints.getEntry(TransVarIp) - fAtInterpolationPoints.getEntry(TransVarIpt) + TransVarMaximization) / TransVarTemp);\n                throw new PathIsExploredException(); // XXX\n            }\n        } while (!(!(getEvaluations() < TransVarNumberOfPoints)));\n    } // prelim\n\n```",
            "method_doc": " SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ, BMAT and ZMAT for the first iteration, and it maintains the values of NF and KOPT. The vector X is also changed by PRELIM.  The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the same as the corresponding arguments in SUBROUTINE BOBYQA. The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU are the same as the corresponding arguments in BOBYQB, the elements of SL and SU being set in BOBYQA. GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but it is set by PRELIM to the gradient of the quadratic model at XBASE. If XOPT is nonzero, BOBYQB will change it to its usual value later. NF is maintaned as the number of calls of CALFUN so far. KOPT will be such that the least calculated value of F so far is at the point XPT(KOPT,.)+XBASE in the space of the variables.  @param lowerBound Lower bounds. @param upperBound Upper bounds. "
        },
        "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::bobyqa(double[],double[])": {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::bobyqa(double[],double[])",
            "method_code": "```java\n    private double bobyqa(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n\n        // Return if there is insufficient space between the bounds. Modify the\n        // initial X if necessary in order to avoid conflicts between the bounds\n        // and the construction of the first quadratic model. The lower and upper\n        // bounds on moves from the updated X are set now, in the ISL and ISU\n        // partitions of W, in order to provide useful and exact information about\n        // components of X that become within distance RHOBEG from their bounds.\n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    // Computing MAX\n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    // Computing MIN\n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n        // Make the call of BOBYQB.\n\n        return bobyqb(lowerBound, upperBound);\n    } // bobyqa\n\n```",
            "method_doc": " This subroutine seeks the least value of a function of many variables, by applying a trust region method that forms quadratic models by interpolation. There is usually some freedom in the interpolation conditions, which is taken up by minimizing the Frobenius norm of the change to the second derivative of the model, beginning with the zero matrix. The values of the variables are constrained by upper and lower bounds. The arguments of the subroutine are as follows.  N must be set to the number of variables and must be at least two. NPT is the number of interpolation conditions. Its value must be in the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not recommended. Initial values of the variables must be set in X(1),X(2),...,X(N). They will be changed to the values that give the least calculated F. For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper bounds, respectively, on X(I). The construction of quadratic models requires XL(I) to be strictly less than XU(I) for each I. Further, the contribution to a model from changes to the I-th variable is damaged severely by rounding errors if XU(I)-XL(I) is too small. RHOBEG and RHOEND must be set to the initial and final values of a trust region radius, so both must be positive with RHOEND no greater than RHOBEG. Typically, RHOBEG should be about one tenth of the greatest expected change to a variable, while RHOEND should indicate the accuracy that is required in the final values of the variables. An error return occurs if any of the differences XU(I)-XL(I), I=1,...,N, is less than 2*RHOBEG. MAXFUN must be set to an upper bound on the number of calls of CALFUN. The array W will be used for working space. Its length must be at least (NPT+5)*(NPT+N)+3*N*(N+5)/2.  @param lowerBound Lower bounds. @param upperBound Upper bounds. @return the value of the objective at the optimum. "
        },
        "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::bobyqb(double[],double[])": {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::bobyqb(double[],double[])",
            "method_code": "```java\n    private double bobyqb(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n        final int npt = numberOfInterpolationPoints;\n        final int np = n + 1;\n        final int nptm = npt - np;\n        final int nh = n * np / 2;\n\n        final ArrayRealVector work1 = new ArrayRealVector(n);\n        final ArrayRealVector work2 = new ArrayRealVector(npt);\n        final ArrayRealVector work3 = new ArrayRealVector(npt);\n\n        double cauchy = Double.NaN;\n        double alpha = Double.NaN;\n        double dsq = Double.NaN;\n        double crvmin = Double.NaN;\n\n        // Set some constants.\n        // Parameter adjustments\n\n        // Function Body\n\n        // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n        // BMAT and ZMAT for the first iteration, with the corresponding values of\n        // of NF and KOPT, which are the number of calls of CALFUN so far and the\n        // index of the interpolation point at the trust region centre. Then the\n        // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n        // less than NPT. GOPT will be updated if KOPT is different from KBASE.\n\n        trustRegionCenterInterpolationPointIndex = 0;\n\n        prelim(lowerBound, upperBound);\n        double xoptsq = ZERO;\n        for (int i = 0; i < n; i++) {\n            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n            // Computing 2nd power\n            final double deltaOne = trustRegionCenterOffset.getEntry(i);\n            xoptsq += deltaOne * deltaOne;\n        }\n        double fsave = fAtInterpolationPoints.getEntry(0);\n        final int kbase = 0;\n\n        // Complete the settings that are required for the iterative procedure.\n\n        int ntrits = 0;\n        int itest = 0;\n        int knew = 0;\n        int nfsav = getEvaluations();\n        double rho = initialTrustRegionRadius;\n        double delta = rho;\n        double diffa = ZERO;\n        double diffb = ZERO;\n        double diffc = ZERO;\n        double f = ZERO;\n        double beta = ZERO;\n        double adelt = ZERO;\n        double denom = ZERO;\n        double ratio = ZERO;\n        double dnorm = ZERO;\n        double scaden = ZERO;\n        double biglsq = ZERO;\n        double distsq = ZERO;\n\n        // Update GOPT if necessary before the first iteration and after each\n        // call of RESCUE that makes a call of CALFUN.\n\n        int state = 20;\n        for(;;) switch (state) {\n        case 20: {\n            printState(20); // XXX\n            if (trustRegionCenterInterpolationPointIndex != kbase) {\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\n                        ih++;\n                    }\n                }\n                if (getEvaluations() > npt) {\n                    for (int k = 0; k < npt; k++) {\n                        double temp = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                        }\n                        temp *= modelSecondDerivativesParameters.getEntry(k);\n                        for (int i = 0; i < n; i++) {\n                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                        }\n                    }\n                    throw new PathIsExploredException(); // XXX\n                }\n            }\n\n            // Generate the next point in the trust region that provides a small value\n            // of the quadratic model subject to the constraints on the variables.\n            // The int NTRITS is set to the number \"trust region\" iterations that\n            // have occurred since the last \"alternative\" iteration. If the length\n            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n        }\n        case 60: {\n            printState(60); // XXX\n            final ArrayRealVector gnew = new ArrayRealVector(n);\n            final ArrayRealVector xbdi = new ArrayRealVector(n);\n            final ArrayRealVector s = new ArrayRealVector(n);\n            final ArrayRealVector hs = new ArrayRealVector(n);\n            final ArrayRealVector hred = new ArrayRealVector(n);\n\n            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\n                                              hs, hred);\n            dsq = dsqCrvmin[0];\n            crvmin = dsqCrvmin[1];\n\n            // Computing MIN\n            double deltaOne = delta;\n            double deltaTwo = Math.sqrt(dsq);\n            dnorm = Math.min(deltaOne, deltaTwo);\n            if (dnorm < HALF * rho) {\n                ntrits = -1;\n                // Computing 2nd power\n                deltaOne = TEN * rho;\n                distsq = deltaOne * deltaOne;\n                if (getEvaluations() <= nfsav + 2) {\n                    state = 650; break;\n                }\n\n                // The following choice between labels 650 and 680 depends on whether or\n                // not our work with the current RHO seems to be complete. Either RHO is\n                // decreased or termination occurs if the errors in the quadratic model at\n                // the last three interpolation points compare favourably with predictions\n                // of likely improvements to the model within distance HALF*RHO of XOPT.\n\n                // Computing MAX\n                deltaOne = Math.max(diffa, diffb);\n                final double errbig = Math.max(deltaOne, diffc);\n                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                if (crvmin > ZERO &&\n                    errbig > frhosq * crvmin) {\n                    state = 650; break;\n                }\n                final double bdtol = errbig / rho;\n                for (int j = 0; j < n; j++) {\n                    double bdtest = bdtol;\n                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\n                        bdtest = work1.getEntry(j);\n                    }\n                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\n                        bdtest = -work1.getEntry(j);\n                    }\n                    if (bdtest < bdtol) {\n                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\n                        for (int k = 0; k < npt; k++) {\n                            // Computing 2nd power\n                            final double d1 = interpolationPoints.getEntry(k, j);\n                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n                        }\n                        bdtest += HALF * curv * rho;\n                        if (bdtest < bdtol) {\n                            state = 650; break;\n                        }\n                        throw new PathIsExploredException(); // XXX\n                    }\n                }\n                state = 680; break;\n            }\n            ++ntrits;\n\n            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n            // If the following test holds, then XBASE is shifted so that XOPT becomes\n            // zero. The appropriate changes are made to BMAT and to the second\n            // derivatives of the current model, beginning with the changes to BMAT\n            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n        }\n        case 90: {\n            printState(90); // XXX\n            if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n                final double fracsq = xoptsq * ONE_OVER_FOUR;\n                double sumpq = ZERO;\n                // final RealVector sumVector\n                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\n                for (int k = 0; k < npt; k++) {\n                    sumpq += modelSecondDerivativesParameters.getEntry(k);\n                    double sum = -HALF * xoptsq;\n                    for (int i = 0; i < n; i++) {\n                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n                    }\n                    // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                    work2.setEntry(k, sum);\n                    final double temp = fracsq - HALF * sum;\n                    for (int i = 0; i < n; i++) {\n                        work1.setEntry(i, bMatrix.getEntry(k, i));\n                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\n                        final int ip = npt + i;\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // Then the revisions of BMAT that depend on ZMAT are calculated.\n\n                for (int m = 0; m < nptm; m++) {\n                    double sumz = ZERO;\n                    double sumw = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sumz += zMatrix.getEntry(k, m);\n                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\n                        sumw += lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int j = 0; j < n; j++) {\n                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\n                        for (int k = 0; k < npt; k++) {\n                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n                        }\n                        work1.setEntry(j, sum);\n                        for (int k = 0; k < npt; k++) {\n                            bMatrix.setEntry(k, j,\n                                          bMatrix.getEntry(k, j)\n                                          + sum * zMatrix.getEntry(k, m));\n                        }\n                    }\n                    for (int i = 0; i < n; i++) {\n                        final int ip = i + npt;\n                        final double temp = work1.getEntry(i);\n                        for (int j = 0; j <= i; j++) {\n                            bMatrix.setEntry(ip, j,\n                                          bMatrix.getEntry(ip, j)\n                                          + temp * work1.getEntry(j));\n                        }\n                    }\n                }\n\n                // The following instructions complete the shift, including the changes\n                // to the second derivative parameters of the quadratic model.\n\n                int ih = 0;\n                for (int j = 0; j < n; j++) {\n                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\n                    for (int k = 0; k < npt; k++) {\n                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\n                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n                    }\n                    for (int i = 0; i <= j; i++) {\n                         modelSecondDerivativesValues.setEntry(ih,\n                                    modelSecondDerivativesValues.getEntry(ih)\n                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\n                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\n                        ih++;\n                    }\n                }\n                for (int i = 0; i < n; i++) {\n                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\n                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    trustRegionCenterOffset.setEntry(i, ZERO);\n                }\n                xoptsq = ZERO;\n            }\n            if (ntrits == 0) {\n                state = 210; break;\n            }\n            state = 230; break;\n\n            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n            // more expensive than the previous shift, because new matrices BMAT and\n            // ZMAT are generated from scratch, which may include the replacement of\n            // interpolation points whose positions seem to be causing near linear\n            // dependence in the interpolation conditions. Therefore RESCUE is called\n            // only if rounding errors have reduced by at least a factor of two the\n            // denominator of the formula for updating the H matrix. It provides a\n            // useful safeguard, but is not invoked in most applications of BOBYQA.\n\n        }\n        case 210: {\n            printState(210); // XXX\n            // Pick two alternative vectors of variables, relative to XBASE, that\n            // are suitable as new positions of the KNEW-th interpolation point.\n            // Firstly, XNEW is set to the point on a line through XOPT and another\n            // interpolation point that minimizes the predicted value of the next\n            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n            // and SU bounds. Secondly, XALT is set to the best feasible point on\n            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n            // function, the corresponding value of the square of this function\n            // being returned in CAUCHY. The choice between these alternatives is\n            // going to be made when the denominator is calculated.\n\n            final double[] alphaCauchy = altmov(knew, adelt);\n            alpha = alphaCauchy[0];\n            cauchy = alphaCauchy[1];\n\n            for (int i = 0; i < n; i++) {\n                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n            }\n\n            // Calculate VLAG and BETA for the current choice of D. The scalar\n            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n            // use when VQUAD is calculated.\n\n        }\n        case 230: {\n            printState(230); // XXX\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                double sumb = ZERO;\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n                }\n                work3.setEntry(k, suma * (HALF * suma + sumb));\n                lagrangeValuesAtNewPoint.setEntry(k, sum);\n                work2.setEntry(k, suma);\n            }\n            beta = ZERO;\n            for (int m = 0; m < nptm; m++) {\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n                }\n                beta -= sum * sum;\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n                }\n            }\n            dsq = ZERO;\n            double bsum = ZERO;\n            double dx = ZERO;\n            for (int j = 0; j < n; j++) {\n                // Computing 2nd power\n                final double d1 = trialStepPoint.getEntry(j);\n                dsq += d1 * d1;\n                double sum = ZERO;\n                for (int k = 0; k < npt; k++) {\n                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n                }\n                bsum += sum * trialStepPoint.getEntry(j);\n                final int jp = npt + j;\n                for (int i = 0; i < n; i++) {\n                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n                }\n                lagrangeValuesAtNewPoint.setEntry(jp, sum);\n                bsum += sum * trialStepPoint.getEntry(j);\n                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n            }\n\n            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\n            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\n                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n            // If NTRITS is zero, the denominator may be increased by replacing\n            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n            // rounding errors have damaged the chosen denominator.\n\n            if (ntrits == 0) {\n                // Computing 2nd power\n                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\n                denom = d1 * d1 + alpha * beta;\n                if (denom < cauchy && cauchy > ZERO) {\n                    for (int i = 0; i < n; i++) {\n                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));\n                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n                    }\n                    cauchy = ZERO; // XXX Useful statement?\n                    state = 230; break;\n                }\n                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n                // the next interpolation point to be deleted to make room for a trust\n                // region step. Again RESCUE may be called if rounding errors have damaged_\n                // the chosen denominator, which is the reason for attempting to select\n                // KNEW before calculating the next value of the objective function.\n\n            } else {\n                final double delsq = delta * delta;\n                scaden = ZERO;\n                biglsq = ZERO;\n                knew = 0;\n                for (int k = 0; k < npt; k++) {\n                    if (k == trustRegionCenterInterpolationPointIndex) {\n                        continue;\n                    }\n                    double hdiag = ZERO;\n                    for (int m = 0; m < nptm; m++) {\n                        // Computing 2nd power\n                        final double d1 = zMatrix.getEntry(k, m);\n                        hdiag += d1 * d1;\n                    }\n                    // Computing 2nd power\n                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);\n                    final double den = beta * hdiag + d2 * d2;\n                    distsq = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        // Computing 2nd power\n                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                        distsq += d3 * d3;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d4 = distsq / delsq;\n                    final double temp = Math.max(ONE, d4 * d4);\n                    if (temp * den > scaden) {\n                        scaden = temp * den;\n                        knew = k;\n                        denom = den;\n                    }\n                    // Computing MAX\n                    // Computing 2nd power\n                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);\n                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                }\n            }\n\n            // Put the variables for the next calculation of the objective function\n            //   in XNEW, with any adjustments for the bounds.\n\n            // Calculate the value of the objective function at XBASE+XNEW, unless\n            //   the limit on the number of calculations of F has been reached.\n\n        }\n        case 360: {\n            printState(360); // XXX\n            for (int i = 0; i < n; i++) {\n                // Computing MIN\n                // Computing MAX\n                final double d3 = lowerBound[i];\n                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\n                final double d1 = Math.max(d3, d4);\n                final double d2 = upperBound[i];\n                currentBest.setEntry(i, Math.min(d1, d2));\n                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\n                    currentBest.setEntry(i, lowerBound[i]);\n                }\n                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\n                    currentBest.setEntry(i, upperBound[i]);\n                }\n            }\n\n            f = computeObjectiveValue(currentBest.toArray());\n\n            if (!isMinimize)\n                f = -f;\n            if (ntrits == -1) {\n                fsave = f;\n                state = 720; break;\n            }\n\n            // Use the quadratic model to predict the change in F due to the step D,\n            //   and set DIFF to the error of this prediction.\n\n            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            double vquad = ZERO;\n            int ih = 0;\n            for (int j = 0; j < n; j++) {\n                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\n                for (int i = 0; i <= j; i++) {\n                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\n                    if (i == j) {\n                        temp *= HALF;\n                    }\n                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;\n                    ih++;\n               }\n            }\n            for (int k = 0; k < npt; k++) {\n                // Computing 2nd power\n                final double d1 = work2.getEntry(k);\n                final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n            }\n            final double diff = f - fopt - vquad;\n            diffc = diffb;\n            diffb = diffa;\n            diffa = Math.abs(diff);\n            if (dnorm > rho) {\n                nfsav = getEvaluations();\n            }\n\n            // Pick the next value of DELTA after a trust region step.\n\n            if (ntrits > 0) {\n                if (vquad >= ZERO) {\n                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                }\n                ratio = (f - fopt) / vquad;\n                final double hDelta = HALF * delta;\n                if (ratio <= ONE_OVER_TEN) {\n                    // Computing MIN\n                    delta = Math.min(hDelta, dnorm);\n                } else if (ratio <= .7) {\n                    // Computing MAX\n                    delta = Math.max(hDelta, dnorm);\n                } else {\n                    // Computing MAX\n                    delta = Math.max(hDelta, 2 * dnorm);\n                }\n                if (delta <= rho * 1.5) {\n                    delta = rho;\n                }\n\n                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n\n                if (f < fopt) {\n                    final int ksav = knew;\n                    final double densav = denom;\n                    final double delsq = delta * delta;\n                    scaden = ZERO;\n                    biglsq = ZERO;\n                    knew = 0;\n                    for (int k = 0; k < npt; k++) {\n                        double hdiag = ZERO;\n                        for (int m = 0; m < nptm; m++) {\n                            // Computing 2nd power\n                            final double d1 = zMatrix.getEntry(k, m);\n                            hdiag += d1 * d1;\n                        }\n                        // Computing 2nd power\n                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double den = beta * hdiag + d1 * d1;\n                        distsq = ZERO;\n                        for (int j = 0; j < n; j++) {\n                            // Computing 2nd power\n                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\n                            distsq += d2 * d2;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d3 = distsq / delsq;\n                        final double temp = Math.max(ONE, d3 * d3);\n                        if (temp * den > scaden) {\n                            scaden = temp * den;\n                            knew = k;\n                            denom = den;\n                        }\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);\n                        final double d5 = temp * (d4 * d4);\n                        biglsq = Math.max(biglsq, d5);\n                    }\n                    if (scaden <= HALF * biglsq) {\n                        knew = ksav;\n                        denom = densav;\n                    }\n                }\n            }\n\n            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n            // moved. Also update the second derivative terms of the model.\n\n            update(beta, denom, knew);\n\n            ih = 0;\n            final double pqold = modelSecondDerivativesParameters.getEntry(knew);\n            modelSecondDerivativesParameters.setEntry(knew, ZERO);\n            for (int i = 0; i < n; i++) {\n                final double temp = pqold * interpolationPoints.getEntry(knew, i);\n                for (int j = 0; j <= i; j++) {\n                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\n                    ih++;\n                }\n            }\n            for (int m = 0; m < nptm; m++) {\n                final double temp = diff * zMatrix.getEntry(knew, m);\n                for (int k = 0; k < npt; k++) {\n                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n                }\n            }\n\n            // Include the new interpolation point, and make the changes to GOPT at\n            // the old XOPT that are caused by the updating of the quadratic model.\n\n            fAtInterpolationPoints.setEntry(knew,  f);\n            for (int i = 0; i < n; i++) {\n                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\n                work1.setEntry(i, bMatrix.getEntry(knew, i));\n            }\n            for (int k = 0; k < npt; k++) {\n                double suma = ZERO;\n                for (int m = 0; m < nptm; m++) {\n                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n                }\n                double sumb = ZERO;\n                for (int j = 0; j < n; j++) {\n                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                }\n                final double temp = suma * sumb;\n                for (int i = 0; i < n; i++) {\n                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n            }\n\n            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\n            if (f < fopt) {\n                trustRegionCenterInterpolationPointIndex = knew;\n                xoptsq = ZERO;\n                ih = 0;\n                for (int j = 0; j < n; j++) {\n                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n                    // Computing 2nd power\n                    final double d1 = trustRegionCenterOffset.getEntry(j);\n                    xoptsq += d1 * d1;\n                    for (int i = 0; i <= j; i++) {\n                        if (i < j) {\n                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n                        }\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\n                        ih++;\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double temp = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n                    }\n                    temp *= modelSecondDerivativesParameters.getEntry(k);\n                    for (int i = 0; i < n; i++) {\n                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n                    }\n                }\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at XOPT being put\n            // into VLAG(NPT+I), I=1,2,...,N.\n\n            if (ntrits > 0) {\n                for (int k = 0; k < npt; k++) {\n                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\n                    work3.setEntry(k, ZERO);\n                }\n                for (int j = 0; j < nptm; j++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n                    }\n                    for (int k = 0; k < npt; k++) {\n                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n                    }\n                }\n                for (int k = 0; k < npt; k++) {\n                    double sum = ZERO;\n                    for (int j = 0; j < n; j++) {\n                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n                    }\n                    work2.setEntry(k, work3.getEntry(k));\n                    work3.setEntry(k, sum * work3.getEntry(k));\n                }\n                double gqsq = ZERO;\n                double gisq = ZERO;\n                for (int i = 0; i < n; i++) {\n                    double sum = ZERO;\n                    for (int k = 0; k < npt; k++) {\n                        sum += bMatrix.getEntry(k, i) *\n                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        // Computing MIN\n                        // Computing 2nd power\n                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.min(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        // Computing MAX\n                        // Computing 2nd power\n                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\n                        gqsq += d1 * d1;\n                        // Computing 2nd power\n                        final double d2 = Math.max(ZERO, sum);\n                        gisq += d2 * d2;\n                    } else {\n                        // Computing 2nd power\n                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);\n                        gqsq += d1 * d1;\n                        gisq += sum * sum;\n                    }\n                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n                }\n\n                // Test whether to replace the new quadratic model by the least Frobenius\n                // norm interpolant, making the replacement if the test is satisfied.\n\n                ++itest;\n                if (gqsq < TEN * gisq) {\n                    itest = 0;\n                }\n                if (itest >= 3) {\n                    for (int i = 0, max = Math.max(npt, nh); i < max; i++) {\n                        if (i < n) {\n                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n                        }\n                        if (i < npt) {\n                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n                        }\n                        if (i < nh) {\n                            modelSecondDerivativesValues.setEntry(i, ZERO);\n                        }\n                        itest = 0;\n                    }\n                }\n            }\n\n            // If a trust region step has provided a sufficient decrease in F, then\n            // branch for another trust region calculation. The case NTRITS=0 occurs\n            // when the new interpolation point was reached by an alternative step.\n\n            if (ntrits == 0) {\n                state = 60; break;\n            }\n            if (f <= fopt + ONE_OVER_TEN * vquad) {\n                state = 60; break;\n            }\n\n            // Alternatively, find out if the interpolation points are close enough\n            //   to the best point so far.\n\n            // Computing MAX\n            // Computing 2nd power\n            final double d1 = TWO * delta;\n            // Computing 2nd power\n            final double d2 = TEN * rho;\n            distsq = Math.max(d1 * d1, d2 * d2);\n        }\n        case 650: {\n            printState(650); // XXX\n            knew = -1;\n            for (int k = 0; k < npt; k++) {\n                double sum = ZERO;\n                for (int j = 0; j < n; j++) {\n                    // Computing 2nd power\n                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\n                    sum += d1 * d1;\n                }\n                if (sum > distsq) {\n                    knew = k;\n                    distsq = sum;\n                }\n            }\n\n            // If KNEW is positive, then ALTMOV finds alternative new positions for\n            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n            // reached via label 90. Otherwise, there is a branch to label 60 for\n            // another trust region iteration, unless the calculations with the\n            // current RHO are complete.\n\n            if (knew >= 0) {\n                final double dist = Math.sqrt(distsq);\n                if (ntrits == -1) {\n                    // Computing MIN\n                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                    if (delta <= rho * 1.5) {\n                        delta = rho;\n                    }\n                }\n                ntrits = 0;\n                // Computing MAX\n                // Computing MIN\n                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n                adelt = Math.max(d1, rho);\n                dsq = adelt * adelt;\n                state = 90; break;\n            }\n            if (ntrits == -1) {\n                state = 680; break;\n            }\n            if (ratio > ZERO) {\n                state = 60; break;\n            }\n            if (Math.max(delta, dnorm) > rho) {\n                state = 60; break;\n            }\n\n            // The calculations with the current value of RHO are complete. Pick the\n            //   next values of RHO and DELTA.\n        }\n        case 680: {\n            printState(680); // XXX\n            if (rho > stoppingTrustRegionRadius) {\n                delta = HALF * rho;\n                ratio = rho / stoppingTrustRegionRadius;\n                if (ratio <= SIXTEEN) {\n                    rho = stoppingTrustRegionRadius;\n                } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                } else {\n                    rho *= ONE_OVER_TEN;\n                }\n                delta = Math.max(delta, rho);\n                ntrits = 0;\n                nfsav = getEvaluations();\n                state = 60; break;\n            }\n\n            // Return from the calculation, after another Newton-Raphson step, if\n            //   it is too short to have been tried before.\n\n            if (ntrits == -1) {\n                state = 360; break;\n            }\n        }\n        case 720: {\n            printState(720); // XXX\n            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\n                for (int i = 0; i < n; i++) {\n                    // Computing MIN\n                    // Computing MAX\n                    final double d3 = lowerBound[i];\n                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\n                    final double d1 = Math.max(d3, d4);\n                    final double d2 = upperBound[i];\n                    currentBest.setEntry(i, Math.min(d1, d2));\n                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n                        currentBest.setEntry(i, lowerBound[i]);\n                    }\n                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n                        currentBest.setEntry(i, upperBound[i]);\n                    }\n                }\n                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n            }\n            return f;\n        }\n        default: {\n            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n        }}\n    } // bobyqb\n\n```",
            "method_doc": " The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN are identical to the corresponding arguments in SUBROUTINE BOBYQA. XBASE holds a shift of origin that should reduce the contributions from rounding errors to values of the model and Lagrange functions. XPT is a two-dimensional array that holds the coordinates of the interpolation points relative to XBASE. FVAL holds the values of F at the interpolation points. XOPT is set to the displacement from XBASE of the trust region centre. GOPT holds the gradient of the quadratic model at XBASE+XOPT. HQ holds the explicit second derivatives of the quadratic model. PQ contains the parameters of the implicit second derivatives of the quadratic model. BMAT holds the last N columns of H. ZMAT holds the factorization of the leading NPT by NPT submatrix of H, this factorization being ZMAT times ZMAT^T, which provides both the correct rank and positive semi-definiteness. NDIM is the first dimension of BMAT and has the value NPT+N. SL and SU hold the differences XL-XBASE and XU-XBASE, respectively. All the components of every XOPT are going to satisfy the bounds SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when XOPT is on a constraint boundary. XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the vector of variables for the next call of CALFUN. XNEW also satisfies the SL and SU constraints in the way that has just been mentioned. XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW in order to increase the denominator in the updating of UPDATE. D is reserved for a trial step from XOPT, which is usually XNEW-XOPT. VLAG contains the values of the Lagrange functions at a new point X. They are part of a product that requires VLAG to be of length NDIM. W is a one-dimensional array that is used for working space. Its length must be at least 3*NDIM = 3*(NPT+N).  @param lowerBound Lower bounds. @param upperBound Upper bounds. @return the value of the objective at the optimum. "
        },
        "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::doOptimize()": {
            "method_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer::doOptimize()",
            "method_code": "```java\n    @Override\n    protected RealPointValuePair doOptimize() {\n        final double[] lowerBound = getLowerBound();\n        final double[] upperBound = getUpperBound();\n\n        // Validity checks.\n        setup(lowerBound, upperBound);\n\n        isMinimize = (getGoalType() == GoalType.MINIMIZE);\n        currentBest = new ArrayRealVector(getStartPoint());\n\n        final double value = bobyqa(lowerBound, upperBound);\n\n        return new RealPointValuePair(currentBest.getDataRef(),\n                                      isMinimize ? value : -value);\n    }\n\n```",
            "method_doc": "{@inheritDoc} */"
        }
    }
}