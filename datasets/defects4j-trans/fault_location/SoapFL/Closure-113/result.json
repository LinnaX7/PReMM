{
    "buggy_classes": [
        "com.google.javascript.jscomp.ProcessClosurePrimitives"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.isExprResult();\n        Node left = n.getFirstChild();\n        if (left.isGetProp()) {\n          Node name = left.getFirstChild();\n          if (name.isName() &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"define\".equals(methodName)) {\n              processDefineCall(t, n, parent);\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.isString()) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, IR.number(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n\n      case Token.EXPR_RESULT:\n        handleTypedefDefinition(t, n);\n        break;\n\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hoisted functions will explode if they're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionExpression(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().isName() &&\n            !parent.isCall() &&\n            !parent.isAssign() &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }\n\n```",
            "method_doc": "AST visitor that handles various node types including CALL, ASSIGN, NAME, EXPR_RESULT, FUNCTION, and GETPROP - this method calls methods \"processBaseClassCall\", \"processDefineCall\", \"processRequireCall\", \"processProvideCall\", \"handleCandidateProvideDefinition\", and \"handleTypedefDefinition\" based on node type",
            "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
            "class_doc": " Replaces goog.provide calls, removes goog.require calls, verifies that goog.require has a corresponding goog.provide and some closure specific simplifications.  ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure reveals a discrepancy in how the Closure Pass handles namespace declarations. The test expects that when `goog.require()` is used with Closure Pass enabled, the `goog` namespace should be properly recognized as declared, but instead it's being flagged as an undeclared variable.\n\n**Key Evidence:**\n- Test output shows: \"variable goog is undeclared\"\n- Expected 1 error (MISSING_PROVIDE_ERROR) but got 2 errors\n- The additional error is an undeclared variable error for `goog`\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **ProcessClosurePrimitives** compiler pass or related namespace handling code. Specifically:\n\n**Possible Defect Location:** `ProcessClosurePrimitives.java` or related namespace declaration logic\n\n**Nature of Defect:** The Closure Pass is failing to properly declare the `goog` namespace when processing `goog.require()` statements, causing the `goog` identifier to be treated as an undeclared variable by subsequent compiler passes (like VarCheck).\n\n**Root Cause Hypothesis:** \n- When `enableClosurePass()` is set, the `ProcessClosurePrimitives` pass should implicitly declare the `goog` namespace when encountering Closure Library primitives\n- However, the current implementation appears to be missing this implicit declaration, causing VarCheck to later flag `goog` as an undeclared variable\n- This creates a situation where both the expected `MISSING_PROVIDE_ERROR` and an unexpected undeclared variable error occur\n\nThe defect likely involves the interaction between the Closure Pass and the variable declaration system, where the implicit namespace declarations that should happen during Closure primitive processing are not being properly registered in the symbol table.",
            "test_suite": "com.google.javascript.jscomp.VarCheckTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location to be fixed because it handles goog.require calls in the processRequireCall method but fails to properly declare the 'goog' namespace variable when processing Closure primitives, causing VarCheck to later flag 'goog' as an undeclared variable. The test failure shows that when enableClosurePass() is set, the goog namespace should be implicitly declared but the current implementation doesn't ensure this declaration happens during require call processing."
        },
        {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::processRequireCall(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void processRequireCall(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarParentNode) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarLeftChild = TransVarNode.getFirstChild();\n    Node TransVarChildNode = TransVarLeftChild.getNext();\n    if (!(!(verifyLastArgumentIsString(TransVarTraversal, TransVarLeftChild, TransVarChildNode)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    String TransVarNamespace = TransVarChildNode.getString();\n      ProvidedName TransVarName = providedNames.get(TransVarNamespace);\n      if (!(!(TransVarName == null || !TransVarName.isExplicitlyProvided()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(TransVarNode, TransVarNamespace, TransVarTraversal.getSourceName()));\n      } else {\n        JSModule TransVarFile = TransVarName.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(TransVarFile);\n\n        JSModule TransVarModuleObj = TransVarTraversal.getModule();\n        if (!(!(moduleGraph != null && TransVarModuleObj != TransVarFile\n                && !moduleGraph.dependsOn(TransVarModuleObj, TransVarFile)))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarNode, XMODULE_REQUIRE_ERROR, TransVarNamespace,\n                  TransVarFile.getName(),\n                  TransVarModuleObj.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(TransVarLeftChild);\n      maybeAddStringNodeToSymbolTable(TransVarChildNode);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (!(!(TransVarName != null))) {\n        TransVarParentNode.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n```",
            "method_doc": " Handles a goog.require call. ",
            "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
            "class_doc": " Replaces goog.provide calls, removes goog.require calls, verifies that goog.require has a corresponding goog.provide and some closure specific simplifications.  ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure reveals a discrepancy in how the Closure Pass handles namespace declarations. The test expects that when `goog.require()` is used with Closure Pass enabled, the `goog` namespace should be properly recognized as declared, but instead it's being flagged as an undeclared variable.\n\n**Key Evidence:**\n- Test output shows: \"variable goog is undeclared\"\n- Expected 1 error (MISSING_PROVIDE_ERROR) but got 2 errors\n- The additional error is an undeclared variable error for `goog`\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **ProcessClosurePrimitives** compiler pass or related namespace handling code. Specifically:\n\n**Possible Defect Location:** `ProcessClosurePrimitives.java` or related namespace declaration logic\n\n**Nature of Defect:** The Closure Pass is failing to properly declare the `goog` namespace when processing `goog.require()` statements, causing the `goog` identifier to be treated as an undeclared variable by subsequent compiler passes (like VarCheck).\n\n**Root Cause Hypothesis:** \n- When `enableClosurePass()` is set, the `ProcessClosurePrimitives` pass should implicitly declare the `goog` namespace when encountering Closure Library primitives\n- However, the current implementation appears to be missing this implicit declaration, causing VarCheck to later flag `goog` as an undeclared variable\n- This creates a situation where both the expected `MISSING_PROVIDE_ERROR` and an unexpected undeclared variable error occur\n\nThe defect likely involves the interaction between the Closure Pass and the variable declaration system, where the implicit namespace declarations that should happen during Closure primitive processing are not being properly registered in the symbol table.",
            "test_suite": "com.google.javascript.jscomp.VarCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because the test failure shows that the 'goog' namespace is being treated as an undeclared variable when processing goog.require calls with Closure Pass enabled. The processRequireCall method handles goog.require calls but appears to be missing logic to properly declare the 'goog' namespace in the symbol table, which would explain why VarCheck later flags it as undeclared. The method's responsibility for processing Closure primitives and the test evidence directly point to this as the root cause."
        },
        {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::process(Node,Node)",
            "method_code": "```java\n  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (Node n : defineCalls) {\n      replaceGoogDefines(n);\n    }\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }\n\n```",
            "method_doc": "Main processing method that traverses the AST and handles goog.define calls and provided names - this method calls method \"replace\" to finalize provided names",
            "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
            "class_doc": " Replaces goog.provide calls, removes goog.require calls, verifies that goog.require has a corresponding goog.provide and some closure specific simplifications.  ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure reveals a discrepancy in how the Closure Pass handles namespace declarations. The test expects that when `goog.require()` is used with Closure Pass enabled, the `goog` namespace should be properly recognized as declared, but instead it's being flagged as an undeclared variable.\n\n**Key Evidence:**\n- Test output shows: \"variable goog is undeclared\"\n- Expected 1 error (MISSING_PROVIDE_ERROR) but got 2 errors\n- The additional error is an undeclared variable error for `goog`\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **ProcessClosurePrimitives** compiler pass or related namespace handling code. Specifically:\n\n**Possible Defect Location:** `ProcessClosurePrimitives.java` or related namespace declaration logic\n\n**Nature of Defect:** The Closure Pass is failing to properly declare the `goog` namespace when processing `goog.require()` statements, causing the `goog` identifier to be treated as an undeclared variable by subsequent compiler passes (like VarCheck).\n\n**Root Cause Hypothesis:** \n- When `enableClosurePass()` is set, the `ProcessClosurePrimitives` pass should implicitly declare the `goog` namespace when encountering Closure Library primitives\n- However, the current implementation appears to be missing this implicit declaration, causing VarCheck to later flag `goog` as an undeclared variable\n- This creates a situation where both the expected `MISSING_PROVIDE_ERROR` and an unexpected undeclared variable error occur\n\nThe defect likely involves the interaction between the Closure Pass and the variable declaration system, where the implicit namespace declarations that should happen during Closure primitive processing are not being properly registered in the symbol table.",
            "test_suite": "com.google.javascript.jscomp.VarCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because the test failure shows that the 'goog' namespace is being treated as an undeclared variable when Closure Pass is enabled, and this method is responsible for processing Closure primitives like goog.require. The method should implicitly declare the 'goog' namespace when handling Closure Library calls, but appears to be missing this functionality, causing VarCheck to later flag 'goog' as undeclared. The issue occurs specifically when processing goog.require statements with Closure Pass enabled, which falls directly under this method's responsibility."
        },
        {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::maybeAddToSymbolTable(Node)",
            "method_code": "```java\n  private void maybeAddToSymbolTable(Node n) {\n    if (preprocessorSymbolTable != null) {\n      preprocessorSymbolTable.addReference(n);\n    }\n  }\n\n```",
            "method_doc": " Add the given qualified name node to the symbol table. ",
            "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
            "class_doc": " Replaces goog.provide calls, removes goog.require calls, verifies that goog.require has a corresponding goog.provide and some closure specific simplifications.  ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure reveals a discrepancy in how the Closure Pass handles namespace declarations. The test expects that when `goog.require()` is used with Closure Pass enabled, the `goog` namespace should be properly recognized as declared, but instead it's being flagged as an undeclared variable.\n\n**Key Evidence:**\n- Test output shows: \"variable goog is undeclared\"\n- Expected 1 error (MISSING_PROVIDE_ERROR) but got 2 errors\n- The additional error is an undeclared variable error for `goog`\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **ProcessClosurePrimitives** compiler pass or related namespace handling code. Specifically:\n\n**Possible Defect Location:** `ProcessClosurePrimitives.java` or related namespace declaration logic\n\n**Nature of Defect:** The Closure Pass is failing to properly declare the `goog` namespace when processing `goog.require()` statements, causing the `goog` identifier to be treated as an undeclared variable by subsequent compiler passes (like VarCheck).\n\n**Root Cause Hypothesis:** \n- When `enableClosurePass()` is set, the `ProcessClosurePrimitives` pass should implicitly declare the `goog` namespace when encountering Closure Library primitives\n- However, the current implementation appears to be missing this implicit declaration, causing VarCheck to later flag `goog` as an undeclared variable\n- This creates a situation where both the expected `MISSING_PROVIDE_ERROR` and an unexpected undeclared variable error occur\n\nThe defect likely involves the interaction between the Closure Pass and the variable declaration system, where the implicit namespace declarations that should happen during Closure primitive processing are not being properly registered in the symbol table.",
            "test_suite": "com.google.javascript.jscomp.VarCheckTest",
            "score": 8,
            "reason": "#8# The maybeAddToSymbolTable method is highly suspicious because it only adds references to the preprocessorSymbolTable when it exists, but doesn't handle the core issue where the 'goog' namespace should be implicitly declared when processing Closure primitives. The test failure shows 'goog' is being treated as undeclared, indicating this method isn't properly registering the goog namespace in the main symbol table during Closure primitive processing."
        },
        {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::maybeAddStringNodeToSymbolTable(Node)",
            "method_code": "```java\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (preprocessorSymbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    Node syntheticRef = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), name,\n        n /* real source offsets will be filled in below */,\n        name);\n\n    // Offsets to add to source. Named for documentation purposes.\n    final int forQuote = 1;\n    final int forDot = 1;\n\n    Node current = null;\n    for (current = syntheticRef;\n         current.isGetProp();\n         current = current.getFirstChild()) {\n      int fullLen = current.getQualifiedName().length();\n      int namespaceLen = current.getFirstChild().getQualifiedName().length();\n\n      current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n      current.setLength(fullLen);\n\n      current.getLastChild().setSourceEncodedPosition(\n          n.getSourcePosition() + namespaceLen + forQuote + forDot);\n      current.getLastChild().setLength(\n          current.getLastChild().getString().length());\n    }\n\n    current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n    current.setLength(current.getString().length());\n\n    maybeAddToSymbolTable(syntheticRef);\n  }\n\n```",
            "method_doc": " The string in {@code n} is a reference name. Create a synthetic node for it with all the proper source info, and add it to the symbol table. ",
            "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
            "class_doc": " Replaces goog.provide calls, removes goog.require calls, verifies that goog.require has a corresponding goog.provide and some closure specific simplifications.  ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure reveals a discrepancy in how the Closure Pass handles namespace declarations. The test expects that when `goog.require()` is used with Closure Pass enabled, the `goog` namespace should be properly recognized as declared, but instead it's being flagged as an undeclared variable.\n\n**Key Evidence:**\n- Test output shows: \"variable goog is undeclared\"\n- Expected 1 error (MISSING_PROVIDE_ERROR) but got 2 errors\n- The additional error is an undeclared variable error for `goog`\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **ProcessClosurePrimitives** compiler pass or related namespace handling code. Specifically:\n\n**Possible Defect Location:** `ProcessClosurePrimitives.java` or related namespace declaration logic\n\n**Nature of Defect:** The Closure Pass is failing to properly declare the `goog` namespace when processing `goog.require()` statements, causing the `goog` identifier to be treated as an undeclared variable by subsequent compiler passes (like VarCheck).\n\n**Root Cause Hypothesis:** \n- When `enableClosurePass()` is set, the `ProcessClosurePrimitives` pass should implicitly declare the `goog` namespace when encountering Closure Library primitives\n- However, the current implementation appears to be missing this implicit declaration, causing VarCheck to later flag `goog` as an undeclared variable\n- This creates a situation where both the expected `MISSING_PROVIDE_ERROR` and an unexpected undeclared variable error occur\n\nThe defect likely involves the interaction between the Closure Pass and the variable declaration system, where the implicit namespace declarations that should happen during Closure primitive processing are not being properly registered in the symbol table.",
            "test_suite": "com.google.javascript.jscomp.VarCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it's responsible for adding qualified name nodes to the symbol table, and the test failure shows that the 'goog' namespace is not being properly declared when processing goog.require statements. The method handles creating synthetic reference nodes for namespace identifiers but may be failing to properly register the base 'goog' namespace in the symbol table when processing Closure primitives, causing VarCheck to later flag it as undeclared."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.ProcessClosurePrimitives::processRequireCall(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::processRequireCall(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void processRequireCall(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarParentNode) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarLeftChild = TransVarNode.getFirstChild();\n    Node TransVarChildNode = TransVarLeftChild.getNext();\n    if (!(!(verifyLastArgumentIsString(TransVarTraversal, TransVarLeftChild, TransVarChildNode)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    String TransVarNamespace = TransVarChildNode.getString();\n      ProvidedName TransVarName = providedNames.get(TransVarNamespace);\n      if (!(!(TransVarName == null || !TransVarName.isExplicitlyProvided()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        unrecognizedRequires.add(\n            new UnrecognizedRequire(TransVarNode, TransVarNamespace, TransVarTraversal.getSourceName()));\n      } else {\n        JSModule TransVarFile = TransVarName.explicitModule;\n\n        // This must be non-null, because there was an explicit provide.\n        Preconditions.checkNotNull(TransVarFile);\n\n        JSModule TransVarModuleObj = TransVarTraversal.getModule();\n        if (!(!(moduleGraph != null && TransVarModuleObj != TransVarFile\n                && !moduleGraph.dependsOn(TransVarModuleObj, TransVarFile)))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarNode, XMODULE_REQUIRE_ERROR, TransVarNamespace,\n                  TransVarFile.getName(),\n                  TransVarModuleObj.getName()));\n        }\n      }\n\n      maybeAddToSymbolTable(TransVarLeftChild);\n      maybeAddStringNodeToSymbolTable(TransVarChildNode);\n\n      // Requires should be removed before further processing.\n      // Some clients run closure pass multiple times, first with\n      // the checks for broken requires turned off. In these cases, we\n      // allow broken requires to be preserved by the first run to\n      // let them be caught in the subsequent run.\n      if (!(!(TransVarName != null))) {\n        TransVarParentNode.detachFromParent();\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n```",
            "method_doc": " Handles a goog.require call. "
        },
        "com.google.javascript.jscomp.ProcessClosurePrimitives::process(Node,Node)": {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::process(Node,Node)",
            "method_code": "```java\n  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (Node n : defineCalls) {\n      replaceGoogDefines(n);\n    }\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }\n\n```",
            "method_doc": "Main processing method that traverses the AST and handles goog.define calls and provided names - this method calls method \"replace\" to finalize provided names"
        },
        "com.google.javascript.jscomp.ProcessClosurePrimitives::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.isExprResult();\n        Node left = n.getFirstChild();\n        if (left.isGetProp()) {\n          Node name = left.getFirstChild();\n          if (name.isName() &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"define\".equals(methodName)) {\n              processDefineCall(t, n, parent);\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.isString()) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, IR.number(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n\n      case Token.EXPR_RESULT:\n        handleTypedefDefinition(t, n);\n        break;\n\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hoisted functions will explode if they're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionExpression(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().isName() &&\n            !parent.isCall() &&\n            !parent.isAssign() &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }\n\n```",
            "method_doc": "AST visitor that handles various node types including CALL, ASSIGN, NAME, EXPR_RESULT, FUNCTION, and GETPROP - this method calls methods \"processBaseClassCall\", \"processDefineCall\", \"processRequireCall\", \"processProvideCall\", \"handleCandidateProvideDefinition\", and \"handleTypedefDefinition\" based on node type"
        },
        "com.google.javascript.jscomp.ProcessClosurePrimitives::maybeAddToSymbolTable(Node)": {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::maybeAddToSymbolTable(Node)",
            "method_code": "```java\n  private void maybeAddToSymbolTable(Node n) {\n    if (preprocessorSymbolTable != null) {\n      preprocessorSymbolTable.addReference(n);\n    }\n  }\n\n```",
            "method_doc": " Add the given qualified name node to the symbol table. "
        },
        "com.google.javascript.jscomp.ProcessClosurePrimitives::maybeAddStringNodeToSymbolTable(Node)": {
            "method_name": "com.google.javascript.jscomp.ProcessClosurePrimitives::maybeAddStringNodeToSymbolTable(Node)",
            "method_code": "```java\n  private void maybeAddStringNodeToSymbolTable(Node n) {\n    if (preprocessorSymbolTable == null) {\n      return;\n    }\n\n    String name = n.getString();\n    Node syntheticRef = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention(), name,\n        n /* real source offsets will be filled in below */,\n        name);\n\n    // Offsets to add to source. Named for documentation purposes.\n    final int forQuote = 1;\n    final int forDot = 1;\n\n    Node current = null;\n    for (current = syntheticRef;\n         current.isGetProp();\n         current = current.getFirstChild()) {\n      int fullLen = current.getQualifiedName().length();\n      int namespaceLen = current.getFirstChild().getQualifiedName().length();\n\n      current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n      current.setLength(fullLen);\n\n      current.getLastChild().setSourceEncodedPosition(\n          n.getSourcePosition() + namespaceLen + forQuote + forDot);\n      current.getLastChild().setLength(\n          current.getLastChild().getString().length());\n    }\n\n    current.setSourceEncodedPosition(n.getSourcePosition() + forQuote);\n    current.setLength(current.getString().length());\n\n    maybeAddToSymbolTable(syntheticRef);\n  }\n\n```",
            "method_doc": " The string in {@code n} is a reference name. Create a synthetic node for it with all the proper source info, and add it to the symbol table. "
        }
    }
}