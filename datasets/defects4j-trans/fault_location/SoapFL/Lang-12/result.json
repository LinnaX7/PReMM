{
    "buggy_classes": [
        "org.apache.commons.lang3.RandomStringUtils"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,int,int,boolean,boolean,char[],Random)",
            "method_code": "```java\n    public static String random(int TransVarCount1, int TransVarCount, int TransVarCount2, boolean TransVarLetter, boolean TransVarNum,\n                                char[] TransVarCharacterArray, Random TransVarRandomNumber) {\n        if (!(!(false))) {\n                                        System.out.println(\"log\");\n                                    }\n        if (!(!(TransVarCount1 == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return \"\";\n        } else if (!(!(TransVarCount1 < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            throw new IllegalArgumentException(\"Requested random string length \" + TransVarCount1 + \" is less than 0.\");\n        }\n\n        if (!(!(TransVarCount == 0 && TransVarCount2 == 0))) {\n                if (!(!(!TransVarLetter && !TransVarNum))) {\n                    TransVarCount2 = Integer.MAX_VALUE;\n            } else {\n                    TransVarCount2 = 'z' + 1;\n                    TransVarCount = ' ';                \n                }\n            }\n\n        char[] TransVarBufferChar = new char[TransVarCount1];\n        int TransVarSpaceCount = TransVarCount2 - TransVarCount;\n\n        for (; !(!(TransVarCount1-- != 0));) {\n            char TransVarCharacter;\n            if (!(!(TransVarCharacterArray == null))) {\n                TransVarCharacter = (char) (TransVarRandomNumber.nextInt(TransVarSpaceCount) + TransVarCount);\n            } else {\n                TransVarCharacter = TransVarCharacterArray[TransVarRandomNumber.nextInt(TransVarSpaceCount)\n                        + TransVarCount];\n            }\n            if (!(!(TransVarLetter && Character.isLetter(TransVarCharacter)\n                    || TransVarNum && Character.isDigit(TransVarCharacter) || !TransVarLetter && !TransVarNum))) {\n                if (!(!(TransVarCharacter >= 56320 && TransVarCharacter <= 57343))) {\n                    if (!(!(TransVarCount1 == 0))) {\n                        TransVarCount1++;\n                    } else {\n                        TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                        TransVarCount1--;\n                        TransVarBufferChar[TransVarCount1] = (char) (55296 + TransVarRandomNumber.nextInt(128));\n                    }\n                } else if (!(!(TransVarCharacter >= 55296 && TransVarCharacter <= 56191))) {\n                    if (!(!(TransVarCount1 == 0))) {\n                        TransVarCount1++;\n                    } else {\n                        TransVarBufferChar[TransVarCount1] = (char) (56320 + TransVarRandomNumber.nextInt(128));\n                        TransVarCount1--;\n                        TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                    }\n                } else if (!(!(TransVarCharacter >= 56192 && TransVarCharacter <= 56319))) {\n                    TransVarCount1++;\n                } else {\n                    TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                }\n            } else {\n                TransVarCount1++;\n            }\n        }\n        return new String(TransVarBufferChar);\n    }\n\n```",
            "method_doc": " <p>Creates a random string based on a variety of options, using supplied source of randomness.</p>  <p>If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set to {@code 0} and {@code Integer.MAX_VALUE}.  <p>If set is not {@code null}, characters between start and end are chosen.</p>  <p>This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single  {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be generated repeatedly and predictably.</p>  @param count  the length of random string to create @param start  the position in set of chars to start at @param end  the position in set of chars to end before @param letters  only allow letters? @param numbers  only allow numbers? @param chars  the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the set of all chars. @param random  a source of randomness. @return the random string @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array. @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty. @since 2.0 ",
            "class_name": "org.apache.commons.lang3.RandomStringUtils",
            "class_doc": " <p>Operations for random {@code String}s.</p> <p>Currently <em>private high surrogate</em> characters are ignored.  These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as we don't know how to handle them.  High and low surrogates are correctly dealt with - that is if a  high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f)  then it is followed by a low surrogate. If a low surrogate is chosen,  56320 (dc00) to 57343 (dfff) then it is placed after a randomly  chosen high surrogate. </p>  <p>#ThreadSafe#</p> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across both test failures:**\n- Both tests fail with `ArrayIndexOutOfBoundsException` at the same location: `RandomStringUtils.java:257`\n- Both failures occur when calling `RandomStringUtils.random()` methods\n- Both involve scenarios with restricted character sets:\n  - `testExceptions`: empty character array `new char[0]`\n  - `testLANG805`: single character array `new char[]{'a'}`\n- The stack traces show the same error pattern with large, seemingly random array indices (380688063 and 452623204)\n\n## Step 2: Analyze the Root Cause\n\nThe `ArrayIndexOutOfBoundsException` with large indices suggests that the code is using an unconstrained random number as an array index without proper bounds checking. Specifically:\n\n- When the character array is empty or very small, the random number generator is producing values that exceed the array bounds\n- The large indices (380688063, 452623204) indicate the random number is being used directly as an array index without modulo operation or bounds validation\n- This affects both the empty array case (should throw `IllegalArgumentException`) and the single-character array case (should produce predictable output)\n\n## Step 3: Recommended Defect in Production Code\n\n**The defect is likely in the `RandomStringUtils.random()` method at line 257, where:**\n\n1. **Missing bounds checking**: The code generates random numbers but fails to ensure they are within the valid range of the provided character array\n2. **Insufficient validation for empty/small arrays**: When the character array is empty or has only one element, the random index calculation doesn't properly handle these edge cases\n3. **Missing input validation**: The method should validate that the character array is not empty before proceeding with random character selection\n\n**Expected behavior**: When provided with an empty character array, the method should throw `IllegalArgumentException` immediately. When provided with a small character array, it should use modulo arithmetic to ensure the random index stays within bounds.\n\nThe defect appears to be a combination of missing input validation and improper bounds checking in the random character selection logic.",
            "test_suite": "org.apache.commons.lang3.RandomStringUtilsTest",
            "score": 10,
            "reason": "#10# This method is definitely the best location to be fixed because both test failures occur at line 257 within this method, which is where the ArrayIndexOutOfBoundsException is thrown. The method fails to properly validate the character array input - it doesn't check if the array is empty before using it, and when using non-null character arrays, it incorrectly calculates the random index by using TransVarSpaceCount (which can be very large) without applying modulo operation to ensure the index stays within the bounds of the character array. This explains why both tests fail with large array indices when using small or empty character arrays."
        },
        {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,char[])",
            "method_code": "```java\n    public static String random(int count, char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, RANDOM);\n        }\n        return random(count, 0, chars.length, false, false, chars, RANDOM);\n    }\n\n```",
            "method_doc": " <p>Creates a random string whose length is the number of characters specified.</p>  <p>Characters will be chosen from the set of characters specified.</p>  @param count  the length of random string to create @param chars  the character array containing the set of characters to use, may be null @return the random string @throws IllegalArgumentException if {@code count} &lt; 0. ",
            "class_name": "org.apache.commons.lang3.RandomStringUtils",
            "class_doc": " <p>Operations for random {@code String}s.</p> <p>Currently <em>private high surrogate</em> characters are ignored.  These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as we don't know how to handle them.  High and low surrogates are correctly dealt with - that is if a  high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f)  then it is followed by a low surrogate. If a low surrogate is chosen,  56320 (dc00) to 57343 (dfff) then it is placed after a randomly  chosen high surrogate. </p>  <p>#ThreadSafe#</p> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across both test failures:**\n- Both tests fail with `ArrayIndexOutOfBoundsException` at the same location: `RandomStringUtils.java:257`\n- Both failures occur when calling `RandomStringUtils.random()` methods\n- Both involve scenarios with restricted character sets:\n  - `testExceptions`: empty character array `new char[0]`\n  - `testLANG805`: single character array `new char[]{'a'}`\n- The stack traces show the same error pattern with large, seemingly random array indices (380688063 and 452623204)\n\n## Step 2: Analyze the Root Cause\n\nThe `ArrayIndexOutOfBoundsException` with large indices suggests that the code is using an unconstrained random number as an array index without proper bounds checking. Specifically:\n\n- When the character array is empty or very small, the random number generator is producing values that exceed the array bounds\n- The large indices (380688063, 452623204) indicate the random number is being used directly as an array index without modulo operation or bounds validation\n- This affects both the empty array case (should throw `IllegalArgumentException`) and the single-character array case (should produce predictable output)\n\n## Step 3: Recommended Defect in Production Code\n\n**The defect is likely in the `RandomStringUtils.random()` method at line 257, where:**\n\n1. **Missing bounds checking**: The code generates random numbers but fails to ensure they are within the valid range of the provided character array\n2. **Insufficient validation for empty/small arrays**: When the character array is empty or has only one element, the random index calculation doesn't properly handle these edge cases\n3. **Missing input validation**: The method should validate that the character array is not empty before proceeding with random character selection\n\n**Expected behavior**: When provided with an empty character array, the method should throw `IllegalArgumentException` immediately. When provided with a small character array, it should use modulo arithmetic to ensure the random index stays within bounds.\n\nThe defect appears to be a combination of missing input validation and improper bounds checking in the random character selection logic.",
            "test_suite": "org.apache.commons.lang3.RandomStringUtilsTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it directly passes the character array to another random method without validating that the array is not empty. Both test failures occur when calling this method with problematic character arrays (empty array in testExceptions and single-character array in testLANG805), and the stack traces show ArrayIndexOutOfBoundsException occurring in the called random method, indicating this method should perform input validation before delegation."
        },
        {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,boolean,boolean)",
            "method_code": "```java\n    public static String random(int count, boolean letters, boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n```",
            "method_doc": " <p>Creates a random string whose length is the number of characters specified.</p>  <p>Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.</p>  @param count  the length of random string to create @param letters  if {@code true}, generated string will include alphabetic characters @param numbers  if {@code true}, generated string will include numeric characters @return the random string ",
            "class_name": "org.apache.commons.lang3.RandomStringUtils",
            "class_doc": " <p>Operations for random {@code String}s.</p> <p>Currently <em>private high surrogate</em> characters are ignored.  These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as we don't know how to handle them.  High and low surrogates are correctly dealt with - that is if a  high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f)  then it is followed by a low surrogate. If a low surrogate is chosen,  56320 (dc00) to 57343 (dfff) then it is placed after a randomly  chosen high surrogate. </p>  <p>#ThreadSafe#</p> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across both test failures:**\n- Both tests fail with `ArrayIndexOutOfBoundsException` at the same location: `RandomStringUtils.java:257`\n- Both failures occur when calling `RandomStringUtils.random()` methods\n- Both involve scenarios with restricted character sets:\n  - `testExceptions`: empty character array `new char[0]`\n  - `testLANG805`: single character array `new char[]{'a'}`\n- The stack traces show the same error pattern with large, seemingly random array indices (380688063 and 452623204)\n\n## Step 2: Analyze the Root Cause\n\nThe `ArrayIndexOutOfBoundsException` with large indices suggests that the code is using an unconstrained random number as an array index without proper bounds checking. Specifically:\n\n- When the character array is empty or very small, the random number generator is producing values that exceed the array bounds\n- The large indices (380688063, 452623204) indicate the random number is being used directly as an array index without modulo operation or bounds validation\n- This affects both the empty array case (should throw `IllegalArgumentException`) and the single-character array case (should produce predictable output)\n\n## Step 3: Recommended Defect in Production Code\n\n**The defect is likely in the `RandomStringUtils.random()` method at line 257, where:**\n\n1. **Missing bounds checking**: The code generates random numbers but fails to ensure they are within the valid range of the provided character array\n2. **Insufficient validation for empty/small arrays**: When the character array is empty or has only one element, the random index calculation doesn't properly handle these edge cases\n3. **Missing input validation**: The method should validate that the character array is not empty before proceeding with random character selection\n\n**Expected behavior**: When provided with an empty character array, the method should throw `IllegalArgumentException` immediately. When provided with a small character array, it should use modulo arithmetic to ensure the random index stays within bounds.\n\nThe defect appears to be a combination of missing input validation and improper bounds checking in the random character selection logic.",
            "test_suite": "org.apache.commons.lang3.RandomStringUtilsTest",
            "score": 1,
            "reason": "#1# This method is not the best location that needs to be fixed because it's just a simple wrapper method that delegates to another random method with default parameters. The actual bug causing the ArrayIndexOutOfBoundsException occurs in the underlying implementation that handles character array selection and bounds checking, not in this high-level method signature."
        },
        {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,int,int,boolean,boolean)",
            "method_code": "```java\n    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n        return random(count, start, end, letters, numbers, null, RANDOM);\n    }\n\n```",
            "method_doc": " <p>Creates a random string whose length is the number of characters specified.</p>  <p>Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.</p>  @param count  the length of random string to create @param start  the position in set of chars to start at @param end  the position in set of chars to end before @param letters  if {@code true}, generated string will include alphabetic characters @param numbers  if {@code true}, generated string will include numeric characters @return the random string ",
            "class_name": "org.apache.commons.lang3.RandomStringUtils",
            "class_doc": " <p>Operations for random {@code String}s.</p> <p>Currently <em>private high surrogate</em> characters are ignored.  These are Unicode characters that fall between the values 56192 (db80) and 56319 (dbff) as we don't know how to handle them.  High and low surrogates are correctly dealt with - that is if a  high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f)  then it is followed by a low surrogate. If a low surrogate is chosen,  56320 (dc00) to 57343 (dfff) then it is placed after a randomly  chosen high surrogate. </p>  <p>#ThreadSafe#</p> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across both test failures:**\n- Both tests fail with `ArrayIndexOutOfBoundsException` at the same location: `RandomStringUtils.java:257`\n- Both failures occur when calling `RandomStringUtils.random()` methods\n- Both involve scenarios with restricted character sets:\n  - `testExceptions`: empty character array `new char[0]`\n  - `testLANG805`: single character array `new char[]{'a'}`\n- The stack traces show the same error pattern with large, seemingly random array indices (380688063 and 452623204)\n\n## Step 2: Analyze the Root Cause\n\nThe `ArrayIndexOutOfBoundsException` with large indices suggests that the code is using an unconstrained random number as an array index without proper bounds checking. Specifically:\n\n- When the character array is empty or very small, the random number generator is producing values that exceed the array bounds\n- The large indices (380688063, 452623204) indicate the random number is being used directly as an array index without modulo operation or bounds validation\n- This affects both the empty array case (should throw `IllegalArgumentException`) and the single-character array case (should produce predictable output)\n\n## Step 3: Recommended Defect in Production Code\n\n**The defect is likely in the `RandomStringUtils.random()` method at line 257, where:**\n\n1. **Missing bounds checking**: The code generates random numbers but fails to ensure they are within the valid range of the provided character array\n2. **Insufficient validation for empty/small arrays**: When the character array is empty or has only one element, the random index calculation doesn't properly handle these edge cases\n3. **Missing input validation**: The method should validate that the character array is not empty before proceeding with random character selection\n\n**Expected behavior**: When provided with an empty character array, the method should throw `IllegalArgumentException` immediately. When provided with a small character array, it should use modulo arithmetic to ensure the random index stays within bounds.\n\nThe defect appears to be a combination of missing input validation and improper bounds checking in the random character selection logic.",
            "test_suite": "org.apache.commons.lang3.RandomStringUtilsTest",
            "score": 1,
            "reason": "#1# This method is not the best location that needs to be fixed because it's just a simple wrapper method that delegates to another overloaded random method with additional parameters. The actual bug appears to be in the more complex overloaded method that handles character arrays and random number generation, where the ArrayIndexOutOfBoundsException is occurring according to the stack traces."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.lang3.RandomStringUtils::random(int,int,int,boolean,boolean,char[],Random)": {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,int,int,boolean,boolean,char[],Random)",
            "method_code": "```java\n    public static String random(int TransVarCount1, int TransVarCount, int TransVarCount2, boolean TransVarLetter, boolean TransVarNum,\n                                char[] TransVarCharacterArray, Random TransVarRandomNumber) {\n        if (!(!(false))) {\n                                        System.out.println(\"log\");\n                                    }\n        if (!(!(TransVarCount1 == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return \"\";\n        } else if (!(!(TransVarCount1 < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            throw new IllegalArgumentException(\"Requested random string length \" + TransVarCount1 + \" is less than 0.\");\n        }\n\n        if (!(!(TransVarCount == 0 && TransVarCount2 == 0))) {\n                if (!(!(!TransVarLetter && !TransVarNum))) {\n                    TransVarCount2 = Integer.MAX_VALUE;\n            } else {\n                    TransVarCount2 = 'z' + 1;\n                    TransVarCount = ' ';                \n                }\n            }\n\n        char[] TransVarBufferChar = new char[TransVarCount1];\n        int TransVarSpaceCount = TransVarCount2 - TransVarCount;\n\n        for (; !(!(TransVarCount1-- != 0));) {\n            char TransVarCharacter;\n            if (!(!(TransVarCharacterArray == null))) {\n                TransVarCharacter = (char) (TransVarRandomNumber.nextInt(TransVarSpaceCount) + TransVarCount);\n            } else {\n                TransVarCharacter = TransVarCharacterArray[TransVarRandomNumber.nextInt(TransVarSpaceCount)\n                        + TransVarCount];\n            }\n            if (!(!(TransVarLetter && Character.isLetter(TransVarCharacter)\n                    || TransVarNum && Character.isDigit(TransVarCharacter) || !TransVarLetter && !TransVarNum))) {\n                if (!(!(TransVarCharacter >= 56320 && TransVarCharacter <= 57343))) {\n                    if (!(!(TransVarCount1 == 0))) {\n                        TransVarCount1++;\n                    } else {\n                        TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                        TransVarCount1--;\n                        TransVarBufferChar[TransVarCount1] = (char) (55296 + TransVarRandomNumber.nextInt(128));\n                    }\n                } else if (!(!(TransVarCharacter >= 55296 && TransVarCharacter <= 56191))) {\n                    if (!(!(TransVarCount1 == 0))) {\n                        TransVarCount1++;\n                    } else {\n                        TransVarBufferChar[TransVarCount1] = (char) (56320 + TransVarRandomNumber.nextInt(128));\n                        TransVarCount1--;\n                        TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                    }\n                } else if (!(!(TransVarCharacter >= 56192 && TransVarCharacter <= 56319))) {\n                    TransVarCount1++;\n                } else {\n                    TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                }\n            } else {\n                TransVarCount1++;\n            }\n        }\n        return new String(TransVarBufferChar);\n    }\n\n```",
            "method_doc": " <p>Creates a random string based on a variety of options, using supplied source of randomness.</p>  <p>If start and end are both {@code 0}, start and end are set to {@code ' '} and {@code 'z'}, the ASCII printable characters, will be used, unless letters and numbers are both {@code false}, in which case, start and end are set to {@code 0} and {@code Integer.MAX_VALUE}.  <p>If set is not {@code null}, characters between start and end are chosen.</p>  <p>This method accepts a user-supplied {@link Random} instance to use as a source of randomness. By seeding a single  {@link Random} instance with a fixed seed and using it for each call, the same random sequence of strings can be generated repeatedly and predictably.</p>  @param count  the length of random string to create @param start  the position in set of chars to start at @param end  the position in set of chars to end before @param letters  only allow letters? @param numbers  only allow numbers? @param chars  the set of chars to choose randoms from, must not be empty. If {@code null}, then it will use the set of all chars. @param random  a source of randomness. @return the random string @throws ArrayIndexOutOfBoundsException if there are not {@code (end - start) + 1} characters in the set array. @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty. @since 2.0 "
        },
        "org.apache.commons.lang3.RandomStringUtils::random(int,boolean,boolean)": {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,boolean,boolean)",
            "method_code": "```java\n    public static String random(int count, boolean letters, boolean numbers) {\n        return random(count, 0, 0, letters, numbers);\n    }\n\n```",
            "method_doc": " <p>Creates a random string whose length is the number of characters specified.</p>  <p>Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.</p>  @param count  the length of random string to create @param letters  if {@code true}, generated string will include alphabetic characters @param numbers  if {@code true}, generated string will include numeric characters @return the random string "
        },
        "org.apache.commons.lang3.RandomStringUtils::random(int,int,int,boolean,boolean)": {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,int,int,boolean,boolean)",
            "method_code": "```java\n    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n        return random(count, start, end, letters, numbers, null, RANDOM);\n    }\n\n```",
            "method_doc": " <p>Creates a random string whose length is the number of characters specified.</p>  <p>Characters will be chosen from the set of alpha-numeric characters as indicated by the arguments.</p>  @param count  the length of random string to create @param start  the position in set of chars to start at @param end  the position in set of chars to end before @param letters  if {@code true}, generated string will include alphabetic characters @param numbers  if {@code true}, generated string will include numeric characters @return the random string "
        },
        "org.apache.commons.lang3.RandomStringUtils::random(int,char[])": {
            "method_name": "org.apache.commons.lang3.RandomStringUtils::random(int,char[])",
            "method_code": "```java\n    public static String random(int count, char... chars) {\n        if (chars == null) {\n            return random(count, 0, 0, false, false, null, RANDOM);\n        }\n        return random(count, 0, chars.length, false, false, chars, RANDOM);\n    }\n\n```",
            "method_doc": " <p>Creates a random string whose length is the number of characters specified.</p>  <p>Characters will be chosen from the set of characters specified.</p>  @param count  the length of random string to create @param chars  the character array containing the set of characters to use, may be null @return the random string @throws IllegalArgumentException if {@code count} &lt; 0. "
        }
    }
}