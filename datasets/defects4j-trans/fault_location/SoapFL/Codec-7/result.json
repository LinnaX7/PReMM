{
    "buggy_classes": [
        "org.apache.commons.codec.binary.Base64"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @param urlSafe if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters. @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE} @since 1.4 ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Looking at the test failures and analyzing the patterns, I can identify the common issue:\n\n**Common Pattern Analysis:**\n\n1. **Both tests fail on static method calls**: \n   - `testByteToStringVariations` fails at `Base64.encodeBase64String(b1)`\n   - `testRfc4648Section10Encode` fails at `Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\"))`\n\n2. **Same symptom in both failures**: \n   - The expected values end with `=` (padding characters) but the actual output has extra characters\n   - Stack traces show comparison failures where expected ends with `=[]` but actual ends with `=[\\n]` (or similar line break)\n\n3. **Instance vs Static method discrepancy**:\n   - In `testByteToStringVariations`, the instance method `base64.encodeToString(b1)` works correctly\n   - But the static method `Base64.encodeBase64String(b1)` fails with the same input\n\n4. **Padding-related failures**:\n   - Both failing assertions involve inputs that require padding (`\"Hello World\"` and `\"f\"`)\n   - The static method appears to be adding unexpected characters after the padding\n\n**Recommended Possible Defect in Production Code:**\n\nThe issue likely lies in the **static `encodeBase64String` method** in the `Base64` class. The defect appears to be that the static method is incorrectly handling line breaks or adding extra characters when it shouldn't.\n\nSpecifically, the static method might be:\n- Using a default line length that adds line breaks even when not requested\n- Failing to respect the \"no line breaks\" configuration that should be the default for `encodeBase64String`\n- Having a bug in the padding logic that adds extra characters after the `=` padding\n\nThe instance method works correctly because it's explicitly constructed with `new Base64(0)` (line length 0 = no line breaks), while the static method might be using a different default configuration that includes line breaks.\n\n**Root Cause Hypothesis**: The static `encodeBase64String` method is likely using a Base64 encoder instance that has line breaks enabled by default, causing it to add unexpected newline characters after padding, which breaks the RFC 4648 compliance and causes the test failures.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it's the entry point for the static encoding methods and likely uses default parameters that cause line breaks to be added. The test failures show that static method calls (encodeBase64String) are adding unexpected characters after padding, while instance methods work correctly. The encodeBase64String method internally calls this encodeBase64 method, and the default behavior appears to be adding line breaks (chunking) when it shouldn't for simple string encoding operations."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64String(byte[])",
            "method_code": "```java\n    public static String encodeBase64String(byte[] TransVarBytes) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return StringUtils.newStringUtf8(encodeBase64(TransVarBytes, true));\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.  @param binaryData binary data to encode @return String containing Base64 characters. @since 1.4 ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Looking at the test failures and analyzing the patterns, I can identify the common issue:\n\n**Common Pattern Analysis:**\n\n1. **Both tests fail on static method calls**: \n   - `testByteToStringVariations` fails at `Base64.encodeBase64String(b1)`\n   - `testRfc4648Section10Encode` fails at `Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\"))`\n\n2. **Same symptom in both failures**: \n   - The expected values end with `=` (padding characters) but the actual output has extra characters\n   - Stack traces show comparison failures where expected ends with `=[]` but actual ends with `=[\\n]` (or similar line break)\n\n3. **Instance vs Static method discrepancy**:\n   - In `testByteToStringVariations`, the instance method `base64.encodeToString(b1)` works correctly\n   - But the static method `Base64.encodeBase64String(b1)` fails with the same input\n\n4. **Padding-related failures**:\n   - Both failing assertions involve inputs that require padding (`\"Hello World\"` and `\"f\"`)\n   - The static method appears to be adding unexpected characters after the padding\n\n**Recommended Possible Defect in Production Code:**\n\nThe issue likely lies in the **static `encodeBase64String` method** in the `Base64` class. The defect appears to be that the static method is incorrectly handling line breaks or adding extra characters when it shouldn't.\n\nSpecifically, the static method might be:\n- Using a default line length that adds line breaks even when not requested\n- Failing to respect the \"no line breaks\" configuration that should be the default for `encodeBase64String`\n- Having a bug in the padding logic that adds extra characters after the `=` padding\n\nThe instance method works correctly because it's explicitly constructed with `new Base64(0)` (line length 0 = no line breaks), while the static method might be using a different default configuration that includes line breaks.\n\n**Root Cause Hypothesis**: The static `encodeBase64String` method is likely using a Base64 encoder instance that has line breaks enabled by default, causing it to add unexpected newline characters after padding, which breaks the RFC 4648 compliance and causes the test failures.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 10,
            "reason": "#10# This method is very likely to be the best location that needs to be fixed because it directly calls encodeBase64 with line breaks enabled (true parameter), which causes the static method to add unexpected line separators after padding characters, explaining why both test failures show extra characters appearing after the '=' padding in the output. The instance method works correctly because it's constructed with line length 0 (no line breaks), while this static method forces line breaks regardless of the intended RFC 4648 compliance."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean,int)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @param urlSafe if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters. @param maxResultSize The maximum result size to accept. @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than maxResultSize @since 1.4 ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Looking at the test failures and analyzing the patterns, I can identify the common issue:\n\n**Common Pattern Analysis:**\n\n1. **Both tests fail on static method calls**: \n   - `testByteToStringVariations` fails at `Base64.encodeBase64String(b1)`\n   - `testRfc4648Section10Encode` fails at `Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\"))`\n\n2. **Same symptom in both failures**: \n   - The expected values end with `=` (padding characters) but the actual output has extra characters\n   - Stack traces show comparison failures where expected ends with `=[]` but actual ends with `=[\\n]` (or similar line break)\n\n3. **Instance vs Static method discrepancy**:\n   - In `testByteToStringVariations`, the instance method `base64.encodeToString(b1)` works correctly\n   - But the static method `Base64.encodeBase64String(b1)` fails with the same input\n\n4. **Padding-related failures**:\n   - Both failing assertions involve inputs that require padding (`\"Hello World\"` and `\"f\"`)\n   - The static method appears to be adding unexpected characters after the padding\n\n**Recommended Possible Defect in Production Code:**\n\nThe issue likely lies in the **static `encodeBase64String` method** in the `Base64` class. The defect appears to be that the static method is incorrectly handling line breaks or adding extra characters when it shouldn't.\n\nSpecifically, the static method might be:\n- Using a default line length that adds line breaks even when not requested\n- Failing to respect the \"no line breaks\" configuration that should be the default for `encodeBase64String`\n- Having a bug in the padding logic that adds extra characters after the `=` padding\n\nThe instance method works correctly because it's explicitly constructed with `new Base64(0)` (line length 0 = no line breaks), while the static method might be using a different default configuration that includes line breaks.\n\n**Root Cause Hypothesis**: The static `encodeBase64String` method is likely using a Base64 encoder instance that has line breaks enabled by default, causing it to add unexpected newline characters after padding, which breaks the RFC 4648 compliance and causes the test failures.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 9,
            "reason": "#9# The method is highly suspicious because it creates a Base64 instance with MIME_CHUNK_SIZE (76) when isChunked is true, which adds line separators. The test failures show that static encodeBase64String calls are adding unexpected line breaks after padding characters, while instance methods with lineLength=0 work correctly. The issue is that encodeBase64String likely calls this method with isChunked=true by default, causing unwanted line breaks that violate RFC 4648 requirements for no line separators in basic Base64 encoding."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE} ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Looking at the test failures and analyzing the patterns, I can identify the common issue:\n\n**Common Pattern Analysis:**\n\n1. **Both tests fail on static method calls**: \n   - `testByteToStringVariations` fails at `Base64.encodeBase64String(b1)`\n   - `testRfc4648Section10Encode` fails at `Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\"))`\n\n2. **Same symptom in both failures**: \n   - The expected values end with `=` (padding characters) but the actual output has extra characters\n   - Stack traces show comparison failures where expected ends with `=[]` but actual ends with `=[\\n]` (or similar line break)\n\n3. **Instance vs Static method discrepancy**:\n   - In `testByteToStringVariations`, the instance method `base64.encodeToString(b1)` works correctly\n   - But the static method `Base64.encodeBase64String(b1)` fails with the same input\n\n4. **Padding-related failures**:\n   - Both failing assertions involve inputs that require padding (`\"Hello World\"` and `\"f\"`)\n   - The static method appears to be adding unexpected characters after the padding\n\n**Recommended Possible Defect in Production Code:**\n\nThe issue likely lies in the **static `encodeBase64String` method** in the `Base64` class. The defect appears to be that the static method is incorrectly handling line breaks or adding extra characters when it shouldn't.\n\nSpecifically, the static method might be:\n- Using a default line length that adds line breaks even when not requested\n- Failing to respect the \"no line breaks\" configuration that should be the default for `encodeBase64String`\n- Having a bug in the padding logic that adds extra characters after the `=` padding\n\nThe instance method works correctly because it's explicitly constructed with `new Base64(0)` (line length 0 = no line breaks), while the static method might be using a different default configuration that includes line breaks.\n\n**Root Cause Hypothesis**: The static `encodeBase64String` method is likely using a Base64 encoder instance that has line breaks enabled by default, causing it to add unexpected newline characters after padding, which breaks the RFC 4648 compliance and causes the test failures.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it's the entry point for the static encoding functionality and delegates to an overloaded method. The test failures show that static method calls (encodeBase64String) are adding unexpected line breaks after padding characters, while instance methods work correctly. Since encodeBase64String internally calls encodeBase64, and the issue is specifically with static methods adding unwanted line breaks, this method's delegation logic or the method it calls is likely using incorrect default parameters that enable chunking/line breaks when they shouldn't be present for basic string encoding operations."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[])",
            "method_code": "```java\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n```",
            "method_doc": " Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.  @param pArray a byte array containing binary data @return A byte array containing only Base64 character data ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Looking at the test failures and analyzing the patterns, I can identify the common issue:\n\n**Common Pattern Analysis:**\n\n1. **Both tests fail on static method calls**: \n   - `testByteToStringVariations` fails at `Base64.encodeBase64String(b1)`\n   - `testRfc4648Section10Encode` fails at `Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\"))`\n\n2. **Same symptom in both failures**: \n   - The expected values end with `=` (padding characters) but the actual output has extra characters\n   - Stack traces show comparison failures where expected ends with `=[]` but actual ends with `=[\\n]` (or similar line break)\n\n3. **Instance vs Static method discrepancy**:\n   - In `testByteToStringVariations`, the instance method `base64.encodeToString(b1)` works correctly\n   - But the static method `Base64.encodeBase64String(b1)` fails with the same input\n\n4. **Padding-related failures**:\n   - Both failing assertions involve inputs that require padding (`\"Hello World\"` and `\"f\"`)\n   - The static method appears to be adding unexpected characters after the padding\n\n**Recommended Possible Defect in Production Code:**\n\nThe issue likely lies in the **static `encodeBase64String` method** in the `Base64` class. The defect appears to be that the static method is incorrectly handling line breaks or adding extra characters when it shouldn't.\n\nSpecifically, the static method might be:\n- Using a default line length that adds line breaks even when not requested\n- Failing to respect the \"no line breaks\" configuration that should be the default for `encodeBase64String`\n- Having a bug in the padding logic that adds extra characters after the `=` padding\n\nThe instance method works correctly because it's explicitly constructed with `new Base64(0)` (line length 0 = no line breaks), while the static method might be using a different default configuration that includes line breaks.\n\n**Root Cause Hypothesis**: The static `encodeBase64String` method is likely using a Base64 encoder instance that has line breaks enabled by default, causing it to add unexpected newline characters after padding, which breaks the RFC 4648 compliance and causes the test failures.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed, because the test failures show that static method encodeBase64String is adding unexpected line breaks after padding characters, and this encode method contains the core encoding logic including line length handling and buffer management. The method uses lineLength and lineSeparator fields which could be causing the static method to add unwanted newlines, and the buffer resizing logic might be incorrectly handling the final output when line breaks are involved."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean,int)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @param urlSafe if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters. @param maxResultSize The maximum result size to accept. @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than maxResultSize @since 1.4 "
        },
        "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean)": {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        return encodeBase64(binaryData, isChunked, false);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE} "
        },
        "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean)": {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe) {\n        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @param urlSafe if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters. @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than {@link Integer#MAX_VALUE} @since 1.4 "
        },
        "org.apache.commons.codec.binary.Base64::encode(byte[])": {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[])",
            "method_code": "```java\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n```",
            "method_doc": " Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.  @param pArray a byte array containing binary data @return A byte array containing only Base64 character data "
        },
        "org.apache.commons.codec.binary.Base64::encodeBase64String(byte[])": {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64String(byte[])",
            "method_code": "```java\n    public static String encodeBase64String(byte[] TransVarBytes) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return StringUtils.newStringUtf8(encodeBase64(TransVarBytes, true));\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.  @param binaryData binary data to encode @return String containing Base64 characters. @since 1.4 "
        }
    }
}