{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::addBeanProps(DeserializationContext,BeanDescription,BeanDeserializerBuilder)",
            "method_code": "```java\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMember anySetter = beanDesc.findAnySetterAccessor();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        } else {\n            // 23-Jan-2018, tatu: although [databind#1805] would suggest we should block\n            //   properties regardless, for now only consider unless there's any setter...\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            \n            // 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n            //   we need to do linkage (as per [databind#318]), and so need to start with\n            //   other types, and only then create constructor parameter, if any.\n            if (propDef.hasSetter()) {\n                AnnotatedMethod setter = propDef.getSetter();\n                JavaType propertyType = setter.getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                AnnotatedField field = propDef.getField();\n                JavaType propertyType = field.getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else {\n                // NOTE: specifically getter, since field was already checked above\n                AnnotatedMethod getter = propDef.getGetter();\n                if (getter != null) {\n                    if (useGettersAsSetters && _isSetterlessType(getter.getRawType())) {\n                        // 23-Jan-2018, tatu: As per [databind#1805], need to ensure we don't\n                        //   accidentally sneak in getter-as-setter for `READ_ONLY` properties\n                        if (builder.hasIgnorable(propDef.getName())) {\n                            ;\n                        } else {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    } else if (!propDef.hasConstructorParameter()) {\n                        PropertyMetadata md = propDef.getMetadata();\n                        // 25-Oct-2016, tatu: If merging enabled, might not need setter.\n                        //   We cannot quite support this with creator parameters; in theory\n                        //   possibly, but right not not due to complexities of routing, so\n                        //   just prevent\n                        if (md.getMergeInfo() != null) {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    }\n                }\n            }\n\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                cprop.setViews(views);\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n            if (prop != null) {\n                // one more thing before adding to builder: copy any metadata\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n\n```",
            "method_doc": " Method called to figure out settable properties for the bean deserializer to use. <p> Note: designed to be overridable, and effort is made to keep interface similar between versions. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory",
            "class_doc": " Concrete deserializer factory class that adds full Bean deserializer construction logic using class introspection. Note that factories specifically do not implement any form of caching: aside from configuration they are stateless; caching is implemented by other components. <p> Instances of this class are fully immutable as all configuration is done by using \"fluent factories\" (methods that construct new factory instances with different configuration, instead of modifying instance). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the core issue and recommend the likely defect in the production code.\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that Jackson cannot find a creator property with the snake case name `param_name0`, even though it knows about the camel case property `paramName0`. This indicates a mismatch between the JSON property naming convention (snake case) and the Java constructor parameter naming convention.\n\n**Key Evidence:**\n- Error message: \"Could not find creator property with name 'param_name0' (known Creator properties: [paramName0])\"\n- The test is using snake case JSON (`param_name0`) but the constructor expects camel case (`paramName0`)\n- The naming strategy appears to be configured but isn't being properly applied to constructor parameter resolution\n\n## Recommended Production Code Defect\n\nThe likely defect is in Jackson's deserialization logic where the **naming strategy is not being consistently applied to constructor parameters during the creator property discovery phase**.\n\n**Specific Location:** The bug is probably in the code that maps JSON property names to constructor parameters when using naming strategies. The naming strategy is likely being applied to field/property access but not to constructor parameter resolution.\n\n**Expected Behavior:** When a snake case naming strategy is configured, Jackson should automatically map `param_name0` in JSON to the `paramName0` constructor parameter.\n\n**Actual Behavior:** The naming strategy is not being considered when looking up constructor parameters, so Jackson only recognizes the exact Java parameter name `paramName0` and cannot find a match for the JSON property `param_name0`.\n\n**Root Cause:** The production code defect is likely in the property discovery mechanism for constructors, specifically in how naming strategies are integrated with constructor parameter resolution in the deserialization process.\n\nThis is a classic case where naming strategy configuration works for field/property access but fails for constructor-based deserialization, indicating an inconsistency in how naming strategies are applied across different deserialization pathways.",
            "test_suite": "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location that needs to be fixed because it handles the mapping of JSON properties to constructor parameters, and the error occurs specifically when trying to match snake case JSON property \"param_name0\" to the camel case constructor parameter \"paramName0\". The method contains the logic for finding creator properties and reports the \"Could not find creator property\" error at line 567, indicating it's responsible for the naming strategy mismatch between JSON input and constructor parameter resolution."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::buildBeanDeserializer(DeserializationContext,JavaType,BeanDescription)",
            "method_code": "```java\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        // may have modifier(s) that wants to modify or replace serializer we just built\n        // (note that `resolve()` and `createContextual()` called later on)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n```",
            "method_doc": " Method that is to actually build a bean deserializer instance. All basic sanity checks have been done to know that what we have may be a valid bean type, and that there are no default simple deserializers. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory",
            "class_doc": " Concrete deserializer factory class that adds full Bean deserializer construction logic using class introspection. Note that factories specifically do not implement any form of caching: aside from configuration they are stateless; caching is implemented by other components. <p> Instances of this class are fully immutable as all configuration is done by using \"fluent factories\" (methods that construct new factory instances with different configuration, instead of modifying instance). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the core issue and recommend the likely defect in the production code.\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that Jackson cannot find a creator property with the snake case name `param_name0`, even though it knows about the camel case property `paramName0`. This indicates a mismatch between the JSON property naming convention (snake case) and the Java constructor parameter naming convention.\n\n**Key Evidence:**\n- Error message: \"Could not find creator property with name 'param_name0' (known Creator properties: [paramName0])\"\n- The test is using snake case JSON (`param_name0`) but the constructor expects camel case (`paramName0`)\n- The naming strategy appears to be configured but isn't being properly applied to constructor parameter resolution\n\n## Recommended Production Code Defect\n\nThe likely defect is in Jackson's deserialization logic where the **naming strategy is not being consistently applied to constructor parameters during the creator property discovery phase**.\n\n**Specific Location:** The bug is probably in the code that maps JSON property names to constructor parameters when using naming strategies. The naming strategy is likely being applied to field/property access but not to constructor parameter resolution.\n\n**Expected Behavior:** When a snake case naming strategy is configured, Jackson should automatically map `param_name0` in JSON to the `paramName0` constructor parameter.\n\n**Actual Behavior:** The naming strategy is not being considered when looking up constructor parameters, so Jackson only recognizes the exact Java parameter name `paramName0` and cannot find a match for the JSON property `param_name0`.\n\n**Root Cause:** The production code defect is likely in the property discovery mechanism for constructors, specifically in how naming strategies are integrated with constructor parameter resolution in the deserialization process.\n\nThis is a classic case where naming strategy configuration works for field/property access but fails for constructor-based deserialization, indicating an inconsistency in how naming strategies are applied across different deserialization pathways.",
            "test_suite": "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it orchestrates the entire bean deserializer construction process, including calling addBeanProps() where the naming strategy mismatch occurs. The error stack trace shows the failure happens in addBeanProps() which is called from this method, and this method controls the overall deserializer building flow where naming strategy integration should be consistently applied across all property resolution phases, including constructor parameter mapping."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::createBeanDeserializer(DeserializationContext,JavaType,BeanDescription)",
            "method_code": "```java\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        // Or, for abstract types, may have alternate means for resolution\n        // (defaulting, materialization)\n\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        _validateSubType(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n```",
            "method_doc": " Method that {@link DeserializerCache}s call to create a new deserializer for types other than Collections, Maps, arrays and enums. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory",
            "class_doc": " Concrete deserializer factory class that adds full Bean deserializer construction logic using class introspection. Note that factories specifically do not implement any form of caching: aside from configuration they are stateless; caching is implemented by other components. <p> Instances of this class are fully immutable as all configuration is done by using \"fluent factories\" (methods that construct new factory instances with different configuration, instead of modifying instance). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the core issue and recommend the likely defect in the production code.\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that Jackson cannot find a creator property with the snake case name `param_name0`, even though it knows about the camel case property `paramName0`. This indicates a mismatch between the JSON property naming convention (snake case) and the Java constructor parameter naming convention.\n\n**Key Evidence:**\n- Error message: \"Could not find creator property with name 'param_name0' (known Creator properties: [paramName0])\"\n- The test is using snake case JSON (`param_name0`) but the constructor expects camel case (`paramName0`)\n- The naming strategy appears to be configured but isn't being properly applied to constructor parameter resolution\n\n## Recommended Production Code Defect\n\nThe likely defect is in Jackson's deserialization logic where the **naming strategy is not being consistently applied to constructor parameters during the creator property discovery phase**.\n\n**Specific Location:** The bug is probably in the code that maps JSON property names to constructor parameters when using naming strategies. The naming strategy is likely being applied to field/property access but not to constructor parameter resolution.\n\n**Expected Behavior:** When a snake case naming strategy is configured, Jackson should automatically map `param_name0` in JSON to the `paramName0` constructor parameter.\n\n**Actual Behavior:** The naming strategy is not being considered when looking up constructor parameters, so Jackson only recognizes the exact Java parameter name `paramName0` and cannot find a match for the JSON property `param_name0`.\n\n**Root Cause:** The production code defect is likely in the property discovery mechanism for constructors, specifically in how naming strategies are integrated with constructor parameter resolution in the deserialization process.\n\nThis is a classic case where naming strategy configuration works for field/property access but fails for constructor-based deserialization, indicating an inconsistency in how naming strategies are applied across different deserialization pathways.",
            "test_suite": "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest",
            "score": 3,
            "reason": "#3# This method is primarily a factory method that delegates to other methods for actual deserializer construction. While it's involved in the deserialization process, the actual issue with naming strategy application to constructor parameters likely occurs deeper in the call chain, specifically in methods like buildBeanDeserializer or addBeanProps where property discovery and constructor parameter mapping happens."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::constructSettableProperty(DeserializationContext,BeanDescription,BeanPropertyDefinition,JavaType)",
            "method_code": "```java\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        // 08-Sep-2016, tatu: issues like [databind#1342] suggest something fishy\n        //   going on; add sanity checks to try to pin down actual problem...\n        //   Possibly passing creator parameter?\n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        // Does the Method specify the deserializer to use? If so, let's use it.\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            // 08-Sep-2016, tatu: wonder if we should verify it is `AnnotatedField` to be safe?\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n```",
            "method_doc": " Method that will construct a regular bean property setter using the given setter method.  @return Property constructed, if any; or null to indicate that there should be no property based on given definitions. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory",
            "class_doc": " Concrete deserializer factory class that adds full Bean deserializer construction logic using class introspection. Note that factories specifically do not implement any form of caching: aside from configuration they are stateless; caching is implemented by other components. <p> Instances of this class are fully immutable as all configuration is done by using \"fluent factories\" (methods that construct new factory instances with different configuration, instead of modifying instance). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the core issue and recommend the likely defect in the production code.\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that Jackson cannot find a creator property with the snake case name `param_name0`, even though it knows about the camel case property `paramName0`. This indicates a mismatch between the JSON property naming convention (snake case) and the Java constructor parameter naming convention.\n\n**Key Evidence:**\n- Error message: \"Could not find creator property with name 'param_name0' (known Creator properties: [paramName0])\"\n- The test is using snake case JSON (`param_name0`) but the constructor expects camel case (`paramName0`)\n- The naming strategy appears to be configured but isn't being properly applied to constructor parameter resolution\n\n## Recommended Production Code Defect\n\nThe likely defect is in Jackson's deserialization logic where the **naming strategy is not being consistently applied to constructor parameters during the creator property discovery phase**.\n\n**Specific Location:** The bug is probably in the code that maps JSON property names to constructor parameters when using naming strategies. The naming strategy is likely being applied to field/property access but not to constructor parameter resolution.\n\n**Expected Behavior:** When a snake case naming strategy is configured, Jackson should automatically map `param_name0` in JSON to the `paramName0` constructor parameter.\n\n**Actual Behavior:** The naming strategy is not being considered when looking up constructor parameters, so Jackson only recognizes the exact Java parameter name `paramName0` and cannot find a match for the JSON property `param_name0`.\n\n**Root Cause:** The production code defect is likely in the property discovery mechanism for constructors, specifically in how naming strategies are integrated with constructor parameter resolution in the deserialization process.\n\nThis is a classic case where naming strategy configuration works for field/property access but fails for constructor-based deserialization, indicating an inconsistency in how naming strategies are applied across different deserialization pathways.",
            "test_suite": "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest",
            "score": 3,
            "reason": "#3# This method handles property construction for setters and fields, but the test failure specifically involves constructor parameter resolution with naming strategies, which is likely handled in a different part of the deserialization process for creator properties."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::buildBeanDeserializer(DeserializationContext,JavaType,BeanDescription)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::buildBeanDeserializer(DeserializationContext,JavaType,BeanDescription)",
            "method_code": "```java\n    @SuppressWarnings(\"unchecked\")\n    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        // First: check what creators we can use, if any\n        ValueInstantiator valueInstantiator;\n        /* 04-Jun-2015, tatu: To work around [databind#636], need to catch the\n         *    issue, defer; this seems like a reasonable good place for now.\n         *   Note, however, that for non-Bean types (Collections, Maps) this\n         *   probably won't work and needs to be added elsewhere.\n         */\n        try {\n            valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n        } catch (NoClassDefFoundError error) {\n            return new ErrorThrowingDeserializer(error);\n        } catch (IllegalArgumentException e) {\n            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n            //   to throw proper exception, it doesn't actually have reference to this\n            //   instance so...\n            throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(),\n                    beanDesc, null);\n        }\n        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n        builder.setValueInstantiator(valueInstantiator);\n         // And then setters for deserializing from JSON Object\n        addBeanProps(ctxt, beanDesc, builder);\n        addObjectIdReader(ctxt, beanDesc, builder);\n\n        // managed/back reference fields/setters need special handling... first part\n        addBackReferenceProperties(ctxt, beanDesc, builder);\n        addInjectables(ctxt, beanDesc, builder);\n        \n        final DeserializationConfig config = ctxt.getConfig();\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                builder = mod.updateBuilder(config, beanDesc, builder);\n            }\n        }\n        JsonDeserializer<?> deserializer;\n\n        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n            deserializer = builder.buildAbstract();\n        } else {\n            deserializer = builder.build();\n        }\n        // may have modifier(s) that wants to modify or replace serializer we just built\n        // (note that `resolve()` and `createContextual()` called later on)\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n            }\n        }\n        return (JsonDeserializer<Object>) deserializer;\n    }\n\n```",
            "method_doc": " Method that is to actually build a bean deserializer instance. All basic sanity checks have been done to know that what we have may be a valid bean type, and that there are no default simple deserializers. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::createBeanDeserializer(DeserializationContext,JavaType,BeanDescription)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::createBeanDeserializer(DeserializationContext,JavaType,BeanDescription)",
            "method_code": "```java\n    @Override\n    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        // We may also have custom overrides:\n        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n        if (custom != null) {\n            return custom;\n        }\n        /* One more thing to check: do we have an exception type\n         * (Throwable or its sub-classes)? If so, need slightly\n         * different handling.\n         */\n        if (type.isThrowable()) {\n            return buildThrowableDeserializer(ctxt, type, beanDesc);\n        }\n        // Or, for abstract types, may have alternate means for resolution\n        // (defaulting, materialization)\n\n        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n        //    not something we could materialize anything for\n        if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n            // Let's make it possible to materialize abstract types.\n            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n            if (concreteType != null) {\n                /* important: introspect actual implementation (abstract class or\n                 * interface doesn't have constructors, for one)\n                 */\n                beanDesc = config.introspect(concreteType);\n                return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n            }\n        }\n        // Otherwise, may want to check handlers for standard types, from superclass:\n        @SuppressWarnings(\"unchecked\")\n        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n        if (deser != null) {\n            return deser;\n        }\n\n        // Otherwise: could the class be a Bean class? If not, bail out\n        if (!isPotentialBeanType(type.getRawClass())) {\n            return null;\n        }\n        // For checks like [databind#1599]\n        _validateSubType(ctxt, type, beanDesc);\n        // Use generic bean introspection to build deserializer\n        return buildBeanDeserializer(ctxt, type, beanDesc);\n    }\n\n```",
            "method_doc": " Method that {@link DeserializerCache}s call to create a new deserializer for types other than Collections, Maps, arrays and enums. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::addBeanProps(DeserializationContext,BeanDescription,BeanDeserializerBuilder)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::addBeanProps(DeserializationContext,BeanDescription,BeanDeserializerBuilder)",
            "method_code": "```java\n    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n\n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMember anySetter = beanDesc.findAnySetterAccessor();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        } else {\n            // 23-Jan-2018, tatu: although [databind#1805] would suggest we should block\n            //   properties regardless, for now only consider unless there's any setter...\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n\n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            \n            // 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n            //   we need to do linkage (as per [databind#318]), and so need to start with\n            //   other types, and only then create constructor parameter, if any.\n            if (propDef.hasSetter()) {\n                AnnotatedMethod setter = propDef.getSetter();\n                JavaType propertyType = setter.getParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                AnnotatedField field = propDef.getField();\n                JavaType propertyType = field.getType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else {\n                // NOTE: specifically getter, since field was already checked above\n                AnnotatedMethod getter = propDef.getGetter();\n                if (getter != null) {\n                    if (useGettersAsSetters && _isSetterlessType(getter.getRawType())) {\n                        // 23-Jan-2018, tatu: As per [databind#1805], need to ensure we don't\n                        //   accidentally sneak in getter-as-setter for `READ_ONLY` properties\n                        if (builder.hasIgnorable(propDef.getName())) {\n                            ;\n                        } else {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    } else if (!propDef.hasConstructorParameter()) {\n                        PropertyMetadata md = propDef.getMetadata();\n                        // 25-Oct-2016, tatu: If merging enabled, might not need setter.\n                        //   We cannot quite support this with creator parameters; in theory\n                        //   possibly, but right not not due to complexities of routing, so\n                        //   just prevent\n                        if (md.getMergeInfo() != null) {\n                            prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                        }\n                    }\n                }\n            }\n\n            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n            //   (since they are never used anyway)\n            if (hasCreatorProps && propDef.hasConstructorParameter()) {\n                /* If property is passed via constructor parameter, we must\n                 * handle things in special way. Not sure what is the most optimal way...\n                 * for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                CreatorProperty cprop = null;\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n                            cprop = (CreatorProperty) cp;\n                            break;\n                        }\n                    }\n                }\n                if (cprop == null) {\n                    List<String> n = new ArrayList<>();\n                    for (SettableBeanProperty cp : creatorProps) {\n                        n.add(cp.getName());\n                    }\n                    ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n                            \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                            name, n);\n                    continue;\n                }\n                if (prop != null) {\n                    cprop.setFallbackSetter(prop);\n                }\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                cprop.setViews(views);\n                builder.addCreatorProperty(cprop);\n                continue;\n            }\n            if (prop != null) {\n                // one more thing before adding to builder: copy any metadata\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    views = beanDesc.findDefaultViews();\n                }\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }\n\n```",
            "method_doc": " Method called to figure out settable properties for the bean deserializer to use. <p> Note: designed to be overridable, and effort is made to keep interface similar between versions. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::constructSettableProperty(DeserializationContext,BeanDescription,BeanPropertyDefinition,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory::constructSettableProperty(DeserializationContext,BeanDescription,BeanPropertyDefinition,JavaType)",
            "method_code": "```java\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        // 08-Sep-2016, tatu: issues like [databind#1342] suggest something fishy\n        //   going on; add sanity checks to try to pin down actual problem...\n        //   Possibly passing creator parameter?\n        if (mutator == null) {\n            ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"No non-constructor mutator available\");\n        }\n        JavaType type = resolveMemberAndTypeAnnotations(ctxt, mutator, propType0);\n        // Does the Method specify the deserializer to use? If so, let's use it.\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            // 08-Sep-2016, tatu: wonder if we should verify it is `AnnotatedField` to be safe?\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, mutator);\n        if (deser == null) {\n            deser = type.getValueHandler();\n        }\n        if (deser != null) {\n            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n            prop = prop.withValueDeserializer(deser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if (objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n\n```",
            "method_doc": " Method that will construct a regular bean property setter using the given setter method.  @return Property constructed, if any; or null to indicate that there should be no property based on given definitions. "
        }
    }
}