{
    "buggy_classes": [
        "org.apache.commons.codec.binary.Base64"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.codec.binary.Base64::decode(byte[],int,int)",
            "method_code": "```java\n    void decode(byte[] TransVarOut, int TransVarIndex, int TransVarAvail) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(eof))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return;\n        }\n        if (!(!(TransVarAvail < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            eof = true;\n        }\n        int TransVarIIndex = 0;\n        while (!(!(TransVarIIndex < TransVarAvail))) {\n            if (!(!(buffer == null || buffer.length - pos < decodeSize))) {\n                resizeBuffer();\n            }\n            byte TransVarBytes = TransVarOut[TransVarIndex++];\n            if (!(!(TransVarBytes == PAD))) {\n                eof = true;\n                break;\n            } else {\n                if (!(!(TransVarBytes >= 0 && TransVarBytes < DECODE_TABLE.length))) {\n                    int TransVarNIndex = DECODE_TABLE[TransVarBytes];\n                    if (!(!(TransVarNIndex >= 0))) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + TransVarNIndex;\n                        if (!(!(modulus == 0))) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n            TransVarIIndex++;\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (!(!(eof && modulus != 0))) {\n            \n            x = x << 6;\n            boolean TransFallThroughFlag0 = false;\n            boolean TransBreakFlag0 = true;\n            {\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 2))))) {\n                    TransBreakFlag0 = false;\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 3))))) {\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " <p> Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\" call is not necessary when decoding, but it doesn't hurt, either. </p> <p> Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in, garbage-out philosophy: it will not check the provided data for validity. </p> <p> Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ </p>  @param in byte[] array of ascii data to base64 decode. @param inPos Position to start reading data from. @param inAvail Amount of bytes available from input for encoding. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, I'll analyze the failure systematically:\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows a consistent pattern:\n- `NullPointerException` occurs at `Base64.decode(Base64.java:607)`\n- This is called from `Base64InputStream.read(Base64InputStream.java:159)`\n- The failure happens during stream reading operations\n\n## Step 2: Examine the Test Behavior Context\n\nThe test `testCodec98NPE` is specifically designed to verify a fix for a known NPE issue (CODEC-98 bug). This indicates:\n- There's a known historical issue with NPE in Base64 decoding\n- The test uses a specific input (`Base64TestData.CODEC_98_NPE`) that previously triggered the bug\n- The failure occurs during the decoding process of Base64InputStream\n\n## Step 3: Identify the Common Failure Point\n\nAll evidence points to the same location:\n- **File**: `Base64.java`\n- **Method**: `decode()` \n- **Line**: 607\n- **Context**: Called from `Base64InputStream.read()` during stream processing\n\n## Step 4: Analyze the Production Code Defect\n\nBased on the NPE occurring in `Base64.decode()` at line 607, the likely defect is:\n\n**Possible Defect**: The `Base64.decode()` method is attempting to access a null object reference when processing certain Base64-encoded inputs. This could be due to:\n\n1. **Null context or buffer**: The decode method might be trying to access a decoding context or buffer that hasn't been properly initialized for certain input patterns.\n\n2. **Input validation gap**: The method may not be properly handling edge cases in the Base64 input stream, particularly when the input contains specific patterns that cause internal state variables to remain null.\n\n3. **State management issue**: The Base64 decoder might not properly maintain its internal state across multiple read operations, leading to null references when processing the specific CODEC-98 test input.\n\nThe defect appears to be a regression of the original CODEC-98 bug, where certain Base64 inputs cause the decoder to encounter a null reference that should have been initialized.\n\n**Recommendation**: Focus debugging efforts on the `Base64.decode()` method around line 607, specifically examining object initialization and state management for the specific input pattern defined in `Base64TestData.CODEC_98_NPE`.",
            "test_suite": "org.apache.commons.codec.binary.Base64InputStreamTest",
            "score": 10,
            "reason": "#9# This method is highly suspicious as the NPE occurs at line 607 within the decode method, and the stack trace clearly shows the failure path from Base64InputStream.read() to Base64.decode(). The method contains multiple complex conditional logic with nested if statements and array operations that could easily lead to null pointer exceptions when processing the specific CODEC-98 test input pattern. The method handles buffer management and state transitions that are prone to null reference issues when dealing with edge cases in Base64 decoding."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::readResults(byte[],int,int)",
            "method_code": "```java\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n```",
            "method_doc": " Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail bytes. Returns how many bytes were actually extracted.  @param b byte[] array to extract the buffered data into. @param bPos position in byte[] array to start extraction at. @param bAvail amount of bytes we're allowed to extract. We may extract fewer (if fewer are available). @return The number of bytes successfully extracted into the provided byte[] array. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, I'll analyze the failure systematically:\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows a consistent pattern:\n- `NullPointerException` occurs at `Base64.decode(Base64.java:607)`\n- This is called from `Base64InputStream.read(Base64InputStream.java:159)`\n- The failure happens during stream reading operations\n\n## Step 2: Examine the Test Behavior Context\n\nThe test `testCodec98NPE` is specifically designed to verify a fix for a known NPE issue (CODEC-98 bug). This indicates:\n- There's a known historical issue with NPE in Base64 decoding\n- The test uses a specific input (`Base64TestData.CODEC_98_NPE`) that previously triggered the bug\n- The failure occurs during the decoding process of Base64InputStream\n\n## Step 3: Identify the Common Failure Point\n\nAll evidence points to the same location:\n- **File**: `Base64.java`\n- **Method**: `decode()` \n- **Line**: 607\n- **Context**: Called from `Base64InputStream.read()` during stream processing\n\n## Step 4: Analyze the Production Code Defect\n\nBased on the NPE occurring in `Base64.decode()` at line 607, the likely defect is:\n\n**Possible Defect**: The `Base64.decode()` method is attempting to access a null object reference when processing certain Base64-encoded inputs. This could be due to:\n\n1. **Null context or buffer**: The decode method might be trying to access a decoding context or buffer that hasn't been properly initialized for certain input patterns.\n\n2. **Input validation gap**: The method may not be properly handling edge cases in the Base64 input stream, particularly when the input contains specific patterns that cause internal state variables to remain null.\n\n3. **State management issue**: The Base64 decoder might not properly maintain its internal state across multiple read operations, leading to null references when processing the specific CODEC-98 test input.\n\nThe defect appears to be a regression of the original CODEC-98 bug, where certain Base64 inputs cause the decoder to encounter a null reference that should have been initialized.\n\n**Recommendation**: Focus debugging efforts on the `Base64.decode()` method around line 607, specifically examining object initialization and state management for the specific input pattern defined in `Base64TestData.CODEC_98_NPE`.",
            "test_suite": "org.apache.commons.codec.binary.Base64InputStreamTest",
            "score": 9,
            "reason": "#8# The readResults method is highly suspicious because it contains null checks for the buffer field and manipulates buffer state. The NPE occurs in Base64.decode at line 607, which likely calls readResults. The method's logic for setting buffer to null when readPos >= pos could cause subsequent calls to return 0 instead of -1 when EOF is reached, potentially leading to the decoder processing null data. The specific CODEC-98 input pattern might trigger this buffer nullification at an unexpected time, causing the NPE during decoding operations."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::avail()",
            "method_code": "```java\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n```",
            "method_doc": " Returns the amount of buffered data available for reading.  @return The amount of buffered data available for reading. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, I'll analyze the failure systematically:\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows a consistent pattern:\n- `NullPointerException` occurs at `Base64.decode(Base64.java:607)`\n- This is called from `Base64InputStream.read(Base64InputStream.java:159)`\n- The failure happens during stream reading operations\n\n## Step 2: Examine the Test Behavior Context\n\nThe test `testCodec98NPE` is specifically designed to verify a fix for a known NPE issue (CODEC-98 bug). This indicates:\n- There's a known historical issue with NPE in Base64 decoding\n- The test uses a specific input (`Base64TestData.CODEC_98_NPE`) that previously triggered the bug\n- The failure occurs during the decoding process of Base64InputStream\n\n## Step 3: Identify the Common Failure Point\n\nAll evidence points to the same location:\n- **File**: `Base64.java`\n- **Method**: `decode()` \n- **Line**: 607\n- **Context**: Called from `Base64InputStream.read()` during stream processing\n\n## Step 4: Analyze the Production Code Defect\n\nBased on the NPE occurring in `Base64.decode()` at line 607, the likely defect is:\n\n**Possible Defect**: The `Base64.decode()` method is attempting to access a null object reference when processing certain Base64-encoded inputs. This could be due to:\n\n1. **Null context or buffer**: The decode method might be trying to access a decoding context or buffer that hasn't been properly initialized for certain input patterns.\n\n2. **Input validation gap**: The method may not be properly handling edge cases in the Base64 input stream, particularly when the input contains specific patterns that cause internal state variables to remain null.\n\n3. **State management issue**: The Base64 decoder might not properly maintain its internal state across multiple read operations, leading to null references when processing the specific CODEC-98 test input.\n\nThe defect appears to be a regression of the original CODEC-98 bug, where certain Base64 inputs cause the decoder to encounter a null reference that should have been initialized.\n\n**Recommendation**: Focus debugging efforts on the `Base64.decode()` method around line 607, specifically examining object initialization and state management for the specific input pattern defined in `Base64TestData.CODEC_98_NPE`.",
            "test_suite": "org.apache.commons.codec.binary.Base64InputStreamTest",
            "score": 8,
            "reason": "#8# The avail() method is highly suspicious because it directly handles the buffer state that could cause NPE. The method checks if buffer is null and returns 0 in that case, but the NPE occurs in Base64.decode() at line 607, which likely calls this method. If buffer becomes null during decoding of the specific CODEC-98 input, and other methods don't properly handle this null state, it could lead to the observed NullPointerException. The method's logic suggests buffer can be null, but the calling code in decode() might not be expecting this scenario."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::resizeBuffer()",
            "method_code": "```java\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n```",
            "method_doc": "Doubles our buffer. */",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test and the provided information, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nLooking at the single failed test `testCodec98NPE`, I observe:\n\n- **Failure Point**: The test fails at `stream.close()` with a `NullPointerException`\n- **Stack Trace Origin**: The NPE originates from `Base64.decode(Base64.java:607)` which is called by `Base64OutputStream.close(Base64OutputStream.java:192)`\n- **Test Purpose**: This test specifically targets a known NPE issue (CODEC-98) that was previously fixed\n\n## Step 2: Identify the Root Cause Location\n\nThe stack trace clearly shows the failure chain:\n1. `Base64OutputStream.close()` calls `Base64.decode()`\n2. `Base64.decode()` at line 607 throws NullPointerException\n3. This occurs during the finalization/flushing process when closing the stream\n\n## Step 3: Analyze the Production Code Defect\n\nThe key insight is that the NPE occurs in `Base64.decode()` method, not in the test code. Given that:\n\n- The test writes 1024 bytes to the stream\n- The failure happens during `close()` when final encoding operations occur\n- This is a regression of a previously fixed bug (CODEC-98)\n\n## Step 4: Recommend Possible Production Code Defect\n\n**Possible Defect in Base64.java (line 607):**\n\nThe `Base64.decode()` method at line 607 is likely attempting to access a null object reference when processing the final chunk of data during stream closure. This could be due to:\n\n1. **Null Buffer Reference**: The decode method may be trying to access an internal buffer that hasn't been properly initialized or has been set to null during the encoding process.\n\n2. **Invalid State Handling**: When `Base64OutputStream.close()` calls the final decode operation, the Base64 encoder/decoder might be in an inconsistent state where required internal fields (like `buffer`, `pos`, or context objects) are null.\n\n3. **Boundary Condition**: The specific 1024-byte input pattern might trigger an edge case where the internal state management fails during the final flush operation.\n\n**Recommended Focus**: The defect appears to be in the state management and null-checking logic within the `Base64.decode()` method, particularly around line 607, where it fails to handle certain input patterns during stream finalization.\n\nThe issue is clearly in the production code's ability to handle this specific input sequence during the close operation, not in the test code which is properly structured to validate the fix for the CODEC-98 bug.",
            "test_suite": "org.apache.commons.codec.binary.Base64OutputStreamTest",
            "score": 8,
            "reason": "#8# The resizeBuffer() method is highly suspicious because it contains a critical flaw: when buffer is null, it initializes the buffer but doesn't handle the case where the buffer might become null again during operations. The NPE in Base64.decode() at line 607 likely occurs because the decode method is trying to access a buffer that has been set to null, possibly due to improper state management during the close() operation when processing the final chunk of data. The resizeBuffer() method should ensure the buffer remains properly initialized throughout the encoding/decoding lifecycle."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::hasData()",
            "method_code": "```java\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n```",
            "method_doc": " Returns true if this Base64 object has buffered data for reading.  @return true if there is Base64 object still available for reading. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, I'll analyze the failure systematically:\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows a consistent pattern:\n- `NullPointerException` occurs at `Base64.decode(Base64.java:607)`\n- This is called from `Base64InputStream.read(Base64InputStream.java:159)`\n- The failure happens during stream reading operations\n\n## Step 2: Examine the Test Behavior Context\n\nThe test `testCodec98NPE` is specifically designed to verify a fix for a known NPE issue (CODEC-98 bug). This indicates:\n- There's a known historical issue with NPE in Base64 decoding\n- The test uses a specific input (`Base64TestData.CODEC_98_NPE`) that previously triggered the bug\n- The failure occurs during the decoding process of Base64InputStream\n\n## Step 3: Identify the Common Failure Point\n\nAll evidence points to the same location:\n- **File**: `Base64.java`\n- **Method**: `decode()` \n- **Line**: 607\n- **Context**: Called from `Base64InputStream.read()` during stream processing\n\n## Step 4: Analyze the Production Code Defect\n\nBased on the NPE occurring in `Base64.decode()` at line 607, the likely defect is:\n\n**Possible Defect**: The `Base64.decode()` method is attempting to access a null object reference when processing certain Base64-encoded inputs. This could be due to:\n\n1. **Null context or buffer**: The decode method might be trying to access a decoding context or buffer that hasn't been properly initialized for certain input patterns.\n\n2. **Input validation gap**: The method may not be properly handling edge cases in the Base64 input stream, particularly when the input contains specific patterns that cause internal state variables to remain null.\n\n3. **State management issue**: The Base64 decoder might not properly maintain its internal state across multiple read operations, leading to null references when processing the specific CODEC-98 test input.\n\nThe defect appears to be a regression of the original CODEC-98 bug, where certain Base64 inputs cause the decoder to encounter a null reference that should have been initialized.\n\n**Recommendation**: Focus debugging efforts on the `Base64.decode()` method around line 607, specifically examining object initialization and state management for the specific input pattern defined in `Base64TestData.CODEC_98_NPE`.",
            "test_suite": "org.apache.commons.codec.binary.Base64InputStreamTest",
            "score": 3,
            "reason": "#3# The hasData() method only checks if buffer is null, but the actual NPE occurs in decode() method at line 607, suggesting the root cause is deeper in the decoding logic rather than this simple state check method."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.codec.binary.Base64::avail()": {
            "method_name": "org.apache.commons.codec.binary.Base64::avail()",
            "method_code": "```java\n    int avail() {\n        return buffer != null ? pos - readPos : 0;\n    }\n\n```",
            "method_doc": " Returns the amount of buffered data available for reading.  @return The amount of buffered data available for reading. "
        },
        "org.apache.commons.codec.binary.Base64::hasData()": {
            "method_name": "org.apache.commons.codec.binary.Base64::hasData()",
            "method_code": "```java\n    boolean hasData() {\n        return this.buffer != null;\n    }\n\n```",
            "method_doc": " Returns true if this Base64 object has buffered data for reading.  @return true if there is Base64 object still available for reading. "
        },
        "org.apache.commons.codec.binary.Base64::decode(byte[],int,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::decode(byte[],int,int)",
            "method_code": "```java\n    void decode(byte[] TransVarOut, int TransVarIndex, int TransVarAvail) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(eof))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return;\n        }\n        if (!(!(TransVarAvail < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            eof = true;\n        }\n        int TransVarIIndex = 0;\n        while (!(!(TransVarIIndex < TransVarAvail))) {\n            if (!(!(buffer == null || buffer.length - pos < decodeSize))) {\n                resizeBuffer();\n            }\n            byte TransVarBytes = TransVarOut[TransVarIndex++];\n            if (!(!(TransVarBytes == PAD))) {\n                eof = true;\n                break;\n            } else {\n                if (!(!(TransVarBytes >= 0 && TransVarBytes < DECODE_TABLE.length))) {\n                    int TransVarNIndex = DECODE_TABLE[TransVarBytes];\n                    if (!(!(TransVarNIndex >= 0))) {\n                        modulus = (++modulus) % 4;\n                        x = (x << 6) + TransVarNIndex;\n                        if (!(!(modulus == 0))) {\n                            buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                            buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                            buffer[pos++] = (byte) (x & MASK_8BITS);\n                        }\n                    }\n                }\n            }\n            TransVarIIndex++;\n        }\n\n        // Two forms of EOF as far as base64 decoder is concerned: actual\n        // EOF (-1) and first time '=' character is encountered in stream.\n        // This approach makes the '=' padding characters completely optional.\n        if (!(!(eof && modulus != 0))) {\n            \n            x = x << 6;\n            boolean TransFallThroughFlag0 = false;\n            boolean TransBreakFlag0 = true;\n            {\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 2))))) {\n                    TransBreakFlag0 = false;\n                    x = x << 6;\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 3))))) {\n                    buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                    buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " <p> Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least twice: once with the data to decode, and once with inAvail set to \"-1\" to alert decoder that EOF has been reached. The \"-1\" call is not necessary when decoding, but it doesn't hurt, either. </p> <p> Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since CR and LF are silently ignored, but has implications for other bytes, too. This method subscribes to the garbage-in, garbage-out philosophy: it will not check the provided data for validity. </p> <p> Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ </p>  @param in byte[] array of ascii data to base64 decode. @param inPos Position to start reading data from. @param inAvail Amount of bytes available from input for encoding. "
        },
        "org.apache.commons.codec.binary.Base64::readResults(byte[],int,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::readResults(byte[],int,int)",
            "method_code": "```java\n    int readResults(byte[] b, int bPos, int bAvail) {\n        if (buffer != null) {\n            int len = Math.min(avail(), bAvail);\n            if (buffer != b) {\n                System.arraycopy(buffer, readPos, b, bPos, len);\n                readPos += len;\n                if (readPos >= pos) {\n                    buffer = null;\n                }\n            } else {\n                // Re-using the original consumer's output array is only\n                // allowed for one round.\n                buffer = null;\n            }\n            return len;\n        }\n        return eof ? -1 : 0;\n    }\n\n```",
            "method_doc": " Extracts buffered data into the provided byte[] array, starting at position bPos, up to a maximum of bAvail bytes. Returns how many bytes were actually extracted.  @param b byte[] array to extract the buffered data into. @param bPos position in byte[] array to start extraction at. @param bAvail amount of bytes we're allowed to extract. We may extract fewer (if fewer are available). @return The number of bytes successfully extracted into the provided byte[] array. "
        },
        "org.apache.commons.codec.binary.Base64::resizeBuffer()": {
            "method_name": "org.apache.commons.codec.binary.Base64::resizeBuffer()",
            "method_code": "```java\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n```",
            "method_doc": "Doubles our buffer. */"
        }
    }
}