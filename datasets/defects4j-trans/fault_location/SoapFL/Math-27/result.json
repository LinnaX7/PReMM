{
    "buggy_classes": [
        "org.apache.commons.math3.fraction.Fraction",
        "org.apache.commons.math3.util.ArithmeticUtils",
        "org.apache.commons.math3.util.FastMath"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math3.fraction.Fraction::percentageValue()",
            "method_code": "```java\n    public double percentageValue() {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return multiply(100).doubleValue();\n    }\n\n```",
            "method_doc": " <p> Gets the fraction percentage as a <tt>double</tt>. This calculates the fraction as the numerator divided by denominator multiplied by 100. </p>  @return the fraction percentage as a <tt>double</tt>. ",
            "class_name": "org.apache.commons.math3.fraction.Fraction",
            "class_doc": " Representation of a rational number.  implements Serializable since 2.0  @since 1.1 @version $Id$ ",
            "test_failure_causes": "Looking at the test failure analysis, I can identify the key pattern and recommend the likely defect in the production code:\n\n## Analysis of Common Patterns\n\n**1. Overflow Issue Pattern:**\n- The test specifically mentions it's designed to verify a fix for \"overflow\" (MATH-835)\n- The test creates a fraction with a very large numerator (`Integer.MAX_VALUE / 99`)\n- The expected value is positive (2.1691754E9) but the actual result is negative (-2.125791896E9)\n- The sign change from positive to negative strongly indicates integer overflow\n\n**2. Mathematical Operation Pattern:**\n- The failure occurs in the `percentageValue()` method\n- The test computes percentage as `100 * ((double) numer) / denom` using double arithmetic\n- The production code's `percentageValue()` method appears to be using integer arithmetic instead\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `Fraction.percentageValue()` method implementation, where integer arithmetic is being used instead of floating-point arithmetic, causing integer overflow when dealing with large numerator values.\n\n**Specific Issue:**\nThe `percentageValue()` method is probably performing calculations like:\n```java\nreturn (numerator * 100) / denominator;  // Integer arithmetic causing overflow\n```\n\nInstead of:\n```java\nreturn 100 * ((double) numerator) / denominator;  // Safe floating-point arithmetic\n```\n\nWhen `numerator * 100` exceeds `Integer.MAX_VALUE`, it wraps around to negative values due to integer overflow, which explains why the test shows a negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9).\n\nThe defect is specifically that the percentage calculation doesn't properly handle large values that would cause integer overflow during the multiplication by 100.",
            "test_suite": "org.apache.commons.math3.fraction.FractionTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it uses integer arithmetic in the multiply() method which causes overflow when dealing with large numerators like Integer.MAX_VALUE/99. The test specifically targets overflow protection (MATH-835) and the negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9) confirms integer overflow is occurring during the multiplication by 100."
        },
        {
            "method_name": "org.apache.commons.math3.fraction.Fraction::multiply(int)",
            "method_code": "```java\n    public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }\n\n```",
            "method_doc": " Multiply the fraction by an integer. @param i the <tt>integer</tt> to multiply by. @return this * i ",
            "class_name": "org.apache.commons.math3.fraction.Fraction",
            "class_doc": " Representation of a rational number.  implements Serializable since 2.0  @since 1.1 @version $Id$ ",
            "test_failure_causes": "Looking at the test failure analysis, I can identify the key pattern and recommend the likely defect in the production code:\n\n## Analysis of Common Patterns\n\n**1. Overflow Issue Pattern:**\n- The test specifically mentions it's designed to verify a fix for \"overflow\" (MATH-835)\n- The test creates a fraction with a very large numerator (`Integer.MAX_VALUE / 99`)\n- The expected value is positive (2.1691754E9) but the actual result is negative (-2.125791896E9)\n- The sign change from positive to negative strongly indicates integer overflow\n\n**2. Mathematical Operation Pattern:**\n- The failure occurs in the `percentageValue()` method\n- The test computes percentage as `100 * ((double) numer) / denom` using double arithmetic\n- The production code's `percentageValue()` method appears to be using integer arithmetic instead\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `Fraction.percentageValue()` method implementation, where integer arithmetic is being used instead of floating-point arithmetic, causing integer overflow when dealing with large numerator values.\n\n**Specific Issue:**\nThe `percentageValue()` method is probably performing calculations like:\n```java\nreturn (numerator * 100) / denominator;  // Integer arithmetic causing overflow\n```\n\nInstead of:\n```java\nreturn 100 * ((double) numerator) / denominator;  // Safe floating-point arithmetic\n```\n\nWhen `numerator * 100` exceeds `Integer.MAX_VALUE`, it wraps around to negative values due to integer overflow, which explains why the test shows a negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9).\n\nThe defect is specifically that the percentage calculation doesn't properly handle large values that would cause integer overflow during the multiplication by 100.",
            "test_suite": "org.apache.commons.math3.fraction.FractionTest",
            "score": 8,
            "reason": "#8# The multiply(int) method is highly suspicious because it performs direct integer multiplication (numerator * i) which can cause overflow when dealing with large values like Integer.MAX_VALUE/99. The test failure shows a sign change from positive to negative, which is characteristic of integer overflow. Since the percentageValue() method likely uses multiply() internally for calculations, fixing the overflow in multiply() would resolve the percentage calculation issue."
        },
        {
            "method_name": "org.apache.commons.math3.fraction.Fraction::Fraction(int,int)",
            "method_code": "```java\n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE ||\n                den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        // reduce numerator and denominator by greatest common denominator.\n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n\n        // move sign to numerator.\n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator   = num;\n        this.denominator = den;\n    }\n\n```",
            "method_doc": " Create a fraction given the numerator and denominator.  The fraction is reduced to lowest terms. @param num the numerator. @param den the denominator. @throws MathArithmeticException if the denominator is {@code zero} ",
            "class_name": "org.apache.commons.math3.fraction.Fraction",
            "class_doc": " Representation of a rational number.  implements Serializable since 2.0  @since 1.1 @version $Id$ ",
            "test_failure_causes": "Looking at the test failure analysis, I can identify the key pattern and recommend the likely defect in the production code:\n\n## Analysis of Common Patterns\n\n**1. Overflow Issue Pattern:**\n- The test specifically mentions it's designed to verify a fix for \"overflow\" (MATH-835)\n- The test creates a fraction with a very large numerator (`Integer.MAX_VALUE / 99`)\n- The expected value is positive (2.1691754E9) but the actual result is negative (-2.125791896E9)\n- The sign change from positive to negative strongly indicates integer overflow\n\n**2. Mathematical Operation Pattern:**\n- The failure occurs in the `percentageValue()` method\n- The test computes percentage as `100 * ((double) numer) / denom` using double arithmetic\n- The production code's `percentageValue()` method appears to be using integer arithmetic instead\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `Fraction.percentageValue()` method implementation, where integer arithmetic is being used instead of floating-point arithmetic, causing integer overflow when dealing with large numerator values.\n\n**Specific Issue:**\nThe `percentageValue()` method is probably performing calculations like:\n```java\nreturn (numerator * 100) / denominator;  // Integer arithmetic causing overflow\n```\n\nInstead of:\n```java\nreturn 100 * ((double) numerator) / denominator;  // Safe floating-point arithmetic\n```\n\nWhen `numerator * 100` exceeds `Integer.MAX_VALUE`, it wraps around to negative values due to integer overflow, which explains why the test shows a negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9).\n\nThe defect is specifically that the percentage calculation doesn't properly handle large values that would cause integer overflow during the multiplication by 100.",
            "test_suite": "org.apache.commons.math3.fraction.FractionTest",
            "score": 3,
            "reason": "#3# While the constructor handles sign normalization and GCD reduction, the actual overflow issue occurs in the percentageValue() method where integer arithmetic causes overflow when multiplying large numerators by 100. The constructor itself appears to handle edge cases properly and doesn't perform the problematic arithmetic operations that lead to the test failure."
        },
        {
            "method_name": "org.apache.commons.math3.util.ArithmeticUtils::gcd(int,int)",
            "method_code": "```java\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                                  p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                              p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n\n```",
            "method_doc": " <p> Gets the greatest common divisor of the absolute value of two numbers, using the \"binary gcd\" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). </p> Special cases: <ul> <li>The invocations {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)}, {@code gcd(Integer.MIN_VALUE, 0)} and {@code gcd(0, Integer.MIN_VALUE)} throw an {@code ArithmeticException}, because the result would be 2^31, which is too large for an int value.</li> <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the absolute value of {@code x}, except for the special cases above. <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li> </ul>  @param p Number. @param q Number. @return the greatest common divisor, never negative. @throws MathArithmeticException if the result cannot be represented as a non-negative {@code int} value. @since 1.1 ",
            "class_name": "org.apache.commons.math3.util.ArithmeticUtils",
            "class_doc": " Some useful, arithmetics related, additions to the built-in functions in {@link Math}.  @version $Id$ ",
            "test_failure_causes": "Looking at the test failure analysis, I can identify the key pattern and recommend the likely defect in the production code:\n\n## Analysis of Common Patterns\n\n**1. Overflow Issue Pattern:**\n- The test specifically mentions it's designed to verify a fix for \"overflow\" (MATH-835)\n- The test creates a fraction with a very large numerator (`Integer.MAX_VALUE / 99`)\n- The expected value is positive (2.1691754E9) but the actual result is negative (-2.125791896E9)\n- The sign change from positive to negative strongly indicates integer overflow\n\n**2. Mathematical Operation Pattern:**\n- The failure occurs in the `percentageValue()` method\n- The test computes percentage as `100 * ((double) numer) / denom` using double arithmetic\n- The production code's `percentageValue()` method appears to be using integer arithmetic instead\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `Fraction.percentageValue()` method implementation, where integer arithmetic is being used instead of floating-point arithmetic, causing integer overflow when dealing with large numerator values.\n\n**Specific Issue:**\nThe `percentageValue()` method is probably performing calculations like:\n```java\nreturn (numerator * 100) / denominator;  // Integer arithmetic causing overflow\n```\n\nInstead of:\n```java\nreturn 100 * ((double) numerator) / denominator;  // Safe floating-point arithmetic\n```\n\nWhen `numerator * 100` exceeds `Integer.MAX_VALUE`, it wraps around to negative values due to integer overflow, which explains why the test shows a negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9).\n\nThe defect is specifically that the percentage calculation doesn't properly handle large values that would cause integer overflow during the multiplication by 100.",
            "test_suite": "org.apache.commons.math3.fraction.FractionTest",
            "score": 3,
            "reason": "#3# While the gcd method could potentially be involved in fraction operations, the test failure specifically shows an overflow issue in percentageValue() calculation where a large numerator multiplied by 100 causes integer overflow, and the gcd method appears to handle edge cases properly with appropriate overflow checks and special case handling for MIN_VALUE scenarios."
        },
        {
            "method_name": "org.apache.commons.math3.fraction.Fraction::doubleValue()",
            "method_code": "```java\n    @Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n\n```",
            "method_doc": " Gets the fraction as a <tt>double</tt>. This calculates the fraction as the numerator divided by denominator. @return the fraction as a <tt>double</tt> ",
            "class_name": "org.apache.commons.math3.fraction.Fraction",
            "class_doc": " Representation of a rational number.  implements Serializable since 2.0  @since 1.1 @version $Id$ ",
            "test_failure_causes": "Looking at the test failure analysis, I can identify the key pattern and recommend the likely defect in the production code:\n\n## Analysis of Common Patterns\n\n**1. Overflow Issue Pattern:**\n- The test specifically mentions it's designed to verify a fix for \"overflow\" (MATH-835)\n- The test creates a fraction with a very large numerator (`Integer.MAX_VALUE / 99`)\n- The expected value is positive (2.1691754E9) but the actual result is negative (-2.125791896E9)\n- The sign change from positive to negative strongly indicates integer overflow\n\n**2. Mathematical Operation Pattern:**\n- The failure occurs in the `percentageValue()` method\n- The test computes percentage as `100 * ((double) numer) / denom` using double arithmetic\n- The production code's `percentageValue()` method appears to be using integer arithmetic instead\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `Fraction.percentageValue()` method implementation, where integer arithmetic is being used instead of floating-point arithmetic, causing integer overflow when dealing with large numerator values.\n\n**Specific Issue:**\nThe `percentageValue()` method is probably performing calculations like:\n```java\nreturn (numerator * 100) / denominator;  // Integer arithmetic causing overflow\n```\n\nInstead of:\n```java\nreturn 100 * ((double) numerator) / denominator;  // Safe floating-point arithmetic\n```\n\nWhen `numerator * 100` exceeds `Integer.MAX_VALUE`, it wraps around to negative values due to integer overflow, which explains why the test shows a negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9).\n\nThe defect is specifically that the percentage calculation doesn't properly handle large values that would cause integer overflow during the multiplication by 100.",
            "test_suite": "org.apache.commons.math3.fraction.FractionTest",
            "score": 2,
            "reason": "#2# The doubleValue() method is not the best location to fix because the test failure occurs in percentageValue() method, not doubleValue(). The doubleValue() method correctly uses floating-point division and handles large values properly, while the actual bug is in percentageValue() where integer overflow occurs during multiplication by 100."
        },
        {
            "method_name": "org.apache.commons.math3.util.FastMath::abs(int)",
            "method_code": "```java\n    public static int abs(final int x) {\n        return (x < 0) ? -x : x;\n    }\n\n```",
            "method_doc": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
            "class_name": "org.apache.commons.math3.util.FastMath",
            "class_doc": " Faster, more accurate, portable alternative to {@link Math} and {@link StrictMath} for large scale computation. <p> FastMath is a drop-in replacement for both Math and StrictMath. This means that for any method in Math (say {@code Math.sin(x)} or {@code Math.cbrt(y)}), user can directly change the class and use the methods as is (using {@code FastMath.sin(x)} or {@code FastMath.cbrt(y)} in the previous example). </p> <p> FastMath speed is achieved by relying heavily on optimizing compilers to native code present in many JVMs today and use of large tables. The larger tables are lazily initialised on first use, so that the setup time does not penalise methods that don't need them. </p> <p> Note that FastMath is extensively used inside Apache Commons Math, so by calling some algorithms, the overhead when the the tables need to be intialised will occur regardless of the end-user calling FastMath methods directly or not. Performance figures for a specific JVM and hardware can be evaluated by running the FastMathTestPerformance tests in the test directory of the source distribution. </p> <p> FastMath accuracy should be mostly independent of the JVM as it relies only on IEEE-754 basic operations and on embedded tables. Almost all operations are accurate to about 0.5 ulp throughout the domain range. This statement, of course is only a rough global observed behavior, it is <em>not</em> a guarantee for <em>every</em> double numbers input (see William Kahan's <a href=\"http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma\">Table Maker's Dilemma</a>). </p> <p> FastMath additionally implements the following methods not found in Math/StrictMath: <ul> <li>{@link #asinh(double)}</li> <li>{@link #acosh(double)}</li> <li>{@link #atanh(double)}</li> </ul> The following methods are found in Math/StrictMath since 1.6 only, they are provided by FastMath even in 1.5 Java virtual machines <ul> <li>{@link #copySign(double, double)}</li> <li>{@link #getExponent(double)}</li> <li>{@link #nextAfter(double,double)}</li> <li>{@link #nextUp(double)}</li> <li>{@link #scalb(double, int)}</li> <li>{@link #copySign(float, float)}</li> <li>{@link #getExponent(float)}</li> <li>{@link #nextAfter(float,double)}</li> <li>{@link #nextUp(float)}</li> <li>{@link #scalb(float, int)}</li> </ul> </p> @version $Id$ @since 2.2 ",
            "test_failure_causes": "Looking at the test failure analysis, I can identify the key pattern and recommend the likely defect in the production code:\n\n## Analysis of Common Patterns\n\n**1. Overflow Issue Pattern:**\n- The test specifically mentions it's designed to verify a fix for \"overflow\" (MATH-835)\n- The test creates a fraction with a very large numerator (`Integer.MAX_VALUE / 99`)\n- The expected value is positive (2.1691754E9) but the actual result is negative (-2.125791896E9)\n- The sign change from positive to negative strongly indicates integer overflow\n\n**2. Mathematical Operation Pattern:**\n- The failure occurs in the `percentageValue()` method\n- The test computes percentage as `100 * ((double) numer) / denom` using double arithmetic\n- The production code's `percentageValue()` method appears to be using integer arithmetic instead\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `Fraction.percentageValue()` method implementation, where integer arithmetic is being used instead of floating-point arithmetic, causing integer overflow when dealing with large numerator values.\n\n**Specific Issue:**\nThe `percentageValue()` method is probably performing calculations like:\n```java\nreturn (numerator * 100) / denominator;  // Integer arithmetic causing overflow\n```\n\nInstead of:\n```java\nreturn 100 * ((double) numerator) / denominator;  // Safe floating-point arithmetic\n```\n\nWhen `numerator * 100` exceeds `Integer.MAX_VALUE`, it wraps around to negative values due to integer overflow, which explains why the test shows a negative result (-2.125791896E9) instead of the expected positive value (2.1691754E9).\n\nThe defect is specifically that the percentage calculation doesn't properly handle large values that would cause integer overflow during the multiplication by 100.",
            "test_suite": "org.apache.commons.math3.fraction.FractionTest",
            "score": 1,
            "reason": "#1# The abs(int) method is not the best location to fix because the test failure clearly shows an integer overflow issue in the Fraction.percentageValue() method, not an absolute value calculation problem. The abs method correctly implements absolute value logic and is unrelated to the overflow occurring when multiplying large integers by 100 in the percentage calculation."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math3.fraction.Fraction::percentageValue()": {
            "method_name": "org.apache.commons.math3.fraction.Fraction::percentageValue()",
            "method_code": "```java\n    public double percentageValue() {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return multiply(100).doubleValue();\n    }\n\n```",
            "method_doc": " <p> Gets the fraction percentage as a <tt>double</tt>. This calculates the fraction as the numerator divided by denominator multiplied by 100. </p>  @return the fraction percentage as a <tt>double</tt>. "
        },
        "org.apache.commons.math3.fraction.Fraction::doubleValue()": {
            "method_name": "org.apache.commons.math3.fraction.Fraction::doubleValue()",
            "method_code": "```java\n    @Override\n    public double doubleValue() {\n        return (double)numerator / (double)denominator;\n    }\n\n```",
            "method_doc": " Gets the fraction as a <tt>double</tt>. This calculates the fraction as the numerator divided by denominator. @return the fraction as a <tt>double</tt> "
        },
        "org.apache.commons.math3.fraction.Fraction::Fraction(int,int)": {
            "method_name": "org.apache.commons.math3.fraction.Fraction::Fraction(int,int)",
            "method_code": "```java\n    public Fraction(int num, int den) {\n        if (den == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,\n                                              num, den);\n        }\n        if (den < 0) {\n            if (num == Integer.MIN_VALUE ||\n                den == Integer.MIN_VALUE) {\n                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,\n                                                  num, den);\n            }\n            num = -num;\n            den = -den;\n        }\n        // reduce numerator and denominator by greatest common denominator.\n        final int d = ArithmeticUtils.gcd(num, den);\n        if (d > 1) {\n            num /= d;\n            den /= d;\n        }\n\n        // move sign to numerator.\n        if (den < 0) {\n            num = -num;\n            den = -den;\n        }\n        this.numerator   = num;\n        this.denominator = den;\n    }\n\n```",
            "method_doc": " Create a fraction given the numerator and denominator.  The fraction is reduced to lowest terms. @param num the numerator. @param den the denominator. @throws MathArithmeticException if the denominator is {@code zero} "
        },
        "org.apache.commons.math3.fraction.Fraction::multiply(int)": {
            "method_name": "org.apache.commons.math3.fraction.Fraction::multiply(int)",
            "method_code": "```java\n    public Fraction multiply(final int i) {\n        return new Fraction(numerator * i, denominator);\n    }\n\n```",
            "method_doc": " Multiply the fraction by an integer. @param i the <tt>integer</tt> to multiply by. @return this * i "
        },
        "org.apache.commons.math3.util.ArithmeticUtils::gcd(int,int)": {
            "method_name": "org.apache.commons.math3.util.ArithmeticUtils::gcd(int,int)",
            "method_code": "```java\n    public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                                  p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                              p, q);\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n\n```",
            "method_doc": " <p> Gets the greatest common divisor of the absolute value of two numbers, using the \"binary gcd\" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). </p> Special cases: <ul> <li>The invocations {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)}, {@code gcd(Integer.MIN_VALUE, 0)} and {@code gcd(0, Integer.MIN_VALUE)} throw an {@code ArithmeticException}, because the result would be 2^31, which is too large for an int value.</li> <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and {@code gcd(x, 0)} is the absolute value of {@code x}, except for the special cases above. <li>The invocation {@code gcd(0, 0)} is the only one which returns {@code 0}.</li> </ul>  @param p Number. @param q Number. @return the greatest common divisor, never negative. @throws MathArithmeticException if the result cannot be represented as a non-negative {@code int} value. @since 1.1 "
        },
        "org.apache.commons.math3.util.FastMath::abs(int)": {
            "method_name": "org.apache.commons.math3.util.FastMath::abs(int)",
            "method_code": "```java\n    public static int abs(final int x) {\n        return (x < 0) ? -x : x;\n    }\n\n```",
            "method_doc": " Absolute value. @param x number from which absolute value is requested @return abs(x) "
        }
    }
}