{
    "buggy_classes": [
        "com.google.javascript.jscomp.parsing.JsDocInfoParser"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseContextTypeExpression(JsDocToken)",
            "method_code": "```java\n  private Node parseContextTypeExpression(JsDocToken TransVarDocToken) {\n          if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        return parseTypeName(TransVarDocToken);\n  }\n\n```",
            "method_doc": " ContextTypeExpression := BasicTypeExpression | '?' For expressions on the right hand side of a this: or new: ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across multiple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Common Patterns Identified:\n\n1. **Both tests involve structural constructor parsing** with `function (new:...)` syntax\n2. **Both failures occur during type name parsing** in `JsDocInfoParser.parseTypeName()`\n3. **Both generate the same warning**: \"Bad type annotation. type not recognized due to syntax error\"\n4. **The stack traces are identical** up to `parseTypeName()` where the divergence occurs\n5. **Both tests use special type tokens**: `?` (unknown) in test 1 and `*` (wildcard) in test 2 in constructor contexts\n\n## Key Observations:\n\n- The failures occur at `JsDocInfoParser.parseTypeName()` (line 1952)\n- Both tests trigger `reportGenericTypeSyntaxWarning()` via `reportTypeSyntaxWarning()`\n- The warning suggests the parser is incorrectly flagging valid constructor syntax as syntax errors\n- The common element is the `new:` prefix in function type annotations\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **type name parsing logic when handling constructor contexts**. Specifically, in `JsDocInfoParser.parseTypeName()` around line 1952, there is likely incorrect handling of type tokens (`?` and `*`) when they appear after the `new:` prefix in function type annotations.\n\n**Possible root cause**: The production code may be failing to recognize that `?` and `*` are valid type annotations in constructor contexts (`function (new:?)` and `function (new:*)`), incorrectly treating them as syntax errors instead of valid unknown/wildcard types.\n\nThe parser should accept these special type tokens in constructor positions but is currently rejecting them with generic syntax warnings, causing both structural constructor tests to fail during type resolution.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it directly handles context type expressions (which include constructor contexts with 'new:' prefix), and the test failures occur when parsing '?' and '*' tokens in constructor positions. The method's comment specifically mentions handling '?' for expressions on the right hand side of 'new:', yet the current implementation simply delegates to parseTypeName without special handling for these tokens in constructor contexts, causing valid constructor syntax to be incorrectly flagged as syntax errors."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseTypeName(JsDocToken)",
            "method_code": "```java\n  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }\n\n```",
            "method_doc": " TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across multiple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Common Patterns Identified:\n\n1. **Both tests involve structural constructor parsing** with `function (new:...)` syntax\n2. **Both failures occur during type name parsing** in `JsDocInfoParser.parseTypeName()`\n3. **Both generate the same warning**: \"Bad type annotation. type not recognized due to syntax error\"\n4. **The stack traces are identical** up to `parseTypeName()` where the divergence occurs\n5. **Both tests use special type tokens**: `?` (unknown) in test 1 and `*` (wildcard) in test 2 in constructor contexts\n\n## Key Observations:\n\n- The failures occur at `JsDocInfoParser.parseTypeName()` (line 1952)\n- Both tests trigger `reportGenericTypeSyntaxWarning()` via `reportTypeSyntaxWarning()`\n- The warning suggests the parser is incorrectly flagging valid constructor syntax as syntax errors\n- The common element is the `new:` prefix in function type annotations\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **type name parsing logic when handling constructor contexts**. Specifically, in `JsDocInfoParser.parseTypeName()` around line 1952, there is likely incorrect handling of type tokens (`?` and `*`) when they appear after the `new:` prefix in function type annotations.\n\n**Possible root cause**: The production code may be failing to recognize that `?` and `*` are valid type annotations in constructor contexts (`function (new:?)` and `function (new:*)`), incorrectly treating them as syntax errors instead of valid unknown/wildcard types.\n\nThe parser should accept these special type tokens in constructor positions but is currently rejecting them with generic syntax warnings, causing both structural constructor tests to fail during type resolution.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location that needs to be fixed because the stack traces clearly show both test failures originate from parseTypeName() at line 1952, where it calls reportGenericTypeSyntaxWarning(). The method is rejecting valid type tokens (? and *) in constructor contexts, incorrectly treating them as syntax errors when they should be accepted as valid unknown/wildcard types in structural constructor annotations."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseBasicTypeExpression(JsDocToken)",
            "method_code": "```java\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }\n\n```",
            "method_doc": " BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across multiple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Common Patterns Identified:\n\n1. **Both tests involve structural constructor parsing** with `function (new:...)` syntax\n2. **Both failures occur during type name parsing** in `JsDocInfoParser.parseTypeName()`\n3. **Both generate the same warning**: \"Bad type annotation. type not recognized due to syntax error\"\n4. **The stack traces are identical** up to `parseTypeName()` where the divergence occurs\n5. **Both tests use special type tokens**: `?` (unknown) in test 1 and `*` (wildcard) in test 2 in constructor contexts\n\n## Key Observations:\n\n- The failures occur at `JsDocInfoParser.parseTypeName()` (line 1952)\n- Both tests trigger `reportGenericTypeSyntaxWarning()` via `reportTypeSyntaxWarning()`\n- The warning suggests the parser is incorrectly flagging valid constructor syntax as syntax errors\n- The common element is the `new:` prefix in function type annotations\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **type name parsing logic when handling constructor contexts**. Specifically, in `JsDocInfoParser.parseTypeName()` around line 1952, there is likely incorrect handling of type tokens (`?` and `*`) when they appear after the `new:` prefix in function type annotations.\n\n**Possible root cause**: The production code may be failing to recognize that `?` and `*` are valid type annotations in constructor contexts (`function (new:?)` and `function (new:*)`), incorrectly treating them as syntax errors instead of valid unknown/wildcard types.\n\nThe parser should accept these special type tokens in constructor positions but is currently rejecting them with generic syntax warnings, causing both structural constructor tests to fail during type resolution.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the parsing of basic type expressions including special tokens like STAR (*), but the stack traces show that the failures occur when parsing constructor types with '?' and '*' tokens after 'new:' prefix, and this method's logic may be incorrectly rejecting these valid constructor type expressions by calling reportGenericTypeSyntaxWarning() instead of properly handling them in constructor contexts."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseFunctionType(JsDocToken)",
            "method_code": "```java\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseContextTypeExpression(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n\n```",
            "method_doc": " FunctionType := 'function' FunctionSignatureType FunctionSignatureType := TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across multiple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Common Patterns Identified:\n\n1. **Both tests involve structural constructor parsing** with `function (new:...)` syntax\n2. **Both failures occur during type name parsing** in `JsDocInfoParser.parseTypeName()`\n3. **Both generate the same warning**: \"Bad type annotation. type not recognized due to syntax error\"\n4. **The stack traces are identical** up to `parseTypeName()` where the divergence occurs\n5. **Both tests use special type tokens**: `?` (unknown) in test 1 and `*` (wildcard) in test 2 in constructor contexts\n\n## Key Observations:\n\n- The failures occur at `JsDocInfoParser.parseTypeName()` (line 1952)\n- Both tests trigger `reportGenericTypeSyntaxWarning()` via `reportTypeSyntaxWarning()`\n- The warning suggests the parser is incorrectly flagging valid constructor syntax as syntax errors\n- The common element is the `new:` prefix in function type annotations\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **type name parsing logic when handling constructor contexts**. Specifically, in `JsDocInfoParser.parseTypeName()` around line 1952, there is likely incorrect handling of type tokens (`?` and `*`) when they appear after the `new:` prefix in function type annotations.\n\n**Possible root cause**: The production code may be failing to recognize that `?` and `*` are valid type annotations in constructor contexts (`function (new:?)` and `function (new:*)`), incorrectly treating them as syntax errors instead of valid unknown/wildcard types.\n\nThe parser should accept these special type tokens in constructor positions but is currently rejecting them with generic syntax warnings, causing both structural constructor tests to fail during type resolution.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because both failed tests involve parsing function types with constructor syntax (function (new:?)) and (function (new:*)), and the stack traces show the failures occur within parseFunctionType when it calls parseContextTypeExpression. The method handles the \"new\" context type parsing but may have issues with special type tokens like ? and * in constructor positions, causing them to be incorrectly flagged as syntax errors."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::reportTypeSyntaxWarning(String)",
            "method_code": "```java\n  private Node reportTypeSyntaxWarning(String warning) {\n    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());\n    return null;\n  }\n\n```",
            "method_doc": "Reports a type syntax warning using the error reporter.",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across multiple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Common Patterns Identified:\n\n1. **Both tests involve structural constructor parsing** with `function (new:...)` syntax\n2. **Both failures occur during type name parsing** in `JsDocInfoParser.parseTypeName()`\n3. **Both generate the same warning**: \"Bad type annotation. type not recognized due to syntax error\"\n4. **The stack traces are identical** up to `parseTypeName()` where the divergence occurs\n5. **Both tests use special type tokens**: `?` (unknown) in test 1 and `*` (wildcard) in test 2 in constructor contexts\n\n## Key Observations:\n\n- The failures occur at `JsDocInfoParser.parseTypeName()` (line 1952)\n- Both tests trigger `reportGenericTypeSyntaxWarning()` via `reportTypeSyntaxWarning()`\n- The warning suggests the parser is incorrectly flagging valid constructor syntax as syntax errors\n- The common element is the `new:` prefix in function type annotations\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **type name parsing logic when handling constructor contexts**. Specifically, in `JsDocInfoParser.parseTypeName()` around line 1952, there is likely incorrect handling of type tokens (`?` and `*`) when they appear after the `new:` prefix in function type annotations.\n\n**Possible root cause**: The production code may be failing to recognize that `?` and `*` are valid type annotations in constructor contexts (`function (new:?)` and `function (new:*)`), incorrectly treating them as syntax errors instead of valid unknown/wildcard types.\n\nThe parser should accept these special type tokens in constructor positions but is currently rejecting them with generic syntax warnings, causing both structural constructor tests to fail during type resolution.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 3,
            "reason": "#3# The reportTypeSyntaxWarning method is just a utility method that reports warnings and doesn't contain the actual logic that determines when to report syntax errors. The real issue is likely in the calling methods (parseTypeName or parseContextTypeExpression) that incorrectly decide to call this warning method for valid constructor syntax with '?' and '*' type tokens."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::reportGenericTypeSyntaxWarning()",
            "method_code": "```java\n  private Node reportGenericTypeSyntaxWarning() {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");\n  }\n\n```",
            "method_doc": "Reports a generic type syntax warning by calling reportTypeSyntaxWarning.",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across multiple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Common Patterns Identified:\n\n1. **Both tests involve structural constructor parsing** with `function (new:...)` syntax\n2. **Both failures occur during type name parsing** in `JsDocInfoParser.parseTypeName()`\n3. **Both generate the same warning**: \"Bad type annotation. type not recognized due to syntax error\"\n4. **The stack traces are identical** up to `parseTypeName()` where the divergence occurs\n5. **Both tests use special type tokens**: `?` (unknown) in test 1 and `*` (wildcard) in test 2 in constructor contexts\n\n## Key Observations:\n\n- The failures occur at `JsDocInfoParser.parseTypeName()` (line 1952)\n- Both tests trigger `reportGenericTypeSyntaxWarning()` via `reportTypeSyntaxWarning()`\n- The warning suggests the parser is incorrectly flagging valid constructor syntax as syntax errors\n- The common element is the `new:` prefix in function type annotations\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **type name parsing logic when handling constructor contexts**. Specifically, in `JsDocInfoParser.parseTypeName()` around line 1952, there is likely incorrect handling of type tokens (`?` and `*`) when they appear after the `new:` prefix in function type annotations.\n\n**Possible root cause**: The production code may be failing to recognize that `?` and `*` are valid type annotations in constructor contexts (`function (new:?)` and `function (new:*)`), incorrectly treating them as syntax errors instead of valid unknown/wildcard types.\n\nThe parser should accept these special type tokens in constructor positions but is currently rejecting them with generic syntax warnings, causing both structural constructor tests to fail during type resolution.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 3,
            "reason": "#3# This method is not the best location to be fixed because it's just a simple wrapper that delegates to reportTypeSyntaxWarning. The actual issue appears to be in the parsing logic that determines when to call this method, specifically in parseTypeName() where the decision is made to treat valid constructor type tokens (? and *) as syntax errors."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseTypeName(JsDocToken)": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseTypeName(JsDocToken)",
            "method_code": "```java\n  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }\n\n```",
            "method_doc": " TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseContextTypeExpression(JsDocToken)": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseContextTypeExpression(JsDocToken)",
            "method_code": "```java\n  private Node parseContextTypeExpression(JsDocToken TransVarDocToken) {\n          if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        return parseTypeName(TransVarDocToken);\n  }\n\n```",
            "method_doc": " ContextTypeExpression := BasicTypeExpression | '?' For expressions on the right hand side of a this: or new: "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::reportTypeSyntaxWarning(String)": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::reportTypeSyntaxWarning(String)",
            "method_code": "```java\n  private Node reportTypeSyntaxWarning(String warning) {\n    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());\n    return null;\n  }\n\n```",
            "method_doc": "Reports a type syntax warning using the error reporter."
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseBasicTypeExpression(JsDocToken)": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseBasicTypeExpression(JsDocToken)",
            "method_code": "```java\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }\n\n```",
            "method_doc": " BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseFunctionType(JsDocToken)": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parseFunctionType(JsDocToken)",
            "method_code": "```java\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseContextTypeExpression(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n\n```",
            "method_doc": " FunctionType := 'function' FunctionSignatureType FunctionSignatureType := TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::reportGenericTypeSyntaxWarning()": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::reportGenericTypeSyntaxWarning()",
            "method_code": "```java\n  private Node reportGenericTypeSyntaxWarning() {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.type.syntax\");\n  }\n\n```",
            "method_doc": "Reports a generic type syntax warning by calling reportTypeSyntaxWarning."
        }
    }
}