{
    "buggy_classes": [
        "org.apache.commons.lang.text.ExtendedMessageFormat"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.lang.text.ExtendedMessageFormat::applyPattern(String)",
            "method_code": "```java\n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList foundFormats = new ArrayList();\n        ArrayList foundDescriptions = new ArrayList();\n        StringBuffer stripCustom = new StringBuffer(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                // fall through\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3 \n            // seems to provide an extra format element:\n            int i = 0;\n            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = (Format) it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n```",
            "method_doc": " Apply the specified pattern.  @param pattern String ",
            "class_name": "org.apache.commons.lang.text.ExtendedMessageFormat",
            "class_doc": " Extends <code>java.text.MessageFormat</code> to allow pluggable/additional formatting options for embedded format elements.  Client code should specify a registry of <code>FormatFactory</code> instances associated with <code>String</code> format names.  This registry will be consulted when the format elements are  parsed from the message pattern.  In this way custom patterns can be specified, and the formats supported by <code>java.text.MessageFormat</code> can be overridden at the format and/or format style level (see MessageFormat).  A \"format element\" embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br /> <code>{</code><i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?)?</b><code>}</code>  <p> <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace in the manner of <code>java.text.MessageFormat</code>.  If <i>format-name</i> denotes <code>FormatFactory formatFactoryInstance</code> in <code>registry</code>, a <code>Format</code> matching <i>format-name</i> and <i>format-style</i> is requested from <code>formatFactoryInstance</code>.  If this is successful, the <code>Format</code> found is used for this format element. </p>  <p>NOTICE: The various subformat mutator methods are considered unnecessary; they exist on the parent class to allow the type of customization which it is the job of this class to provide in a configurable fashion.  These methods have thus been disabled and will throw <code>UnsupportedOperationException</code> if called. </p>  <p>Limitations inherited from <code>java.text.MessageFormat</code>: <ul> <li>When using \"choice\" subformats, support for nested formatting instructions is limited to that provided by the base class.</li> <li>Thread-safety of <code>Format</code>s, including <code>MessageFormat</code> and thus <code>ExtendedMessageFormat</code>, is not guaranteed.</li> </ul> </p>  @since 2.4 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**1. Common Pattern Identified:**\n- The test fails with an `OutOfMemoryError` during the construction of `ExtendedMessageFormat`\n- The error occurs specifically when processing a pattern containing escaped quotes (`it''s`)\n- The stack trace points to `appendQuotedString` method as the source of the memory issue\n\n**2. Stack Trace Analysis:**\n- The error originates in `ExtendedMessageFormat.appendQuotedString(ExtendedMessageFormat.java:428)`\n- This method is called from `applyPattern(ExtendedMessageFormat.java:158)`\n- The memory exhaustion happens in `StringBuffer.append()` operations within the quoted string processing\n\n**3. Test Behavior Insight:**\n- The test is specifically designed to verify handling of escaped quotes (Bug LANG-477)\n- The pattern `\"it''s a {0,lower} 'test'!\"` contains both escaped quotes (`''`) and quoted text (`'test'`)\n- The escaped quotes should be collapsed to literal single quotes during parsing\n\n## Recommended Possible Defect in Production Code\n\n**Defect Location:** `org.apache.commons.lang.text.ExtendedMessageFormat.appendQuotedString` method\n\n**Root Cause:** The method likely contains an infinite loop or excessive string buffer growth when processing escaped quotes within quoted segments. Specifically:\n\n- When encountering two consecutive single quotes (`''`) that represent an escaped quote, the parsing logic may fail to properly advance the position or handle the escape sequence\n- This could cause the method to repeatedly append to a `StringBuffer` without proper termination conditions\n- The escaped quote processing might be interfering with the normal quote parsing state machine\n\n**Expected Behavior:** The `appendQuotedString` method should:\n1. Recognize `''` as an escaped single quote character\n2. Append a single quote literal to the output buffer\n3. Advance the parser position appropriately\n4. Continue processing the remaining pattern\n\n**Actual Behavior:** The method appears to enter an infinite loop or excessive buffer growth when handling escaped quotes, leading to heap space exhaustion.\n\nThe defect is specifically in how escaped quotes are processed within the quoted string parsing logic, causing uncontrolled memory allocation in the string buffer operations.",
            "test_suite": "org.apache.commons.lang.text.ExtendedMessageFormatTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because the stack trace clearly shows the OutOfMemoryError originates from the appendQuotedString method called at line 158 within applyPattern. The test pattern contains escaped quotes (\"it''s\") which triggers infinite string buffer growth in the quoted string processing logic, causing heap space exhaustion during pattern application."
        },
        {
            "method_name": "org.apache.commons.lang.text.ExtendedMessageFormat::appendQuotedString(String,ParsePosition,StringBuffer,boolean)",
            "method_code": "```java\n    private StringBuffer appendQuotedString(String TransVarStringPattern, ParsePosition TransVarParsePosition,\n            StringBuffer TransVarAppendToBuffer, boolean TransVarEscaping) {\n        if (!(!(false))) {\n                    System.out.println(\"log\");\n        }\n        int TransVarPosStart = TransVarParsePosition.getIndex();\n        char[] TransVarCTemp = TransVarStringPattern.toCharArray();\n        if (!(!(TransVarEscaping && TransVarCTemp[TransVarPosStart] == QUOTE))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarAppendToBuffer == null ? null : TransVarAppendToBuffer.append(QUOTE);\n        }\n        int TransVarHold = TransVarPosStart;\n        int TransVarIndex = TransVarParsePosition.getIndex();\n        while (!(!(TransVarIndex < TransVarStringPattern.length()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarEscaping && TransVarStringPattern.substring(TransVarIndex).startsWith(ESCAPED_QUOTE)))) {\n                TransVarAppendToBuffer\n                        .append(TransVarCTemp, TransVarHold, TransVarParsePosition.getIndex() - TransVarHold)\n                        .append(QUOTE);\n                TransVarParsePosition.setIndex(TransVarIndex + ESCAPED_QUOTE.length());\n                TransVarHold = TransVarParsePosition.getIndex();\n                continue;\n            }\n            switch (TransVarCTemp[TransVarParsePosition.getIndex()]) {\n            case QUOTE:\n                next(TransVarParsePosition);\n                return TransVarAppendToBuffer == null ? null\n                        : TransVarAppendToBuffer.append(TransVarCTemp, TransVarHold,\n                                TransVarParsePosition.getIndex() - TransVarHold);\n            default:\n                next(TransVarParsePosition);\n            }\n            TransVarIndex++;\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + TransVarPosStart);\n    }\n\n```",
            "method_doc": " Consume a quoted string, adding it to <code>appendTo</code> if specified.  @param pattern pattern to parse @param pos current parse position @param appendTo optional StringBuffer to append @param escapingOn whether to process escaped quotes @return <code>appendTo</code> ",
            "class_name": "org.apache.commons.lang.text.ExtendedMessageFormat",
            "class_doc": " Extends <code>java.text.MessageFormat</code> to allow pluggable/additional formatting options for embedded format elements.  Client code should specify a registry of <code>FormatFactory</code> instances associated with <code>String</code> format names.  This registry will be consulted when the format elements are  parsed from the message pattern.  In this way custom patterns can be specified, and the formats supported by <code>java.text.MessageFormat</code> can be overridden at the format and/or format style level (see MessageFormat).  A \"format element\" embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br /> <code>{</code><i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?)?</b><code>}</code>  <p> <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace in the manner of <code>java.text.MessageFormat</code>.  If <i>format-name</i> denotes <code>FormatFactory formatFactoryInstance</code> in <code>registry</code>, a <code>Format</code> matching <i>format-name</i> and <i>format-style</i> is requested from <code>formatFactoryInstance</code>.  If this is successful, the <code>Format</code> found is used for this format element. </p>  <p>NOTICE: The various subformat mutator methods are considered unnecessary; they exist on the parent class to allow the type of customization which it is the job of this class to provide in a configurable fashion.  These methods have thus been disabled and will throw <code>UnsupportedOperationException</code> if called. </p>  <p>Limitations inherited from <code>java.text.MessageFormat</code>: <ul> <li>When using \"choice\" subformats, support for nested formatting instructions is limited to that provided by the base class.</li> <li>Thread-safety of <code>Format</code>s, including <code>MessageFormat</code> and thus <code>ExtendedMessageFormat</code>, is not guaranteed.</li> </ul> </p>  @since 2.4 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**1. Common Pattern Identified:**\n- The test fails with an `OutOfMemoryError` during the construction of `ExtendedMessageFormat`\n- The error occurs specifically when processing a pattern containing escaped quotes (`it''s`)\n- The stack trace points to `appendQuotedString` method as the source of the memory issue\n\n**2. Stack Trace Analysis:**\n- The error originates in `ExtendedMessageFormat.appendQuotedString(ExtendedMessageFormat.java:428)`\n- This method is called from `applyPattern(ExtendedMessageFormat.java:158)`\n- The memory exhaustion happens in `StringBuffer.append()` operations within the quoted string processing\n\n**3. Test Behavior Insight:**\n- The test is specifically designed to verify handling of escaped quotes (Bug LANG-477)\n- The pattern `\"it''s a {0,lower} 'test'!\"` contains both escaped quotes (`''`) and quoted text (`'test'`)\n- The escaped quotes should be collapsed to literal single quotes during parsing\n\n## Recommended Possible Defect in Production Code\n\n**Defect Location:** `org.apache.commons.lang.text.ExtendedMessageFormat.appendQuotedString` method\n\n**Root Cause:** The method likely contains an infinite loop or excessive string buffer growth when processing escaped quotes within quoted segments. Specifically:\n\n- When encountering two consecutive single quotes (`''`) that represent an escaped quote, the parsing logic may fail to properly advance the position or handle the escape sequence\n- This could cause the method to repeatedly append to a `StringBuffer` without proper termination conditions\n- The escaped quote processing might be interfering with the normal quote parsing state machine\n\n**Expected Behavior:** The `appendQuotedString` method should:\n1. Recognize `''` as an escaped single quote character\n2. Append a single quote literal to the output buffer\n3. Advance the parser position appropriately\n4. Continue processing the remaining pattern\n\n**Actual Behavior:** The method appears to enter an infinite loop or excessive buffer growth when handling escaped quotes, leading to heap space exhaustion.\n\nThe defect is specifically in how escaped quotes are processed within the quoted string parsing logic, causing uncontrolled memory allocation in the string buffer operations.",
            "test_suite": "org.apache.commons.lang.text.ExtendedMessageFormatTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious as the root cause because the stack trace clearly shows the OutOfMemoryError originates from line 428 within appendQuotedString during StringBuffer.append operations. The test pattern contains escaped quotes (\"it''s\") which should be handled by this method, but the while loop appears to have incorrect termination logic when processing escaped quotes, causing infinite string buffer growth and heap exhaustion. The method's complex conditionals and loop structure suggest it fails to properly handle the escape sequence case, leading to uncontrolled memory allocation."
        },
        {
            "method_name": "org.apache.commons.lang.text.ExtendedMessageFormat::ExtendedMessageFormat(String,Locale,Map)",
            "method_code": "```java\n    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n```",
            "method_doc": " Create a new ExtendedMessageFormat.  @param pattern String @param locale Locale @param registry Registry of format factories:  Map<String, FormatFactory> @throws IllegalArgumentException in case of a bad pattern. ",
            "class_name": "org.apache.commons.lang.text.ExtendedMessageFormat",
            "class_doc": " Extends <code>java.text.MessageFormat</code> to allow pluggable/additional formatting options for embedded format elements.  Client code should specify a registry of <code>FormatFactory</code> instances associated with <code>String</code> format names.  This registry will be consulted when the format elements are  parsed from the message pattern.  In this way custom patterns can be specified, and the formats supported by <code>java.text.MessageFormat</code> can be overridden at the format and/or format style level (see MessageFormat).  A \"format element\" embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br /> <code>{</code><i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?)?</b><code>}</code>  <p> <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace in the manner of <code>java.text.MessageFormat</code>.  If <i>format-name</i> denotes <code>FormatFactory formatFactoryInstance</code> in <code>registry</code>, a <code>Format</code> matching <i>format-name</i> and <i>format-style</i> is requested from <code>formatFactoryInstance</code>.  If this is successful, the <code>Format</code> found is used for this format element. </p>  <p>NOTICE: The various subformat mutator methods are considered unnecessary; they exist on the parent class to allow the type of customization which it is the job of this class to provide in a configurable fashion.  These methods have thus been disabled and will throw <code>UnsupportedOperationException</code> if called. </p>  <p>Limitations inherited from <code>java.text.MessageFormat</code>: <ul> <li>When using \"choice\" subformats, support for nested formatting instructions is limited to that provided by the base class.</li> <li>Thread-safety of <code>Format</code>s, including <code>MessageFormat</code> and thus <code>ExtendedMessageFormat</code>, is not guaranteed.</li> </ul> </p>  @since 2.4 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**1. Common Pattern Identified:**\n- The test fails with an `OutOfMemoryError` during the construction of `ExtendedMessageFormat`\n- The error occurs specifically when processing a pattern containing escaped quotes (`it''s`)\n- The stack trace points to `appendQuotedString` method as the source of the memory issue\n\n**2. Stack Trace Analysis:**\n- The error originates in `ExtendedMessageFormat.appendQuotedString(ExtendedMessageFormat.java:428)`\n- This method is called from `applyPattern(ExtendedMessageFormat.java:158)`\n- The memory exhaustion happens in `StringBuffer.append()` operations within the quoted string processing\n\n**3. Test Behavior Insight:**\n- The test is specifically designed to verify handling of escaped quotes (Bug LANG-477)\n- The pattern `\"it''s a {0,lower} 'test'!\"` contains both escaped quotes (`''`) and quoted text (`'test'`)\n- The escaped quotes should be collapsed to literal single quotes during parsing\n\n## Recommended Possible Defect in Production Code\n\n**Defect Location:** `org.apache.commons.lang.text.ExtendedMessageFormat.appendQuotedString` method\n\n**Root Cause:** The method likely contains an infinite loop or excessive string buffer growth when processing escaped quotes within quoted segments. Specifically:\n\n- When encountering two consecutive single quotes (`''`) that represent an escaped quote, the parsing logic may fail to properly advance the position or handle the escape sequence\n- This could cause the method to repeatedly append to a `StringBuffer` without proper termination conditions\n- The escaped quote processing might be interfering with the normal quote parsing state machine\n\n**Expected Behavior:** The `appendQuotedString` method should:\n1. Recognize `''` as an escaped single quote character\n2. Append a single quote literal to the output buffer\n3. Advance the parser position appropriately\n4. Continue processing the remaining pattern\n\n**Actual Behavior:** The method appears to enter an infinite loop or excessive buffer growth when handling escaped quotes, leading to heap space exhaustion.\n\nThe defect is specifically in how escaped quotes are processed within the quoted string parsing logic, causing uncontrolled memory allocation in the string buffer operations.",
            "test_suite": "org.apache.commons.lang.text.ExtendedMessageFormatTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because it directly calls the applyPattern method where the OutOfMemoryError occurs in the stack trace, and the constructor is the entry point where the problematic pattern processing begins, making it the appropriate place to handle the escaped quote parsing issue."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.lang.text.ExtendedMessageFormat::applyPattern(String)": {
            "method_name": "org.apache.commons.lang.text.ExtendedMessageFormat::applyPattern(String)",
            "method_code": "```java\n    public final void applyPattern(String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        ArrayList foundFormats = new ArrayList();\n        ArrayList foundDescriptions = new ArrayList();\n        StringBuffer stripCustom = new StringBuffer(pattern.length());\n\n        ParsePosition pos = new ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                appendQuotedString(pattern, pos, stripCustom, true);\n                break;\n            case START_FE:\n                fmtCount++;\n                seekNonWs(pattern, pos);\n                int start = pos.getIndex();\n                int index = readArgumentIndex(pattern, next(pos));\n                stripCustom.append(START_FE).append(index);\n                seekNonWs(pattern, pos);\n                Format format = null;\n                String formatDescription = null;\n                if (c[pos.getIndex()] == START_FMT) {\n                    formatDescription = parseFormatDescription(pattern,\n                            next(pos));\n                    format = getFormat(formatDescription);\n                    if (format == null) {\n                        stripCustom.append(START_FMT).append(formatDescription);\n                    }\n                }\n                foundFormats.add(format);\n                foundDescriptions.add(format == null ? null : formatDescription);\n                Validate.isTrue(foundFormats.size() == fmtCount);\n                Validate.isTrue(foundDescriptions.size() == fmtCount);\n                if (c[pos.getIndex()] != END_FE) {\n                    throw new IllegalArgumentException(\n                            \"Unreadable format element at position \" + start);\n                }\n                // fall through\n            default:\n                stripCustom.append(c[pos.getIndex()]);\n                next(pos);\n            }\n        }\n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            Format[] origFormats = getFormats();\n            // only loop over what we know we have, as MessageFormat on Java 1.3 \n            // seems to provide an extra format element:\n            int i = 0;\n            for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {\n                Format f = (Format) it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n```",
            "method_doc": " Apply the specified pattern.  @param pattern String "
        },
        "org.apache.commons.lang.text.ExtendedMessageFormat::ExtendedMessageFormat(String,Locale,Map)": {
            "method_name": "org.apache.commons.lang.text.ExtendedMessageFormat::ExtendedMessageFormat(String,Locale,Map)",
            "method_code": "```java\n    public ExtendedMessageFormat(String pattern, Locale locale, Map registry) {\n        super(DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n```",
            "method_doc": " Create a new ExtendedMessageFormat.  @param pattern String @param locale Locale @param registry Registry of format factories:  Map<String, FormatFactory> @throws IllegalArgumentException in case of a bad pattern. "
        },
        "org.apache.commons.lang.text.ExtendedMessageFormat::appendQuotedString(String,ParsePosition,StringBuffer,boolean)": {
            "method_name": "org.apache.commons.lang.text.ExtendedMessageFormat::appendQuotedString(String,ParsePosition,StringBuffer,boolean)",
            "method_code": "```java\n    private StringBuffer appendQuotedString(String TransVarStringPattern, ParsePosition TransVarParsePosition,\n            StringBuffer TransVarAppendToBuffer, boolean TransVarEscaping) {\n        if (!(!(false))) {\n                    System.out.println(\"log\");\n        }\n        int TransVarPosStart = TransVarParsePosition.getIndex();\n        char[] TransVarCTemp = TransVarStringPattern.toCharArray();\n        if (!(!(TransVarEscaping && TransVarCTemp[TransVarPosStart] == QUOTE))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarAppendToBuffer == null ? null : TransVarAppendToBuffer.append(QUOTE);\n        }\n        int TransVarHold = TransVarPosStart;\n        int TransVarIndex = TransVarParsePosition.getIndex();\n        while (!(!(TransVarIndex < TransVarStringPattern.length()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarEscaping && TransVarStringPattern.substring(TransVarIndex).startsWith(ESCAPED_QUOTE)))) {\n                TransVarAppendToBuffer\n                        .append(TransVarCTemp, TransVarHold, TransVarParsePosition.getIndex() - TransVarHold)\n                        .append(QUOTE);\n                TransVarParsePosition.setIndex(TransVarIndex + ESCAPED_QUOTE.length());\n                TransVarHold = TransVarParsePosition.getIndex();\n                continue;\n            }\n            switch (TransVarCTemp[TransVarParsePosition.getIndex()]) {\n            case QUOTE:\n                next(TransVarParsePosition);\n                return TransVarAppendToBuffer == null ? null\n                        : TransVarAppendToBuffer.append(TransVarCTemp, TransVarHold,\n                                TransVarParsePosition.getIndex() - TransVarHold);\n            default:\n                next(TransVarParsePosition);\n            }\n            TransVarIndex++;\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + TransVarPosStart);\n    }\n\n```",
            "method_doc": " Consume a quoted string, adding it to <code>appendTo</code> if specified.  @param pattern pattern to parse @param pos current parse position @param appendTo optional StringBuffer to append @param escapingOn whether to process escaped quotes @return <code>appendTo</code> "
        }
    }
}