{
    "buggy_classes": [
        "org.apache.commons.codec.language.DoubleMetaphone"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone::handleG(String,DoubleMetaphoneResult,int,boolean)",
            "method_code": "```java\n    private int handleG(String TransVarStrValue, \n                        DoubleMetaphoneResult TransVarDoubleMetaphoneResult, \n                        int TransVarCurrentIndex, \n                        boolean TransVarIsSlavoGermanic) {\n        if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n        if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'H'))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarCurrentIndex = handleGH(TransVarStrValue, TransVarDoubleMetaphoneResult, TransVarCurrentIndex);\n        } else if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'N'))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarCurrentIndex == 1 && isVowel(charAt(TransVarStrValue, 0)) && !TransVarIsSlavoGermanic))) {\n                TransVarDoubleMetaphoneResult.append(\"KN\", \"N\");\n            } else if (!(!(!contains(TransVarStrValue, TransVarCurrentIndex + 2, 2, \"EY\")\n                    && charAt(TransVarStrValue, TransVarCurrentIndex + 1) != 'Y' && !TransVarIsSlavoGermanic))) {\n                TransVarDoubleMetaphoneResult.append(\"N\", \"KN\");\n            } else {\n                TransVarDoubleMetaphoneResult.append(\"KN\");\n            }\n            TransVarCurrentIndex = TransVarCurrentIndex + 2;\n        } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"LI\") && !TransVarIsSlavoGermanic))) {\n            TransVarDoubleMetaphoneResult.append(\"KL\", \"L\");\n            TransVarCurrentIndex += 2;\n        } else if (!(!(TransVarCurrentIndex == 0 && (charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'Y'\n                || contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            TransVarDoubleMetaphoneResult.append('K', 'J');\n            TransVarCurrentIndex += 2;\n        } else if (!(!((contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"ER\")\n                || charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'Y')\n                && !contains(TransVarStrValue, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\")\n                && !contains(TransVarStrValue, TransVarCurrentIndex - 1, 1, \"E\", \"I\")\n                && !contains(TransVarStrValue, TransVarCurrentIndex - 1, 3, \"RGY\", \"OGY\")))) {\n            //-- -ger-, -gy- --//\n            TransVarDoubleMetaphoneResult.append('K', 'J');\n            TransVarCurrentIndex += 2;\n        } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 1, \"E\", \"I\", \"Y\")\n                || contains(TransVarStrValue, TransVarCurrentIndex - 1, 4, \"AGGI\", \"OGGI\")))) {\n            //-- Italian \"biaggi\" --//\n            if (!(!((contains(TransVarStrValue, 0, 4, \"VAN \", \"VON \") || contains(TransVarStrValue, 0, 3, \"SCH\"))\n                    || contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"ET\")))) {\n                //-- obvious germanic --//\n                TransVarDoubleMetaphoneResult.append('K');\n            } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 4, \"IER\")))) {\n                TransVarDoubleMetaphoneResult.append('J');\n            } else {\n                TransVarDoubleMetaphoneResult.append('J', 'K');\n            }\n            TransVarCurrentIndex += 2;\n        } else if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'G'))) {\n            TransVarCurrentIndex += 2;\n            TransVarDoubleMetaphoneResult.append('K');\n        } else {\n            TransVarCurrentIndex++;\n            TransVarDoubleMetaphoneResult.append('K');\n        }\n        return TransVarCurrentIndex;\n    }\n\n```",
            "method_doc": " Handles 'G' cases ",
            "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
            "class_doc": " Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>. <ul> <li>Original Article: <a  href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\"> http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li> <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\"> ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li> </ul>  @version $Id$ ",
            "test_failure_causes": "Based on the test failure analysis, I can identify the following key information:\n\n**Step 1: Analyze the Test Failure Pattern**\n\nThe test `testDoubleMetaphoneAlternate` is failing at index 19 with input \"Angier\". The expected alternate encoding is \"ANJR\" but the actual result is \"ANKR\". This indicates a specific issue with how the DoubleMetaphone algorithm handles the \"g\" in \"Angier\" when computing alternate encodings.\n\n**Step 2: Identify the Common Issue**\n\nThe failure occurs specifically in the alternate encoding path (when the second parameter is `true` in `doubleMetaphone(value, true)`). The discrepancy between expected \"J\" and actual \"K\" suggests that the algorithm is incorrectly handling the transformation of the \"g\" sound in certain phonetic contexts.\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `DoubleMetaphone.doubleMetaphone(String value, boolean alternate)` method, specifically in the logic that handles the letter 'G' when computing alternate encodings. The production code appears to have incorrect conditional logic for determining when 'G' should be encoded as 'J' versus 'K' in the alternate encoding path.\n\n**Possible defect location**: The method responsible for processing the 'G' character in the `DoubleMetaphone` class, particularly in the alternate encoding branch. The algorithm may be missing a specific condition or has incorrect logic for handling 'G' followed by certain vowels or in specific positions within words like \"Angier\".\n\n**Root cause**: The production code likely has a flawed phonetic rule implementation for 'G' \u2192 'J' transformation in the alternate encoding, causing it to default to 'K' in cases where it should produce 'J'.",
            "test_suite": "org.apache.commons.codec.language.DoubleMetaphone2Test",
            "score": 9,
            "reason": "#9# This method is highly suspicious because the test failure shows \"Angier\" producing \"ANKR\" instead of expected \"ANJR\", indicating incorrect 'G' handling. The method contains complex logic for determining when 'G' should be encoded as 'J' versus 'K', and the specific case of \"Angier\" likely falls through to the default 'K' encoding when it should produce 'J' in the alternate encoding path. The nested conditions for Italian words and Germanic patterns appear to be misclassifying this input."
        },
        {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone::doubleMetaphone(String,boolean)",
            "method_code": "```java\n    public String doubleMetaphone(String value, boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n        \n        boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n        \n        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n        \n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(value, result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break; \n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }\n\n```",
            "method_doc": " Encode a value with Double Metaphone, optionally using the alternate encoding.  @param value String to encode @param alternate use alternate encode @return an encoded string ",
            "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
            "class_doc": " Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>. <ul> <li>Original Article: <a  href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\"> http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li> <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\"> ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li> </ul>  @version $Id$ ",
            "test_failure_causes": "Based on the test failure analysis, I can identify the following key information:\n\n**Step 1: Analyze the Test Failure Pattern**\n\nThe test `testDoubleMetaphoneAlternate` is failing at index 19 with input \"Angier\". The expected alternate encoding is \"ANJR\" but the actual result is \"ANKR\". This indicates a specific issue with how the DoubleMetaphone algorithm handles the \"g\" in \"Angier\" when computing alternate encodings.\n\n**Step 2: Identify the Common Issue**\n\nThe failure occurs specifically in the alternate encoding path (when the second parameter is `true` in `doubleMetaphone(value, true)`). The discrepancy between expected \"J\" and actual \"K\" suggests that the algorithm is incorrectly handling the transformation of the \"g\" sound in certain phonetic contexts.\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `DoubleMetaphone.doubleMetaphone(String value, boolean alternate)` method, specifically in the logic that handles the letter 'G' when computing alternate encodings. The production code appears to have incorrect conditional logic for determining when 'G' should be encoded as 'J' versus 'K' in the alternate encoding path.\n\n**Possible defect location**: The method responsible for processing the 'G' character in the `DoubleMetaphone` class, particularly in the alternate encoding branch. The algorithm may be missing a specific condition or has incorrect logic for handling 'G' followed by certain vowels or in specific positions within words like \"Angier\".\n\n**Root cause**: The production code likely has a flawed phonetic rule implementation for 'G' \u2192 'J' transformation in the alternate encoding, causing it to default to 'K' in cases where it should produce 'J'.",
            "test_suite": "org.apache.commons.codec.language.DoubleMetaphone2Test",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because the test failure specifically occurs when calling doubleMetaphone(value, true) for alternate encoding, and the method contains the switch statement that handles character 'G' by calling handleG(), which is where the incorrect encoding logic for \"Angier\" producing \"ANKR\" instead of \"ANJR\" likely resides."
        },
        {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult::append(char,char)",
            "method_code": "```java\n        public void append(char primary, char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n```",
            "method_doc": "Appends different characters to primary and alternate result buffers. This method calls appendPrimary and appendAlternate.",
            "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
            "class_doc": " Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>. <ul> <li>Original Article: <a  href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\"> http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li> <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\"> ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li> </ul>  @version $Id$ ",
            "test_failure_causes": "Based on the test failure analysis, I can identify the following key information:\n\n**Step 1: Analyze the Test Failure Pattern**\n\nThe test `testDoubleMetaphoneAlternate` is failing at index 19 with input \"Angier\". The expected alternate encoding is \"ANJR\" but the actual result is \"ANKR\". This indicates a specific issue with how the DoubleMetaphone algorithm handles the \"g\" in \"Angier\" when computing alternate encodings.\n\n**Step 2: Identify the Common Issue**\n\nThe failure occurs specifically in the alternate encoding path (when the second parameter is `true` in `doubleMetaphone(value, true)`). The discrepancy between expected \"J\" and actual \"K\" suggests that the algorithm is incorrectly handling the transformation of the \"g\" sound in certain phonetic contexts.\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `DoubleMetaphone.doubleMetaphone(String value, boolean alternate)` method, specifically in the logic that handles the letter 'G' when computing alternate encodings. The production code appears to have incorrect conditional logic for determining when 'G' should be encoded as 'J' versus 'K' in the alternate encoding path.\n\n**Possible defect location**: The method responsible for processing the 'G' character in the `DoubleMetaphone` class, particularly in the alternate encoding branch. The algorithm may be missing a specific condition or has incorrect logic for handling 'G' followed by certain vowels or in specific positions within words like \"Angier\".\n\n**Root cause**: The production code likely has a flawed phonetic rule implementation for 'G' \u2192 'J' transformation in the alternate encoding, causing it to default to 'K' in cases where it should produce 'J'.",
            "test_suite": "org.apache.commons.codec.language.DoubleMetaphone2Test",
            "score": 2,
            "reason": "#2# The append(char,char) method simply delegates to appendPrimary and appendAlternate methods and doesn't contain any logic that would affect the encoding algorithm. The actual bug is likely in the DoubleMetaphone algorithm logic that determines when to use 'J' vs 'K' encoding for the letter 'G', not in this result appending utility method."
        },
        {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult::appendAlternate(char)",
            "method_code": "```java\n        public void appendAlternate(char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }\n\n```",
            "method_doc": "Appends character to alternate result buffer if within max length limit.",
            "class_name": "org.apache.commons.codec.language.DoubleMetaphone",
            "class_doc": " Encodes a string into a double metaphone value. This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>. <ul> <li>Original Article: <a  href=\"http://www.cuj.com/documents/s=8038/cuj0006philips/\"> http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li> <li>Original Source Code: <a href=\"ftp://ftp.cuj.com/pub/2000/1806/philips.zip\"> ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li> </ul>  @version $Id$ ",
            "test_failure_causes": "Based on the test failure analysis, I can identify the following key information:\n\n**Step 1: Analyze the Test Failure Pattern**\n\nThe test `testDoubleMetaphoneAlternate` is failing at index 19 with input \"Angier\". The expected alternate encoding is \"ANJR\" but the actual result is \"ANKR\". This indicates a specific issue with how the DoubleMetaphone algorithm handles the \"g\" in \"Angier\" when computing alternate encodings.\n\n**Step 2: Identify the Common Issue**\n\nThe failure occurs specifically in the alternate encoding path (when the second parameter is `true` in `doubleMetaphone(value, true)`). The discrepancy between expected \"J\" and actual \"K\" suggests that the algorithm is incorrectly handling the transformation of the \"g\" sound in certain phonetic contexts.\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `DoubleMetaphone.doubleMetaphone(String value, boolean alternate)` method, specifically in the logic that handles the letter 'G' when computing alternate encodings. The production code appears to have incorrect conditional logic for determining when 'G' should be encoded as 'J' versus 'K' in the alternate encoding path.\n\n**Possible defect location**: The method responsible for processing the 'G' character in the `DoubleMetaphone` class, particularly in the alternate encoding branch. The algorithm may be missing a specific condition or has incorrect logic for handling 'G' followed by certain vowels or in specific positions within words like \"Angier\".\n\n**Root cause**: The production code likely has a flawed phonetic rule implementation for 'G' \u2192 'J' transformation in the alternate encoding, causing it to default to 'K' in cases where it should produce 'J'.",
            "test_suite": "org.apache.commons.codec.language.DoubleMetaphone2Test",
            "score": 2,
            "reason": "#2# The appendAlternate method simply appends characters to the alternate buffer within length limits and doesn't contain any phonetic encoding logic. The actual bug is likely in the DoubleMetaphone algorithm's phonetic rules for handling 'G' sounds in alternate encodings, not in this simple buffer management method."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.codec.language.DoubleMetaphone::doubleMetaphone(String,boolean)": {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone::doubleMetaphone(String,boolean)",
            "method_code": "```java\n    public String doubleMetaphone(String value, boolean alternate) {\n        value = cleanInput(value);\n        if (value == null) {\n            return null;\n        }\n        \n        boolean slavoGermanic = isSlavoGermanic(value);\n        int index = isSilentStart(value) ? 1 : 0;\n        \n        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());\n        \n        while (!result.isComplete() && index <= value.length() - 1) {\n            switch (value.charAt(index)) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                index = handleAEIOUY(value, result, index);\n                break;\n            case 'B':\n                result.append('P');\n                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;\n                break;\n            case '\\u00C7':\n                // A C with a Cedilla\n                result.append('S');\n                index++;\n                break; \n            case 'C':\n                index = handleC(value, result, index);\n                break;\n            case 'D':\n                index = handleD(value, result, index);\n                break;\n            case 'F':\n                result.append('F');\n                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;\n                break;\n            case 'G':\n                index = handleG(value, result, index, slavoGermanic);\n                break;\n            case 'H':\n                index = handleH(value, result, index);\n                break;\n            case 'J':\n                index = handleJ(value, result, index, slavoGermanic);\n                break;\n            case 'K':\n                result.append('K');\n                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;\n                break;\n            case 'L':\n                index = handleL(value, result, index);\n                break;\n            case 'M':\n                result.append('M');\n                index = conditionM0(value, index) ? index + 2 : index + 1;\n                break;\n            case 'N':\n                result.append('N');\n                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;\n                break;\n            case '\\u00D1':\n                // N with a tilde (spanish ene)\n                result.append('N');\n                index++;\n                break;\n            case 'P':\n                index = handleP(value, result, index);\n                break;\n            case 'Q':\n                result.append('K');\n                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;\n                break;\n            case 'R':\n                index = handleR(value, result, index, slavoGermanic);\n                break;\n            case 'S':\n                index = handleS(value, result, index, slavoGermanic);\n                break;\n            case 'T':\n                index = handleT(value, result, index);\n                break;\n            case 'V':\n                result.append('F');\n                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;\n                break;\n            case 'W':\n                index = handleW(value, result, index);\n                break;\n            case 'X':\n                index = handleX(value, result, index);\n                break;\n            case 'Z':\n                index = handleZ(value, result, index, slavoGermanic);\n                break;\n            default:\n                index++;\n                break;\n            }\n        }\n\n        return alternate ? result.getAlternate() : result.getPrimary();\n    }\n\n```",
            "method_doc": " Encode a value with Double Metaphone, optionally using the alternate encoding.  @param value String to encode @param alternate use alternate encode @return an encoded string "
        },
        "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult::append(char,char)": {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult::append(char,char)",
            "method_code": "```java\n        public void append(char primary, char alternate) {\n            appendPrimary(primary);\n            appendAlternate(alternate);\n        }\n\n```",
            "method_doc": "Appends different characters to primary and alternate result buffers. This method calls appendPrimary and appendAlternate."
        },
        "org.apache.commons.codec.language.DoubleMetaphone::handleG(String,DoubleMetaphoneResult,int,boolean)": {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone::handleG(String,DoubleMetaphoneResult,int,boolean)",
            "method_code": "```java\n    private int handleG(String TransVarStrValue, \n                        DoubleMetaphoneResult TransVarDoubleMetaphoneResult, \n                        int TransVarCurrentIndex, \n                        boolean TransVarIsSlavoGermanic) {\n        if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n        if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'H'))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarCurrentIndex = handleGH(TransVarStrValue, TransVarDoubleMetaphoneResult, TransVarCurrentIndex);\n        } else if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'N'))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarCurrentIndex == 1 && isVowel(charAt(TransVarStrValue, 0)) && !TransVarIsSlavoGermanic))) {\n                TransVarDoubleMetaphoneResult.append(\"KN\", \"N\");\n            } else if (!(!(!contains(TransVarStrValue, TransVarCurrentIndex + 2, 2, \"EY\")\n                    && charAt(TransVarStrValue, TransVarCurrentIndex + 1) != 'Y' && !TransVarIsSlavoGermanic))) {\n                TransVarDoubleMetaphoneResult.append(\"N\", \"KN\");\n            } else {\n                TransVarDoubleMetaphoneResult.append(\"KN\");\n            }\n            TransVarCurrentIndex = TransVarCurrentIndex + 2;\n        } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"LI\") && !TransVarIsSlavoGermanic))) {\n            TransVarDoubleMetaphoneResult.append(\"KL\", \"L\");\n            TransVarCurrentIndex += 2;\n        } else if (!(!(TransVarCurrentIndex == 0 && (charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'Y'\n                || contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))))) {\n            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            TransVarDoubleMetaphoneResult.append('K', 'J');\n            TransVarCurrentIndex += 2;\n        } else if (!(!((contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"ER\")\n                || charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'Y')\n                && !contains(TransVarStrValue, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\")\n                && !contains(TransVarStrValue, TransVarCurrentIndex - 1, 1, \"E\", \"I\")\n                && !contains(TransVarStrValue, TransVarCurrentIndex - 1, 3, \"RGY\", \"OGY\")))) {\n            //-- -ger-, -gy- --//\n            TransVarDoubleMetaphoneResult.append('K', 'J');\n            TransVarCurrentIndex += 2;\n        } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 1, \"E\", \"I\", \"Y\")\n                || contains(TransVarStrValue, TransVarCurrentIndex - 1, 4, \"AGGI\", \"OGGI\")))) {\n            //-- Italian \"biaggi\" --//\n            if (!(!((contains(TransVarStrValue, 0, 4, \"VAN \", \"VON \") || contains(TransVarStrValue, 0, 3, \"SCH\"))\n                    || contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"ET\")))) {\n                //-- obvious germanic --//\n                TransVarDoubleMetaphoneResult.append('K');\n            } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 4, \"IER\")))) {\n                TransVarDoubleMetaphoneResult.append('J');\n            } else {\n                TransVarDoubleMetaphoneResult.append('J', 'K');\n            }\n            TransVarCurrentIndex += 2;\n        } else if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'G'))) {\n            TransVarCurrentIndex += 2;\n            TransVarDoubleMetaphoneResult.append('K');\n        } else {\n            TransVarCurrentIndex++;\n            TransVarDoubleMetaphoneResult.append('K');\n        }\n        return TransVarCurrentIndex;\n    }\n\n```",
            "method_doc": " Handles 'G' cases "
        },
        "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult::appendAlternate(char)": {
            "method_name": "org.apache.commons.codec.language.DoubleMetaphone$DoubleMetaphoneResult::appendAlternate(char)",
            "method_code": "```java\n        public void appendAlternate(char value) {\n            if (this.alternate.length() < this.maxLength) {\n                this.alternate.append(value);\n            }\n        }\n\n```",
            "method_doc": "Appends character to alternate result buffer if within max length limit."
        }
    }
}