{
    "buggy_classes": [
        "org.joda.time.Partial"
    ],
    "buggy_methods": [
        {
            "method_name": "org.joda.time.Partial::with(DateTimeFieldType,int)",
            "method_code": "```java\n    public Partial with(DateTimeFieldType TransVarDateType, int TransVarDate) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarDateType == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int TransVarFieldIndex = indexOf(TransVarDateType);\n        if (!(!(TransVarFieldIndex == -1))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            DateTimeFieldType[] TransVarNewTypes_2 = new DateTimeFieldType[iTypes.length + 1];\n            int[] TransVarNewTypes = new int[TransVarNewTypes_2.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int TransVarIndex = 0;\n            DurationField TransVarUnit = TransVarDateType.getDurationType().getField(iChronology);\n            if (!(!(TransVarUnit.isSupported()))) {\n                while (!(!(TransVarIndex < iTypes.length))) {\n                    DateTimeFieldType TransVarLoopType2 = iTypes[TransVarIndex];\n                    DurationField TransVarField = TransVarLoopType2.getDurationType().getField(iChronology);\n                    if (!(!(TransVarField.isSupported()))) {\n                        int TransVarCompare1 = TransVarUnit.compareTo(TransVarField);\n                        if (!(!(TransVarCompare1 > 0))) {\n                            break;\n                        } else if (!(!(TransVarCompare1 == 0))) {\n                            DurationField TransVarRangeDurationField = TransVarDateType.getRangeDurationType()\n                                    .getField(iChronology);\n                            DurationField TransVarLoopRangeField2 = TransVarLoopType2.getRangeDurationType()\n                                    .getField(iChronology);\n                            if (!(!(TransVarRangeDurationField.compareTo(TransVarLoopRangeField2) > 0))) {\n                                break;\n                            }\n                        }\n                    }\n                    TransVarIndex++;\n                }\n            }\n            System.arraycopy(iTypes, 0, TransVarNewTypes_2, 0, TransVarIndex);\n            System.arraycopy(iValues, 0, TransVarNewTypes, 0, TransVarIndex);\n            TransVarNewTypes_2[TransVarIndex] = TransVarDateType;\n            TransVarNewTypes[TransVarIndex] = TransVarDate;\n            System.arraycopy(iTypes, TransVarIndex, TransVarNewTypes_2, TransVarIndex + 1, TransVarNewTypes_2.length - TransVarIndex - 1);\n            System.arraycopy(iValues, TransVarIndex, TransVarNewTypes, TransVarIndex + 1, TransVarNewTypes.length - TransVarIndex - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial TransVarPartial = new Partial(iChronology, TransVarNewTypes_2, TransVarNewTypes);\n            iChronology.validate(TransVarPartial, TransVarNewTypes);\n            return TransVarPartial;\n        }\n        if (!(!(TransVarDate == getValue(TransVarFieldIndex)))) {\n            return this;\n        }\n        int[] TransVarNewValues_2 = getValues();\n        TransVarNewValues_2 = getField(TransVarFieldIndex).set(this, TransVarFieldIndex, TransVarNewValues_2, TransVarDate);\n        return new Partial(this, TransVarNewValues_2);\n    }\n\n```",
            "method_doc": " Gets a copy of this date with the specified field set to a new value. <p> If this partial did not previously support the field, the new one will. Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed/added in the returned instance.  @param fieldType  the field type to set, not null @param value  the value to set @return a copy of this instance with the field set @throws IllegalArgumentException if the value is null or invalid ",
            "class_name": "org.joda.time.Partial",
            "class_doc": " Partial is an immutable partial datetime supporting any set of datetime fields. <p> A Partial instance can be used to hold any combination of fields. The instance does not contain a time zone, so any datetime is local. <p> A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}. This method compares each field on this partial with those of the instant and determines if the partial matches the instant. Given this definition, an empty Partial instance represents any datetime and always matches. <p> Calculations on Partial are performed using a {@link Chronology}. This chronology is set to be in the UTC time zone for all calculations. <p> Each individual field can be queried in two ways: <ul> <li><code>get(DateTimeFieldType.monthOfYear())</code> <li><code>property(DateTimeFieldType.monthOfYear()).get()</code> </ul> The second technique also provides access to other useful methods on the field: <ul> <li>numeric value - <code>monthOfYear().get()</code> <li>text value - <code>monthOfYear().getAsText()</code> <li>short text value - <code>monthOfYear().getAsShortText()</code> <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code> <li>add/subtract - <code>monthOfYear().addToCopy()</code> <li>set - <code>monthOfYear().setCopy()</code> </ul> <p> Partial is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.  @since 1.1 ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this test failure systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe test `testWith3` is designed to verify that when attempting to add an incompatible field type (`clockhourOfDay`) to a `Partial` object that already contains `hourOfDay` and `minuteOfHour` fields, the system should:\n\n1. Throw an `IllegalArgumentException`\n2. Leave the original `Partial` object unchanged\n\n## Step 2: Identifying the Failure Pattern\n\nThe test is failing because:\n- The `test.with(DateTimeFieldType.clockhourOfDay(), 6)` call is **not throwing** the expected `IllegalArgumentException`\n- This causes the `fail()` statement to execute, making the test fail\n- The stack trace shows the failure occurs at the assertion level, not from any exception\n\n## Step 3: Analyzing the Root Cause\n\nThe core issue appears to be in the `Partial.with()` method implementation. The method should:\n\n1. **Validate field compatibility** before attempting to modify the Partial\n2. **Detect incompatible field types** and throw `IllegalArgumentException`\n3. **Maintain object immutability** when validation fails\n\n## Step 4: Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the `Partial.with(DateTimeFieldType fieldType, int value)` method:\n\n**Possible Defect**: The method is not properly validating field type compatibility between `clockhourOfDay` and existing fields (`hourOfDay` and `minuteOfHour`). Specifically:\n\n- The validation logic may be missing or incomplete for detecting that `clockhourOfDay` cannot coexist with `hourOfDay` in the same Partial\n- The method might be attempting to proceed with the modification instead of throwing the expected exception\n- There could be a flaw in the field type compatibility matrix or the validation rules\n\n**Expected Behavior**: When trying to add an incompatible field type, the method should immediately throw `IllegalArgumentException` without modifying the original Partial object.\n\n**Actual Behavior**: The method appears to be proceeding with the operation (or failing silently) instead of throwing the expected exception, causing the test to reach the `fail()` statement.\n\nThe defect likely resides in the field validation logic within the `Partial` class's `with()` method implementation.",
            "test_suite": "org.joda.time.TestPartial_Basics",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it fails to validate field type compatibility before proceeding with the operation. The test expects an IllegalArgumentException when trying to add clockhourOfDay to a Partial that already contains hourOfDay, but the method attempts to insert the new field without checking if it's compatible with existing fields. The validation logic only occurs after creating the new Partial object, which is too late to prevent the invalid operation."
        },
        {
            "method_name": "org.joda.time.Partial::Partial(DateTimeFieldType[],int[],Chronology)",
            "method_code": "```java\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n```",
            "method_doc": " Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. <p> The constructor uses the specified chronology.  @param types  the types to create the partial from, not null @param values  the values to store, not null @param chronology  the chronology, null means ISO @throws IllegalArgumentException if the types or values are invalid ",
            "class_name": "org.joda.time.Partial",
            "class_doc": " Partial is an immutable partial datetime supporting any set of datetime fields. <p> A Partial instance can be used to hold any combination of fields. The instance does not contain a time zone, so any datetime is local. <p> A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}. This method compares each field on this partial with those of the instant and determines if the partial matches the instant. Given this definition, an empty Partial instance represents any datetime and always matches. <p> Calculations on Partial are performed using a {@link Chronology}. This chronology is set to be in the UTC time zone for all calculations. <p> Each individual field can be queried in two ways: <ul> <li><code>get(DateTimeFieldType.monthOfYear())</code> <li><code>property(DateTimeFieldType.monthOfYear()).get()</code> </ul> The second technique also provides access to other useful methods on the field: <ul> <li>numeric value - <code>monthOfYear().get()</code> <li>text value - <code>monthOfYear().getAsText()</code> <li>short text value - <code>monthOfYear().getAsShortText()</code> <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code> <li>add/subtract - <code>monthOfYear().addToCopy()</code> <li>set - <code>monthOfYear().setCopy()</code> </ul> <p> Partial is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.  @since 1.1 ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this test failure systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe test `testWith3` is designed to verify that when attempting to add an incompatible field type (`clockhourOfDay`) to a `Partial` object that already contains `hourOfDay` and `minuteOfHour` fields, the system should:\n\n1. Throw an `IllegalArgumentException`\n2. Leave the original `Partial` object unchanged\n\n## Step 2: Identifying the Failure Pattern\n\nThe test is failing because:\n- The `test.with(DateTimeFieldType.clockhourOfDay(), 6)` call is **not throwing** the expected `IllegalArgumentException`\n- This causes the `fail()` statement to execute, making the test fail\n- The stack trace shows the failure occurs at the assertion level, not from any exception\n\n## Step 3: Analyzing the Root Cause\n\nThe core issue appears to be in the `Partial.with()` method implementation. The method should:\n\n1. **Validate field compatibility** before attempting to modify the Partial\n2. **Detect incompatible field types** and throw `IllegalArgumentException`\n3. **Maintain object immutability** when validation fails\n\n## Step 4: Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the `Partial.with(DateTimeFieldType fieldType, int value)` method:\n\n**Possible Defect**: The method is not properly validating field type compatibility between `clockhourOfDay` and existing fields (`hourOfDay` and `minuteOfHour`). Specifically:\n\n- The validation logic may be missing or incomplete for detecting that `clockhourOfDay` cannot coexist with `hourOfDay` in the same Partial\n- The method might be attempting to proceed with the modification instead of throwing the expected exception\n- There could be a flaw in the field type compatibility matrix or the validation rules\n\n**Expected Behavior**: When trying to add an incompatible field type, the method should immediately throw `IllegalArgumentException` without modifying the original Partial object.\n\n**Actual Behavior**: The method appears to be proceeding with the operation (or failing silently) instead of throwing the expected exception, causing the test to reach the `fail()` statement.\n\nThe defect likely resides in the field validation logic within the `Partial` class's `with()` method implementation.",
            "test_suite": "org.joda.time.TestPartial_Basics",
            "score": 3,
            "reason": "#3# This method is the constructor that validates field ordering and duplicates, but the test failure is related to the with() method's field compatibility validation when adding clockhourOfDay to an existing Partial containing hourOfDay. The constructor validates field ordering and duplicates during creation, but the test failure suggests the issue is in the with() method's logic for detecting incompatible field types during modification operations."
        },
        {
            "method_name": "org.joda.time.Partial::Partial(Chronology,DateTimeFieldType[],int[])",
            "method_code": "```java\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n```",
            "method_doc": " Constructs a Partial with the specified chronology, fields and values. This constructor assigns and performs no validation.  @param chronology  the chronology @param types  the types to create the partial from @param values  the values to store @throws IllegalArgumentException if the types or values are invalid ",
            "class_name": "org.joda.time.Partial",
            "class_doc": " Partial is an immutable partial datetime supporting any set of datetime fields. <p> A Partial instance can be used to hold any combination of fields. The instance does not contain a time zone, so any datetime is local. <p> A Partial can be matched against an instant using {@link #isMatch(ReadableInstant)}. This method compares each field on this partial with those of the instant and determines if the partial matches the instant. Given this definition, an empty Partial instance represents any datetime and always matches. <p> Calculations on Partial are performed using a {@link Chronology}. This chronology is set to be in the UTC time zone for all calculations. <p> Each individual field can be queried in two ways: <ul> <li><code>get(DateTimeFieldType.monthOfYear())</code> <li><code>property(DateTimeFieldType.monthOfYear()).get()</code> </ul> The second technique also provides access to other useful methods on the field: <ul> <li>numeric value - <code>monthOfYear().get()</code> <li>text value - <code>monthOfYear().getAsText()</code> <li>short text value - <code>monthOfYear().getAsShortText()</code> <li>maximum/minimum values - <code>monthOfYear().getMaximumValue()</code> <li>add/subtract - <code>monthOfYear().addToCopy()</code> <li>set - <code>monthOfYear().setCopy()</code> </ul> <p> Partial is thread-safe and immutable, provided that the Chronology is as well. All standard Chronology classes supplied are thread-safe and immutable.  @since 1.1 ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this test failure systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe test `testWith3` is designed to verify that when attempting to add an incompatible field type (`clockhourOfDay`) to a `Partial` object that already contains `hourOfDay` and `minuteOfHour` fields, the system should:\n\n1. Throw an `IllegalArgumentException`\n2. Leave the original `Partial` object unchanged\n\n## Step 2: Identifying the Failure Pattern\n\nThe test is failing because:\n- The `test.with(DateTimeFieldType.clockhourOfDay(), 6)` call is **not throwing** the expected `IllegalArgumentException`\n- This causes the `fail()` statement to execute, making the test fail\n- The stack trace shows the failure occurs at the assertion level, not from any exception\n\n## Step 3: Analyzing the Root Cause\n\nThe core issue appears to be in the `Partial.with()` method implementation. The method should:\n\n1. **Validate field compatibility** before attempting to modify the Partial\n2. **Detect incompatible field types** and throw `IllegalArgumentException`\n3. **Maintain object immutability** when validation fails\n\n## Step 4: Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the `Partial.with(DateTimeFieldType fieldType, int value)` method:\n\n**Possible Defect**: The method is not properly validating field type compatibility between `clockhourOfDay` and existing fields (`hourOfDay` and `minuteOfHour`). Specifically:\n\n- The validation logic may be missing or incomplete for detecting that `clockhourOfDay` cannot coexist with `hourOfDay` in the same Partial\n- The method might be attempting to proceed with the modification instead of throwing the expected exception\n- There could be a flaw in the field type compatibility matrix or the validation rules\n\n**Expected Behavior**: When trying to add an incompatible field type, the method should immediately throw `IllegalArgumentException` without modifying the original Partial object.\n\n**Actual Behavior**: The method appears to be proceeding with the operation (or failing silently) instead of throwing the expected exception, causing the test to reach the `fail()` statement.\n\nThe defect likely resides in the field validation logic within the `Partial` class's `with()` method implementation.",
            "test_suite": "org.joda.time.TestPartial_Basics",
            "score": 2,
            "reason": "#2# This method is a simple constructor that only assigns values without any validation logic. The test failure indicates a validation issue in the with() method when handling incompatible field types, not in this basic constructor that explicitly states it performs no validation."
        }
    ],
    "buggy_codes": {
        "org.joda.time.Partial::Partial(Chronology,DateTimeFieldType[],int[])": {
            "method_name": "org.joda.time.Partial::Partial(Chronology,DateTimeFieldType[],int[])",
            "method_code": "```java\n    Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\n        super();\n        iChronology = chronology;\n        iTypes = types;\n        iValues = values;\n    }\n\n```",
            "method_doc": " Constructs a Partial with the specified chronology, fields and values. This constructor assigns and performs no validation.  @param chronology  the chronology @param types  the types to create the partial from @param values  the values to store @throws IllegalArgumentException if the types or values are invalid "
        },
        "org.joda.time.Partial::with(DateTimeFieldType,int)": {
            "method_name": "org.joda.time.Partial::with(DateTimeFieldType,int)",
            "method_code": "```java\n    public Partial with(DateTimeFieldType TransVarDateType, int TransVarDate) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarDateType == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int TransVarFieldIndex = indexOf(TransVarDateType);\n        if (!(!(TransVarFieldIndex == -1))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            DateTimeFieldType[] TransVarNewTypes_2 = new DateTimeFieldType[iTypes.length + 1];\n            int[] TransVarNewTypes = new int[TransVarNewTypes_2.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int TransVarIndex = 0;\n            DurationField TransVarUnit = TransVarDateType.getDurationType().getField(iChronology);\n            if (!(!(TransVarUnit.isSupported()))) {\n                while (!(!(TransVarIndex < iTypes.length))) {\n                    DateTimeFieldType TransVarLoopType2 = iTypes[TransVarIndex];\n                    DurationField TransVarField = TransVarLoopType2.getDurationType().getField(iChronology);\n                    if (!(!(TransVarField.isSupported()))) {\n                        int TransVarCompare1 = TransVarUnit.compareTo(TransVarField);\n                        if (!(!(TransVarCompare1 > 0))) {\n                            break;\n                        } else if (!(!(TransVarCompare1 == 0))) {\n                            DurationField TransVarRangeDurationField = TransVarDateType.getRangeDurationType()\n                                    .getField(iChronology);\n                            DurationField TransVarLoopRangeField2 = TransVarLoopType2.getRangeDurationType()\n                                    .getField(iChronology);\n                            if (!(!(TransVarRangeDurationField.compareTo(TransVarLoopRangeField2) > 0))) {\n                                break;\n                            }\n                        }\n                    }\n                    TransVarIndex++;\n                }\n            }\n            System.arraycopy(iTypes, 0, TransVarNewTypes_2, 0, TransVarIndex);\n            System.arraycopy(iValues, 0, TransVarNewTypes, 0, TransVarIndex);\n            TransVarNewTypes_2[TransVarIndex] = TransVarDateType;\n            TransVarNewTypes[TransVarIndex] = TransVarDate;\n            System.arraycopy(iTypes, TransVarIndex, TransVarNewTypes_2, TransVarIndex + 1, TransVarNewTypes_2.length - TransVarIndex - 1);\n            System.arraycopy(iValues, TransVarIndex, TransVarNewTypes, TransVarIndex + 1, TransVarNewTypes.length - TransVarIndex - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial TransVarPartial = new Partial(iChronology, TransVarNewTypes_2, TransVarNewTypes);\n            iChronology.validate(TransVarPartial, TransVarNewTypes);\n            return TransVarPartial;\n        }\n        if (!(!(TransVarDate == getValue(TransVarFieldIndex)))) {\n            return this;\n        }\n        int[] TransVarNewValues_2 = getValues();\n        TransVarNewValues_2 = getField(TransVarFieldIndex).set(this, TransVarFieldIndex, TransVarNewValues_2, TransVarDate);\n        return new Partial(this, TransVarNewValues_2);\n    }\n\n```",
            "method_doc": " Gets a copy of this date with the specified field set to a new value. <p> If this partial did not previously support the field, the new one will. Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed/added in the returned instance.  @param fieldType  the field type to set, not null @param value  the value to set @return a copy of this instance with the field set @throws IllegalArgumentException if the value is null or invalid "
        },
        "org.joda.time.Partial::Partial(DateTimeFieldType[],int[],Chronology)": {
            "method_name": "org.joda.time.Partial::Partial(DateTimeFieldType[],int[],Chronology)",
            "method_code": "```java\n    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }\n\n```",
            "method_doc": " Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. <p> The constructor uses the specified chronology.  @param types  the types to create the partial from, not null @param values  the values to store, not null @param chronology  the chronology, null means ISO @throws IllegalArgumentException if the types or values are invalid "
        }
    }
}