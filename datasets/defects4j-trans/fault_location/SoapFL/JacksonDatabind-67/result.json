{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::withResolved(KeyDeserializer,JsonDeserializer,TypeDeserializer)",
            "method_code": "```java\n    public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n    {\n        if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n            return this;\n        }\n        return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n    }\n\n```",
            "method_doc": "Creates a new deserializer instance if any of the key deserializer, value deserializer, or type deserializer parameters differ from current ones, otherwise returns current instance.",
            "class_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer",
            "class_doc": " Deserializer for {@link EnumMap} values. <p> Note: casting within this class is all messed up -- just could not figure out a way to properly deal with recursive definition of \"EnumMap&lt;K extends Enum&lt;K>, V> ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my assessment:\n\n## Common Patterns and Similarities\n\n1. **Enum Key Deserialization Failure**: The test fails specifically when deserializing enum keys in an EnumMap context\n2. **Case Sensitivity Issue**: The failure occurs with mixed-case input \"REPlaceMENTS\" that should be converted to lowercase\n3. **Custom Deserializer Bypass**: The stack trace shows `StdKeyDeserializer.deserializeKey` is being called instead of the custom key deserializer\n\n## Key Observations from Stack Trace\n\nThe stack trace indicates:\n- `StdKeyDeserializer.deserializeKey` is handling the key deserialization\n- The error occurs because \"REPlaceMENTS\" doesn't match any enum constant names\n- The custom `KeyDeserializer` from `modifyKeyDeserializer` is not being invoked for enum map keys\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in how Jackson's deserialization framework handles **enum key deserialization in EnumMap contexts**. Specifically, there may be a bug where:\n\n**The custom `KeyDeserializer` returned by `BeanDeserializerModifier.modifyKeyDeserializer()` is not being properly applied when deserializing enum keys for `EnumMap` objects.**\n\nThe production code likely has an issue in the enum map deserialization path where it fails to retrieve or use the custom key deserializer configured via the module system, instead falling back to the standard enum key deserialization logic that doesn't apply the custom case conversion.\n\nThis would explain why:\n- Regular enum value deserialization works (uses the custom JsonDeserializer)\n- Enum key deserialization fails (bypasses the custom KeyDeserializer)\n- The error shows standard deserialization logic being used instead of the custom one\n\nThe defect is likely in the interaction between `EnumMapDeserializer` and the key deserializer resolution mechanism when custom modifiers are involved.",
            "test_suite": "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it's responsible for creating new EnumMapDeserializer instances with resolved deserializers. The test failure shows that the custom KeyDeserializer from the BeanDeserializerModifier is not being used during enum map key deserialization, suggesting that the keyDeserializer parameter passed to this method may not be properly resolved to include the custom deserializer logic. The method's current implementation simply passes the keyDeserializer to the new instance without any validation or resolution logic, which could be causing the custom key deserializer to be bypassed in favor of the default StdKeyDeserializer."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::createContextual(DeserializationContext,BeanProperty)",
            "method_code": "```java\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n    {\n        // note: instead of finding key deserializer, with enums we actually\n        // work with regular deserializers (less code duplication; but not\n        // quite as clean as it ought to be)\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        final JavaType vt = _mapType.getContentType();\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            vd = ctxt.handleSecondaryContextualization(vd, property, vt);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        return withResolved(kd, vd, vtd);\n    }\n\n```",
            "method_doc": " Method called to finalize setup of this deserializer, when it is known for which property deserializer is needed for. ",
            "class_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer",
            "class_doc": " Deserializer for {@link EnumMap} values. <p> Note: casting within this class is all messed up -- just could not figure out a way to properly deal with recursive definition of \"EnumMap&lt;K extends Enum&lt;K>, V> ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my assessment:\n\n## Common Patterns and Similarities\n\n1. **Enum Key Deserialization Failure**: The test fails specifically when deserializing enum keys in an EnumMap context\n2. **Case Sensitivity Issue**: The failure occurs with mixed-case input \"REPlaceMENTS\" that should be converted to lowercase\n3. **Custom Deserializer Bypass**: The stack trace shows `StdKeyDeserializer.deserializeKey` is being called instead of the custom key deserializer\n\n## Key Observations from Stack Trace\n\nThe stack trace indicates:\n- `StdKeyDeserializer.deserializeKey` is handling the key deserialization\n- The error occurs because \"REPlaceMENTS\" doesn't match any enum constant names\n- The custom `KeyDeserializer` from `modifyKeyDeserializer` is not being invoked for enum map keys\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in how Jackson's deserialization framework handles **enum key deserialization in EnumMap contexts**. Specifically, there may be a bug where:\n\n**The custom `KeyDeserializer` returned by `BeanDeserializerModifier.modifyKeyDeserializer()` is not being properly applied when deserializing enum keys for `EnumMap` objects.**\n\nThe production code likely has an issue in the enum map deserialization path where it fails to retrieve or use the custom key deserializer configured via the module system, instead falling back to the standard enum key deserialization logic that doesn't apply the custom case conversion.\n\nThis would explain why:\n- Regular enum value deserialization works (uses the custom JsonDeserializer)\n- Enum key deserialization fails (bypasses the custom KeyDeserializer)\n- The error shows standard deserialization logic being used instead of the custom one\n\nThe defect is likely in the interaction between `EnumMapDeserializer` and the key deserializer resolution mechanism when custom modifiers are involved.",
            "test_suite": "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it's responsible for resolving the key deserializer for EnumMap deserialization. The issue occurs when the method fails to properly retrieve the custom KeyDeserializer configured via BeanDeserializerModifier.modifyKeyDeserializer() for enum keys. Specifically, when _keyDeserializer is null, it calls ctxt.findKeyDeserializer() but this appears to bypass the custom key deserializer logic for enum map keys, causing the system to fall back to StdKeyDeserializer which doesn't apply the custom case conversion logic."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::deserialize(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @Override\n    public EnumMap<?,?> deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // Ok: must point to START_OBJECT\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            return _deserializeFromEmpty(p, ctxt);\n        }\n        EnumMap result = constructMap();\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        while ((p.nextToken()) == JsonToken.FIELD_NAME) {\n            String keyName = p.getCurrentName(); // just for error message\n            // but we need to let key deserializer handle it separately, nonetheless\n            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);\n            if (key == null) {\n                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                    return (EnumMap<?,?>) ctxt.handleWeirdStringValue(_enumClass, keyName,\n                            \"value not one of declared Enum instance names for %s\",\n                            _mapType.getKeyType());\n                }\n                /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n                 *  just skip the entry then. But we must skip the value as well, if so.\n                 */\n                p.nextToken();\n                p.skipChildren();\n                continue;\n            }\n            // And then the value...\n            JsonToken t = p.nextToken();\n            /* note: MUST check for nulls separately: deserializers will\n             * not handle them (and maybe fail or return bogus data)\n             */\n            Object value;\n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue(ctxt);\n                } else if (typeDeser == null) {\n                    value =  valueDes.deserialize(p, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, result, keyName);\n                return null;\n            }\n            result.put(key, value);\n        }\n        return result;\n    }\n\n```",
            "method_doc": "  Actual deserialization  ",
            "class_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer",
            "class_doc": " Deserializer for {@link EnumMap} values. <p> Note: casting within this class is all messed up -- just could not figure out a way to properly deal with recursive definition of \"EnumMap&lt;K extends Enum&lt;K>, V> ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my assessment:\n\n## Common Patterns and Similarities\n\n1. **Enum Key Deserialization Failure**: The test fails specifically when deserializing enum keys in an EnumMap context\n2. **Case Sensitivity Issue**: The failure occurs with mixed-case input \"REPlaceMENTS\" that should be converted to lowercase\n3. **Custom Deserializer Bypass**: The stack trace shows `StdKeyDeserializer.deserializeKey` is being called instead of the custom key deserializer\n\n## Key Observations from Stack Trace\n\nThe stack trace indicates:\n- `StdKeyDeserializer.deserializeKey` is handling the key deserialization\n- The error occurs because \"REPlaceMENTS\" doesn't match any enum constant names\n- The custom `KeyDeserializer` from `modifyKeyDeserializer` is not being invoked for enum map keys\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in how Jackson's deserialization framework handles **enum key deserialization in EnumMap contexts**. Specifically, there may be a bug where:\n\n**The custom `KeyDeserializer` returned by `BeanDeserializerModifier.modifyKeyDeserializer()` is not being properly applied when deserializing enum keys for `EnumMap` objects.**\n\nThe production code likely has an issue in the enum map deserialization path where it fails to retrieve or use the custom key deserializer configured via the module system, instead falling back to the standard enum key deserialization logic that doesn't apply the custom case conversion.\n\nThis would explain why:\n- Regular enum value deserialization works (uses the custom JsonDeserializer)\n- Enum key deserialization fails (bypasses the custom KeyDeserializer)\n- The error shows standard deserialization logic being used instead of the custom one\n\nThe defect is likely in the interaction between `EnumMapDeserializer` and the key deserializer resolution mechanism when custom modifiers are involved.",
            "test_suite": "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because the stack trace shows the failure occurs at line 139 in EnumMapDeserializer.deserialize, and the code shows it's using _keyDeserializer.deserializeKey() which should be the custom key deserializer but appears to be falling back to standard deserialization. The issue is that the custom key deserializer configured via BeanDeserializerModifier is not being properly utilized for enum map key deserialization, causing case conversion to be bypassed."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::withResolved(KeyDeserializer,JsonDeserializer,TypeDeserializer)": {
            "method_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::withResolved(KeyDeserializer,JsonDeserializer,TypeDeserializer)",
            "method_code": "```java\n    public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n    {\n        if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n            return this;\n        }\n        return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n    }\n\n```",
            "method_doc": "Creates a new deserializer instance if any of the key deserializer, value deserializer, or type deserializer parameters differ from current ones, otherwise returns current instance."
        },
        "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::createContextual(DeserializationContext,BeanProperty)": {
            "method_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::createContextual(DeserializationContext,BeanProperty)",
            "method_code": "```java\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n    {\n        // note: instead of finding key deserializer, with enums we actually\n        // work with regular deserializers (less code duplication; but not\n        // quite as clean as it ought to be)\n        KeyDeserializer kd = _keyDeserializer;\n        if (kd == null) {\n            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n        }\n        JsonDeserializer<?> vd = _valueDeserializer;\n        final JavaType vt = _mapType.getContentType();\n        if (vd == null) {\n            vd = ctxt.findContextualValueDeserializer(vt, property);\n        } else { // if directly assigned, probably not yet contextual, so:\n            vd = ctxt.handleSecondaryContextualization(vd, property, vt);\n        }\n        TypeDeserializer vtd = _valueTypeDeserializer;\n        if (vtd != null) {\n            vtd = vtd.forProperty(property);\n        }\n        return withResolved(kd, vd, vtd);\n    }\n\n```",
            "method_doc": " Method called to finalize setup of this deserializer, when it is known for which property deserializer is needed for. "
        },
        "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::deserialize(JsonParser,DeserializationContext)": {
            "method_name": "com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer::deserialize(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @Override\n    public EnumMap<?,?> deserialize(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        // Ok: must point to START_OBJECT\n        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n            return _deserializeFromEmpty(p, ctxt);\n        }\n        EnumMap result = constructMap();\n        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n\n        while ((p.nextToken()) == JsonToken.FIELD_NAME) {\n            String keyName = p.getCurrentName(); // just for error message\n            // but we need to let key deserializer handle it separately, nonetheless\n            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);\n            if (key == null) {\n                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                    return (EnumMap<?,?>) ctxt.handleWeirdStringValue(_enumClass, keyName,\n                            \"value not one of declared Enum instance names for %s\",\n                            _mapType.getKeyType());\n                }\n                /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n                 *  just skip the entry then. But we must skip the value as well, if so.\n                 */\n                p.nextToken();\n                p.skipChildren();\n                continue;\n            }\n            // And then the value...\n            JsonToken t = p.nextToken();\n            /* note: MUST check for nulls separately: deserializers will\n             * not handle them (and maybe fail or return bogus data)\n             */\n            Object value;\n\n            try {\n                if (t == JsonToken.VALUE_NULL) {\n                    value = valueDes.getNullValue(ctxt);\n                } else if (typeDeser == null) {\n                    value =  valueDes.deserialize(p, ctxt);\n                } else {\n                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                }\n            } catch (Exception e) {\n                wrapAndThrow(e, result, keyName);\n                return null;\n            }\n            result.put(key, value);\n        }\n        return result;\n    }\n\n```",
            "method_doc": "  Actual deserialization  "
        }
    }
}