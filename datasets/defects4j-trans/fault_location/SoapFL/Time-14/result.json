{
    "buggy_classes": [
        "org.joda.time.chrono.BasicMonthOfYearDateTimeField"
    ],
    "buggy_methods": [
        {
            "method_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField::add(ReadablePartial,int,int[],int)",
            "method_code": "```java\n    public int[] add(ReadablePartial TransVarPartialLocal, int TransVarField, int[] TransVarValue, int TransVarValueToWrite) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (!(!(TransVarValueToWrite == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            return TransVarValue;\n        }\n            // month is largest field and being added to, such as month-day\n        if (!(!(DateTimeUtils.isContiguous(TransVarPartialLocal)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            long TransVarInstantToWrite = 0L;\n            int TransVarJ = 0, TransVarCount = TransVarPartialLocal.size();\n            while (!(!(TransVarJ < TransVarCount))) {\n                TransVarInstantToWrite = TransVarPartialLocal.getFieldType(TransVarJ).getField(iChronology)\n                        .set(TransVarInstantToWrite, TransVarValue[TransVarJ]);\n                TransVarJ++;\n            }\n            TransVarInstantToWrite = add(TransVarInstantToWrite, TransVarValueToWrite);\n            return iChronology.get(TransVarPartialLocal, TransVarInstantToWrite);\n        } else {\n            return super.add(TransVarPartialLocal, TransVarField, TransVarValue, TransVarValueToWrite);\n        }\n    }\n\n```",
            "method_doc": "-----------------------------------------------------------------------",
            "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
            "class_doc": " Provides time calculations for the month of the year component of time.  @since 1.2, refactored from GJMonthOfYearDateTimeField ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All failures involve leap day (February 29th) scenarios** or **end-of-month date adjustments**\n\n2. **Two types of failures occur**:\n   - **Assertion failures**: Where the actual result doesn't match expected date values\n   - **IllegalFieldValueException**: Where the code attempts to set invalid day values (like day 29 in months with only 28 days)\n\n3. **The operations involved are**:\n   - Month arithmetic (`plusMonths`, `minusMonths`)\n   - Day arithmetic (`minusDays` with negative values)\n   - All operations transition between months with different day counts\n\n4. **Stack traces consistently point to the same call chain**:\n   `MonthDay.withFieldAdded()` \u2192 `BasicMonthOfYearDateTimeField.add()` \u2192 `PreciseDurationDateTimeField.set()` \u2192 `FieldUtils.verifyValueBounds()`\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **date adjustment logic within `BasicMonthOfYearDateTimeField.add()` method** (specifically around line 223). The issue is that when performing month arithmetic operations on `MonthDay` instances:\n\n**The code is not properly handling day-of-month validation and adjustment when moving between months with different numbers of days, particularly when dealing with leap days (February 29th).**\n\n**Specific problems:**\n1. When subtracting months from February 29th, the code doesn't validate if the target month (January) can accommodate day 29\n2. When adding months from February 29th, the code doesn't validate if the target month (March) can accommodate day 29\n3. The end-of-month adjustment logic for cases like March 31st \u2192 February is not working correctly for leap years\n4. The day validation occurs too late in the process, after invalid day values have been set\n\nThe core issue is likely in how the month arithmetic operations handle **day normalization** when the resulting day exceeds the maximum days in the target month. The production code should automatically adjust invalid days to the last valid day of the target month, but this adjustment logic is either missing or broken for leap year scenarios.\n\nThis single defect in the month/day adjustment logic explains why all five tests are failing with similar patterns around leap day handling and month transitions.",
            "test_suite": "org.joda.time.TestMonthDay_Basics",
            "score": 10,
            "reason": "#10# This method is highly suspicious and likely the best location to fix because it contains the core month arithmetic logic that handles leap day scenarios and month transitions. The method specifically mentions handling \"2004-02-29 + 48 months -> 2008-02-29 type dates\" in its comments, indicating it's designed to handle leap day cases, yet all test failures involve exactly these scenarios. The stack traces consistently show the failures occur within this method's add operation, and the method contains complex date adjustment logic that appears to be failing to properly validate and normalize day values when moving between months with different day counts, particularly for February 29th transitions."
        },
        {
            "method_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField::add(long,int)",
            "method_code": "```java\n    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n```",
            "method_doc": " Add the specified month to the specified time instant. The amount added may be negative.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 - (1 month) = 06-30<p> 03-31 - (1 month) = 02-28 or 02-29 depending<p>  @see org.joda.time.DateTimeField#add @see org.joda.time.ReadWritableDateTime#addMonths(int) @param instant  the time instant in millis to update. @param months  the months to add (can be negative). @return the updated time instant. ",
            "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
            "class_doc": " Provides time calculations for the month of the year component of time.  @since 1.2, refactored from GJMonthOfYearDateTimeField ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All failures involve leap day (February 29th) scenarios** or **end-of-month date adjustments**\n\n2. **Two types of failures occur**:\n   - **Assertion failures**: Where the actual result doesn't match expected date values\n   - **IllegalFieldValueException**: Where the code attempts to set invalid day values (like day 29 in months with only 28 days)\n\n3. **The operations involved are**:\n   - Month arithmetic (`plusMonths`, `minusMonths`)\n   - Day arithmetic (`minusDays` with negative values)\n   - All operations transition between months with different day counts\n\n4. **Stack traces consistently point to the same call chain**:\n   `MonthDay.withFieldAdded()` \u2192 `BasicMonthOfYearDateTimeField.add()` \u2192 `PreciseDurationDateTimeField.set()` \u2192 `FieldUtils.verifyValueBounds()`\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **date adjustment logic within `BasicMonthOfYearDateTimeField.add()` method** (specifically around line 223). The issue is that when performing month arithmetic operations on `MonthDay` instances:\n\n**The code is not properly handling day-of-month validation and adjustment when moving between months with different numbers of days, particularly when dealing with leap days (February 29th).**\n\n**Specific problems:**\n1. When subtracting months from February 29th, the code doesn't validate if the target month (January) can accommodate day 29\n2. When adding months from February 29th, the code doesn't validate if the target month (March) can accommodate day 29\n3. The end-of-month adjustment logic for cases like March 31st \u2192 February is not working correctly for leap years\n4. The day validation occurs too late in the process, after invalid day values have been set\n\nThe core issue is likely in how the month arithmetic operations handle **day normalization** when the resulting day exceeds the maximum days in the target month. The production code should automatically adjust invalid days to the last valid day of the target month, but this adjustment logic is either missing or broken for leap year scenarios.\n\nThis single defect in the month/day adjustment logic explains why all five tests are failing with similar patterns around leap day handling and month transitions.",
            "test_suite": "org.joda.time.TestMonthDay_Basics",
            "score": 10,
            "reason": "#10# This method is highly suspicious and likely the best location to fix because it contains the core logic for month arithmetic operations that are failing in all test cases. The method handles day-of-month adjustment when moving between months, but the current implementation at lines 223-227 only adjusts the day if it exceeds the maximum days in the target month, without properly handling leap year scenarios and February 29th transitions. The stack traces consistently show failures occurring in this method's add operation, and the comment specifically mentions handling cases like \"03-31 - (1 month) = 02-28 or 02-29 depending\" which aligns exactly with the failing test scenarios involving leap day adjustments."
        },
        {
            "method_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField::set(long,int)",
            "method_code": "```java\n    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }\n\n```",
            "method_doc": " Set the Month component of the specified time instant.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 to month 6 = 06-30<p> 03-31 to month 2 = 02-28 or 02-29 depending<p>  @param instant  the time instant in millis to update. @param month  the month (1,12) to update the time to. @return the updated time instant. @throws IllegalArgumentException  if month is invalid ",
            "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
            "class_doc": " Provides time calculations for the month of the year component of time.  @since 1.2, refactored from GJMonthOfYearDateTimeField ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All failures involve leap day (February 29th) scenarios** or **end-of-month date adjustments**\n\n2. **Two types of failures occur**:\n   - **Assertion failures**: Where the actual result doesn't match expected date values\n   - **IllegalFieldValueException**: Where the code attempts to set invalid day values (like day 29 in months with only 28 days)\n\n3. **The operations involved are**:\n   - Month arithmetic (`plusMonths`, `minusMonths`)\n   - Day arithmetic (`minusDays` with negative values)\n   - All operations transition between months with different day counts\n\n4. **Stack traces consistently point to the same call chain**:\n   `MonthDay.withFieldAdded()` \u2192 `BasicMonthOfYearDateTimeField.add()` \u2192 `PreciseDurationDateTimeField.set()` \u2192 `FieldUtils.verifyValueBounds()`\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **date adjustment logic within `BasicMonthOfYearDateTimeField.add()` method** (specifically around line 223). The issue is that when performing month arithmetic operations on `MonthDay` instances:\n\n**The code is not properly handling day-of-month validation and adjustment when moving between months with different numbers of days, particularly when dealing with leap days (February 29th).**\n\n**Specific problems:**\n1. When subtracting months from February 29th, the code doesn't validate if the target month (January) can accommodate day 29\n2. When adding months from February 29th, the code doesn't validate if the target month (March) can accommodate day 29\n3. The end-of-month adjustment logic for cases like March 31st \u2192 February is not working correctly for leap years\n4. The day validation occurs too late in the process, after invalid day values have been set\n\nThe core issue is likely in how the month arithmetic operations handle **day normalization** when the resulting day exceeds the maximum days in the target month. The production code should automatically adjust invalid days to the last valid day of the target month, but this adjustment logic is either missing or broken for leap year scenarios.\n\nThis single defect in the month/day adjustment logic explains why all five tests are failing with similar patterns around leap day handling and month transitions.",
            "test_suite": "org.joda.time.TestMonthDay_Basics",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it contains the core logic for handling day-of-month adjustments when setting month values, which directly relates to all the test failures involving leap day scenarios and month transitions. The method attempts to adjust days that exceed the maximum days in the target month, but the logic appears flawed when dealing with February 29th transitions to/from other months, causing either incorrect day adjustments or illegal field value exceptions."
        }
    ],
    "buggy_codes": {
        "org.joda.time.chrono.BasicMonthOfYearDateTimeField::add(ReadablePartial,int,int[],int)": {
            "method_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField::add(ReadablePartial,int,int[],int)",
            "method_code": "```java\n    public int[] add(ReadablePartial TransVarPartialLocal, int TransVarField, int[] TransVarValue, int TransVarValueToWrite) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (!(!(TransVarValueToWrite == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            return TransVarValue;\n        }\n            // month is largest field and being added to, such as month-day\n        if (!(!(DateTimeUtils.isContiguous(TransVarPartialLocal)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            long TransVarInstantToWrite = 0L;\n            int TransVarJ = 0, TransVarCount = TransVarPartialLocal.size();\n            while (!(!(TransVarJ < TransVarCount))) {\n                TransVarInstantToWrite = TransVarPartialLocal.getFieldType(TransVarJ).getField(iChronology)\n                        .set(TransVarInstantToWrite, TransVarValue[TransVarJ]);\n                TransVarJ++;\n            }\n            TransVarInstantToWrite = add(TransVarInstantToWrite, TransVarValueToWrite);\n            return iChronology.get(TransVarPartialLocal, TransVarInstantToWrite);\n        } else {\n            return super.add(TransVarPartialLocal, TransVarField, TransVarValue, TransVarValueToWrite);\n        }\n    }\n\n```",
            "method_doc": "-----------------------------------------------------------------------"
        },
        "org.joda.time.chrono.BasicMonthOfYearDateTimeField::set(long,int)": {
            "method_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField::set(long,int)",
            "method_code": "```java\n    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }\n\n```",
            "method_doc": " Set the Month component of the specified time instant.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 to month 6 = 06-30<p> 03-31 to month 2 = 02-28 or 02-29 depending<p>  @param instant  the time instant in millis to update. @param month  the month (1,12) to update the time to. @return the updated time instant. @throws IllegalArgumentException  if month is invalid "
        },
        "org.joda.time.chrono.BasicMonthOfYearDateTimeField::add(long,int)": {
            "method_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField::add(long,int)",
            "method_code": "```java\n    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }\n\n```",
            "method_doc": " Add the specified month to the specified time instant. The amount added may be negative.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 - (1 month) = 06-30<p> 03-31 - (1 month) = 02-28 or 02-29 depending<p>  @see org.joda.time.DateTimeField#add @see org.joda.time.ReadWritableDateTime#addMonths(int) @param instant  the time instant in millis to update. @param months  the months to add (can be negative). @return the updated time instant. "
        }
    }
}