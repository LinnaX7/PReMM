{
    "buggy_classes": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::applyPaxHeadersToCurrentEntry(Map)",
            "method_code": "```java\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> TransVarHeaders1) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n        for (Entry<String, String> TransVarHeaders : TransVarHeaders1.entrySet()){\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarHeaderKey = TransVarHeaders.getKey();\n            String TransVarValue = TransVarHeaders.getValue();\n            if (!(!(\"path\".equals(TransVarHeaderKey)))){\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                currEntry.setName(TransVarValue);\n            } else if (!(!(\"linkpath\".equals(TransVarHeaderKey)))){\n                currEntry.setLinkName(TransVarValue);\n            } else if (!(!(\"gid\".equals(TransVarHeaderKey)))){\n                currEntry.setGroupId(Integer.parseInt(TransVarValue));\n            } else if (!(!(\"gname\".equals(TransVarHeaderKey)))){\n                currEntry.setGroupName(TransVarValue);\n            } else if (!(!(\"uid\".equals(TransVarHeaderKey)))){\n                currEntry.setUserId(Integer.parseInt(TransVarValue));\n            } else if (!(!(\"uname\".equals(TransVarHeaderKey)))){\n                currEntry.setUserName(TransVarValue);\n            } else if (!(!(\"size\".equals(TransVarHeaderKey)))){\n                currEntry.setSize(Long.parseLong(TransVarValue));\n            } else if (!(!(\"mtime\".equals(TransVarHeaderKey)))){\n                currEntry.setModTime((long) (Double.parseDouble(TransVarValue) * 1000));\n            } else if (!(!(\"SCHILY.devminor\".equals(TransVarHeaderKey)))){\n                currEntry.setDevMinor(Integer.parseInt(TransVarValue));\n            } else if (!(!(\"SCHILY.devmajor\".equals(TransVarHeaderKey)))){\n                currEntry.setDevMajor(Integer.parseInt(TransVarValue));\n            }\n        }\n    }\n\n```",
            "method_doc": "Applies Pax header values to current tar entry fields.",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**Step 1: Understanding the Test Scenario**\n- The test creates a TAR entry with a very large group ID (4294967294L) using POSIX big number mode\n- This value exceeds the traditional TAR format limits for numeric fields\n- The test verifies that the large GID can be correctly written and read back\n\n**Step 2: Examining the Stack Trace**\nThe stack trace reveals:\n- `NumberFormatException` occurs at `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` line 510\n- The error happens when trying to parse the string \"4294967294\" as an integer\n- This occurs during `getNextTarEntry()` when reading the TAR entry\n\n**Step 3: Identifying the Root Cause Pattern**\nThe common pattern is:\n1. Large numeric values (GID = 4294967294L) are written successfully using POSIX big number mode\n2. During reading, the system attempts to parse these large values from extended headers\n3. The parsing fails because it's using `Integer.parseInt()` for values that exceed Integer.MAX_VALUE (2147483647)\n\n## Recommended Production Code Defect\n\nThe defect is in `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` method around line 510, where the code is incorrectly using `Integer.parseInt()` to parse large numeric values from PAX headers that were specifically designed to handle values beyond 32-bit integer limits.\n\n**Specific Issue:**\nWhen processing PAX extended headers for large numeric fields (like group IDs), the code should use `Long.parseLong()` instead of `Integer.parseInt()` because:\n- The POSIX big number mode is specifically designed to handle 64-bit values\n- The test sets a GID of 4294967294L which exceeds Integer.MAX_VALUE\n- Using `Integer.parseInt()` for such values will always throw NumberFormatException\n\n**Expected Fix:**\nThe production code should be modified to properly handle large numeric values in PAX headers by using appropriate parsing methods (`Long.parseLong()`) for fields that can contain values beyond 32-bit integer range when POSIX big number mode is used.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 10,
            "reason": "#10# This method is definitely the best location to be fixed because the NumberFormatException occurs specifically at line 510 where Integer.parseInt() is used to parse \"4294967294\" for the \"gid\" field, but this value exceeds Integer.MAX_VALUE (2147483647). The method should use Long.parseLong() instead for numeric fields like gid, uid, devminor, and devmajor that can contain large values when POSIX big number mode is enabled."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::paxHeaders()",
            "method_code": "```java\n    private void paxHeaders() throws IOException{\n        Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n```",
            "method_doc": "Processes Pax headers for current entry. This method calls methods \"parsePaxHeaders\", \"getNextEntry\", and \"applyPaxHeadersToCurrentEntry\".",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**Step 1: Understanding the Test Scenario**\n- The test creates a TAR entry with a very large group ID (4294967294L) using POSIX big number mode\n- This value exceeds the traditional TAR format limits for numeric fields\n- The test verifies that the large GID can be correctly written and read back\n\n**Step 2: Examining the Stack Trace**\nThe stack trace reveals:\n- `NumberFormatException` occurs at `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` line 510\n- The error happens when trying to parse the string \"4294967294\" as an integer\n- This occurs during `getNextTarEntry()` when reading the TAR entry\n\n**Step 3: Identifying the Root Cause Pattern**\nThe common pattern is:\n1. Large numeric values (GID = 4294967294L) are written successfully using POSIX big number mode\n2. During reading, the system attempts to parse these large values from extended headers\n3. The parsing fails because it's using `Integer.parseInt()` for values that exceed Integer.MAX_VALUE (2147483647)\n\n## Recommended Production Code Defect\n\nThe defect is in `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` method around line 510, where the code is incorrectly using `Integer.parseInt()` to parse large numeric values from PAX headers that were specifically designed to handle values beyond 32-bit integer limits.\n\n**Specific Issue:**\nWhen processing PAX extended headers for large numeric fields (like group IDs), the code should use `Long.parseLong()` instead of `Integer.parseInt()` because:\n- The POSIX big number mode is specifically designed to handle 64-bit values\n- The test sets a GID of 4294967294L which exceeds Integer.MAX_VALUE\n- Using `Integer.parseInt()` for such values will always throw NumberFormatException\n\n**Expected Fix:**\nThe production code should be modified to properly handle large numeric values in PAX headers by using appropriate parsing methods (`Long.parseLong()`) for fields that can contain values beyond 32-bit integer range when POSIX big number mode is used.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 8,
            "reason": "#8# The paxHeaders() method is highly suspicious because it orchestrates the PAX header processing flow where the actual parsing error occurs. While the NumberFormatException happens in applyPaxHeadersToCurrentEntry(), paxHeaders() is the entry point that calls this problematic method and manages the PAX header processing sequence. The test failure specifically involves large numeric values in PAX headers, and paxHeaders() is responsible for the complete PAX header handling workflow, making it the appropriate location to coordinate the fix for large number parsing issues."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getNextTarEntry()",
            "method_code": "```java\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            /* Skip will only go to the end of the current entry */\n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            /* skip to the end of the last record */\n            skipRecordPadding();\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            /* hit EOF */\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long link entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n\n```",
            "method_doc": " Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.  @return The next TarEntry in the archive, or null. @throws IOException on error ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**Step 1: Understanding the Test Scenario**\n- The test creates a TAR entry with a very large group ID (4294967294L) using POSIX big number mode\n- This value exceeds the traditional TAR format limits for numeric fields\n- The test verifies that the large GID can be correctly written and read back\n\n**Step 2: Examining the Stack Trace**\nThe stack trace reveals:\n- `NumberFormatException` occurs at `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` line 510\n- The error happens when trying to parse the string \"4294967294\" as an integer\n- This occurs during `getNextTarEntry()` when reading the TAR entry\n\n**Step 3: Identifying the Root Cause Pattern**\nThe common pattern is:\n1. Large numeric values (GID = 4294967294L) are written successfully using POSIX big number mode\n2. During reading, the system attempts to parse these large values from extended headers\n3. The parsing fails because it's using `Integer.parseInt()` for values that exceed Integer.MAX_VALUE (2147483647)\n\n## Recommended Production Code Defect\n\nThe defect is in `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` method around line 510, where the code is incorrectly using `Integer.parseInt()` to parse large numeric values from PAX headers that were specifically designed to handle values beyond 32-bit integer limits.\n\n**Specific Issue:**\nWhen processing PAX extended headers for large numeric fields (like group IDs), the code should use `Long.parseLong()` instead of `Integer.parseInt()` because:\n- The POSIX big number mode is specifically designed to handle 64-bit values\n- The test sets a GID of 4294967294L which exceeds Integer.MAX_VALUE\n- Using `Integer.parseInt()` for such values will always throw NumberFormatException\n\n**Expected Fix:**\nThe production code should be modified to properly handle large numeric values in PAX headers by using appropriate parsing methods (`Long.parseLong()`) for fields that can contain values beyond 32-bit integer range when POSIX big number mode is used.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 3,
            "reason": "#3# While the getNextTarEntry() method is involved in the call chain, the actual NumberFormatException occurs in the applyPaxHeadersToCurrentEntry() method at line 510, which is called from paxHeaders() within getNextTarEntry(). The root cause is in the parsing logic of PAX headers, not in the main entry retrieval flow of getNextTarEntry()."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::parsePaxHeaders(InputStream)",
            "method_code": "```java\n    Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){ // End of length string\n                    // Get keyword\n                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            byte[] rest = new byte[restLen];\n                            int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + restLen\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(rest, 0,\n                                                      restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }\n\n```",
            "method_doc": "Parses Pax headers from input stream into key-value map. This method calls method \"readFully\" to read header data.",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**Step 1: Understanding the Test Scenario**\n- The test creates a TAR entry with a very large group ID (4294967294L) using POSIX big number mode\n- This value exceeds the traditional TAR format limits for numeric fields\n- The test verifies that the large GID can be correctly written and read back\n\n**Step 2: Examining the Stack Trace**\nThe stack trace reveals:\n- `NumberFormatException` occurs at `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` line 510\n- The error happens when trying to parse the string \"4294967294\" as an integer\n- This occurs during `getNextTarEntry()` when reading the TAR entry\n\n**Step 3: Identifying the Root Cause Pattern**\nThe common pattern is:\n1. Large numeric values (GID = 4294967294L) are written successfully using POSIX big number mode\n2. During reading, the system attempts to parse these large values from extended headers\n3. The parsing fails because it's using `Integer.parseInt()` for values that exceed Integer.MAX_VALUE (2147483647)\n\n## Recommended Production Code Defect\n\nThe defect is in `TarArchiveInputStream.applyPaxHeadersToCurrentEntry()` method around line 510, where the code is incorrectly using `Integer.parseInt()` to parse large numeric values from PAX headers that were specifically designed to handle values beyond 32-bit integer limits.\n\n**Specific Issue:**\nWhen processing PAX extended headers for large numeric fields (like group IDs), the code should use `Long.parseLong()` instead of `Integer.parseInt()` because:\n- The POSIX big number mode is specifically designed to handle 64-bit values\n- The test sets a GID of 4294967294L which exceeds Integer.MAX_VALUE\n- Using `Integer.parseInt()` for such values will always throw NumberFormatException\n\n**Expected Fix:**\nThe production code should be modified to properly handle large numeric values in PAX headers by using appropriate parsing methods (`Long.parseLong()`) for fields that can contain values beyond 32-bit integer range when POSIX big number mode is used.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 3,
            "reason": "#3# The parsePaxHeaders method correctly reads and stores the header values as strings, but the actual parsing error occurs in applyPaxHeadersToCurrentEntry method where Integer.parseInt is used for large numeric values. The parsePaxHeaders method itself doesn't contain the problematic parsing logic."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getNextTarEntry()": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getNextTarEntry()",
            "method_code": "```java\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            /* Skip will only go to the end of the current entry */\n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            /* skip to the end of the last record */\n            skipRecordPadding();\n        }\n\n        byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            /* hit EOF */\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (IllegalArgumentException e) {\n            IOException ioe = new IOException(\"Error detected parsing the header\");\n            ioe.initCause(e);\n            throw ioe;\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long link entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        }\n\n        if (currEntry.isGNUSparse()){ // Process sparse files\n            readGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n\n```",
            "method_doc": " Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.  @return The next TarEntry in the archive, or null. @throws IOException on error "
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::applyPaxHeadersToCurrentEntry(Map)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::applyPaxHeadersToCurrentEntry(Map)",
            "method_code": "```java\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> TransVarHeaders1) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n        for (Entry<String, String> TransVarHeaders : TransVarHeaders1.entrySet()){\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarHeaderKey = TransVarHeaders.getKey();\n            String TransVarValue = TransVarHeaders.getValue();\n            if (!(!(\"path\".equals(TransVarHeaderKey)))){\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                currEntry.setName(TransVarValue);\n            } else if (!(!(\"linkpath\".equals(TransVarHeaderKey)))){\n                currEntry.setLinkName(TransVarValue);\n            } else if (!(!(\"gid\".equals(TransVarHeaderKey)))){\n                currEntry.setGroupId(Integer.parseInt(TransVarValue));\n            } else if (!(!(\"gname\".equals(TransVarHeaderKey)))){\n                currEntry.setGroupName(TransVarValue);\n            } else if (!(!(\"uid\".equals(TransVarHeaderKey)))){\n                currEntry.setUserId(Integer.parseInt(TransVarValue));\n            } else if (!(!(\"uname\".equals(TransVarHeaderKey)))){\n                currEntry.setUserName(TransVarValue);\n            } else if (!(!(\"size\".equals(TransVarHeaderKey)))){\n                currEntry.setSize(Long.parseLong(TransVarValue));\n            } else if (!(!(\"mtime\".equals(TransVarHeaderKey)))){\n                currEntry.setModTime((long) (Double.parseDouble(TransVarValue) * 1000));\n            } else if (!(!(\"SCHILY.devminor\".equals(TransVarHeaderKey)))){\n                currEntry.setDevMinor(Integer.parseInt(TransVarValue));\n            } else if (!(!(\"SCHILY.devmajor\".equals(TransVarHeaderKey)))){\n                currEntry.setDevMajor(Integer.parseInt(TransVarValue));\n            }\n        }\n    }\n\n```",
            "method_doc": "Applies Pax header values to current tar entry fields."
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::parsePaxHeaders(InputStream)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::parsePaxHeaders(InputStream)",
            "method_code": "```java\n    Map<String, String> parsePaxHeaders(InputStream i) throws IOException {\n        Map<String, String> headers = new HashMap<String, String>();\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == ' '){ // End of length string\n                    // Get keyword\n                    ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            byte[] rest = new byte[restLen];\n                            int got = IOUtils.readFully(i, rest);\n                            if (got != restLen) {\n                                throw new IOException(\"Failed to read \"\n                                                      + \"Paxheader. Expected \"\n                                                      + restLen\n                                                      + \" bytes, read \"\n                                                      + got);\n                            }\n                            // Drop trailing NL\n                            String value = new String(rest, 0,\n                                                      restLen - 1, CharsetNames.UTF_8);\n                            headers.put(keyword, value);\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }\n\n```",
            "method_doc": "Parses Pax headers from input stream into key-value map. This method calls method \"readFully\" to read header data."
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::paxHeaders()": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::paxHeaders()",
            "method_code": "```java\n    private void paxHeaders() throws IOException{\n        Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n```",
            "method_doc": "Processes Pax headers for current entry. This method calls methods \"parsePaxHeaders\", \"getNextEntry\", and \"applyPaxHeadersToCurrentEntry\"."
        }
    }
}