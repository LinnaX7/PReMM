{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_removeUnwantedProperties()",
            "method_code": "```java\n    protected void _removeUnwantedProperties()\n    {\n        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = _properties.entrySet().iterator();\n        final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n\n        while (it.hasNext()) {\n            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n            POJOPropertyBuilder prop = entry.getValue();\n\n            // First: if nothing visible, just remove altogether\n            if (!prop.anyVisible()) {\n                it.remove();\n                continue;\n            }\n            // Otherwise, check ignorals\n            if (prop.anyIgnorals()) {\n                // first: if one or more ignorals, and no explicit markers, remove the whole thing\n                if (!prop.isExplicitlyIncluded()) {\n                    it.remove();\n                    _addIgnored(prop.getName());\n                    continue;\n                }\n                // otherwise just remove ones marked to be ignored\n                prop.removeIgnored();\n                if (!_forSerialization && !prop.couldDeserialize()) {\n                    _addIgnored(prop.getName());\n                }\n            }\n            // and finally, handle removal of individual non-visible elements\n            prop.removeNonVisible(forceNonVisibleRemoval);\n        }\n    }\n\n```",
            "method_doc": " Method called to get rid of candidate properties that are marked as ignored, or that are not visible. ",
            "class_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector",
            "class_doc": " Helper class used for aggregating information about all possible properties of a POJO. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when multiple auto-detection features are disabled (`AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, `INFER_PROPERTY_MUTATORS`), the mixin functionality fails to properly apply, resulting in no properties being serialized.\n\n**Key Observations:**\n1. The test expects `{\"city\":\"Seattle\"}` but gets a `JsonMappingException` indicating \"No serializer found\"\n2. All auto-detection mechanisms are explicitly disabled\n3. The mixin (PersonMixin.class) should provide the \"city\" property for serialization\n4. The exception suggests that even mixin-provided properties are not being recognized\n\n## Recommended Production Code Defect\n\n**Possible Defect:** The mixin annotation processing in Jackson's `AnnotationIntrospector` or `POJOPropertiesCollector` may not properly integrate mixin-defined properties when all auto-detection features are disabled.\n\n**Specific Issue:** When `AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, and `INFER_PROPERTY_MUTATORS` are all disabled, the code path that collects properties for serialization might be incorrectly excluding properties defined in mixins, treating them as if they were auto-detected properties rather than explicitly configured ones.\n\n**Root Cause Location:** The defect likely resides in:\n- `com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector` - in the property collection logic\n- `com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair` - in mixin annotation processing\n- `com.fasterxml.jackson.databind.ser.BeanSerializerFactory` - in serializer construction\n\nThe mixin properties should be treated as explicitly configured properties and should not be affected by the auto-detection feature flags, but the current implementation appears to be incorrectly filtering them out.",
            "test_suite": "com.fasterxml.jackson.databind.introspect.TestMixinMerging",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it contains logic that filters out properties based on visibility and inclusion criteria. When all auto-detection features are disabled, the mixin-provided properties might be incorrectly removed by the visibility checks (prop.anyVisible() returns false) or inclusion checks (!prop.isExplicitlyIncluded() returns true), causing the \"No serializer found\" error. The forceNonVisibleRemoval flag and property visibility logic appear to be incorrectly handling mixin-defined properties when auto-detection is disabled."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addMethods()",
            "method_code": "```java\n    protected void _addMethods()\n    {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        \n        for (AnnotatedMethod m : _classDef.memberMethods()) {\n            /* For methods, handling differs between getters and setters; and\n             * we will also only consider entries that either follow the bean\n             * naming convention or are explicitly marked: just being visible\n             * is not enough (unlike with fields)\n             */\n            int argCount = m.getParameterCount();\n            if (argCount == 0) { // getters (including 'any getter')\n            \t_addGetterMethod(m, ai);\n            } else if (argCount == 1) { // setters\n            \t_addSetterMethod(m, ai);\n            } else if (argCount == 2) { // any getter?\n                if (ai != null  && ai.hasAnySetterAnnotation(m)) {\n                    if (_anySetters == null) {\n                        _anySetters = new LinkedList<AnnotatedMethod>();\n                    }\n                    _anySetters.add(m);\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " Method for collecting basic information on all fields found ",
            "class_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector",
            "class_doc": " Helper class used for aggregating information about all possible properties of a POJO. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when multiple auto-detection features are disabled (`AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, `INFER_PROPERTY_MUTATORS`), the mixin functionality fails to properly apply, resulting in no properties being serialized.\n\n**Key Observations:**\n1. The test expects `{\"city\":\"Seattle\"}` but gets a `JsonMappingException` indicating \"No serializer found\"\n2. All auto-detection mechanisms are explicitly disabled\n3. The mixin (PersonMixin.class) should provide the \"city\" property for serialization\n4. The exception suggests that even mixin-provided properties are not being recognized\n\n## Recommended Production Code Defect\n\n**Possible Defect:** The mixin annotation processing in Jackson's `AnnotationIntrospector` or `POJOPropertiesCollector` may not properly integrate mixin-defined properties when all auto-detection features are disabled.\n\n**Specific Issue:** When `AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, and `INFER_PROPERTY_MUTATORS` are all disabled, the code path that collects properties for serialization might be incorrectly excluding properties defined in mixins, treating them as if they were auto-detected properties rather than explicitly configured ones.\n\n**Root Cause Location:** The defect likely resides in:\n- `com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector` - in the property collection logic\n- `com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair` - in mixin annotation processing\n- `com.fasterxml.jackson.databind.ser.BeanSerializerFactory` - in serializer construction\n\nThe mixin properties should be treated as explicitly configured properties and should not be affected by the auto-detection feature flags, but the current implementation appears to be incorrectly filtering them out.",
            "test_suite": "com.fasterxml.jackson.databind.introspect.TestMixinMerging",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles method collection for serialization and when all auto-detection features are disabled, the mixin-defined methods (which should be explicitly configured properties) might be incorrectly filtered out during the _addGetterMethod or _addSetterMethod processing, causing the \"No serializer found\" exception when mixin properties aren't properly recognized."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::collect()",
            "method_code": "```java\n    public POJOPropertiesCollector collect()\n    {\n        _properties.clear();\n        \n        // First: gather basic data\n        _addFields();\n        _addMethods();\n        _addCreators();\n        _addInjectables();\n\n        // Remove ignored properties, individual entries\n        _removeUnwantedProperties();\n\n        // Rename remaining properties\n        _renameProperties();\n        // And use custom naming strategy, if applicable...\n        PropertyNamingStrategy naming = _findNamingStrategy();\n        if (naming != null) {\n            _renameUsing(naming);\n        }\n\n        /* Sort by visibility (explicit over implicit); drop all but first\n         * of member type (getter, setter etc) if there is visibility\n         * difference\n         */\n        for (POJOPropertyBuilder property : _properties.values()) {\n            property.trimByVisibility();\n        }\n\n        // and then \"merge\" annotations\n        for (POJOPropertyBuilder property : _properties.values()) {\n            property.mergeAnnotations(_forSerialization);\n        }\n\n        /* and, if required, apply wrapper name: note, MUST be done after\n         * annotations are merged.\n         */\n        if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) {\n            _renameWithWrappers();\n        }\n        \n        // well, almost last: there's still ordering...\n        _sortProperties();\n        return this;\n    }\n\n```",
            "method_doc": " Method that orchestrates collection activities, and needs to be called after creating the instance. ",
            "class_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector",
            "class_doc": " Helper class used for aggregating information about all possible properties of a POJO. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when multiple auto-detection features are disabled (`AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, `INFER_PROPERTY_MUTATORS`), the mixin functionality fails to properly apply, resulting in no properties being serialized.\n\n**Key Observations:**\n1. The test expects `{\"city\":\"Seattle\"}` but gets a `JsonMappingException` indicating \"No serializer found\"\n2. All auto-detection mechanisms are explicitly disabled\n3. The mixin (PersonMixin.class) should provide the \"city\" property for serialization\n4. The exception suggests that even mixin-provided properties are not being recognized\n\n## Recommended Production Code Defect\n\n**Possible Defect:** The mixin annotation processing in Jackson's `AnnotationIntrospector` or `POJOPropertiesCollector` may not properly integrate mixin-defined properties when all auto-detection features are disabled.\n\n**Specific Issue:** When `AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, and `INFER_PROPERTY_MUTATORS` are all disabled, the code path that collects properties for serialization might be incorrectly excluding properties defined in mixins, treating them as if they were auto-detected properties rather than explicitly configured ones.\n\n**Root Cause Location:** The defect likely resides in:\n- `com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector` - in the property collection logic\n- `com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair` - in mixin annotation processing\n- `com.fasterxml.jackson.databind.ser.BeanSerializerFactory` - in serializer construction\n\nThe mixin properties should be treated as explicitly configured properties and should not be affected by the auto-detection feature flags, but the current implementation appears to be incorrectly filtering them out.",
            "test_suite": "com.fasterxml.jackson.databind.introspect.TestMixinMerging",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it orchestrates the entire property collection process including field and method discovery. When auto-detection features are disabled, the mixin properties defined in PersonMixin.class should still be collected, but the current implementation appears to be incorrectly filtering them out during the property collection phases (_addFields, _addMethods) or during the cleanup phase (_removeUnwantedProperties). The method's responsibility for gathering all POJO properties makes it the most likely location where mixin properties are being improperly excluded when auto-detection is disabled."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addGetterMethod(AnnotatedMethod,AnnotationIntrospector)",
            "method_code": "```java\n    protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai)\n    {\n        // Very first thing: skip if not returning any value\n        if (!m.hasReturnType()) {\n            return;\n        }\n        \n        // any getter?\n        if (ai != null) {\n            if (ai.hasAnyGetterAnnotation(m)) {\n                if (_anyGetters == null) {\n                    _anyGetters = new LinkedList<AnnotatedMember>();\n                }\n                _anyGetters.add(m);\n                return;\n            }\n            // @JsonValue?\n            if (ai.hasAsValueAnnotation(m)) {\n                if (_jsonValueGetters == null) {\n                    _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n                }\n                _jsonValueGetters.add(m);\n                return;\n            }\n        }\n        String implName; // from naming convention\n        boolean visible;\n\n        PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n        boolean nameExplicit = (pn != null);\n\n        if (!nameExplicit) { // no explicit name; must consider implicit\n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n            }\n            if (implName == null) { // if not, must skip\n                implName = BeanUtil.okNameForIsGetter(m, m.getName());\n                if (implName == null) {\n                    return;\n                }\n                visible = _visibilityChecker.isIsGetterVisible(m);\n            } else {\n                visible = _visibilityChecker.isGetterVisible(m);\n            }\n        } else { // explicit indication of inclusion, but may be empty\n            // we still need implicit name to link with other pieces\n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForGetter(m);\n            }\n            // if not regular getter name, use method name as is\n            if (implName == null) {\n                implName = m.getName();\n            }\n            if (pn.isEmpty()) {\n                // !!! TODO: use PropertyName for implicit names too\n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            visible = true;\n        }\n        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n        _property(implName).addGetter(m, pn, nameExplicit, visible, ignore);\n    }\n\n```",
            "method_doc": "Processes getter methods, handling any-getter and @JsonValue annotations, and calls _property to build property definitions.",
            "class_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector",
            "class_doc": " Helper class used for aggregating information about all possible properties of a POJO. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when multiple auto-detection features are disabled (`AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, `INFER_PROPERTY_MUTATORS`), the mixin functionality fails to properly apply, resulting in no properties being serialized.\n\n**Key Observations:**\n1. The test expects `{\"city\":\"Seattle\"}` but gets a `JsonMappingException` indicating \"No serializer found\"\n2. All auto-detection mechanisms are explicitly disabled\n3. The mixin (PersonMixin.class) should provide the \"city\" property for serialization\n4. The exception suggests that even mixin-provided properties are not being recognized\n\n## Recommended Production Code Defect\n\n**Possible Defect:** The mixin annotation processing in Jackson's `AnnotationIntrospector` or `POJOPropertiesCollector` may not properly integrate mixin-defined properties when all auto-detection features are disabled.\n\n**Specific Issue:** When `AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, and `INFER_PROPERTY_MUTATORS` are all disabled, the code path that collects properties for serialization might be incorrectly excluding properties defined in mixins, treating them as if they were auto-detected properties rather than explicitly configured ones.\n\n**Root Cause Location:** The defect likely resides in:\n- `com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector` - in the property collection logic\n- `com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair` - in mixin annotation processing\n- `com.fasterxml.jackson.databind.ser.BeanSerializerFactory` - in serializer construction\n\nThe mixin properties should be treated as explicitly configured properties and should not be affected by the auto-detection feature flags, but the current implementation appears to be incorrectly filtering them out.",
            "test_suite": "com.fasterxml.jackson.databind.introspect.TestMixinMerging",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles getter method processing and property name resolution, which is critical when mixins are involved. The test failure occurs when auto-detection features are disabled but mixin-defined properties should still be serialized. The method's logic for determining property names and visibility checks may be incorrectly filtering out mixin-provided getters when auto-detection is turned off, particularly in the sections that handle implicit naming and visibility determination based on the annotation introspector."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addFields()",
            "method_code": "```java\n    protected void _addFields()\n    {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        /* 28-Mar-2013, tatu: For deserialization we may also want to remove\n         *   final fields, as often they won't make very good mutators...\n         *   (although, maybe surprisingly, JVM _can_ force setting of such fields!)\n         */\n        final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);\n        \n        for (AnnotatedField f : _classDef.fields()) {\n            String implName = (ai == null) ? null : ai.findImplicitPropertyName(f);\n            if (implName == null) {\n                implName = f.getName();\n            }\n            \n            PropertyName pn;\n\n            if (ai == null) {\n                pn = null;\n            } else if (_forSerialization) {\n                /* 18-Aug-2011, tatu: As per existing unit tests, we should only\n                 *   use serialization annotation (@JsonSerializer) when serializing\n                 *   fields, and similarly for deserialize-only annotations... so\n                 *   no fallbacks in this particular case.\n                 */\n                pn = ai.findNameForSerialization(f);\n            } else {\n                pn = ai.findNameForDeserialization(f);\n            }\n            boolean nameExplicit = (pn != null);\n\n            if (nameExplicit && pn.isEmpty()) { // empty String meaning \"use default name\", here just means \"same as field name\"\n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            // having explicit name means that field is visible; otherwise need to check the rules\n            boolean visible = (pn != null);\n            if (!visible) {\n                visible = _visibilityChecker.isFieldVisible(f);\n            }\n            // and finally, may also have explicit ignoral\n            boolean ignored = (ai != null) && ai.hasIgnoreMarker(f);\n            /* [Issue#190]: this is the place to prune final fields, if they are not\n             *  to be used as mutators. Must verify they are not explicitly included.\n             *  Also: if 'ignored' is set, need to included until a later point, to\n             *  avoid losing ignoral information.\n             */\n            if (pruneFinalFields && (pn == null) && !ignored && Modifier.isFinal(f.getModifiers())) {\n                continue;\n            }\n            _property(implName).addField(f, pn, nameExplicit, visible, ignored);\n        }\n    }\n\n```",
            "method_doc": " Method for collecting basic information on all fields found ",
            "class_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector",
            "class_doc": " Helper class used for aggregating information about all possible properties of a POJO. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the key patterns and possible defect in the production code:\n\n## Analysis Summary\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when multiple auto-detection features are disabled (`AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, `INFER_PROPERTY_MUTATORS`), the mixin functionality fails to properly apply, resulting in no properties being serialized.\n\n**Key Observations:**\n1. The test expects `{\"city\":\"Seattle\"}` but gets a `JsonMappingException` indicating \"No serializer found\"\n2. All auto-detection mechanisms are explicitly disabled\n3. The mixin (PersonMixin.class) should provide the \"city\" property for serialization\n4. The exception suggests that even mixin-provided properties are not being recognized\n\n## Recommended Production Code Defect\n\n**Possible Defect:** The mixin annotation processing in Jackson's `AnnotationIntrospector` or `POJOPropertiesCollector` may not properly integrate mixin-defined properties when all auto-detection features are disabled.\n\n**Specific Issue:** When `AUTO_DETECT_FIELDS`, `AUTO_DETECT_GETTERS`, `AUTO_DETECT_IS_GETTERS`, and `INFER_PROPERTY_MUTATORS` are all disabled, the code path that collects properties for serialization might be incorrectly excluding properties defined in mixins, treating them as if they were auto-detected properties rather than explicitly configured ones.\n\n**Root Cause Location:** The defect likely resides in:\n- `com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector` - in the property collection logic\n- `com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair` - in mixin annotation processing\n- `com.fasterxml.jackson.databind.ser.BeanSerializerFactory` - in serializer construction\n\nThe mixin properties should be treated as explicitly configured properties and should not be affected by the auto-detection feature flags, but the current implementation appears to be incorrectly filtering them out.",
            "test_suite": "com.fasterxml.jackson.databind.introspect.TestMixinMerging",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles field collection logic and contains the visibility checking mechanism that determines whether fields should be included for serialization. The test failure occurs when all auto-detection features are disabled, and the mixin-provided field \"city\" is not being recognized. The method uses `_visibilityChecker.isFieldVisible(f)` to determine field visibility, but this check may be incorrectly filtering out mixin-defined fields when auto-detection is disabled, even though mixin properties should be treated as explicitly configured and not subject to auto-detection rules."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_removeUnwantedProperties()": {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_removeUnwantedProperties()",
            "method_code": "```java\n    protected void _removeUnwantedProperties()\n    {\n        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = _properties.entrySet().iterator();\n        final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n\n        while (it.hasNext()) {\n            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n            POJOPropertyBuilder prop = entry.getValue();\n\n            // First: if nothing visible, just remove altogether\n            if (!prop.anyVisible()) {\n                it.remove();\n                continue;\n            }\n            // Otherwise, check ignorals\n            if (prop.anyIgnorals()) {\n                // first: if one or more ignorals, and no explicit markers, remove the whole thing\n                if (!prop.isExplicitlyIncluded()) {\n                    it.remove();\n                    _addIgnored(prop.getName());\n                    continue;\n                }\n                // otherwise just remove ones marked to be ignored\n                prop.removeIgnored();\n                if (!_forSerialization && !prop.couldDeserialize()) {\n                    _addIgnored(prop.getName());\n                }\n            }\n            // and finally, handle removal of individual non-visible elements\n            prop.removeNonVisible(forceNonVisibleRemoval);\n        }\n    }\n\n```",
            "method_doc": " Method called to get rid of candidate properties that are marked as ignored, or that are not visible. "
        },
        "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addMethods()": {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addMethods()",
            "method_code": "```java\n    protected void _addMethods()\n    {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        \n        for (AnnotatedMethod m : _classDef.memberMethods()) {\n            /* For methods, handling differs between getters and setters; and\n             * we will also only consider entries that either follow the bean\n             * naming convention or are explicitly marked: just being visible\n             * is not enough (unlike with fields)\n             */\n            int argCount = m.getParameterCount();\n            if (argCount == 0) { // getters (including 'any getter')\n            \t_addGetterMethod(m, ai);\n            } else if (argCount == 1) { // setters\n            \t_addSetterMethod(m, ai);\n            } else if (argCount == 2) { // any getter?\n                if (ai != null  && ai.hasAnySetterAnnotation(m)) {\n                    if (_anySetters == null) {\n                        _anySetters = new LinkedList<AnnotatedMethod>();\n                    }\n                    _anySetters.add(m);\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " Method for collecting basic information on all fields found "
        },
        "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::collect()": {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::collect()",
            "method_code": "```java\n    public POJOPropertiesCollector collect()\n    {\n        _properties.clear();\n        \n        // First: gather basic data\n        _addFields();\n        _addMethods();\n        _addCreators();\n        _addInjectables();\n\n        // Remove ignored properties, individual entries\n        _removeUnwantedProperties();\n\n        // Rename remaining properties\n        _renameProperties();\n        // And use custom naming strategy, if applicable...\n        PropertyNamingStrategy naming = _findNamingStrategy();\n        if (naming != null) {\n            _renameUsing(naming);\n        }\n\n        /* Sort by visibility (explicit over implicit); drop all but first\n         * of member type (getter, setter etc) if there is visibility\n         * difference\n         */\n        for (POJOPropertyBuilder property : _properties.values()) {\n            property.trimByVisibility();\n        }\n\n        // and then \"merge\" annotations\n        for (POJOPropertyBuilder property : _properties.values()) {\n            property.mergeAnnotations(_forSerialization);\n        }\n\n        /* and, if required, apply wrapper name: note, MUST be done after\n         * annotations are merged.\n         */\n        if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) {\n            _renameWithWrappers();\n        }\n        \n        // well, almost last: there's still ordering...\n        _sortProperties();\n        return this;\n    }\n\n```",
            "method_doc": " Method that orchestrates collection activities, and needs to be called after creating the instance. "
        },
        "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addGetterMethod(AnnotatedMethod,AnnotationIntrospector)": {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addGetterMethod(AnnotatedMethod,AnnotationIntrospector)",
            "method_code": "```java\n    protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai)\n    {\n        // Very first thing: skip if not returning any value\n        if (!m.hasReturnType()) {\n            return;\n        }\n        \n        // any getter?\n        if (ai != null) {\n            if (ai.hasAnyGetterAnnotation(m)) {\n                if (_anyGetters == null) {\n                    _anyGetters = new LinkedList<AnnotatedMember>();\n                }\n                _anyGetters.add(m);\n                return;\n            }\n            // @JsonValue?\n            if (ai.hasAsValueAnnotation(m)) {\n                if (_jsonValueGetters == null) {\n                    _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n                }\n                _jsonValueGetters.add(m);\n                return;\n            }\n        }\n        String implName; // from naming convention\n        boolean visible;\n\n        PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n        boolean nameExplicit = (pn != null);\n\n        if (!nameExplicit) { // no explicit name; must consider implicit\n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n            }\n            if (implName == null) { // if not, must skip\n                implName = BeanUtil.okNameForIsGetter(m, m.getName());\n                if (implName == null) {\n                    return;\n                }\n                visible = _visibilityChecker.isIsGetterVisible(m);\n            } else {\n                visible = _visibilityChecker.isGetterVisible(m);\n            }\n        } else { // explicit indication of inclusion, but may be empty\n            // we still need implicit name to link with other pieces\n            implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n            if (implName == null) {\n                implName = BeanUtil.okNameForGetter(m);\n            }\n            // if not regular getter name, use method name as is\n            if (implName == null) {\n                implName = m.getName();\n            }\n            if (pn.isEmpty()) {\n                // !!! TODO: use PropertyName for implicit names too\n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            visible = true;\n        }\n        boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n        _property(implName).addGetter(m, pn, nameExplicit, visible, ignore);\n    }\n\n```",
            "method_doc": "Processes getter methods, handling any-getter and @JsonValue annotations, and calls _property to build property definitions."
        },
        "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addFields()": {
            "method_name": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector::_addFields()",
            "method_code": "```java\n    protected void _addFields()\n    {\n        final AnnotationIntrospector ai = _annotationIntrospector;\n        /* 28-Mar-2013, tatu: For deserialization we may also want to remove\n         *   final fields, as often they won't make very good mutators...\n         *   (although, maybe surprisingly, JVM _can_ force setting of such fields!)\n         */\n        final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);\n        \n        for (AnnotatedField f : _classDef.fields()) {\n            String implName = (ai == null) ? null : ai.findImplicitPropertyName(f);\n            if (implName == null) {\n                implName = f.getName();\n            }\n            \n            PropertyName pn;\n\n            if (ai == null) {\n                pn = null;\n            } else if (_forSerialization) {\n                /* 18-Aug-2011, tatu: As per existing unit tests, we should only\n                 *   use serialization annotation (@JsonSerializer) when serializing\n                 *   fields, and similarly for deserialize-only annotations... so\n                 *   no fallbacks in this particular case.\n                 */\n                pn = ai.findNameForSerialization(f);\n            } else {\n                pn = ai.findNameForDeserialization(f);\n            }\n            boolean nameExplicit = (pn != null);\n\n            if (nameExplicit && pn.isEmpty()) { // empty String meaning \"use default name\", here just means \"same as field name\"\n                pn = _propNameFromSimple(implName);\n                nameExplicit = false;\n            }\n            // having explicit name means that field is visible; otherwise need to check the rules\n            boolean visible = (pn != null);\n            if (!visible) {\n                visible = _visibilityChecker.isFieldVisible(f);\n            }\n            // and finally, may also have explicit ignoral\n            boolean ignored = (ai != null) && ai.hasIgnoreMarker(f);\n            /* [Issue#190]: this is the place to prune final fields, if they are not\n             *  to be used as mutators. Must verify they are not explicitly included.\n             *  Also: if 'ignored' is set, need to included until a later point, to\n             *  avoid losing ignoral information.\n             */\n            if (pruneFinalFields && (pn == null) && !ignored && Modifier.isFinal(f.getModifiers())) {\n                continue;\n            }\n            _property(implName).addField(f, pn, nameExplicit, visible, ignored);\n        }\n    }\n\n```",
            "method_doc": " Method for collecting basic information on all fields found "
        }
    }
}