{
    "buggy_classes": [
        "org.jsoup.parser.Parser"
    ],
    "buggy_methods": [
        {
            "method_name": "org.jsoup.parser.Parser::parseTextNode()",
            "method_code": "```java\n    private void parseTextNode() {\n        String text = tq.consumeTo(\"<\");\n        TextNode textNode = TextNode.createFromEncoded(text, baseUri);\n        last().appendChild(textNode);\n    }\n\n```",
            "method_doc": "Creates text nodes from content between tags and appends them to the last element in the stack by calling method \"last()\".",
            "class_name": "org.jsoup.parser.Parser",
            "class_doc": " Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}. ",
            "test_failure_causes": "As the Software Test Engineer, I'll analyze the test failure step by step to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure\n\n**Test Behavior Pattern:**\n- The test `createsStructureFromBodySnippet` is failing due to incorrect text normalization\n- Input: `\"foo <b>bar</b> baz\"`\n- Expected: `\"foo bar baz\"`\n- Actual: `\"bar baz foo\"`\n- The issue appears to be with the order of text content when parsing body snippets\n\n**Key Observations:**\n\n1. **Text Ordering Issue**: The actual output shows the text in the order \"bar baz foo\" instead of the expected \"foo bar baz\"\n2. **Inline Element Handling**: The `<b>` element is an inline element that should not disrupt the natural text flow\n3. **Body Snippet Parsing**: The test specifically deals with parsing HTML body snippets without explicit structure\n\n## Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the Jsoup parser:\n\n### 1. **Text Node Ordering in Body Normalization**\nThe parser may be incorrectly ordering text nodes when normalizing body content. When parsing snippets without explicit HTML structure, the normalization routine that moves content into the body might be reordering text nodes.\n\n**Location to investigate**: The body normalization logic in the HTML parser, particularly how it handles text nodes that appear before inline elements.\n\n### 2. **Inline Element Text Extraction**\nThe `Document.text()` method might be incorrectly traversing the DOM tree when extracting text from documents containing inline elements, potentially processing child elements before their parent's preceding text nodes.\n\n### 3. **Fragment Parsing Logic**\nSince this is a body snippet (not a full HTML document), the fragment parsing logic might have a defect in how it structures the content, particularly with text that appears before the first HTML element.\n\n### 4. **Whitespace and Text Normalization**\nThe parser's whitespace normalization or text concatenation logic might be incorrectly handling the sequence of text nodes around inline elements.\n\n**Primary Focus**: The most likely defect is in the **body normalization routine** that handles how text content is structured when parsing HTML snippets, specifically the ordering of text nodes relative to inline elements in the resulting DOM tree.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 8,
            "reason": "#8# The parseTextNode method is highly suspicious because it directly handles text node creation and appending to the DOM tree. The test failure shows text ordering issues where \"foo\" appears at the end instead of the beginning, suggesting that text nodes are being appended in the wrong order. Since this method is responsible for consuming text content and appending it to the last element in the stack, any defect in how it processes text before/after inline elements could cause the observed text ordering problem."
        },
        {
            "method_name": "org.jsoup.parser.Parser::addChildToParent(Element,boolean)",
            "method_code": "```java\n    private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor) {\n            // create implicit parent around this child\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            // special case: make sure there's a head before putting in body\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            // recurse to ensure somewhere to put parent\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }\n\n```",
            "method_doc": "Adds child element to suitable parent by calling methods \"popStackToSuitableContainer()\" and \"stackHasValidParent()\" to find appropriate container and validate parent-child relationship. Handles implicit parent creation for invalid ancestors.",
            "class_name": "org.jsoup.parser.Parser",
            "class_doc": " Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}. ",
            "test_failure_causes": "As the Software Test Engineer, I'll analyze the test failure step by step to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure\n\n**Test Behavior Pattern:**\n- The test `createsStructureFromBodySnippet` is failing due to incorrect text normalization\n- Input: `\"foo <b>bar</b> baz\"`\n- Expected: `\"foo bar baz\"`\n- Actual: `\"bar baz foo\"`\n- The issue appears to be with the order of text content when parsing body snippets\n\n**Key Observations:**\n\n1. **Text Ordering Issue**: The actual output shows the text in the order \"bar baz foo\" instead of the expected \"foo bar baz\"\n2. **Inline Element Handling**: The `<b>` element is an inline element that should not disrupt the natural text flow\n3. **Body Snippet Parsing**: The test specifically deals with parsing HTML body snippets without explicit structure\n\n## Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the Jsoup parser:\n\n### 1. **Text Node Ordering in Body Normalization**\nThe parser may be incorrectly ordering text nodes when normalizing body content. When parsing snippets without explicit HTML structure, the normalization routine that moves content into the body might be reordering text nodes.\n\n**Location to investigate**: The body normalization logic in the HTML parser, particularly how it handles text nodes that appear before inline elements.\n\n### 2. **Inline Element Text Extraction**\nThe `Document.text()` method might be incorrectly traversing the DOM tree when extracting text from documents containing inline elements, potentially processing child elements before their parent's preceding text nodes.\n\n### 3. **Fragment Parsing Logic**\nSince this is a body snippet (not a full HTML document), the fragment parsing logic might have a defect in how it structures the content, particularly with text that appears before the first HTML element.\n\n### 4. **Whitespace and Text Normalization**\nThe parser's whitespace normalization or text concatenation logic might be incorrectly handling the sequence of text nodes around inline elements.\n\n**Primary Focus**: The most likely defect is in the **body normalization routine** that handles how text content is structured when parsing HTML snippets, specifically the ordering of text nodes relative to inline elements in the resulting DOM tree.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles implicit parent creation and element ordering when adding children to parents. The test failure shows text ordering issues where \"foo\" appears after \"bar baz\" instead of before, suggesting the method may be incorrectly structuring the DOM tree when processing body snippets with mixed text and inline elements. The implicit parent creation logic and stack manipulation could be causing the text node ordering problem observed in the test."
        },
        {
            "method_name": "org.jsoup.parser.Parser::parse()",
            "method_code": "```java\n    private Document parse() {\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"<!--\")) {\n                parseComment();\n            } else if (tq.matches(\"<![CDATA[\")) {\n                parseCdata();\n            } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) {\n                parseXmlDecl();\n            } else if (tq.matches(\"</\")) {\n                parseEndTag();\n            } else if (tq.matches(\"<\")) {\n                parseStartTag();\n            } else {\n                parseTextNode();\n            }\n        }\n        return doc.normalise();\n    }\n\n```",
            "method_doc": "Main parsing loop that processes tokens from input HTML by calling various parse methods based on token type, including \"parseComment()\", \"parseCdata()\", \"parseXmlDecl()\", \"parseEndTag()\", \"parseStartTag()\", and \"parseTextNode()\". Returns normalized document.",
            "class_name": "org.jsoup.parser.Parser",
            "class_doc": " Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}. ",
            "test_failure_causes": "As the Software Test Engineer, I'll analyze the test failure step by step to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure\n\n**Test Behavior Pattern:**\n- The test `createsStructureFromBodySnippet` is failing due to incorrect text normalization\n- Input: `\"foo <b>bar</b> baz\"`\n- Expected: `\"foo bar baz\"`\n- Actual: `\"bar baz foo\"`\n- The issue appears to be with the order of text content when parsing body snippets\n\n**Key Observations:**\n\n1. **Text Ordering Issue**: The actual output shows the text in the order \"bar baz foo\" instead of the expected \"foo bar baz\"\n2. **Inline Element Handling**: The `<b>` element is an inline element that should not disrupt the natural text flow\n3. **Body Snippet Parsing**: The test specifically deals with parsing HTML body snippets without explicit structure\n\n## Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the Jsoup parser:\n\n### 1. **Text Node Ordering in Body Normalization**\nThe parser may be incorrectly ordering text nodes when normalizing body content. When parsing snippets without explicit HTML structure, the normalization routine that moves content into the body might be reordering text nodes.\n\n**Location to investigate**: The body normalization logic in the HTML parser, particularly how it handles text nodes that appear before inline elements.\n\n### 2. **Inline Element Text Extraction**\nThe `Document.text()` method might be incorrectly traversing the DOM tree when extracting text from documents containing inline elements, potentially processing child elements before their parent's preceding text nodes.\n\n### 3. **Fragment Parsing Logic**\nSince this is a body snippet (not a full HTML document), the fragment parsing logic might have a defect in how it structures the content, particularly with text that appears before the first HTML element.\n\n### 4. **Whitespace and Text Normalization**\nThe parser's whitespace normalization or text concatenation logic might be incorrectly handling the sequence of text nodes around inline elements.\n\n**Primary Focus**: The most likely defect is in the **body normalization routine** that handles how text content is structured when parsing HTML snippets, specifically the ordering of text nodes relative to inline elements in the resulting DOM tree.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 8,
            "reason": "#8# The parse() method is highly suspicious because it contains the main parsing loop that processes all HTML tokens and calls doc.normalise() at the end, which is directly related to the text ordering issue in the test. The normalise() method is responsible for restructuring the document, and the test failure shows incorrect text ordering after normalization, making this the most likely location for the defect."
        },
        {
            "method_name": "org.jsoup.parser.Parser::parseStartTag()",
            "method_code": "```java\n    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n\n        addChildToParent(child, isEmptyElement);\n    }\n\n```",
            "method_doc": "Processes start tags by consuming opening tag syntax, parsing attributes, creating elements, handling self-closing tags, and calling method \"addChildToParent()\" to add child to appropriate parent. Also handles data tags and base tag processing.",
            "class_name": "org.jsoup.parser.Parser",
            "class_doc": " Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}. ",
            "test_failure_causes": "As the Software Test Engineer, I'll analyze the test failure step by step to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure\n\n**Test Behavior Pattern:**\n- The test `createsStructureFromBodySnippet` is failing due to incorrect text normalization\n- Input: `\"foo <b>bar</b> baz\"`\n- Expected: `\"foo bar baz\"`\n- Actual: `\"bar baz foo\"`\n- The issue appears to be with the order of text content when parsing body snippets\n\n**Key Observations:**\n\n1. **Text Ordering Issue**: The actual output shows the text in the order \"bar baz foo\" instead of the expected \"foo bar baz\"\n2. **Inline Element Handling**: The `<b>` element is an inline element that should not disrupt the natural text flow\n3. **Body Snippet Parsing**: The test specifically deals with parsing HTML body snippets without explicit structure\n\n## Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the Jsoup parser:\n\n### 1. **Text Node Ordering in Body Normalization**\nThe parser may be incorrectly ordering text nodes when normalizing body content. When parsing snippets without explicit HTML structure, the normalization routine that moves content into the body might be reordering text nodes.\n\n**Location to investigate**: The body normalization logic in the HTML parser, particularly how it handles text nodes that appear before inline elements.\n\n### 2. **Inline Element Text Extraction**\nThe `Document.text()` method might be incorrectly traversing the DOM tree when extracting text from documents containing inline elements, potentially processing child elements before their parent's preceding text nodes.\n\n### 3. **Fragment Parsing Logic**\nSince this is a body snippet (not a full HTML document), the fragment parsing logic might have a defect in how it structures the content, particularly with text that appears before the first HTML element.\n\n### 4. **Whitespace and Text Normalization**\nThe parser's whitespace normalization or text concatenation logic might be incorrectly handling the sequence of text nodes around inline elements.\n\n**Primary Focus**: The most likely defect is in the **body normalization routine** that handles how text content is structured when parsing HTML snippets, specifically the ordering of text nodes relative to inline elements in the resulting DOM tree.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 7,
            "reason": "#7# The parseStartTag() method handles element creation and addition to the DOM tree, which could affect text node ordering when parsing body snippets. The test failure shows incorrect text sequence (\"bar baz foo\" vs \"foo bar baz\"), suggesting the method may be incorrectly handling the positioning of text nodes relative to inline elements like <b> during the parsing process."
        },
        {
            "method_name": "org.jsoup.parser.Parser::popStackToSuitableContainer(Tag)",
            "method_code": "```java\n    private Element popStackToSuitableContainer(Tag tag) {\n        while (!stack.isEmpty()) {\n            if (last().tag().canContain(tag))\n                return last();\n            else\n                stack.removeLast();\n        }\n        return null;\n    }\n\n```",
            "method_doc": "Pops elements from the stack until finding a container that can hold the specified tag, using method \"last()\" to check current stack top.",
            "class_name": "org.jsoup.parser.Parser",
            "class_doc": " Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}. ",
            "test_failure_causes": "As the Software Test Engineer, I'll analyze the test failure step by step to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure\n\n**Test Behavior Pattern:**\n- The test `createsStructureFromBodySnippet` is failing due to incorrect text normalization\n- Input: `\"foo <b>bar</b> baz\"`\n- Expected: `\"foo bar baz\"`\n- Actual: `\"bar baz foo\"`\n- The issue appears to be with the order of text content when parsing body snippets\n\n**Key Observations:**\n\n1. **Text Ordering Issue**: The actual output shows the text in the order \"bar baz foo\" instead of the expected \"foo bar baz\"\n2. **Inline Element Handling**: The `<b>` element is an inline element that should not disrupt the natural text flow\n3. **Body Snippet Parsing**: The test specifically deals with parsing HTML body snippets without explicit structure\n\n## Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the Jsoup parser:\n\n### 1. **Text Node Ordering in Body Normalization**\nThe parser may be incorrectly ordering text nodes when normalizing body content. When parsing snippets without explicit HTML structure, the normalization routine that moves content into the body might be reordering text nodes.\n\n**Location to investigate**: The body normalization logic in the HTML parser, particularly how it handles text nodes that appear before inline elements.\n\n### 2. **Inline Element Text Extraction**\nThe `Document.text()` method might be incorrectly traversing the DOM tree when extracting text from documents containing inline elements, potentially processing child elements before their parent's preceding text nodes.\n\n### 3. **Fragment Parsing Logic**\nSince this is a body snippet (not a full HTML document), the fragment parsing logic might have a defect in how it structures the content, particularly with text that appears before the first HTML element.\n\n### 4. **Whitespace and Text Normalization**\nThe parser's whitespace normalization or text concatenation logic might be incorrectly handling the sequence of text nodes around inline elements.\n\n**Primary Focus**: The most likely defect is in the **body normalization routine** that handles how text content is structured when parsing HTML snippets, specifically the ordering of text nodes relative to inline elements in the resulting DOM tree.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 7,
            "reason": "#7# The popStackToSuitableContainer method is suspicious because it controls element stacking order during parsing, which directly affects DOM structure. The test failure shows text ordering issues (\"foo bar baz\" vs \"bar baz foo\"), suggesting the parser may be incorrectly handling the stacking of inline elements like <b> tags. This method determines where new elements are placed in the DOM hierarchy, and if it's popping elements incorrectly or choosing wrong containers, it could cause the observed text reordering problem in body snippet parsing."
        },
        {
            "method_name": "org.jsoup.parser.Parser::last()",
            "method_code": "```java\n    private Element last() {\n        return stack.getLast();\n    }\n\n```",
            "method_doc": "Returns the last element in the parsing stack, used by various methods to access current parsing context.",
            "class_name": "org.jsoup.parser.Parser",
            "class_doc": " Parses HTML into a {@link Document}. Generally best to use one of the  more convenient parse methods in {@link org.jsoup.Jsoup}. ",
            "test_failure_causes": "As the Software Test Engineer, I'll analyze the test failure step by step to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure\n\n**Test Behavior Pattern:**\n- The test `createsStructureFromBodySnippet` is failing due to incorrect text normalization\n- Input: `\"foo <b>bar</b> baz\"`\n- Expected: `\"foo bar baz\"`\n- Actual: `\"bar baz foo\"`\n- The issue appears to be with the order of text content when parsing body snippets\n\n**Key Observations:**\n\n1. **Text Ordering Issue**: The actual output shows the text in the order \"bar baz foo\" instead of the expected \"foo bar baz\"\n2. **Inline Element Handling**: The `<b>` element is an inline element that should not disrupt the natural text flow\n3. **Body Snippet Parsing**: The test specifically deals with parsing HTML body snippets without explicit structure\n\n## Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the Jsoup parser:\n\n### 1. **Text Node Ordering in Body Normalization**\nThe parser may be incorrectly ordering text nodes when normalizing body content. When parsing snippets without explicit HTML structure, the normalization routine that moves content into the body might be reordering text nodes.\n\n**Location to investigate**: The body normalization logic in the HTML parser, particularly how it handles text nodes that appear before inline elements.\n\n### 2. **Inline Element Text Extraction**\nThe `Document.text()` method might be incorrectly traversing the DOM tree when extracting text from documents containing inline elements, potentially processing child elements before their parent's preceding text nodes.\n\n### 3. **Fragment Parsing Logic**\nSince this is a body snippet (not a full HTML document), the fragment parsing logic might have a defect in how it structures the content, particularly with text that appears before the first HTML element.\n\n### 4. **Whitespace and Text Normalization**\nThe parser's whitespace normalization or text concatenation logic might be incorrectly handling the sequence of text nodes around inline elements.\n\n**Primary Focus**: The most likely defect is in the **body normalization routine** that handles how text content is structured when parsing HTML snippets, specifically the ordering of text nodes relative to inline elements in the resulting DOM tree.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 3,
            "reason": "#3# The last() method simply returns the last element from the parsing stack and doesn't directly handle text ordering or body normalization logic. While it's used to access current parsing context, the text ordering issue in the test failure is more likely related to how elements are added to the stack or how text nodes are processed during parsing, rather than this simple accessor method."
        }
    ],
    "buggy_codes": {
        "org.jsoup.parser.Parser::parseTextNode()": {
            "method_name": "org.jsoup.parser.Parser::parseTextNode()",
            "method_code": "```java\n    private void parseTextNode() {\n        String text = tq.consumeTo(\"<\");\n        TextNode textNode = TextNode.createFromEncoded(text, baseUri);\n        last().appendChild(textNode);\n    }\n\n```",
            "method_doc": "Creates text nodes from content between tags and appends them to the last element in the stack by calling method \"last()\"."
        },
        "org.jsoup.parser.Parser::parseStartTag()": {
            "method_name": "org.jsoup.parser.Parser::parseStartTag()",
            "method_code": "```java\n    private void parseStartTag() {\n        tq.consume(\"<\");\n        String tagName = tq.consumeWord();\n\n        if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n            tq.addFirst(\"&lt;\");\n            parseTextNode();\n            return;\n        }\n\n        Attributes attributes = new Attributes();\n        while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n\n        addChildToParent(child, isEmptyElement);\n    }\n\n```",
            "method_doc": "Processes start tags by consuming opening tag syntax, parsing attributes, creating elements, handling self-closing tags, and calling method \"addChildToParent()\" to add child to appropriate parent. Also handles data tags and base tag processing."
        },
        "org.jsoup.parser.Parser::addChildToParent(Element,boolean)": {
            "method_name": "org.jsoup.parser.Parser::addChildToParent(Element,boolean)",
            "method_code": "```java\n    private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor) {\n            // create implicit parent around this child\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            // special case: make sure there's a head before putting in body\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            // recurse to ensure somewhere to put parent\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }\n\n```",
            "method_doc": "Adds child element to suitable parent by calling methods \"popStackToSuitableContainer()\" and \"stackHasValidParent()\" to find appropriate container and validate parent-child relationship. Handles implicit parent creation for invalid ancestors."
        },
        "org.jsoup.parser.Parser::parse()": {
            "method_name": "org.jsoup.parser.Parser::parse()",
            "method_code": "```java\n    private Document parse() {\n        while (!tq.isEmpty()) {\n            if (tq.matches(\"<!--\")) {\n                parseComment();\n            } else if (tq.matches(\"<![CDATA[\")) {\n                parseCdata();\n            } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) {\n                parseXmlDecl();\n            } else if (tq.matches(\"</\")) {\n                parseEndTag();\n            } else if (tq.matches(\"<\")) {\n                parseStartTag();\n            } else {\n                parseTextNode();\n            }\n        }\n        return doc.normalise();\n    }\n\n```",
            "method_doc": "Main parsing loop that processes tokens from input HTML by calling various parse methods based on token type, including \"parseComment()\", \"parseCdata()\", \"parseXmlDecl()\", \"parseEndTag()\", \"parseStartTag()\", and \"parseTextNode()\". Returns normalized document."
        },
        "org.jsoup.parser.Parser::last()": {
            "method_name": "org.jsoup.parser.Parser::last()",
            "method_code": "```java\n    private Element last() {\n        return stack.getLast();\n    }\n\n```",
            "method_doc": "Returns the last element in the parsing stack, used by various methods to access current parsing context."
        },
        "org.jsoup.parser.Parser::popStackToSuitableContainer(Tag)": {
            "method_name": "org.jsoup.parser.Parser::popStackToSuitableContainer(Tag)",
            "method_code": "```java\n    private Element popStackToSuitableContainer(Tag tag) {\n        while (!stack.isEmpty()) {\n            if (last().tag().canContain(tag))\n                return last();\n            else\n                stack.removeLast();\n        }\n        return null;\n    }\n\n```",
            "method_doc": "Pops elements from the stack until finding a container that can hold the specified tag, using method \"last()\" to check current stack top."
        }
    }
}