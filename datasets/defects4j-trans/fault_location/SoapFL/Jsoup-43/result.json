{
    "buggy_classes": [
        "org.jsoup.nodes.Element",
        "org.jsoup.nodes.Node"
    ],
    "buggy_methods": [
        {
            "method_name": "org.jsoup.nodes.Element::indexInList(Element,List)",
            "method_code": "```java\n    private static <E extends Element> Integer indexInList(Element TransVarNewSearchElement, List<E> TransVarSearchElement) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Validate.notNull(TransVarNewSearchElement);\n        Validate.notNull(TransVarSearchElement);\n\n        int TransVarIndex = 0;\n        while (!(!(TransVarIndex < TransVarSearchElement.size()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            E TransVarNewElement = TransVarSearchElement.get(TransVarIndex);\n            if (!(!(TransVarNewElement.equals(TransVarNewSearchElement))))\n                return TransVarIndex;\n            TransVarIndex++;\n        }\n        return null;\n    }\n\n```",
            "method_doc": "Finds the index of an element in a list by iterating and comparing elements using method \"equals(Object)\".",
            "class_name": "org.jsoup.nodes.Element",
            "class_doc": " A HTML element consists of a tag name, attributes, and child nodes (including text nodes and other elements).  From an Element, you can extract data, traverse the node graph, and manipulate the HTML.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it uses element equality comparison (TransVarNewElement.equals(TransVarNewSearchElement)) to find the index, but when elements have duplicate content, they may be considered equal even though they are different sibling elements in the DOM structure. This explains why both tests fail with duplicate content - the method incorrectly identifies elements as equal based on content rather than their actual position in the sibling list, leading to wrong sibling indices and navigation results."
        },
        {
            "method_name": "org.jsoup.nodes.Element::nextElementSibling()",
            "method_code": "```java\n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n```",
            "method_doc": " Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,  the {@code nextElementSibling} of the first {@code p} is the second {@code p}. <p> This is similar to {@link #nextSibling()}, but specifically finds only Elements </p> @return the next element, or null if there is no next element @see #previousElementSibling() ",
            "class_name": "org.jsoup.nodes.Element",
            "class_doc": " A HTML element consists of a tag name, attributes, and child nodes (including text nodes and other elements).  From an Element, you can extract data, traverse the node graph, and manipulate the HTML.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 8,
            "reason": "#8# The nextElementSibling() method is highly suspicious because it directly handles sibling element navigation, which is the core functionality failing in both tests. The method uses index-based lookup from the parent's children list, and if there's an issue with how the index is calculated or maintained (particularly when dealing with duplicate elements), it would cause exactly the failures observed where sibling relationships are incorrectly determined."
        },
        {
            "method_name": "org.jsoup.nodes.Element::elementSiblingIndex()",
            "method_code": "```java\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n```",
            "method_doc": " Get the list index of this element in its element sibling list. I.e. if this is the first element sibling, returns 0. @return position in element sibling list ",
            "class_name": "org.jsoup.nodes.Element",
            "class_doc": " A HTML element consists of a tag name, attributes, and child nodes (including text nodes and other elements).  From an Element, you can extract data, traverse the node graph, and manipulate the HTML.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 8,
            "reason": "#8# The elementSiblingIndex() method is highly suspicious because it directly calculates sibling positions and both test failures involve sibling indexing and navigation. The method uses parent().children() to determine position, which may not properly handle cases with duplicate content elements. The first test fails on sibling index assertion, and the second test shows sibling navigation issues that could stem from incorrect indexing. The method's simple implementation suggests it may not account for edge cases with identical sibling elements."
        },
        {
            "method_name": "org.jsoup.nodes.Node::nextSibling()",
            "method_code": "```java\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n```",
            "method_doc": " Get this node's next sibling. @return next sibling, or null if this is the last sibling ",
            "class_name": "org.jsoup.nodes.Node",
            "class_doc": " The base, abstract Node model. Elements, Documents, Comments etc are all Node instances. ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 8,
            "reason": "#8# The nextSibling() method is highly suspicious because it directly implements sibling traversal logic that is failing in both test cases. The method uses siblingIndex+1 to get the next sibling, but if the siblingIndex values are incorrect (as shown in testElementSiblingIndexSameContent), this will return wrong siblings. The testGetSiblingsWithDuplicateContent failure shows exactly this issue - when navigating through siblings with duplicate content, the method returns incorrect elements due to faulty indexing. Since both failed tests involve sibling navigation and the core logic for getting next siblings is implemented here, this is very likely the best location to fix."
        },
        {
            "method_name": "org.jsoup.nodes.Element::previousElementSibling()",
            "method_code": "```java\n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n```",
            "method_doc": " Gets the previous element sibling of this element. @return the previous element, or null if there is no previous element @see #nextElementSibling() ",
            "class_name": "org.jsoup.nodes.Element",
            "class_doc": " A HTML element consists of a tag name, attributes, and child nodes (including text nodes and other elements).  From an Element, you can extract data, traverse the node graph, and manipulate the HTML.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 3,
            "reason": "#3# The previousElementSibling() method appears to be correctly implemented - it simply gets the parent's children list and returns the element at index-1. The real issue likely lies in the elementSiblingIndex() method or the sibling navigation logic that maintains the children list structure, as both test failures involve sibling indexing and traversal problems with duplicate content elements."
        },
        {
            "method_name": "org.jsoup.nodes.Element::equals(Object)",
            "method_code": "```java\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return tag.equals(element.tag);\n    }\n\n```",
            "method_doc": "Checks equality by comparing tags after verifying class and superclass equality.",
            "class_name": "org.jsoup.nodes.Element",
            "class_doc": " A HTML element consists of a tag name, attributes, and child nodes (including text nodes and other elements).  From an Element, you can extract data, traverse the node graph, and manipulate the HTML.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 3,
            "reason": "#3# The equals method compares elements based on tag equality, but the test failures involve sibling indexing and navigation issues with duplicate content, suggesting the problem is more likely in sibling relationship management rather than element equality comparison."
        },
        {
            "method_name": "org.jsoup.nodes.Node::setSiblingIndex(int)",
            "method_code": "```java\n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n```",
            "method_doc": "Sets the sibling index for this node. Updates the siblingIndex field directly.",
            "class_name": "org.jsoup.nodes.Node",
            "class_doc": " The base, abstract Node model. Elements, Documents, Comments etc are all Node instances. ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve sibling element operations** - `elementSiblingIndex()` and sibling navigation methods (`previousElementSibling()`, `nextElementSibling()`, etc.)\n\n2. **Both failures occur when dealing with duplicate content** - The tests specifically use elements with identical text content (\"One\" in the first test, \"this\" in the second test)\n\n3. **The failures suggest indexing/traversal issues** - The first test shows incorrect sibling indexing, while the second test shows incorrect sibling navigation\n\n## Recommended Possible Defects in Production Code:\n\nThe most likely defect is in the **sibling indexing and traversal logic** within the `Element` class, specifically in methods that handle sibling relationships. The evidence suggests:\n\n1. **Defect in `elementSiblingIndex()` method**: The method appears to be incorrectly calculating the position of elements among their siblings, particularly when siblings have identical content. This could be due to:\n   - Incorrect counting logic that doesn't properly handle duplicate elements\n   - Off-by-one errors in the indexing algorithm\n   - Dependency on element content/text for indexing rather than structural position\n\n2. **Defect in sibling navigation methods** (`nextElementSibling()`, `previousElementSibling()`, etc.): These methods seem to be skipping over elements or returning incorrect siblings when duplicate content is present. This could be caused by:\n   - Faulty linked list traversal in the sibling chain\n   - Incorrect filtering or comparison logic that mistakenly treats duplicate-content elements as the same element\n   - Problems with the internal sibling pointer management\n\nThe root cause likely lies in how the DOM tree maintains and traverses sibling relationships, particularly in scenarios where multiple sibling elements share identical characteristics (like text content). The production code may be using content-based comparisons instead of structural position for sibling operations, or there may be issues with how sibling indices are calculated and maintained.",
            "test_suite": "org.jsoup.nodes.ElementTest",
            "score": 2,
            "reason": "#2# The setSiblingIndex method simply assigns a value to a field and doesn't contain any complex logic that could cause the sibling indexing issues. The actual problems likely lie in the methods that calculate and use sibling indices, such as elementSiblingIndex() and sibling navigation methods, which rely on proper sibling index management throughout the DOM structure."
        }
    ],
    "buggy_codes": {
        "org.jsoup.nodes.Element::indexInList(Element,List)": {
            "method_name": "org.jsoup.nodes.Element::indexInList(Element,List)",
            "method_code": "```java\n    private static <E extends Element> Integer indexInList(Element TransVarNewSearchElement, List<E> TransVarSearchElement) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Validate.notNull(TransVarNewSearchElement);\n        Validate.notNull(TransVarSearchElement);\n\n        int TransVarIndex = 0;\n        while (!(!(TransVarIndex < TransVarSearchElement.size()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            E TransVarNewElement = TransVarSearchElement.get(TransVarIndex);\n            if (!(!(TransVarNewElement.equals(TransVarNewSearchElement))))\n                return TransVarIndex;\n            TransVarIndex++;\n        }\n        return null;\n    }\n\n```",
            "method_doc": "Finds the index of an element in a list by iterating and comparing elements using method \"equals(Object)\"."
        },
        "org.jsoup.nodes.Element::nextElementSibling()": {
            "method_name": "org.jsoup.nodes.Element::nextElementSibling()",
            "method_code": "```java\n    public Element nextElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (siblings.size() > index+1)\n            return siblings.get(index+1);\n        else\n            return null;\n    }\n\n```",
            "method_doc": " Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,  the {@code nextElementSibling} of the first {@code p} is the second {@code p}. <p> This is similar to {@link #nextSibling()}, but specifically finds only Elements </p> @return the next element, or null if there is no next element @see #previousElementSibling() "
        },
        "org.jsoup.nodes.Element::elementSiblingIndex()": {
            "method_name": "org.jsoup.nodes.Element::elementSiblingIndex()",
            "method_code": "```java\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n```",
            "method_doc": " Get the list index of this element in its element sibling list. I.e. if this is the first element sibling, returns 0. @return position in element sibling list "
        },
        "org.jsoup.nodes.Element::previousElementSibling()": {
            "method_name": "org.jsoup.nodes.Element::previousElementSibling()",
            "method_code": "```java\n    public Element previousElementSibling() {\n        if (parentNode == null) return null;\n        List<Element> siblings = parent().children();\n        Integer index = indexInList(this, siblings);\n        Validate.notNull(index);\n        if (index > 0)\n            return siblings.get(index-1);\n        else\n            return null;\n    }\n\n```",
            "method_doc": " Gets the previous element sibling of this element. @return the previous element, or null if there is no previous element @see #nextElementSibling() "
        },
        "org.jsoup.nodes.Element::equals(Object)": {
            "method_name": "org.jsoup.nodes.Element::equals(Object)",
            "method_code": "```java\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return tag.equals(element.tag);\n    }\n\n```",
            "method_doc": "Checks equality by comparing tags after verifying class and superclass equality."
        },
        "org.jsoup.nodes.Node::setSiblingIndex(int)": {
            "method_name": "org.jsoup.nodes.Node::setSiblingIndex(int)",
            "method_code": "```java\n    protected void setSiblingIndex(int siblingIndex) {\n        this.siblingIndex = siblingIndex;\n    }\n\n```",
            "method_doc": "Sets the sibling index for this node. Updates the siblingIndex field directly."
        },
        "org.jsoup.nodes.Node::nextSibling()": {
            "method_name": "org.jsoup.nodes.Node::nextSibling()",
            "method_code": "```java\n    public Node nextSibling() {\n        if (parentNode == null)\n            return null; // root\n        \n        final List<Node> siblings = parentNode.childNodes;\n        final int index = siblingIndex+1;\n        if (siblings.size() > index)\n            return siblings.get(index);\n        else\n            return null;\n    }\n\n```",
            "method_doc": " Get this node's next sibling. @return next sibling, or null if this is the last sibling "
        }
    }
}