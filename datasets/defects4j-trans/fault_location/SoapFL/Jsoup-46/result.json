{
    "buggy_classes": [
        "org.jsoup.helper.DataUtil"
    ],
    "buggy_methods": [
        {
            "method_name": "org.jsoup.helper.DataUtil::parseByteData(ByteBuffer,String,String,Parser)",
            "method_code": "```java\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n```",
            "method_doc": "todo - this is getting gnarly. needs a rewrite.",
            "class_name": "org.jsoup.helper.DataUtil",
            "class_doc": " Internal static utilities for handling data.  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves charset encoding issues during HTML parsing and serialization roundtrips, specifically with Shift_JIS encoding and entity handling.\n\n**Key Observations:**\n1. The test fails when checking for the presence of '?' characters in the output\n2. The issue occurs during a charset roundtrip (ASCII input \u2192 Shift_JIS parsing \u2192 Shift_JIS output)\n3. The non-breaking space entity (&nbsp;) is not being properly preserved\n4. The failure suggests character encoding problems where valid characters are being replaced with replacement characters ('?')\n\n## Recommended Possible Defects in Production Code\n\nBased on the test behavior, I recommend investigating these potential defects in the Jsoup production code:\n\n### 1. **Charset Detection and Application in InputStream Parsing**\n**Location:** `Jsoup.parse(InputStream, String, String)` method and related charset detection logic\n**Defect:** The charset detection from meta tags may not be properly handling Shift_JIS encoding when the input stream uses ASCII bytes. The production code might be failing to correctly apply the detected Shift_JIS charset during parsing, leading to incorrect character decoding.\n\n### 2. **Entity Encoding in Shift_JIS Output**\n**Location:** Document serialization and entity escaping logic, particularly in `OutputSettings` and charset encoding components\n**Defect:** When serializing HTML with Shift_JIS charset and xhtml escape mode, the production code may be incorrectly encoding the non-breaking space character (U+00A0) or failing to properly represent it as an entity, causing it to be replaced with '?' during the byte conversion.\n\n### 3. **Charset Roundtrip Consistency**\n**Location:** Charset handling during both parsing and serialization phases\n**Defect:** There may be an inconsistency between how charset is handled during document parsing versus document serialization. The production code might be using different charset handling logic for input vs output, breaking the roundtrip integrity.\n\n### 4. **Byte-to-Character Mapping in Shift_JIS**\n**Location:** Low-level charset encoding/decoding operations\n**Defect:** The production code may have issues with the specific byte sequences that represent the non-breaking space character in Shift_JIS encoding, either during decoding from the input stream or during encoding to the output stream.\n\nThe core issue appears to be in how Jsoup handles character set transitions and entity preservation when dealing with specific encodings like Shift_JIS, particularly in scenarios involving meta tag charset declarations and xhtml escape modes.",
            "test_suite": "org.jsoup.nodes.DocumentTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles charset detection and decoding from byte data, which directly relates to the Shift_JIS encoding issue in the test. The method contains logic for detecting charset from meta tags (like the one in the test), re-decoding when a different charset is found, and handling BOM characters. The test failure involves incorrect character encoding during the roundtrip process, and this method is responsible for the initial parsing and charset application that could cause the non-breaking space entity to be improperly decoded or encoded, leading to '?' characters in the output."
        },
        {
            "method_name": "org.jsoup.helper.DataUtil::load(InputStream,String,String)",
            "method_code": "```java\n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n```",
            "method_doc": " Parses a Document from an input steam. @param in input stream to parse. You will need to close it. @param charsetName character set of input @param baseUri base URI of document, to resolve relative links against @return Document @throws IOException on IO error ",
            "class_name": "org.jsoup.helper.DataUtil",
            "class_doc": " Internal static utilities for handling data.  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves charset encoding issues during HTML parsing and serialization roundtrips, specifically with Shift_JIS encoding and entity handling.\n\n**Key Observations:**\n1. The test fails when checking for the presence of '?' characters in the output\n2. The issue occurs during a charset roundtrip (ASCII input \u2192 Shift_JIS parsing \u2192 Shift_JIS output)\n3. The non-breaking space entity (&nbsp;) is not being properly preserved\n4. The failure suggests character encoding problems where valid characters are being replaced with replacement characters ('?')\n\n## Recommended Possible Defects in Production Code\n\nBased on the test behavior, I recommend investigating these potential defects in the Jsoup production code:\n\n### 1. **Charset Detection and Application in InputStream Parsing**\n**Location:** `Jsoup.parse(InputStream, String, String)` method and related charset detection logic\n**Defect:** The charset detection from meta tags may not be properly handling Shift_JIS encoding when the input stream uses ASCII bytes. The production code might be failing to correctly apply the detected Shift_JIS charset during parsing, leading to incorrect character decoding.\n\n### 2. **Entity Encoding in Shift_JIS Output**\n**Location:** Document serialization and entity escaping logic, particularly in `OutputSettings` and charset encoding components\n**Defect:** When serializing HTML with Shift_JIS charset and xhtml escape mode, the production code may be incorrectly encoding the non-breaking space character (U+00A0) or failing to properly represent it as an entity, causing it to be replaced with '?' during the byte conversion.\n\n### 3. **Charset Roundtrip Consistency**\n**Location:** Charset handling during both parsing and serialization phases\n**Defect:** There may be an inconsistency between how charset is handled during document parsing versus document serialization. The production code might be using different charset handling logic for input vs output, breaking the roundtrip integrity.\n\n### 4. **Byte-to-Character Mapping in Shift_JIS**\n**Location:** Low-level charset encoding/decoding operations\n**Defect:** The production code may have issues with the specific byte sequences that represent the non-breaking space character in Shift_JIS encoding, either during decoding from the input stream or during encoding to the output stream.\n\nThe core issue appears to be in how Jsoup handles character set transitions and entity preservation when dealing with specific encodings like Shift_JIS, particularly in scenarios involving meta tag charset declarations and xhtml escape modes.",
            "test_suite": "org.jsoup.nodes.DocumentTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the core parsing logic from InputStream to Document, including charset processing. The test failure involves charset encoding issues during HTML parsing with Shift_JIS, and this method is responsible for reading the input stream and parsing byte data with the specified charset. The problem likely occurs in how this method or its dependencies handle charset detection and application when the input stream contains ASCII bytes but the document declares Shift_JIS encoding via meta tag."
        },
        {
            "method_name": "org.jsoup.helper.DataUtil::getCharsetFromContentType(String)",
            "method_code": "```java\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            if (charset.length() == 0) return null;\n            try {\n                if (Charset.isSupported(charset)) return charset;\n                charset = charset.toUpperCase(Locale.ENGLISH);\n                if (Charset.isSupported(charset)) return charset;\n            } catch (IllegalCharsetNameException e) {\n                // if our advanced charset matching fails.... we just take the default\n                return null;\n            }\n        }\n        return null;\n    }\n\n```",
            "method_doc": " Parse out a charset from a content type header. If the charset is not supported, returns null (so the default will kick in.) @param contentType e.g. \"text/html; charset=EUC-JP\" @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased. ",
            "class_name": "org.jsoup.helper.DataUtil",
            "class_doc": " Internal static utilities for handling data.  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves charset encoding issues during HTML parsing and serialization roundtrips, specifically with Shift_JIS encoding and entity handling.\n\n**Key Observations:**\n1. The test fails when checking for the presence of '?' characters in the output\n2. The issue occurs during a charset roundtrip (ASCII input \u2192 Shift_JIS parsing \u2192 Shift_JIS output)\n3. The non-breaking space entity (&nbsp;) is not being properly preserved\n4. The failure suggests character encoding problems where valid characters are being replaced with replacement characters ('?')\n\n## Recommended Possible Defects in Production Code\n\nBased on the test behavior, I recommend investigating these potential defects in the Jsoup production code:\n\n### 1. **Charset Detection and Application in InputStream Parsing**\n**Location:** `Jsoup.parse(InputStream, String, String)` method and related charset detection logic\n**Defect:** The charset detection from meta tags may not be properly handling Shift_JIS encoding when the input stream uses ASCII bytes. The production code might be failing to correctly apply the detected Shift_JIS charset during parsing, leading to incorrect character decoding.\n\n### 2. **Entity Encoding in Shift_JIS Output**\n**Location:** Document serialization and entity escaping logic, particularly in `OutputSettings` and charset encoding components\n**Defect:** When serializing HTML with Shift_JIS charset and xhtml escape mode, the production code may be incorrectly encoding the non-breaking space character (U+00A0) or failing to properly represent it as an entity, causing it to be replaced with '?' during the byte conversion.\n\n### 3. **Charset Roundtrip Consistency**\n**Location:** Charset handling during both parsing and serialization phases\n**Defect:** There may be an inconsistency between how charset is handled during document parsing versus document serialization. The production code might be using different charset handling logic for input vs output, breaking the roundtrip integrity.\n\n### 4. **Byte-to-Character Mapping in Shift_JIS**\n**Location:** Low-level charset encoding/decoding operations\n**Defect:** The production code may have issues with the specific byte sequences that represent the non-breaking space character in Shift_JIS encoding, either during decoding from the input stream or during encoding to the output stream.\n\nThe core issue appears to be in how Jsoup handles character set transitions and entity preservation when dealing with specific encodings like Shift_JIS, particularly in scenarios involving meta tag charset declarations and xhtml escape modes.",
            "test_suite": "org.jsoup.nodes.DocumentTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles charset extraction from content type headers, and the test failure specifically involves Shift_JIS charset detection. The method's charset matching logic may not properly handle the \"Shift_JIS\" charset name format, potentially returning null instead of the correct charset, which would cause default charset behavior and lead to character encoding issues during the roundtrip process."
        }
    ],
    "buggy_codes": {
        "org.jsoup.helper.DataUtil::load(InputStream,String,String)": {
            "method_name": "org.jsoup.helper.DataUtil::load(InputStream,String,String)",
            "method_code": "```java\n    public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n        ByteBuffer byteData = readToByteBuffer(in);\n        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n    }\n\n```",
            "method_doc": " Parses a Document from an input steam. @param in input stream to parse. You will need to close it. @param charsetName character set of input @param baseUri base URI of document, to resolve relative links against @return Document @throws IOException on IO error "
        },
        "org.jsoup.helper.DataUtil::parseByteData(ByteBuffer,String,String,Parser)": {
            "method_name": "org.jsoup.helper.DataUtil::parseByteData(ByteBuffer,String,String,Parser)",
            "method_code": "```java\n    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n        String docData;\n        Document doc = null;\n        if (charsetName == null) { // determine from meta. safe parse as UTF-8\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) { // if not found, will keep utf-8 as best attempt\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n```",
            "method_doc": "todo - this is getting gnarly. needs a rewrite."
        },
        "org.jsoup.helper.DataUtil::getCharsetFromContentType(String)": {
            "method_name": "org.jsoup.helper.DataUtil::getCharsetFromContentType(String)",
            "method_code": "```java\n    static String getCharsetFromContentType(String contentType) {\n        if (contentType == null) return null;\n        Matcher m = charsetPattern.matcher(contentType);\n        if (m.find()) {\n            String charset = m.group(1).trim();\n            charset = charset.replace(\"charset=\", \"\");\n            if (charset.length() == 0) return null;\n            try {\n                if (Charset.isSupported(charset)) return charset;\n                charset = charset.toUpperCase(Locale.ENGLISH);\n                if (Charset.isSupported(charset)) return charset;\n            } catch (IllegalCharsetNameException e) {\n                // if our advanced charset matching fails.... we just take the default\n                return null;\n            }\n        }\n        return null;\n    }\n\n```",
            "method_doc": " Parse out a charset from a content type header. If the charset is not supported, returns null (so the default will kick in.) @param contentType e.g. \"text/html; charset=EUC-JP\" @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased. "
        }
    }
}