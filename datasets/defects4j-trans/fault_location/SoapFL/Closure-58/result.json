{
    "buggy_classes": [
        "com.google.javascript.jscomp.LiveVariablesAnalysis"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.LiveVariablesAnalysis::addToSetIfLocal(Node,BitSet)",
            "method_code": "```java\n  private void addToSetIfLocal(Node node, BitSet set) {\n    Preconditions.checkState(NodeUtil.isName(node));\n    String name = node.getString();\n    if (!jsScope.isDeclared(name, false)) {\n      return;\n    }\n    Var var = jsScope.getVar(name);\n    if (!escaped.contains(var)) {\n      set.set(var.index);\n    }\n  }\n\n```",
            "method_doc": "Adds variable to BitSet if it's a local non-escaped variable.",
            "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
            "class_doc": " Compute the \"liveness\" of all local variables. A variable is \"live\" at a point of a program if the value it is currently holding might be read later. Otherwise, the variable is considered \"dead\" if we know for sure that it will no longer be read. Dead variables are candidates for dead assignment elimination and variable name sharing. The worst case safe assumption is to assume that all variables are live. In that case, we will have no opportunity for optimizations. This is especially the case within a TRY block when an assignment is not guaranteed to take place. We bail out by assuming that all variables are live. <p> Due to the possibility of inner functions and closures, certain \"local\" variables can escape the function. These variables will be considered as global and they can be retrieved with {@link #getEscapedLocals()}.  ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Scenario:**\n- The test is verifying live variable analysis for a `for-in` loop with an expression (`a[1]`) as the left-hand side\n- The test expects variable `a` to be live before the loop because `a[1]` requires accessing the base array `a`\n- The failure occurs in `LiveVariablesAnalysis.addToSetIfLocal` method\n\n**2. Stack Trace Analysis:**\n- The failure originates from `Preconditions.checkState()` in `LiveVariablesAnalysis.addToSetIfLocal` at line 295\n- This method is called during `computeGenKill` at line 226, which is part of the data flow analysis\n- The `IllegalStateException` suggests an invariant violation in the liveness analysis logic\n\n**3. Common Pattern Identified:**\nThe failure occurs specifically when handling complex expressions (array access `a[1]`) in the left-hand side of a `for-in` loop, rather than simple variable names.\n\n## Recommended Defect in Production Code\n\n**Possible Defect:** The `LiveVariablesAnalysis.addToSetIfLocal` method likely fails to properly handle expressions (like `a[1]`) in the left-hand side of `for-in` loops, causing it to encounter an unexpected node type or state when processing the AST.\n\n**Root Cause Hypothesis:** The production code probably assumes that the left-hand side of a `for-in` loop is always a simple variable name, but when it encounters an expression like `a[1]`, it either:\n- Fails to recursively analyze the base variable `a` within the expression\n- Incorrectly handles the GETPROP or GETELEM node types in the AST\n- Violates a state assumption about what types of nodes can appear in this position\n\n**Specific Location:** The defect is likely in `com.google.javascript.jscomp.LiveVariablesAnalysis.addToSetIfLocal` method around line 295, where it performs state validation that fails when processing array access expressions in `for-in` loop targets.\n\nThe fix should ensure that when analyzing expressions in `for-in` loop left-hand sides, the code properly identifies and handles all base variables that need to be considered live.",
            "test_suite": "com.google.javascript.jscomp.LiveVariableAnalysisTest",
            "score": 9,
            "reason": "#9# The method addToSetIfLocal is highly suspicious because it contains the exact line (Preconditions.checkState) that throws the IllegalStateException in the stack trace. The method assumes all nodes passed to it are NAME nodes (simple variables), but the test case uses an array access expression a[1] in the for-in loop, which would be a GETELEM node, not a NAME node. This violates the precondition check and causes the test failure. The method needs to handle complex expressions by recursively analyzing their base variables."
        },
        {
            "method_name": "com.google.javascript.jscomp.LiveVariablesAnalysis::computeGenKill(Node,BitSet,BitSet,boolean)",
            "method_code": "```java\n  private void computeGenKill(Node TransVarNode, BitSet TransVarGenerated, BitSet TransVarKill_set,\n      boolean TransVarIsConditional) {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))) {\n            TransFallThroughFlag0 = true;\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))) {\n            TransFallThroughFlag0 = true;\n            computeGenKill(NodeUtil.getConditionExpression(TransVarNode), TransVarGenerated, TransVarKill_set,\n                    TransVarIsConditional);\n        return;\n          }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(!NodeUtil.isForIn(TransVarNode)))) {\n                computeGenKill(NodeUtil.getConditionExpression(TransVarNode), TransVarGenerated, TransVarKill_set,\n                        TransVarIsConditional);\n          } else {\n                Node TransVarLeft = TransVarNode.getFirstChild();\n                Node TransVarRight = TransVarLeft.getNext();\n                if (!(!(NodeUtil.isVar(TransVarLeft)))) {\n                    TransVarLeft = TransVarLeft.getLastChild();\n          }\n                addToSetIfLocal(TransVarLeft, TransVarKill_set);\n                addToSetIfLocal(TransVarLeft, TransVarGenerated);\n                computeGenKill(TransVarRight, TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        }\n        return;\n            }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))) {\n            TransFallThroughFlag0 = true;\n            Node TransVarChild = TransVarNode.getFirstChild();\n            while (!(!(TransVarChild != null))) {\n                if (!(!(TransVarChild.hasChildren()))) {\n                    computeGenKill(TransVarChild.getFirstChild(), TransVarGenerated, TransVarKill_set,\n                            TransVarIsConditional);\n                    if (!(!(!TransVarIsConditional))) {\n                        addToSetIfLocal(TransVarChild, TransVarKill_set);\n          }\n        }\n                TransVarChild = TransVarChild.getNext();\n            }\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))) {\n            TransFallThroughFlag0 = true;\n            computeGenKill(TransVarNode.getFirstChild(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n            computeGenKill(TransVarNode.getLastChild(), TransVarGenerated, TransVarKill_set, true);\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))) {\n            TransFallThroughFlag0 = true;\n            computeGenKill(TransVarNode.getFirstChild(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n            computeGenKill(TransVarNode.getFirstChild().getNext(), TransVarGenerated, TransVarKill_set, true);\n            computeGenKill(TransVarNode.getLastChild(), TransVarGenerated, TransVarKill_set, true);\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(isArgumentsName(TransVarNode)))) {\n          markAllParametersEscaped();\n        } else {\n                addToSetIfLocal(TransVarNode, TransVarGenerated);\n        }\n        return;\n          }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            if (!(!(NodeUtil.isAssignmentOp(TransVarNode) && NodeUtil.isName(TransVarNode.getFirstChild())))) {\n                Node TransVarTemp = TransVarNode.getFirstChild();\n                if (!(!(!TransVarIsConditional))) {\n                    addToSetIfLocal(TransVarTemp, TransVarKill_set);\n          }\n                if (!(!(!NodeUtil.isAssign(TransVarNode)))) {\n                    addToSetIfLocal(TransVarTemp, TransVarGenerated);\n                }\n                computeGenKill(TransVarTemp.getNext(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        } else {\n                Node TransVarChildNode = TransVarNode.getFirstChild();\n                while (!(!(TransVarChildNode != null))) {\n                    computeGenKill(TransVarChildNode, TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n                    TransVarChildNode = TransVarChildNode.getNext();\n          }\n        }\n        return;\n        }\n    }\n  }\n\n```",
            "method_doc": " Computes the GEN and KILL set.  @param n Root node. @param gen Local variables that are live because of the instruction at {@code n} will be added to this set. @param kill Local variables that are killed because of the instruction at {@code n} will be added to this set. @param conditional {@code true} if any assignments encountered are conditionally executed. These assignments might not kill a variable. ",
            "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
            "class_doc": " Compute the \"liveness\" of all local variables. A variable is \"live\" at a point of a program if the value it is currently holding might be read later. Otherwise, the variable is considered \"dead\" if we know for sure that it will no longer be read. Dead variables are candidates for dead assignment elimination and variable name sharing. The worst case safe assumption is to assume that all variables are live. In that case, we will have no opportunity for optimizations. This is especially the case within a TRY block when an assignment is not guaranteed to take place. We bail out by assuming that all variables are live. <p> Due to the possibility of inner functions and closures, certain \"local\" variables can escape the function. These variables will be considered as global and they can be retrieved with {@link #getEscapedLocals()}.  ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Scenario:**\n- The test is verifying live variable analysis for a `for-in` loop with an expression (`a[1]`) as the left-hand side\n- The test expects variable `a` to be live before the loop because `a[1]` requires accessing the base array `a`\n- The failure occurs in `LiveVariablesAnalysis.addToSetIfLocal` method\n\n**2. Stack Trace Analysis:**\n- The failure originates from `Preconditions.checkState()` in `LiveVariablesAnalysis.addToSetIfLocal` at line 295\n- This method is called during `computeGenKill` at line 226, which is part of the data flow analysis\n- The `IllegalStateException` suggests an invariant violation in the liveness analysis logic\n\n**3. Common Pattern Identified:**\nThe failure occurs specifically when handling complex expressions (array access `a[1]`) in the left-hand side of a `for-in` loop, rather than simple variable names.\n\n## Recommended Defect in Production Code\n\n**Possible Defect:** The `LiveVariablesAnalysis.addToSetIfLocal` method likely fails to properly handle expressions (like `a[1]`) in the left-hand side of `for-in` loops, causing it to encounter an unexpected node type or state when processing the AST.\n\n**Root Cause Hypothesis:** The production code probably assumes that the left-hand side of a `for-in` loop is always a simple variable name, but when it encounters an expression like `a[1]`, it either:\n- Fails to recursively analyze the base variable `a` within the expression\n- Incorrectly handles the GETPROP or GETELEM node types in the AST\n- Violates a state assumption about what types of nodes can appear in this position\n\n**Specific Location:** The defect is likely in `com.google.javascript.jscomp.LiveVariablesAnalysis.addToSetIfLocal` method around line 295, where it performs state validation that fails when processing array access expressions in `for-in` loop targets.\n\nThe fix should ensure that when analyzing expressions in `for-in` loop left-hand sides, the code properly identifies and handles all base variables that need to be considered live.",
            "test_suite": "com.google.javascript.jscomp.LiveVariableAnalysisTest",
            "score": 9,
            "reason": "#9# The method computeGenKill is highly suspicious because the stack trace shows the failure occurs in addToSetIfLocal called from computeGenKill at line 226. The test specifically fails when processing a for-in loop with an expression (a[1]) as the left-hand side, and the code in the FOR case handles for-in loops differently from regular for loops. The current implementation assumes the left-hand side of for-in is always a simple variable name, but when it encounters an expression like a[1], it fails to properly handle the complex node structure, leading to the IllegalStateException in addToSetIfLocal."
        },
        {
            "method_name": "com.google.javascript.jscomp.LiveVariablesAnalysis::flowThrough(Node,LiveVariableLattice)",
            "method_code": "```java\n  @Override\n  LiveVariableLattice flowThrough(Node node, LiveVariableLattice input) {\n    final BitSet gen = new BitSet(input.liveSet.size());\n    final BitSet kill = new BitSet(input.liveSet.size());\n\n    // Make kills conditional if the node can end abruptly by an exception.\n    boolean conditional = false;\n    List<DiGraphEdge<Node, Branch>> edgeList = getCfg().getOutEdges(node);\n    for (DiGraphEdge<Node, Branch> edge : edgeList) {\n      if (Branch.ON_EX.equals(edge.getValue())) {\n        conditional = true;\n      }\n    }\n    computeGenKill(node, gen, kill, conditional);\n    LiveVariableLattice result = new LiveVariableLattice(input);\n    // L_in = L_out - Kill + Gen\n    result.liveSet.andNot(kill);\n    result.liveSet.or(gen);\n    return result;\n  }\n\n```",
            "method_doc": "Computes new lattice state by applying GEN/KILL sets to input; this method calls method \"computeGenKill\" to generate GEN/KILL sets for the node.",
            "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
            "class_doc": " Compute the \"liveness\" of all local variables. A variable is \"live\" at a point of a program if the value it is currently holding might be read later. Otherwise, the variable is considered \"dead\" if we know for sure that it will no longer be read. Dead variables are candidates for dead assignment elimination and variable name sharing. The worst case safe assumption is to assume that all variables are live. In that case, we will have no opportunity for optimizations. This is especially the case within a TRY block when an assignment is not guaranteed to take place. We bail out by assuming that all variables are live. <p> Due to the possibility of inner functions and closures, certain \"local\" variables can escape the function. These variables will be considered as global and they can be retrieved with {@link #getEscapedLocals()}.  ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Scenario:**\n- The test is verifying live variable analysis for a `for-in` loop with an expression (`a[1]`) as the left-hand side\n- The test expects variable `a` to be live before the loop because `a[1]` requires accessing the base array `a`\n- The failure occurs in `LiveVariablesAnalysis.addToSetIfLocal` method\n\n**2. Stack Trace Analysis:**\n- The failure originates from `Preconditions.checkState()` in `LiveVariablesAnalysis.addToSetIfLocal` at line 295\n- This method is called during `computeGenKill` at line 226, which is part of the data flow analysis\n- The `IllegalStateException` suggests an invariant violation in the liveness analysis logic\n\n**3. Common Pattern Identified:**\nThe failure occurs specifically when handling complex expressions (array access `a[1]`) in the left-hand side of a `for-in` loop, rather than simple variable names.\n\n## Recommended Defect in Production Code\n\n**Possible Defect:** The `LiveVariablesAnalysis.addToSetIfLocal` method likely fails to properly handle expressions (like `a[1]`) in the left-hand side of `for-in` loops, causing it to encounter an unexpected node type or state when processing the AST.\n\n**Root Cause Hypothesis:** The production code probably assumes that the left-hand side of a `for-in` loop is always a simple variable name, but when it encounters an expression like `a[1]`, it either:\n- Fails to recursively analyze the base variable `a` within the expression\n- Incorrectly handles the GETPROP or GETELEM node types in the AST\n- Violates a state assumption about what types of nodes can appear in this position\n\n**Specific Location:** The defect is likely in `com.google.javascript.jscomp.LiveVariablesAnalysis.addToSetIfLocal` method around line 295, where it performs state validation that fails when processing array access expressions in `for-in` loop targets.\n\nThe fix should ensure that when analyzing expressions in `for-in` loop left-hand sides, the code properly identifies and handles all base variables that need to be considered live.",
            "test_suite": "com.google.javascript.jscomp.LiveVariableAnalysisTest",
            "score": 3,
            "reason": "#3# While the flowThrough method is involved in the data flow analysis process, the actual failure occurs in the computeGenKill method which is called from flowThrough. The stack trace shows the IllegalStateException originates from addToSetIfLocal called by computeGenKill, not directly from flowThrough. The flowThrough method itself appears to correctly implement the standard data flow equation (L_in = L_out - Kill + Gen), so the root cause is more likely in the computeGenKill or addToSetIfLocal methods that generate the GEN/KILL sets."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.LiveVariablesAnalysis::addToSetIfLocal(Node,BitSet)": {
            "method_name": "com.google.javascript.jscomp.LiveVariablesAnalysis::addToSetIfLocal(Node,BitSet)",
            "method_code": "```java\n  private void addToSetIfLocal(Node node, BitSet set) {\n    Preconditions.checkState(NodeUtil.isName(node));\n    String name = node.getString();\n    if (!jsScope.isDeclared(name, false)) {\n      return;\n    }\n    Var var = jsScope.getVar(name);\n    if (!escaped.contains(var)) {\n      set.set(var.index);\n    }\n  }\n\n```",
            "method_doc": "Adds variable to BitSet if it's a local non-escaped variable."
        },
        "com.google.javascript.jscomp.LiveVariablesAnalysis::computeGenKill(Node,BitSet,BitSet,boolean)": {
            "method_name": "com.google.javascript.jscomp.LiveVariablesAnalysis::computeGenKill(Node,BitSet,BitSet,boolean)",
            "method_code": "```java\n  private void computeGenKill(Node TransVarNode, BitSet TransVarGenerated, BitSet TransVarKill_set,\n      boolean TransVarIsConditional) {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))) {\n            TransFallThroughFlag0 = true;\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))) {\n            TransFallThroughFlag0 = true;\n            computeGenKill(NodeUtil.getConditionExpression(TransVarNode), TransVarGenerated, TransVarKill_set,\n                    TransVarIsConditional);\n        return;\n          }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(!NodeUtil.isForIn(TransVarNode)))) {\n                computeGenKill(NodeUtil.getConditionExpression(TransVarNode), TransVarGenerated, TransVarKill_set,\n                        TransVarIsConditional);\n          } else {\n                Node TransVarLeft = TransVarNode.getFirstChild();\n                Node TransVarRight = TransVarLeft.getNext();\n                if (!(!(NodeUtil.isVar(TransVarLeft)))) {\n                    TransVarLeft = TransVarLeft.getLastChild();\n          }\n                addToSetIfLocal(TransVarLeft, TransVarKill_set);\n                addToSetIfLocal(TransVarLeft, TransVarGenerated);\n                computeGenKill(TransVarRight, TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        }\n        return;\n            }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))) {\n            TransFallThroughFlag0 = true;\n            Node TransVarChild = TransVarNode.getFirstChild();\n            while (!(!(TransVarChild != null))) {\n                if (!(!(TransVarChild.hasChildren()))) {\n                    computeGenKill(TransVarChild.getFirstChild(), TransVarGenerated, TransVarKill_set,\n                            TransVarIsConditional);\n                    if (!(!(!TransVarIsConditional))) {\n                        addToSetIfLocal(TransVarChild, TransVarKill_set);\n          }\n        }\n                TransVarChild = TransVarChild.getNext();\n            }\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))) {\n            TransFallThroughFlag0 = true;\n            computeGenKill(TransVarNode.getFirstChild(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n            computeGenKill(TransVarNode.getLastChild(), TransVarGenerated, TransVarKill_set, true);\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))) {\n            TransFallThroughFlag0 = true;\n            computeGenKill(TransVarNode.getFirstChild(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n            computeGenKill(TransVarNode.getFirstChild().getNext(), TransVarGenerated, TransVarKill_set, true);\n            computeGenKill(TransVarNode.getLastChild(), TransVarGenerated, TransVarKill_set, true);\n        return;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(isArgumentsName(TransVarNode)))) {\n          markAllParametersEscaped();\n        } else {\n                addToSetIfLocal(TransVarNode, TransVarGenerated);\n        }\n        return;\n          }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            if (!(!(NodeUtil.isAssignmentOp(TransVarNode) && NodeUtil.isName(TransVarNode.getFirstChild())))) {\n                Node TransVarTemp = TransVarNode.getFirstChild();\n                if (!(!(!TransVarIsConditional))) {\n                    addToSetIfLocal(TransVarTemp, TransVarKill_set);\n          }\n                if (!(!(!NodeUtil.isAssign(TransVarNode)))) {\n                    addToSetIfLocal(TransVarTemp, TransVarGenerated);\n                }\n                computeGenKill(TransVarTemp.getNext(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        } else {\n                Node TransVarChildNode = TransVarNode.getFirstChild();\n                while (!(!(TransVarChildNode != null))) {\n                    computeGenKill(TransVarChildNode, TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n                    TransVarChildNode = TransVarChildNode.getNext();\n          }\n        }\n        return;\n        }\n    }\n  }\n\n```",
            "method_doc": " Computes the GEN and KILL set.  @param n Root node. @param gen Local variables that are live because of the instruction at {@code n} will be added to this set. @param kill Local variables that are killed because of the instruction at {@code n} will be added to this set. @param conditional {@code true} if any assignments encountered are conditionally executed. These assignments might not kill a variable. "
        },
        "com.google.javascript.jscomp.LiveVariablesAnalysis::flowThrough(Node,LiveVariableLattice)": {
            "method_name": "com.google.javascript.jscomp.LiveVariablesAnalysis::flowThrough(Node,LiveVariableLattice)",
            "method_code": "```java\n  @Override\n  LiveVariableLattice flowThrough(Node node, LiveVariableLattice input) {\n    final BitSet gen = new BitSet(input.liveSet.size());\n    final BitSet kill = new BitSet(input.liveSet.size());\n\n    // Make kills conditional if the node can end abruptly by an exception.\n    boolean conditional = false;\n    List<DiGraphEdge<Node, Branch>> edgeList = getCfg().getOutEdges(node);\n    for (DiGraphEdge<Node, Branch> edge : edgeList) {\n      if (Branch.ON_EX.equals(edge.getValue())) {\n        conditional = true;\n      }\n    }\n    computeGenKill(node, gen, kill, conditional);\n    LiveVariableLattice result = new LiveVariableLattice(input);\n    // L_in = L_out - Kill + Gen\n    result.liveSet.andNot(kill);\n    result.liveSet.or(gen);\n    return result;\n  }\n\n```",
            "method_doc": "Computes new lattice state by applying GEN/KILL sets to input; this method calls method \"computeGenKill\" to generate GEN/KILL sets for the node."
        }
    }
}