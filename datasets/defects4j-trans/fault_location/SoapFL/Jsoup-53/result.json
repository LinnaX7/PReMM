{
    "buggy_classes": [
        "org.jsoup.select.QueryParser"
    ],
    "buggy_methods": [
        {
            "method_name": "org.jsoup.select.QueryParser::byAttribute()",
            "method_code": "```java\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n```",
            "method_doc": "This method processes attribute selectors from token queues, handling various attribute matching operators and adding corresponding Attribute Evaluators to the evaluation list.",
            "class_name": "org.jsoup.select.QueryParser",
            "class_doc": " Parses a CSS selector into an Evaluator tree. ",
            "test_failure_causes": "Looking at the failed test and the analysis, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Common Pattern**: The test failure occurs when parsing CSS selectors with attribute values containing special characters like brackets. Specifically, the selector `div[data='End]']` fails to parse because the attribute value contains an unescaped closing bracket.\n\n**Key Observations**:\n1. The stack trace shows a `SelectorParseException` at `QueryParser.findElements()`\n2. The error message indicates: \"unexpected token at '''\" - suggesting the parser encounters issues with the quote handling\n3. The selector `div[data='End]']` contains a closing bracket `]` inside the single-quoted attribute value\n4. The parser seems to be interpreting the `]` inside the quotes as the end of the attribute selector rather than as part of the attribute value\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the **CSS selector parsing logic** in the `QueryParser` class, specifically in how it handles attribute selectors with special characters inside quoted attribute values.\n\n**Possible Root Cause**: The parser is not properly handling escaped characters or special characters within quoted attribute values in CSS selectors. When it encounters a `]` character inside single quotes, it's incorrectly treating it as the end of the attribute selector bracket rather than as a literal character within the attribute value.\n\n**Expected Behavior**: The parser should recognize that characters inside quoted attribute values (whether single or double quotes) should be treated as literal text, and special CSS selector characters like `]` should not terminate the attribute selector prematurely.\n\n**Files to Investigate**:\n- `org.jsoup.select.QueryParser` (specifically the attribute selector parsing logic)\n- `org.jsoup.select.Selector` (which uses QueryParser)\n\nThe fix would likely involve modifying the attribute selector parsing to properly handle special characters within quoted values, ensuring the parser maintains proper state about being inside quoted regions.",
            "test_suite": "org.jsoup.select.SelectorTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location that needs to be fixed because the issue occurs during attribute selector parsing with special characters inside quoted values. The method uses `tq.chompBalanced('[', ']')` to extract content between brackets, but this approach fails when the attribute value itself contains unescaped closing brackets, causing premature termination of the attribute selector parsing. The parser doesn't properly handle quoted content within attribute selectors, leading to the \"unexpected token\" error when encountering special characters like ']' inside quoted attribute values."
        },
        {
            "method_name": "org.jsoup.select.QueryParser::parse()",
            "method_code": "```java\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n```",
            "method_doc": " Parse the query @return Evaluator ",
            "class_name": "org.jsoup.select.QueryParser",
            "class_doc": " Parses a CSS selector into an Evaluator tree. ",
            "test_failure_causes": "Looking at the failed test and the analysis, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Common Pattern**: The test failure occurs when parsing CSS selectors with attribute values containing special characters like brackets. Specifically, the selector `div[data='End]']` fails to parse because the attribute value contains an unescaped closing bracket.\n\n**Key Observations**:\n1. The stack trace shows a `SelectorParseException` at `QueryParser.findElements()`\n2. The error message indicates: \"unexpected token at '''\" - suggesting the parser encounters issues with the quote handling\n3. The selector `div[data='End]']` contains a closing bracket `]` inside the single-quoted attribute value\n4. The parser seems to be interpreting the `]` inside the quotes as the end of the attribute selector rather than as part of the attribute value\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the **CSS selector parsing logic** in the `QueryParser` class, specifically in how it handles attribute selectors with special characters inside quoted attribute values.\n\n**Possible Root Cause**: The parser is not properly handling escaped characters or special characters within quoted attribute values in CSS selectors. When it encounters a `]` character inside single quotes, it's incorrectly treating it as the end of the attribute selector bracket rather than as a literal character within the attribute value.\n\n**Expected Behavior**: The parser should recognize that characters inside quoted attribute values (whether single or double quotes) should be treated as literal text, and special CSS selector characters like `]` should not terminate the attribute selector prematurely.\n\n**Files to Investigate**:\n- `org.jsoup.select.QueryParser` (specifically the attribute selector parsing logic)\n- `org.jsoup.select.Selector` (which uses QueryParser)\n\nThe fix would likely involve modifying the attribute selector parsing to properly handle special characters within quoted values, ensuring the parser maintains proper state about being inside quoted regions.",
            "test_suite": "org.jsoup.select.SelectorTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because the parse() method calls findElements() which is where the SelectorParseException occurs according to the stack trace, and the parse() method orchestrates the entire CSS selector parsing process including handling attribute selectors with special characters in quoted values."
        },
        {
            "method_name": "org.jsoup.select.QueryParser::parse(String)",
            "method_code": "```java\n    public static Evaluator parse(String query) {\n        QueryParser p = new QueryParser(query);\n        return p.parse();\n    }\n\n```",
            "method_doc": " Parse a CSS query into an Evaluator. @param query CSS query @return Evaluator ",
            "class_name": "org.jsoup.select.QueryParser",
            "class_doc": " Parses a CSS selector into an Evaluator tree. ",
            "test_failure_causes": "Looking at the failed test and the analysis, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Common Pattern**: The test failure occurs when parsing CSS selectors with attribute values containing special characters like brackets. Specifically, the selector `div[data='End]']` fails to parse because the attribute value contains an unescaped closing bracket.\n\n**Key Observations**:\n1. The stack trace shows a `SelectorParseException` at `QueryParser.findElements()`\n2. The error message indicates: \"unexpected token at '''\" - suggesting the parser encounters issues with the quote handling\n3. The selector `div[data='End]']` contains a closing bracket `]` inside the single-quoted attribute value\n4. The parser seems to be interpreting the `]` inside the quotes as the end of the attribute selector rather than as part of the attribute value\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the **CSS selector parsing logic** in the `QueryParser` class, specifically in how it handles attribute selectors with special characters inside quoted attribute values.\n\n**Possible Root Cause**: The parser is not properly handling escaped characters or special characters within quoted attribute values in CSS selectors. When it encounters a `]` character inside single quotes, it's incorrectly treating it as the end of the attribute selector bracket rather than as a literal character within the attribute value.\n\n**Expected Behavior**: The parser should recognize that characters inside quoted attribute values (whether single or double quotes) should be treated as literal text, and special CSS selector characters like `]` should not terminate the attribute selector prematurely.\n\n**Files to Investigate**:\n- `org.jsoup.select.QueryParser` (specifically the attribute selector parsing logic)\n- `org.jsoup.select.Selector` (which uses QueryParser)\n\nThe fix would likely involve modifying the attribute selector parsing to properly handle special characters within quoted values, ensuring the parser maintains proper state about being inside quoted regions.",
            "test_suite": "org.jsoup.select.SelectorTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it serves as the entry point for CSS selector parsing and delegates to the actual parsing logic. The test failure occurs when parsing the selector string \"div[data='End]'\", and the parse method is responsible for initiating the parsing process that ultimately fails with a SelectorParseException. While the actual parsing logic may be in other methods within QueryParser, this method is the gateway that coordinates the parsing workflow and would need to be considered as part of the fix."
        },
        {
            "method_name": "org.jsoup.select.QueryParser::findElements()",
            "method_code": "```java\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord())\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n```",
            "method_doc": "This method identifies and processes different CSS selector types from the token queue. It calls byTag() for tag selectors and byAttribute() for attribute selectors, among other specific handler methods.",
            "class_name": "org.jsoup.select.QueryParser",
            "class_doc": " Parses a CSS selector into an Evaluator tree. ",
            "test_failure_causes": "Looking at the failed test and the analysis, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Common Pattern**: The test failure occurs when parsing CSS selectors with attribute values containing special characters like brackets. Specifically, the selector `div[data='End]']` fails to parse because the attribute value contains an unescaped closing bracket.\n\n**Key Observations**:\n1. The stack trace shows a `SelectorParseException` at `QueryParser.findElements()`\n2. The error message indicates: \"unexpected token at '''\" - suggesting the parser encounters issues with the quote handling\n3. The selector `div[data='End]']` contains a closing bracket `]` inside the single-quoted attribute value\n4. The parser seems to be interpreting the `]` inside the quotes as the end of the attribute selector rather than as part of the attribute value\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the **CSS selector parsing logic** in the `QueryParser` class, specifically in how it handles attribute selectors with special characters inside quoted attribute values.\n\n**Possible Root Cause**: The parser is not properly handling escaped characters or special characters within quoted attribute values in CSS selectors. When it encounters a `]` character inside single quotes, it's incorrectly treating it as the end of the attribute selector bracket rather than as a literal character within the attribute value.\n\n**Expected Behavior**: The parser should recognize that characters inside quoted attribute values (whether single or double quotes) should be treated as literal text, and special CSS selector characters like `]` should not terminate the attribute selector prematurely.\n\n**Files to Investigate**:\n- `org.jsoup.select.QueryParser` (specifically the attribute selector parsing logic)\n- `org.jsoup.select.Selector` (which uses QueryParser)\n\nThe fix would likely involve modifying the attribute selector parsing to properly handle special characters within quoted values, ensuring the parser maintains proper state about being inside quoted regions.",
            "test_suite": "org.jsoup.select.SelectorTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the parsing of CSS selectors including attribute selectors, and the test failure occurs when parsing an attribute selector with special characters inside quotes. The method delegates to byAttribute() for attribute parsing, which is where the actual issue with handling quoted attribute values containing brackets likely resides."
        }
    ],
    "buggy_codes": {
        "org.jsoup.select.QueryParser::parse()": {
            "method_name": "org.jsoup.select.QueryParser::parse()",
            "method_code": "```java\n    Evaluator parse() {\n        tq.consumeWhitespace();\n\n        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n            evals.add(new StructuralEvaluator.Root());\n            combinator(tq.consume());\n        } else {\n            findElements();\n        }\n\n        while (!tq.isEmpty()) {\n            // hierarchy and extras\n            boolean seenWhite = tq.consumeWhitespace();\n\n            if (tq.matchesAny(combinators)) {\n                combinator(tq.consume());\n            } else if (seenWhite) {\n                combinator(' ');\n            } else { // E.class, E#id, E[attr] etc. AND\n                findElements(); // take next el, #. etc off queue\n            }\n        }\n\n        if (evals.size() == 1)\n            return evals.get(0);\n\n        return new CombiningEvaluator.And(evals);\n    }\n\n```",
            "method_doc": " Parse the query @return Evaluator "
        },
        "org.jsoup.select.QueryParser::parse(String)": {
            "method_name": "org.jsoup.select.QueryParser::parse(String)",
            "method_code": "```java\n    public static Evaluator parse(String query) {\n        QueryParser p = new QueryParser(query);\n        return p.parse();\n    }\n\n```",
            "method_doc": " Parse a CSS query into an Evaluator. @param query CSS query @return Evaluator "
        },
        "org.jsoup.select.QueryParser::byAttribute()": {
            "method_name": "org.jsoup.select.QueryParser::byAttribute()",
            "method_code": "```java\n    private void byAttribute() {\n        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n        Validate.notEmpty(key);\n        cq.consumeWhitespace();\n\n        if (cq.isEmpty()) {\n            if (key.startsWith(\"^\"))\n                evals.add(new Evaluator.AttributeStarting(key.substring(1)));\n            else\n                evals.add(new Evaluator.Attribute(key));\n        } else {\n            if (cq.matchChomp(\"=\"))\n                evals.add(new Evaluator.AttributeWithValue(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"!=\"))\n                evals.add(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"^=\"))\n                evals.add(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"$=\"))\n                evals.add(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"*=\"))\n                evals.add(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n\n            else if (cq.matchChomp(\"~=\"))\n                evals.add(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n            else\n                throw new Selector.SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n        }\n    }\n\n```",
            "method_doc": "This method processes attribute selectors from token queues, handling various attribute matching operators and adding corresponding Attribute Evaluators to the evaluation list."
        },
        "org.jsoup.select.QueryParser::findElements()": {
            "method_name": "org.jsoup.select.QueryParser::findElements()",
            "method_code": "```java\n    private void findElements() {\n        if (tq.matchChomp(\"#\"))\n            byId();\n        else if (tq.matchChomp(\".\"))\n            byClass();\n        else if (tq.matchesWord())\n            byTag();\n        else if (tq.matches(\"[\"))\n            byAttribute();\n        else if (tq.matchChomp(\"*\"))\n            allElements();\n        else if (tq.matchChomp(\":lt(\"))\n            indexLessThan();\n        else if (tq.matchChomp(\":gt(\"))\n            indexGreaterThan();\n        else if (tq.matchChomp(\":eq(\"))\n            indexEquals();\n        else if (tq.matches(\":has(\"))\n            has();\n        else if (tq.matches(\":contains(\"))\n            contains(false);\n        else if (tq.matches(\":containsOwn(\"))\n            contains(true);\n        else if (tq.matches(\":matches(\"))\n            matches(false);\n        else if (tq.matches(\":matchesOwn(\"))\n            matches(true);\n        else if (tq.matches(\":not(\"))\n            not();\n\t\telse if (tq.matchChomp(\":nth-child(\"))\n        \tcssNthChild(false, false);\n        else if (tq.matchChomp(\":nth-last-child(\"))\n        \tcssNthChild(true, false);\n        else if (tq.matchChomp(\":nth-of-type(\"))\n        \tcssNthChild(false, true);\n        else if (tq.matchChomp(\":nth-last-of-type(\"))\n        \tcssNthChild(true, true);\n        else if (tq.matchChomp(\":first-child\"))\n        \tevals.add(new Evaluator.IsFirstChild());\n        else if (tq.matchChomp(\":last-child\"))\n        \tevals.add(new Evaluator.IsLastChild());\n        else if (tq.matchChomp(\":first-of-type\"))\n        \tevals.add(new Evaluator.IsFirstOfType());\n        else if (tq.matchChomp(\":last-of-type\"))\n        \tevals.add(new Evaluator.IsLastOfType());\n        else if (tq.matchChomp(\":only-child\"))\n        \tevals.add(new Evaluator.IsOnlyChild());\n        else if (tq.matchChomp(\":only-of-type\"))\n        \tevals.add(new Evaluator.IsOnlyOfType());\n        else if (tq.matchChomp(\":empty\"))\n        \tevals.add(new Evaluator.IsEmpty());\n        else if (tq.matchChomp(\":root\"))\n        \tevals.add(new Evaluator.IsRoot());\n\t\telse // unhandled\n            throw new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n    }\n\n```",
            "method_doc": "This method identifies and processes different CSS selector types from the token queue. It calls byTag() for tag selectors and byAttribute() for attribute selectors, among other specific handler methods."
        }
    }
}