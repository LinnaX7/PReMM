{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.deser.DeserializerCache"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCache2(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            /* We better only expose checked exceptions, since those\n             * are what caller is expected to handle\n             */\n            throw new JsonMappingException(iae.getMessage(), null, iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n        boolean addToCache = deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (isResolvable) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method that handles actual construction (via factory) and caching (both intermediate and eventual) ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following key patterns and recommend a possible defect in the production code:\n\n**Common Pattern Analysis:**\n\n1. **Single Test Failure**: Only one test is failing, but it reveals a critical issue with custom deserializer application\n2. **Cross-Contamination Issue**: The custom deserializer intended for one property (`map1`) is being incorrectly applied to another property (`map2`)\n3. **Deserializer Scope Problem**: The test expects different deserialization behavior for two similar map properties, but both end up with the same (custom) behavior\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect appears to be in Jackson's deserialization mechanism where **custom deserializers are not being properly scoped to their intended target properties**. Specifically, the issue likely involves:\n\n1. **Global Deserializer Registration**: The custom deserializer for map values might be registered globally rather than being property-specific, causing it to apply to all map properties of the same type\n\n2. **Contextual Deserializer Caching**: Jackson may be incorrectly caching and reusing the custom deserializer across multiple properties of the same type within the same deserialization context\n\n3. **Bean Property Resolution**: The mechanism that determines which deserializer to use for specific bean properties might be failing to distinguish between `map1` and `map2` when both have similar value types\n\n4. **Annotation Processing**: If the custom deserializer is applied via annotations, there may be a bug in how Jackson processes and applies these annotations to specific properties versus applying them globally\n\nThe core issue is that Jackson's deserialization framework is not correctly isolating the custom deserializer to only the intended property (`map1`), allowing it to \"leak\" and affect other properties (`map2`) that should use the default deserialization behavior.",
            "test_suite": "com.fasterxml.jackson.databind.deser.TestCustomDeserializers",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles deserializer creation and caching, and the test failure shows cross-contamination where a custom deserializer intended for one property is incorrectly applied to another property. The caching mechanism in this method (_cachedDeserializers.put(type, deser)) may be causing the custom deserializer to be reused across multiple properties of the same JavaType, rather than being properly scoped to specific bean properties. The issue appears to be related to how contextual deserializers are cached and retrieved based solely on type without considering the specific property context."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::findValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            // If not, need to request factory to construct (or recycle)\n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                /* Should we let caller handle it? Let's have a helper method\n                 * decide it; can throw an exception, or return a valid\n                 * deserializer\n                 */\n                deser = _handleUnknownValueDeserializer(propertyType);\n            }\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method called to get hold of a deserializer for a value of given type; or if no such deserializer can be found, a default handler (which may do a best-effort generic serialization or just simply throw an exception when invoked). <p> Note: this method is only called for value types; not for keys. Key deserializers can be accessed using {@link #findKeyDeserializer}. <p> Note also that deserializer returned is guaranteed to be resolved (if it is of type {@link ResolvableDeserializer}), but not contextualized (wrt {@link ContextualDeserializer}): caller has to handle latter if necessary.  @param ctxt Deserialization context @param propertyType Declared type of the value to deserializer (obtained using 'setter' method signature and/or type annotations  @throws JsonMappingException if there are fatal problems with accessing suitable deserializer; including that of not finding any serializer ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following key patterns and recommend a possible defect in the production code:\n\n**Common Pattern Analysis:**\n\n1. **Single Test Failure**: Only one test is failing, but it reveals a critical issue with custom deserializer application\n2. **Cross-Contamination Issue**: The custom deserializer intended for one property (`map1`) is being incorrectly applied to another property (`map2`)\n3. **Deserializer Scope Problem**: The test expects different deserialization behavior for two similar map properties, but both end up with the same (custom) behavior\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect appears to be in Jackson's deserialization mechanism where **custom deserializers are not being properly scoped to their intended target properties**. Specifically, the issue likely involves:\n\n1. **Global Deserializer Registration**: The custom deserializer for map values might be registered globally rather than being property-specific, causing it to apply to all map properties of the same type\n\n2. **Contextual Deserializer Caching**: Jackson may be incorrectly caching and reusing the custom deserializer across multiple properties of the same type within the same deserialization context\n\n3. **Bean Property Resolution**: The mechanism that determines which deserializer to use for specific bean properties might be failing to distinguish between `map1` and `map2` when both have similar value types\n\n4. **Annotation Processing**: If the custom deserializer is applied via annotations, there may be a bug in how Jackson processes and applies these annotations to specific properties versus applying them globally\n\nThe core issue is that Jackson's deserialization framework is not correctly isolating the custom deserializer to only the intended property (`map1`), allowing it to \"leak\" and affect other properties (`map2`) that should use the default deserialization behavior.",
            "test_suite": "com.fasterxml.jackson.databind.deser.TestCustomDeserializers",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles deserializer caching and retrieval, which directly relates to the cross-contamination issue where a custom deserializer intended for one property is incorrectly applied to another property. The caching mechanism in _findCachedDeserializer and _createAndCacheValueDeserializer may not properly account for contextual differences between bean properties, causing the custom map value deserializer to be reused incorrectly across different map properties with the same value type."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCacheValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            // Or perhaps being resolved right now?\n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            // Nope: need to create and possibly cache\n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                // also: any deserializers that have been created are complete by now\n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " Method that will try to create a deserializer for given type, and resolve and cache it if necessary  @param ctxt Currently active deserialization context @param type Type of property to deserialize ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following key patterns and recommend a possible defect in the production code:\n\n**Common Pattern Analysis:**\n\n1. **Single Test Failure**: Only one test is failing, but it reveals a critical issue with custom deserializer application\n2. **Cross-Contamination Issue**: The custom deserializer intended for one property (`map1`) is being incorrectly applied to another property (`map2`)\n3. **Deserializer Scope Problem**: The test expects different deserialization behavior for two similar map properties, but both end up with the same (custom) behavior\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect appears to be in Jackson's deserialization mechanism where **custom deserializers are not being properly scoped to their intended target properties**. Specifically, the issue likely involves:\n\n1. **Global Deserializer Registration**: The custom deserializer for map values might be registered globally rather than being property-specific, causing it to apply to all map properties of the same type\n\n2. **Contextual Deserializer Caching**: Jackson may be incorrectly caching and reusing the custom deserializer across multiple properties of the same type within the same deserialization context\n\n3. **Bean Property Resolution**: The mechanism that determines which deserializer to use for specific bean properties might be failing to distinguish between `map1` and `map2` when both have similar value types\n\n4. **Annotation Processing**: If the custom deserializer is applied via annotations, there may be a bug in how Jackson processes and applies these annotations to specific properties versus applying them globally\n\nThe core issue is that Jackson's deserialization framework is not correctly isolating the custom deserializer to only the intended property (`map1`), allowing it to \"leak\" and affect other properties (`map2`) that should use the default deserialization behavior.",
            "test_suite": "com.fasterxml.jackson.databind.deser.TestCustomDeserializers",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles deserializer caching and creation, and the test failure shows cross-contamination where a custom deserializer intended for one property is incorrectly applied to another property. The caching mechanism in this method may be incorrectly reusing the same deserializer instance for multiple properties of the same type, rather than creating property-specific contextual deserializers. The synchronization and caching logic could be causing the custom map value deserializer to be globally cached and reused across both map1 and map2 properties."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::findDeserializerFromAnnotation(DeserializationContext,Annotated)",
            "method_code": "```java\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        // One more thing however: may need to also apply a converter:\n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n```",
            "method_doc": " Helper method called to check if a class or method has annotation that tells which class to use for deserialization. Returns null if no such annotation found. ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following key patterns and recommend a possible defect in the production code:\n\n**Common Pattern Analysis:**\n\n1. **Single Test Failure**: Only one test is failing, but it reveals a critical issue with custom deserializer application\n2. **Cross-Contamination Issue**: The custom deserializer intended for one property (`map1`) is being incorrectly applied to another property (`map2`)\n3. **Deserializer Scope Problem**: The test expects different deserialization behavior for two similar map properties, but both end up with the same (custom) behavior\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect appears to be in Jackson's deserialization mechanism where **custom deserializers are not being properly scoped to their intended target properties**. Specifically, the issue likely involves:\n\n1. **Global Deserializer Registration**: The custom deserializer for map values might be registered globally rather than being property-specific, causing it to apply to all map properties of the same type\n\n2. **Contextual Deserializer Caching**: Jackson may be incorrectly caching and reusing the custom deserializer across multiple properties of the same type within the same deserialization context\n\n3. **Bean Property Resolution**: The mechanism that determines which deserializer to use for specific bean properties might be failing to distinguish between `map1` and `map2` when both have similar value types\n\n4. **Annotation Processing**: If the custom deserializer is applied via annotations, there may be a bug in how Jackson processes and applies these annotations to specific properties versus applying them globally\n\nThe core issue is that Jackson's deserialization framework is not correctly isolating the custom deserializer to only the intended property (`map1`), allowing it to \"leak\" and affect other properties (`map2`) that should use the default deserialization behavior.",
            "test_suite": "com.fasterxml.jackson.databind.deser.TestCustomDeserializers",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles annotation-based deserializer lookup and instantiation, which directly relates to the test failure where a custom deserializer intended for one property is incorrectly applied to another property. The method processes deserializer annotations globally without property-specific context, potentially causing cross-contamination between map1 and map2 properties that should have different deserialization behaviors."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { // nope, just construct in normal way\n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n```",
            "method_doc": " Method that does the heavy lifting of checking for per-type annotations, find out full type, and figure out which actual factory method to call. ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following key patterns and recommend a possible defect in the production code:\n\n**Common Pattern Analysis:**\n\n1. **Single Test Failure**: Only one test is failing, but it reveals a critical issue with custom deserializer application\n2. **Cross-Contamination Issue**: The custom deserializer intended for one property (`map1`) is being incorrectly applied to another property (`map2`)\n3. **Deserializer Scope Problem**: The test expects different deserialization behavior for two similar map properties, but both end up with the same (custom) behavior\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect appears to be in Jackson's deserialization mechanism where **custom deserializers are not being properly scoped to their intended target properties**. Specifically, the issue likely involves:\n\n1. **Global Deserializer Registration**: The custom deserializer for map values might be registered globally rather than being property-specific, causing it to apply to all map properties of the same type\n\n2. **Contextual Deserializer Caching**: Jackson may be incorrectly caching and reusing the custom deserializer across multiple properties of the same type within the same deserialization context\n\n3. **Bean Property Resolution**: The mechanism that determines which deserializer to use for specific bean properties might be failing to distinguish between `map1` and `map2` when both have similar value types\n\n4. **Annotation Processing**: If the custom deserializer is applied via annotations, there may be a bug in how Jackson processes and applies these annotations to specific properties versus applying them globally\n\nThe core issue is that Jackson's deserialization framework is not correctly isolating the custom deserializer to only the intended property (`map1`), allowing it to \"leak\" and affect other properties (`map2`) that should use the default deserialization behavior.",
            "test_suite": "com.fasterxml.jackson.databind.deser.TestCustomDeserializers",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the creation and caching of deserializers, and the test failure shows cross-contamination where a custom deserializer intended for one property is incorrectly applied to another property. The method's logic for finding deserializers from annotations and handling type modifications could be incorrectly caching or reusing deserializers across different properties of the same type, causing the scope issue observed in the test."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCache2(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCache2(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            /* We better only expose checked exceptions, since those\n             * are what caller is expected to handle\n             */\n            throw new JsonMappingException(iae.getMessage(), null, iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n        boolean addToCache = deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (isResolvable) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method that handles actual construction (via factory) and caching (both intermediate and eventual) "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::findValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::findValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            // If not, need to request factory to construct (or recycle)\n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                /* Should we let caller handle it? Let's have a helper method\n                 * decide it; can throw an exception, or return a valid\n                 * deserializer\n                 */\n                deser = _handleUnknownValueDeserializer(propertyType);\n            }\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method called to get hold of a deserializer for a value of given type; or if no such deserializer can be found, a default handler (which may do a best-effort generic serialization or just simply throw an exception when invoked). <p> Note: this method is only called for value types; not for keys. Key deserializers can be accessed using {@link #findKeyDeserializer}. <p> Note also that deserializer returned is guaranteed to be resolved (if it is of type {@link ResolvableDeserializer}), but not contextualized (wrt {@link ContextualDeserializer}): caller has to handle latter if necessary.  @param ctxt Deserialization context @param propertyType Declared type of the value to deserializer (obtained using 'setter' method signature and/or type annotations  @throws JsonMappingException if there are fatal problems with accessing suitable deserializer; including that of not finding any serializer "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCacheValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCacheValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            // Or perhaps being resolved right now?\n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            // Nope: need to create and possibly cache\n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                // also: any deserializers that have been created are complete by now\n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " Method that will try to create a deserializer for given type, and resolve and cache it if necessary  @param ctxt Currently active deserialization context @param type Type of property to deserialize "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::findDeserializerFromAnnotation(DeserializationContext,Annotated)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::findDeserializerFromAnnotation(DeserializationContext,Annotated)",
            "method_code": "```java\n    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n            Annotated ann)\n        throws JsonMappingException\n    {\n        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n        if (deserDef == null) {\n            return null;\n        }\n        JsonDeserializer<Object> deser = ctxt.deserializerInstance(ann, deserDef);\n        // One more thing however: may need to also apply a converter:\n        return findConvertingDeserializer(ctxt, ann, deser);\n    }\n\n```",
            "method_doc": " Helper method called to check if a class or method has annotation that tells which class to use for deserialization. Returns null if no such annotation found. "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_createDeserializer(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { // nope, just construct in normal way\n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n```",
            "method_doc": " Method that does the heavy lifting of checking for per-type annotations, find out full type, and figure out which actual factory method to call. "
        }
    }
}