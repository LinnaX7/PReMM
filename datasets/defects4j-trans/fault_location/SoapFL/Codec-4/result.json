{
    "buggy_classes": [
        "org.apache.commons.codec.binary.Base64"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[])",
            "method_code": "```java\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n```",
            "method_doc": " Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.  @param pArray a byte array containing binary data @return A byte array containing only Base64 character data ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failures systematically:\n\n## Analysis of Common Patterns\n\n**Similarities Identified:**\n1. Both tests fail at index 1 (test-1) in their respective loops\n2. Both tests use the same data arrays (STRINGS and BYTES)\n3. Both tests perform identical operations: encoding binary data and comparing with expected Base64 strings\n4. Both failures occur in the assertion comparing encoded output with expected UTF-8 bytes\n5. Both tests implement the same core logic but through different interfaces (Encoder vs BinaryEncoder)\n\n**Key Observations:**\n- The failure occurs specifically at index 1, suggesting the issue manifests with a particular input data pattern\n- Since both tests fail identically, the problem is not interface-specific but rather in the core Base64 encoding logic\n- The tests are designed to verify compatibility with commons-codec-1.3.jar, indicating a regression from that reference implementation\n\n## Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the **Base64 encoding algorithm implementation**, specifically:\n\n**Possible Defect: Incorrect handling of padding or line breaks in Base64 encoding**\n\nThe failure at index 1 suggests the issue occurs with a specific binary input pattern that requires special handling in Base64 encoding. Given that:\n- Base64 encoding involves grouping 3 bytes into 4 characters\n- Padding with '=' characters when input length isn't divisible by 3\n- Potential line breaking behavior differences\n\n**Specific areas to investigate in Base64 production code:**\n1. **Padding logic** - Incorrect calculation or application of '=' padding characters\n2. **Character encoding** - Mismatch in the Base64 alphabet or encoding table\n3. **Line length handling** - Differences in line breaking behavior compared to commons-codec-1.3\n4. **Binary data boundary handling** - Issues with specific byte patterns that trigger edge cases\n\nThe defect likely causes the Base64 encoder to produce output that doesn't match the reference implementation from commons-codec-1.3.jar for the specific binary data at index 1 in the BYTES array.",
            "test_suite": "org.apache.commons.codec.binary.Base64Codec13Test",
            "score": 9,
            "reason": "#9# This method is highly suspicious as it contains the core Base64 encoding logic and both failed tests directly call this encode method. The method handles padding, buffer management, and URL-safe mode - all potential sources of incompatibility with the commons-codec-1.3 reference implementation. The double call to encode() with -1 length for EOF notification and the buffer resizing logic are particularly concerning areas that could cause the test failures at index 1."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[],int,int)",
            "method_code": "```java\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " <p> Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 3). </p> <p> Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ </p>  @param in byte[] array of binary data to base64 encode. @param inPos Position to start reading data from. @param inAvail Amount of bytes available from input for encoding. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failures systematically:\n\n## Analysis of Common Patterns\n\n**Similarities Identified:**\n1. Both tests fail at index 1 (test-1) in their respective loops\n2. Both tests use the same data arrays (STRINGS and BYTES)\n3. Both tests perform identical operations: encoding binary data and comparing with expected Base64 strings\n4. Both failures occur in the assertion comparing encoded output with expected UTF-8 bytes\n5. Both tests implement the same core logic but through different interfaces (Encoder vs BinaryEncoder)\n\n**Key Observations:**\n- The failure occurs specifically at index 1, suggesting the issue manifests with a particular input data pattern\n- Since both tests fail identically, the problem is not interface-specific but rather in the core Base64 encoding logic\n- The tests are designed to verify compatibility with commons-codec-1.3.jar, indicating a regression from that reference implementation\n\n## Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the **Base64 encoding algorithm implementation**, specifically:\n\n**Possible Defect: Incorrect handling of padding or line breaks in Base64 encoding**\n\nThe failure at index 1 suggests the issue occurs with a specific binary input pattern that requires special handling in Base64 encoding. Given that:\n- Base64 encoding involves grouping 3 bytes into 4 characters\n- Padding with '=' characters when input length isn't divisible by 3\n- Potential line breaking behavior differences\n\n**Specific areas to investigate in Base64 production code:**\n1. **Padding logic** - Incorrect calculation or application of '=' padding characters\n2. **Character encoding** - Mismatch in the Base64 alphabet or encoding table\n3. **Line length handling** - Differences in line breaking behavior compared to commons-codec-1.3\n4. **Binary data boundary handling** - Issues with specific byte patterns that trigger edge cases\n\nThe defect likely causes the Base64 encoder to produce output that doesn't match the reference implementation from commons-codec-1.3.jar for the specific binary data at index 1 in the BYTES array.",
            "test_suite": "org.apache.commons.codec.binary.Base64Codec13Test",
            "score": 9,
            "reason": "#9# This method is highly suspicious as it contains the core Base64 encoding logic with potential issues in padding calculation, modulus handling, and line separator insertion. Both test failures occur at index 1 where specific binary data patterns likely trigger edge cases in the encoding algorithm, particularly in the EOF handling section where padding characters are added based on modulus values. The method's complex state management (modulus, x, eof) and conditional padding logic could easily produce output that doesn't match the reference implementation from commons-codec-1.3.jar."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::getEncodeLength(byte[],int,byte[])",
            "method_code": "```java\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n```",
            "method_doc": " Pre-calculates the amount of space needed to base64-encode the supplied array.  @param pArray byte[] array which will later be encoded @param chunkSize line-length of the output (<= 0 means no chunking) between each chunkSeparator (e.g. CRLF). @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).  @return amount of space needed to encoded the supplied array.  Returns a long since a max-len array will require Integer.MAX_VALUE + 33%. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failures systematically:\n\n## Analysis of Common Patterns\n\n**Similarities Identified:**\n1. Both tests fail at index 1 (test-1) in their respective loops\n2. Both tests use the same data arrays (STRINGS and BYTES)\n3. Both tests perform identical operations: encoding binary data and comparing with expected Base64 strings\n4. Both failures occur in the assertion comparing encoded output with expected UTF-8 bytes\n5. Both tests implement the same core logic but through different interfaces (Encoder vs BinaryEncoder)\n\n**Key Observations:**\n- The failure occurs specifically at index 1, suggesting the issue manifests with a particular input data pattern\n- Since both tests fail identically, the problem is not interface-specific but rather in the core Base64 encoding logic\n- The tests are designed to verify compatibility with commons-codec-1.3.jar, indicating a regression from that reference implementation\n\n## Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the **Base64 encoding algorithm implementation**, specifically:\n\n**Possible Defect: Incorrect handling of padding or line breaks in Base64 encoding**\n\nThe failure at index 1 suggests the issue occurs with a specific binary input pattern that requires special handling in Base64 encoding. Given that:\n- Base64 encoding involves grouping 3 bytes into 4 characters\n- Padding with '=' characters when input length isn't divisible by 3\n- Potential line breaking behavior differences\n\n**Specific areas to investigate in Base64 production code:**\n1. **Padding logic** - Incorrect calculation or application of '=' padding characters\n2. **Character encoding** - Mismatch in the Base64 alphabet or encoding table\n3. **Line length handling** - Differences in line breaking behavior compared to commons-codec-1.3\n4. **Binary data boundary handling** - Issues with specific byte patterns that trigger edge cases\n\nThe defect likely causes the Base64 encoder to produce output that doesn't match the reference implementation from commons-codec-1.3.jar for the specific binary data at index 1 in the BYTES array.",
            "test_suite": "org.apache.commons.codec.binary.Base64Codec13Test",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it calculates the encoded length for Base64 output, and incorrect length calculations can lead to buffer allocation issues that cause encoding errors. The method handles padding logic and chunk separators, and since both tests fail at the same data index with encoding mismatches, the problem likely stems from improper length computation affecting the actual encoding output. The formula for Base64 length must account for padding correctly, and any miscalculation here would propagate to the encoding process, causing the test assertions to fail when comparing with expected results."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::setInitialBuffer(byte[],int,int)",
            "method_code": "```java\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n```",
            "method_doc": " Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output array for one round (if the consumer calls this method first) instead of starting our own buffer.  @param out byte[] array to buffer directly to. @param outPos Position to start buffering into. @param outAvail Amount of bytes available for direct buffering. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failures systematically:\n\n## Analysis of Common Patterns\n\n**Similarities Identified:**\n1. Both tests fail at index 1 (test-1) in their respective loops\n2. Both tests use the same data arrays (STRINGS and BYTES)\n3. Both tests perform identical operations: encoding binary data and comparing with expected Base64 strings\n4. Both failures occur in the assertion comparing encoded output with expected UTF-8 bytes\n5. Both tests implement the same core logic but through different interfaces (Encoder vs BinaryEncoder)\n\n**Key Observations:**\n- The failure occurs specifically at index 1, suggesting the issue manifests with a particular input data pattern\n- Since both tests fail identically, the problem is not interface-specific but rather in the core Base64 encoding logic\n- The tests are designed to verify compatibility with commons-codec-1.3.jar, indicating a regression from that reference implementation\n\n## Recommended Possible Defect in Production Code\n\nBased on the analysis, the likely defect is in the **Base64 encoding algorithm implementation**, specifically:\n\n**Possible Defect: Incorrect handling of padding or line breaks in Base64 encoding**\n\nThe failure at index 1 suggests the issue occurs with a specific binary input pattern that requires special handling in Base64 encoding. Given that:\n- Base64 encoding involves grouping 3 bytes into 4 characters\n- Padding with '=' characters when input length isn't divisible by 3\n- Potential line breaking behavior differences\n\n**Specific areas to investigate in Base64 production code:**\n1. **Padding logic** - Incorrect calculation or application of '=' padding characters\n2. **Character encoding** - Mismatch in the Base64 alphabet or encoding table\n3. **Line length handling** - Differences in line breaking behavior compared to commons-codec-1.3\n4. **Binary data boundary handling** - Issues with specific byte patterns that trigger edge cases\n\nThe defect likely causes the Base64 encoder to produce output that doesn't match the reference implementation from commons-codec-1.3.jar for the specific binary data at index 1 in the BYTES array.",
            "test_suite": "org.apache.commons.codec.binary.Base64Codec13Test",
            "score": 3,
            "reason": "#3# The setInitialBuffer method is unlikely to be the root cause of the Base64 encoding failures. The method appears to be an optimization for direct buffering and doesn't contain the core Base64 encoding logic. The test failures suggest issues with the actual encoding algorithm, padding, or character mapping, which would be handled in the main encode methods rather than this buffer setup utility."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.codec.binary.Base64::encode(byte[])": {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[])",
            "method_code": "```java\n    public byte[] encode(byte[] pArray) {\n        reset();        \n        if (pArray == null || pArray.length == 0) {\n            return pArray;\n        }\n        long len = getEncodeLength(pArray, lineLength, lineSeparator);\n        byte[] buf = new byte[(int) len];\n        setInitialBuffer(buf, 0, buf.length);\n        encode(pArray, 0, pArray.length);\n        encode(pArray, 0, -1); // Notify encoder of EOF.\n        // Encoder might have resized, even though it was unnecessary.\n        if (buffer != buf) {\n            readResults(buf, 0, buf.length);\n        }\n        // In URL-SAFE mode we skip the padding characters, so sometimes our\n        // final length is a bit smaller.\n        if (isUrlSafe() && pos < buf.length) {\n            byte[] smallerBuf = new byte[pos];\n            System.arraycopy(buf, 0, smallerBuf, 0, pos);\n            buf = smallerBuf;\n        }\n        return buf;        \n    }\n\n```",
            "method_doc": " Encodes a byte[] containing binary data, into a byte[] containing characters in the Base64 alphabet.  @param pArray a byte array containing binary data @return A byte array containing only Base64 character data "
        },
        "org.apache.commons.codec.binary.Base64::setInitialBuffer(byte[],int,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::setInitialBuffer(byte[],int,int)",
            "method_code": "```java\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        // We can re-use consumer's original output array under\n        // special circumstances, saving on some System.arraycopy().\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n```",
            "method_doc": " Sets the streaming buffer. This is a small optimization where we try to buffer directly to the consumer's output array for one round (if the consumer calls this method first) instead of starting our own buffer.  @param out byte[] array to buffer directly to. @param outPos Position to start buffering into. @param outAvail Amount of bytes available for direct buffering. "
        },
        "org.apache.commons.codec.binary.Base64::encode(byte[],int,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[],int,int)",
            "method_code": "```java\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " <p> Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 3). </p> <p> Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ </p>  @param in byte[] array of binary data to base64 encode. @param inPos Position to start reading data from. @param inAvail Amount of bytes available from input for encoding. "
        },
        "org.apache.commons.codec.binary.Base64::getEncodeLength(byte[],int,byte[])": {
            "method_name": "org.apache.commons.codec.binary.Base64::getEncodeLength(byte[],int,byte[])",
            "method_code": "```java\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n```",
            "method_doc": " Pre-calculates the amount of space needed to base64-encode the supplied array.  @param pArray byte[] array which will later be encoded @param chunkSize line-length of the output (<= 0 means no chunking) between each chunkSeparator (e.g. CRLF). @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).  @return amount of space needed to encoded the supplied array.  Returns a long since a max-len array will require Integer.MAX_VALUE + 33%. "
        }
    }
}