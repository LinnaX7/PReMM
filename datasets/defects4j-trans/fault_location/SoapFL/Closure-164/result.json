{
    "buggy_classes": [
        "com.google.javascript.rhino.jstype.FunctionType"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::checkDeclaredPropertyInheritance(NodeTraversal,Node,FunctionType,String,JSDocInfo,JSType)",
            "method_code": "```java\n  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getPrototype().hasProperty(propertyName);\n    // For interface\n    boolean superInterfacesHasProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfacesHasProperty =\n          superInterfacesHasProperty || interfaceType.hasProperty(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n        if (reportMissingOverride.isOn() && !declaredOverride &&\n            interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride && !superClassHasProperty\n        && !superInterfacesHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    JSType topInstanceType = superClassHasProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n        !declaredOverride && superClassHasProperty) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n      // there's no @override to check\n      return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getPrototype().getPropertyType(propertyName);\n      if (!propertyType.canAssignTo(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfacesHasProperty) {\n      // there is an super interface property\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n            interfaceType.getPropertyType(propertyName);\n          if (!propertyType.canAssignTo(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }\n\n```",
            "method_doc": " Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failures\n\n**Common Pattern Identified:**\n- All failures relate to method signature validation in inheritance hierarchies\n- The test expects type checking to detect method signature mismatches during method overriding\n- The test framework is expecting warnings/errors that are not being generated\n\n## Key Observations from testMethodInference7:\n\n1. **Test Expectation**: The test expects the type checker to report a method signature mismatch when:\n   - Base class `F` has method `foo` with signature `function(): undefined` (no parameters)\n   - Subclass `G` overrides with `function(x, y): undefined` (two parameters)\n\n2. **Actual Behavior**: The test fails because no warning is generated when it should be\n\n3. **Critical Insight**: The test uses `isError=false` in the test framework setup, meaning it expects no errors, but the test description suggests it should be detecting a signature mismatch\n\n## Recommended Possible Defects in Production Code:\n\n### 1. **Method Signature Validation Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The loose type checker may be incorrectly allowing parameter count mismatches in method overrides. The production code might be:\n- Not properly comparing parameter counts between base and overriding methods\n- Applying overly permissive rules for method signature compatibility\n- Failing to traverse the prototype chain correctly to find the original method signature\n\n### 2. **Type Relationship Resolution**\n**Location**: Type system components handling inheritance and prototype chains\n**Defect**: The code that resolves method overrides and checks compatibility between base and derived class methods may have a flaw where:\n- It doesn't properly validate that overriding methods must have compatible signatures\n- It's missing validation for parameter count consistency\n- It's incorrectly handling the `@override` annotation validation\n\n### 3. **Error Reporting Mechanism**\n**Location**: Warning/error generation logic in type checking\n**Defect**: Even if the type checker detects the signature mismatch internally, the production code might have a bug that prevents the proper warning from being:\n- Generated at the correct severity level\n- Reported through the appropriate channels\n- Matched against the expected error patterns in tests\n\nThe core issue appears to be that the loose type checker is not enforcing method signature compatibility rules strictly enough, particularly regarding parameter counts in overriding methods.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles method override validation and type compatibility checking, which directly relates to the test failure where a method with different parameter counts should trigger a warning but doesn't. The method contains logic for checking if an overriding property type can assign to the superclass property type, but it may not properly validate parameter count mismatches in function signatures, allowing the invalid override in testMethodInference7 to pass without warning."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::supAndInfHelper(FunctionType,boolean)",
            "method_code": "```java\n  FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {\n    // NOTE(nicksantos): When we remove the unknown type, the function types\n    // form a lattice with the universal constructor at the top of the lattice,\n    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.\n    //\n    // When we introduce the unknown type, it's much more difficult to make\n    // heads or tails of the partial ordering of types, because there's no\n    // clear hierarchy between the different components (parameter types and\n    // return types) in the ArrowType.\n    //\n    // Rather than make the situation more complicated by introducing new\n    // types (like unions of functions), we just fallback on the simpler\n    // approach of getting things right at the top and the bottom of the\n    // lattice.\n    //\n    // If there are unknown parameters or return types making things\n    // ambiguous, then sup(A, B) is always the top function type, and\n    // inf(A, B) is always the bottom function type.\n    Preconditions.checkNotNull(that);\n\n    if (isEquivalentTo(that)) {\n      return this;\n    }\n\n    // If these are ordinary functions, then merge them.\n    // Don't do this if any of the params/return\n    // values are unknown, because then there will be cycles in\n    // their local lattice and they will merge in weird ways.\n    if (isOrdinaryFunction() && that.isOrdinaryFunction() &&\n        !this.call.hasUnknownParamsOrReturn() &&\n        !that.call.hasUnknownParamsOrReturn()) {\n\n      // Check for the degenerate case, but double check\n      // that there's not a cycle.\n      boolean isSubtypeOfThat = this.isSubtype(that);\n      boolean isSubtypeOfThis = that.isSubtype(this);\n      if (isSubtypeOfThat && !isSubtypeOfThis) {\n        return leastSuper ? that : this;\n      } else if (isSubtypeOfThis && !isSubtypeOfThat) {\n        return leastSuper ? this : that;\n      }\n\n      // Merge the two functions component-wise.\n      FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);\n      if (merged != null) {\n        return merged;\n      }\n    }\n\n    // The function instance type is a special case\n    // that lives above the rest of the lattice.\n    JSType functionInstance = registry.getNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE);\n    if (functionInstance.isEquivalentTo(that)) {\n      return leastSuper ? that : this;\n    } else if (functionInstance.isEquivalentTo(this)) {\n      return leastSuper ? this : that;\n    }\n\n    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the\n    // greatest function. In practice, we don't because it's way too\n    // broad. The greatest function takes var_args None parameters, which\n    // means that all parameters register a type warning.\n    //\n    // Instead, we use the U2U ctor type, which has unknown type args.\n    FunctionType greatestFn =\n        registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n    FunctionType leastFn =\n        registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);\n    return leastSuper ? greatestFn : leastFn;\n  }\n\n```",
            "method_doc": " Computes the supremum or infimum of two functions. Because sup() and inf() share a lot of logic for functions, we use a single helper. @param leastSuper If true, compute the supremum of {@code this} with {@code that}. Otherwise compute the infimum. @return The least supertype or greatest subtype. ",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Looking at the test failure, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Pattern Identified:**\n- The test is failing on `assertLeastSupertype` when comparing functions with different parameter counts\n- Expected: `\"function (number, number): boolean\"`\n- Actual: `\"Function\"` (truncated output)\n- This suggests the least supertype calculation is returning a generic `Function` type instead of the more specific function type with two parameters\n\n**Root Cause Analysis:**\n\nThe test expects that when finding the least supertype between:\n- `function(number, number): boolean` (two parameters)\n- `function(number): boolean` (one parameter)\n\nThe result should be `function(number, number): boolean` (the function with more parameters), but instead it's returning a generic `Function` type.\n\n## Recommended Production Code Defect\n\n**Possible Defect in `FunctionType.getLeastSupertype()` method:**\n\nThe bug likely exists in the least supertype calculation logic for `FunctionType` when functions have different arities (parameter counts). The production code is probably:\n\n1. **Incorrectly handling parameter count mismatch**: When comparing functions with different numbers of parameters, the code may be falling back to a generic `Function` type instead of properly selecting the function with more parameters as the least supertype.\n\n2. **Missing arity-based comparison logic**: The implementation may not properly consider that a function with more parameters can accept calls intended for a function with fewer parameters (through partial application or ignoring extra parameters), making it a valid supertype.\n\n3. **Overly conservative type merging**: The algorithm might be too conservative when parameter lists don't match exactly, defaulting to the most generic function type rather than analyzing which function type is more specific.\n\n**Specific location to investigate:**\n- `FunctionType.getLeastSupertype()` method\n- Any helper methods that handle function type comparisons with parameter count differences\n- The type relationship logic between functions with different arities\n\nThe fix should ensure that when comparing functions with the same return type but different parameter counts, the least supertype is the function with more parameters, as this can accommodate calls to both functions.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 9,
            "reason": "#9# The supAndInfHelper method is highly suspicious because it handles function type comparisons and the test failure occurs when finding the least supertype between functions with different parameter counts. The method's logic for merging functions piecewise may be incorrectly handling the case where functions have different arities, causing it to fall back to generic function types instead of properly selecting the function with more parameters as the least supertype."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::tryMergeFunctionPiecewise(FunctionType,boolean)",
            "method_code": "```java\n  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call)) {\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }\n\n```",
            "method_doc": " Try to get the sup/inf of two functions by looking at the piecewise components. ",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Looking at the test failure, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Pattern Identified:**\n- The test is failing on `assertLeastSupertype` when comparing functions with different parameter counts\n- Expected: `\"function (number, number): boolean\"`\n- Actual: `\"Function\"` (truncated output)\n- This suggests the least supertype calculation is returning a generic `Function` type instead of the more specific function type with two parameters\n\n**Root Cause Analysis:**\n\nThe test expects that when finding the least supertype between:\n- `function(number, number): boolean` (two parameters)\n- `function(number): boolean` (one parameter)\n\nThe result should be `function(number, number): boolean` (the function with more parameters), but instead it's returning a generic `Function` type.\n\n## Recommended Production Code Defect\n\n**Possible Defect in `FunctionType.getLeastSupertype()` method:**\n\nThe bug likely exists in the least supertype calculation logic for `FunctionType` when functions have different arities (parameter counts). The production code is probably:\n\n1. **Incorrectly handling parameter count mismatch**: When comparing functions with different numbers of parameters, the code may be falling back to a generic `Function` type instead of properly selecting the function with more parameters as the least supertype.\n\n2. **Missing arity-based comparison logic**: The implementation may not properly consider that a function with more parameters can accept calls intended for a function with fewer parameters (through partial application or ignoring extra parameters), making it a valid supertype.\n\n3. **Overly conservative type merging**: The algorithm might be too conservative when parameter lists don't match exactly, defaulting to the most generic function type rather than analyzing which function type is more specific.\n\n**Specific location to investigate:**\n- `FunctionType.getLeastSupertype()` method\n- Any helper methods that handle function type comparisons with parameter count differences\n- The type relationship logic between functions with different arities\n\nThe fix should ensure that when comparing functions with the same return type but different parameter counts, the least supertype is the function with more parameters, as this can accommodate calls to both functions.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location that needs to be fixed because it explicitly handles parameter comparison and returns null when parameters are not equal, which causes the fallback to a generic Function type. The test failure occurs when comparing functions with different parameter counts (2 vs 1 parameters), and this method's logic \"If the parameters are not equal, don't try to merge them\" directly prevents proper least supertype calculation for functions with different arities, leading to the incorrect generic Function result instead of the expected function with more parameters."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitAssign(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      String property = lvalue.getLastChild().getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n        }\n      }\n\n      // /** @type ... */object.name = ...;\n      if (info != null && info.hasType()) {\n        visitAnnotatedAssignGetprop(t, assign,\n            info.getType().evaluate(t.getScope(), typeRegistry), object,\n            property, rvalue);\n        return;\n      }\n\n      checkEnumAlias(t, info, rvalue);\n\n      // object.prototype = ...;\n      if (property.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n          }\n        } else {\n          // TODO(user): might want to flag that\n        }\n        return;\n      }\n\n      // object.prototype.property = ...;\n      if (object.isGetProp()) {\n        Node object2 = object.getFirstChild();\n        String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n        if (\"prototype\".equals(property2)) {\n          JSType jsType = getJSType(object2);\n          if (jsType.isFunctionType()) {\n            FunctionType functionType = jsType.toMaybeFunctionType();\n            if (functionType.isConstructor() || functionType.isInterface()) {\n              checkDeclaredPropertyInheritance(\n                  t, assign, functionType, property, info, getJSType(rvalue));\n            }\n          } else {\n            // TODO(user): might want to flag that\n          }\n          return;\n        }\n      }\n\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(property) &&\n            !type.isPropertyTypeInferred(property) &&\n            !propertyIsImplicitCast(type, property)) {\n          validator.expectCanAssignToPropertyOf(\n              t, assign, getJSType(rvalue),\n              type.getPropertyType(property), object, property);\n        }\n        return;\n      }\n    } else if (lvalue.isName()) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getString());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n      }\n    }\n\n    // fall through case\n    JSType leftType = getJSType(lvalue);\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n\n```",
            "method_doc": " Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to. @param t the traversal @param assign the assign node (<code>assign.isAssign()</code> is an implicit invariant) ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failures\n\n**Common Pattern Identified:**\n- All failures relate to method signature validation in inheritance hierarchies\n- The test expects type checking to detect method signature mismatches during method overriding\n- The test framework is expecting warnings/errors that are not being generated\n\n## Key Observations from testMethodInference7:\n\n1. **Test Expectation**: The test expects the type checker to report a method signature mismatch when:\n   - Base class `F` has method `foo` with signature `function(): undefined` (no parameters)\n   - Subclass `G` overrides with `function(x, y): undefined` (two parameters)\n\n2. **Actual Behavior**: The test fails because no warning is generated when it should be\n\n3. **Critical Insight**: The test uses `isError=false` in the test framework setup, meaning it expects no errors, but the test description suggests it should be detecting a signature mismatch\n\n## Recommended Possible Defects in Production Code:\n\n### 1. **Method Signature Validation Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The loose type checker may be incorrectly allowing parameter count mismatches in method overrides. The production code might be:\n- Not properly comparing parameter counts between base and overriding methods\n- Applying overly permissive rules for method signature compatibility\n- Failing to traverse the prototype chain correctly to find the original method signature\n\n### 2. **Type Relationship Resolution**\n**Location**: Type system components handling inheritance and prototype chains\n**Defect**: The code that resolves method overrides and checks compatibility between base and derived class methods may have a flaw where:\n- It doesn't properly validate that overriding methods must have compatible signatures\n- It's missing validation for parameter count consistency\n- It's incorrectly handling the `@override` annotation validation\n\n### 3. **Error Reporting Mechanism**\n**Location**: Warning/error generation logic in type checking\n**Defect**: Even if the type checker detects the signature mismatch internally, the production code might have a bug that prevents the proper warning from being:\n- Generated at the correct severity level\n- Reported through the appropriate channels\n- Matched against the expected error patterns in tests\n\nThe core issue appears to be that the loose type checker is not enforcing method signature compatibility rules strictly enough, particularly regarding parameter counts in overriding methods.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles prototype property assignments where method overrides occur. The test failure involves a method signature mismatch during prototype assignment (G.prototype.foo = function(x, y) { }), and this method contains the logic for checking declared property inheritance through the checkDeclaredPropertyInheritance call, which should validate that overriding methods have compatible signatures with their superclass counterparts."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitFunction(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != null &&\n          baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          (baseConstructor.isInterface() && functionType.isConstructor())) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n      } else {\n        // All interfaces are properly implemented by a class\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        // check properties\n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      // Interface must extend only interfaces\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n        }\n      }\n      // Interface cannot implement any interfaces\n      if (functionType.hasImplementedInterfaces()) {\n        compiler.report(t.makeError(n,\n            CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));\n      }\n      // Check whether the extended interfaces have any conflicts\n      if (functionType.getExtendedInterfacesCount() > 1) {\n        // Only check when extending more than one interfaces\n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Visits a {@link Token#FUNCTION} node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failures\n\n**Common Pattern Identified:**\n- All failures relate to method signature validation in inheritance hierarchies\n- The test expects type checking to detect method signature mismatches during method overriding\n- The test framework is expecting warnings/errors that are not being generated\n\n## Key Observations from testMethodInference7:\n\n1. **Test Expectation**: The test expects the type checker to report a method signature mismatch when:\n   - Base class `F` has method `foo` with signature `function(): undefined` (no parameters)\n   - Subclass `G` overrides with `function(x, y): undefined` (two parameters)\n\n2. **Actual Behavior**: The test fails because no warning is generated when it should be\n\n3. **Critical Insight**: The test uses `isError=false` in the test framework setup, meaning it expects no errors, but the test description suggests it should be detecting a signature mismatch\n\n## Recommended Possible Defects in Production Code:\n\n### 1. **Method Signature Validation Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The loose type checker may be incorrectly allowing parameter count mismatches in method overrides. The production code might be:\n- Not properly comparing parameter counts between base and overriding methods\n- Applying overly permissive rules for method signature compatibility\n- Failing to traverse the prototype chain correctly to find the original method signature\n\n### 2. **Type Relationship Resolution**\n**Location**: Type system components handling inheritance and prototype chains\n**Defect**: The code that resolves method overrides and checks compatibility between base and derived class methods may have a flaw where:\n- It doesn't properly validate that overriding methods must have compatible signatures\n- It's missing validation for parameter count consistency\n- It's incorrectly handling the `@override` annotation validation\n\n### 3. **Error Reporting Mechanism**\n**Location**: Warning/error generation logic in type checking\n**Defect**: Even if the type checker detects the signature mismatch internally, the production code might have a bug that prevents the proper warning from being:\n- Generated at the correct severity level\n- Reported through the appropriate channels\n- Matched against the expected error patterns in tests\n\nThe core issue appears to be that the loose type checker is not enforcing method signature compatibility rules strictly enough, particularly regarding parameter counts in overriding methods.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 8,
            "reason": "#3# This method handles function visitation but focuses primarily on constructor and interface validation, not method signature compatibility checking for regular method overrides. The test failure involves parameter count mismatch detection in method overrides, which is likely handled elsewhere in the type checking system, possibly in property/method validation logic rather than the general function visitation routine."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isSubtype(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      FunctionType other = that.toMaybeFunctionType();\n      if (other.isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }\n\n```",
            "method_doc": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Looking at the test failure, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Pattern Identified:**\n- The test is failing on `assertLeastSupertype` when comparing functions with different parameter counts\n- Expected: `\"function (number, number): boolean\"`\n- Actual: `\"Function\"` (truncated output)\n- This suggests the least supertype calculation is returning a generic `Function` type instead of the more specific function type with two parameters\n\n**Root Cause Analysis:**\n\nThe test expects that when finding the least supertype between:\n- `function(number, number): boolean` (two parameters)\n- `function(number): boolean` (one parameter)\n\nThe result should be `function(number, number): boolean` (the function with more parameters), but instead it's returning a generic `Function` type.\n\n## Recommended Production Code Defect\n\n**Possible Defect in `FunctionType.getLeastSupertype()` method:**\n\nThe bug likely exists in the least supertype calculation logic for `FunctionType` when functions have different arities (parameter counts). The production code is probably:\n\n1. **Incorrectly handling parameter count mismatch**: When comparing functions with different numbers of parameters, the code may be falling back to a generic `Function` type instead of properly selecting the function with more parameters as the least supertype.\n\n2. **Missing arity-based comparison logic**: The implementation may not properly consider that a function with more parameters can accept calls intended for a function with fewer parameters (through partial application or ignoring extra parameters), making it a valid supertype.\n\n3. **Overly conservative type merging**: The algorithm might be too conservative when parameter lists don't match exactly, defaulting to the most generic function type rather than analyzing which function type is more specific.\n\n**Specific location to investigate:**\n- `FunctionType.getLeastSupertype()` method\n- Any helper methods that handle function type comparisons with parameter count differences\n- The type relationship logic between functions with different arities\n\nThe fix should ensure that when comparing functions with the same return type but different parameter counts, the least supertype is the function with more parameters, as this can accommodate calls to both functions.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 8,
            "reason": "#8# The isSubtype method is highly suspicious because it handles function type comparisons but appears to have incomplete logic for handling functions with different parameter counts. The test failure shows that when comparing functions with different arities (one vs two parameters), the least supertype calculation incorrectly returns a generic Function type instead of properly determining that the function with more parameters should be the supertype. The current implementation focuses on \"this\" type covariance and call subtype checking but may not properly handle the parameter count mismatch scenario that's causing the test failure."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (!parent.isFunction()) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        } else {\n          // Object literal keys are not typeable\n          typeable = false;\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.isNE()) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failures\n\n**Common Pattern Identified:**\n- All failures relate to method signature validation in inheritance hierarchies\n- The test expects type checking to detect method signature mismatches during method overriding\n- The test framework is expecting warnings/errors that are not being generated\n\n## Key Observations from testMethodInference7:\n\n1. **Test Expectation**: The test expects the type checker to report a method signature mismatch when:\n   - Base class `F` has method `foo` with signature `function(): undefined` (no parameters)\n   - Subclass `G` overrides with `function(x, y): undefined` (two parameters)\n\n2. **Actual Behavior**: The test fails because no warning is generated when it should be\n\n3. **Critical Insight**: The test uses `isError=false` in the test framework setup, meaning it expects no errors, but the test description suggests it should be detecting a signature mismatch\n\n## Recommended Possible Defects in Production Code:\n\n### 1. **Method Signature Validation Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The loose type checker may be incorrectly allowing parameter count mismatches in method overrides. The production code might be:\n- Not properly comparing parameter counts between base and overriding methods\n- Applying overly permissive rules for method signature compatibility\n- Failing to traverse the prototype chain correctly to find the original method signature\n\n### 2. **Type Relationship Resolution**\n**Location**: Type system components handling inheritance and prototype chains\n**Defect**: The code that resolves method overrides and checks compatibility between base and derived class methods may have a flaw where:\n- It doesn't properly validate that overriding methods must have compatible signatures\n- It's missing validation for parameter count consistency\n- It's incorrectly handling the `@override` annotation validation\n\n### 3. **Error Reporting Mechanism**\n**Location**: Warning/error generation logic in type checking\n**Defect**: Even if the type checker detects the signature mismatch internally, the production code might have a bug that prevents the proper warning from being:\n- Generated at the correct severity level\n- Reported through the appropriate channels\n- Matched against the expected error patterns in tests\n\nThe core issue appears to be that the loose type checker is not enforcing method signature compatibility rules strictly enough, particularly regarding parameter counts in overriding methods.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 3,
            "reason": "#3# This method is the main type checking dispatch method that handles all AST node types, but the specific issue with method signature validation in inheritance hierarchies is likely handled in more specialized methods like visitFunction or visitGetProp that are called from this method, rather than in the main switch statement itself."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isEquivalentTo(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    FunctionType that =\n        JSType.toMaybeFunctionType(otherType);\n    if (that == null) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }\n\n```",
            "method_doc": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Looking at the test failure, I can identify the key issue:\n\n## Analysis of Test Failure\n\n**Pattern Identified:**\n- The test is failing on `assertLeastSupertype` when comparing functions with different parameter counts\n- Expected: `\"function (number, number): boolean\"`\n- Actual: `\"Function\"` (truncated output)\n- This suggests the least supertype calculation is returning a generic `Function` type instead of the more specific function type with two parameters\n\n**Root Cause Analysis:**\n\nThe test expects that when finding the least supertype between:\n- `function(number, number): boolean` (two parameters)\n- `function(number): boolean` (one parameter)\n\nThe result should be `function(number, number): boolean` (the function with more parameters), but instead it's returning a generic `Function` type.\n\n## Recommended Production Code Defect\n\n**Possible Defect in `FunctionType.getLeastSupertype()` method:**\n\nThe bug likely exists in the least supertype calculation logic for `FunctionType` when functions have different arities (parameter counts). The production code is probably:\n\n1. **Incorrectly handling parameter count mismatch**: When comparing functions with different numbers of parameters, the code may be falling back to a generic `Function` type instead of properly selecting the function with more parameters as the least supertype.\n\n2. **Missing arity-based comparison logic**: The implementation may not properly consider that a function with more parameters can accept calls intended for a function with fewer parameters (through partial application or ignoring extra parameters), making it a valid supertype.\n\n3. **Overly conservative type merging**: The algorithm might be too conservative when parameter lists don't match exactly, defaulting to the most generic function type rather than analyzing which function type is more specific.\n\n**Specific location to investigate:**\n- `FunctionType.getLeastSupertype()` method\n- Any helper methods that handle function type comparisons with parameter count differences\n- The type relationship logic between functions with different arities\n\nThe fix should ensure that when comparing functions with the same return type but different parameter counts, the least supertype is the function with more parameters, as this can accommodate calls to both functions.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 3,
            "reason": "#3# The isEquivalentTo method is not the best location to fix because the test failure is about least supertype calculation (getLeastSupertype), not type equivalence checking. The isEquivalentTo method handles type equality for constructors, interfaces, and function signatures, but the test failure specifically involves finding the least supertype between functions with different parameter counts, which is a different operation entirely."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.TypeCheck::checkDeclaredPropertyInheritance(NodeTraversal,Node,FunctionType,String,JSDocInfo,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::checkDeclaredPropertyInheritance(NodeTraversal,Node,FunctionType,String,JSDocInfo,JSType)",
            "method_code": "```java\n  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getPrototype().hasProperty(propertyName);\n    // For interface\n    boolean superInterfacesHasProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfacesHasProperty =\n          superInterfacesHasProperty || interfaceType.hasProperty(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n        if (reportMissingOverride.isOn() && !declaredOverride &&\n            interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride && !superClassHasProperty\n        && !superInterfacesHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    JSType topInstanceType = superClassHasProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n        !declaredOverride && superClassHasProperty) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n      // there's no @override to check\n      return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getPrototype().getPropertyType(propertyName);\n      if (!propertyType.canAssignTo(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfacesHasProperty) {\n      // there is an super interface property\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n            interfaceType.getPropertyType(propertyName);\n          if (!propertyType.canAssignTo(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }\n\n```",
            "method_doc": " Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed. "
        },
        "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.PARAM_LIST:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (!parent.isFunction()) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        } else {\n          // Object literal keys are not typeable\n          typeable = false;\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.isAssign() &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !parent.isExprResult();\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.isNE()) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT_CASE:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.isObjectLit())\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.isObjectLit()) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. "
        },
        "com.google.javascript.jscomp.TypeCheck::visitFunction(NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitFunction(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\n      if (baseConstructor != null &&\n          baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          (baseConstructor.isInterface() && functionType.isConstructor())) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n      } else {\n        // All interfaces are properly implemented by a class\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        // check properties\n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      // Interface must extend only interfaces\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n        }\n      }\n      // Interface cannot implement any interfaces\n      if (functionType.hasImplementedInterfaces()) {\n        compiler.report(t.makeError(n,\n            CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));\n      }\n      // Check whether the extended interfaces have any conflicts\n      if (functionType.getExtendedInterfacesCount() > 1) {\n        // Only check when extending more than one interfaces\n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Visits a {@link Token#FUNCTION} node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. "
        },
        "com.google.javascript.jscomp.TypeCheck::visitAssign(NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitAssign(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    if (lvalue.isGetProp()) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      String property = lvalue.getLastChild().getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.isGetProp()) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n        }\n      }\n\n      // /** @type ... */object.name = ...;\n      if (info != null && info.hasType()) {\n        visitAnnotatedAssignGetprop(t, assign,\n            info.getType().evaluate(t.getScope(), typeRegistry), object,\n            property, rvalue);\n        return;\n      }\n\n      checkEnumAlias(t, info, rvalue);\n\n      // object.prototype = ...;\n      if (property.equals(\"prototype\")) {\n        if (objectJsType != null && objectJsType.isFunctionType()) {\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n          }\n        } else {\n          // TODO(user): might want to flag that\n        }\n        return;\n      }\n\n      // object.prototype.property = ...;\n      if (object.isGetProp()) {\n        Node object2 = object.getFirstChild();\n        String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n        if (\"prototype\".equals(property2)) {\n          JSType jsType = getJSType(object2);\n          if (jsType.isFunctionType()) {\n            FunctionType functionType = jsType.toMaybeFunctionType();\n            if (functionType.isConstructor() || functionType.isInterface()) {\n              checkDeclaredPropertyInheritance(\n                  t, assign, functionType, property, info, getJSType(rvalue));\n            }\n          } else {\n            // TODO(user): might want to flag that\n          }\n          return;\n        }\n      }\n\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(property) &&\n            !type.isPropertyTypeInferred(property) &&\n            !propertyIsImplicitCast(type, property)) {\n          validator.expectCanAssignToPropertyOf(\n              t, assign, getJSType(rvalue),\n              type.getPropertyType(property), object, property);\n        }\n        return;\n      }\n    } else if (lvalue.isName()) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getString());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n      }\n    }\n\n    // fall through case\n    JSType leftType = getJSType(lvalue);\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n\n```",
            "method_doc": " Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to. @param t the traversal @param assign the assign node (<code>assign.isAssign()</code> is an implicit invariant) "
        },
        "com.google.javascript.rhino.jstype.FunctionType::supAndInfHelper(FunctionType,boolean)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::supAndInfHelper(FunctionType,boolean)",
            "method_code": "```java\n  FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {\n    // NOTE(nicksantos): When we remove the unknown type, the function types\n    // form a lattice with the universal constructor at the top of the lattice,\n    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.\n    //\n    // When we introduce the unknown type, it's much more difficult to make\n    // heads or tails of the partial ordering of types, because there's no\n    // clear hierarchy between the different components (parameter types and\n    // return types) in the ArrowType.\n    //\n    // Rather than make the situation more complicated by introducing new\n    // types (like unions of functions), we just fallback on the simpler\n    // approach of getting things right at the top and the bottom of the\n    // lattice.\n    //\n    // If there are unknown parameters or return types making things\n    // ambiguous, then sup(A, B) is always the top function type, and\n    // inf(A, B) is always the bottom function type.\n    Preconditions.checkNotNull(that);\n\n    if (isEquivalentTo(that)) {\n      return this;\n    }\n\n    // If these are ordinary functions, then merge them.\n    // Don't do this if any of the params/return\n    // values are unknown, because then there will be cycles in\n    // their local lattice and they will merge in weird ways.\n    if (isOrdinaryFunction() && that.isOrdinaryFunction() &&\n        !this.call.hasUnknownParamsOrReturn() &&\n        !that.call.hasUnknownParamsOrReturn()) {\n\n      // Check for the degenerate case, but double check\n      // that there's not a cycle.\n      boolean isSubtypeOfThat = this.isSubtype(that);\n      boolean isSubtypeOfThis = that.isSubtype(this);\n      if (isSubtypeOfThat && !isSubtypeOfThis) {\n        return leastSuper ? that : this;\n      } else if (isSubtypeOfThis && !isSubtypeOfThat) {\n        return leastSuper ? this : that;\n      }\n\n      // Merge the two functions component-wise.\n      FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);\n      if (merged != null) {\n        return merged;\n      }\n    }\n\n    // The function instance type is a special case\n    // that lives above the rest of the lattice.\n    JSType functionInstance = registry.getNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE);\n    if (functionInstance.isEquivalentTo(that)) {\n      return leastSuper ? that : this;\n    } else if (functionInstance.isEquivalentTo(this)) {\n      return leastSuper ? this : that;\n    }\n\n    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the\n    // greatest function. In practice, we don't because it's way too\n    // broad. The greatest function takes var_args None parameters, which\n    // means that all parameters register a type warning.\n    //\n    // Instead, we use the U2U ctor type, which has unknown type args.\n    FunctionType greatestFn =\n        registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n    FunctionType leastFn =\n        registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);\n    return leastSuper ? greatestFn : leastFn;\n  }\n\n```",
            "method_doc": " Computes the supremum or infimum of two functions. Because sup() and inf() share a lot of logic for functions, we use a single helper. @param leastSuper If true, compute the supremum of {@code this} with {@code that}. Otherwise compute the infimum. @return The least supertype or greatest subtype. "
        },
        "com.google.javascript.rhino.jstype.FunctionType::isEquivalentTo(JSType)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isEquivalentTo(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    FunctionType that =\n        JSType.toMaybeFunctionType(otherType);\n    if (that == null) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }\n\n```",
            "method_doc": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. "
        },
        "com.google.javascript.rhino.jstype.FunctionType::isSubtype(JSType)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isSubtype(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      FunctionType other = that.toMaybeFunctionType();\n      if (other.isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }\n\n```",
            "method_doc": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. "
        },
        "com.google.javascript.rhino.jstype.FunctionType::tryMergeFunctionPiecewise(FunctionType,boolean)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::tryMergeFunctionPiecewise(FunctionType,boolean)",
            "method_code": "```java\n  private FunctionType tryMergeFunctionPiecewise(\n      FunctionType other, boolean leastSuper) {\n    Node newParamsNode = null;\n    if (call.hasEqualParameters(other.call)) {\n      newParamsNode = call.parameters;\n    } else {\n      // If the parameters are not equal, don't try to merge them.\n      // Someday, we should try to merge the individual params.\n      return null;\n    }\n\n    JSType newReturnType = leastSuper ?\n        call.returnType.getLeastSupertype(other.call.returnType) :\n        call.returnType.getGreatestSubtype(other.call.returnType);\n\n    ObjectType newTypeOfThis = null;\n    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n      newTypeOfThis = typeOfThis;\n    } else {\n      JSType maybeNewTypeOfThis = leastSuper ?\n          typeOfThis.getLeastSupertype(other.typeOfThis) :\n          typeOfThis.getGreatestSubtype(other.typeOfThis);\n      if (maybeNewTypeOfThis instanceof ObjectType) {\n        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n      } else {\n        newTypeOfThis = leastSuper ?\n            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n    }\n\n    boolean newReturnTypeInferred =\n        call.returnTypeInferred || other.call.returnTypeInferred;\n\n    return new FunctionType(\n        registry, null, null,\n        new ArrowType(\n            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n        newTypeOfThis, null, false, false);\n  }\n\n```",
            "method_doc": " Try to get the sup/inf of two functions by looking at the piecewise components. "
        }
    }
}