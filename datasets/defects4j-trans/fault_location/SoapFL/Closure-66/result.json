{
    "buggy_classes": [
        "com.google.javascript.jscomp.TypeCheck"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarCurrentParent) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JSType TransVarChild;\n    JSType TransVarType, TransVarRightTypeValue;\n    Node TransVarLeftNode, TransVarRightNode;\n    // To be explicitly set to false if the node is not typeable.\n    boolean TransVarTypeValue = true;\n\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))){if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransBreakFlag0=false;TransVarTypeValue=visitName(TransVarTraversal,TransVarNode,TransVarCurrentParent);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LP))))){TransBreakFlag0=false;if (!(!(TransVarCurrentParent.getType() != Token.FUNCTION))){ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getFirstChild()));} else {TransVarTypeValue=false;}}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.COMMA))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getLastChild()));}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRUE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FALSE))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THIS))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,TransVarTraversal.getScope().getTypeOfThis());}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REF_SPECIAL))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET_REF))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getFirstChild()));}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NULL))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,NULL_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NUMBER))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.STRING))))){TransBreakFlag0=false;if (!(!(!NodeUtil.isObjectLitKey(TransVarNode, TransVarNode.getParent())))){ensureTyped(TransVarTraversal,TransVarNode,STRING_TYPE);}}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SET))))){TransBreakFlag0=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ARRAYLIT))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,ARRAY_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REGEXP))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,REGEXP_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETPROP))))){TransBreakFlag0=false;visitGetProp(TransVarTraversal,TransVarNode,TransVarCurrentParent);TransVarTypeValue=!(TransVarCurrentParent.getType() == Token.ASSIGN && TransVarCurrentParent.getFirstChild() == TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETELEM))))){TransBreakFlag0=false;visitGetElem(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))){TransBreakFlag0=false;visitVar(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEW))))){TransBreakFlag0=false;visitNew(TransVarTraversal,TransVarNode);TransVarTypeValue=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CALL))))){TransBreakFlag0=false;visitCall(TransVarTraversal,TransVarNode);TransVarTypeValue=!NodeUtil.isExpressionNode(TransVarCurrentParent);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RETURN))))){TransBreakFlag0=false;visitReturn(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEC))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INC))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();validator.expectNumber(TransVarTraversal,TransVarLeftNode,getJSType(TransVarLeftNode),\"increment/decrement\");ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NOT))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VOID))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,VOID_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TYPEOF))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,STRING_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITNOT))))){TransBreakFlag0=false;TransVarChild=getJSType(TransVarNode.getFirstChild());if (!(!(!TransVarChild.matchesInt32Context()))){report(TransVarTraversal,TransVarNode,BIT_OPERATION,NodeUtil.opToStr(TransVarNode.getType()),TransVarChild.toString());}ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.POS))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEG))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();validator.expectNumber(TransVarTraversal,TransVarLeftNode,getJSType(TransVarLeftNode),\"sign operator\");ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EQ))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());JSType TransVarLeftTypeValue=TransVarType.restrictByNotNullOrUndefined();JSType TransVarRightTypeNotNullOrUndefined=TransVarRightTypeValue.restrictByNotNullOrUndefined();TernaryValue TransVarTernaryValue=TransVarLeftTypeValue.testForEquality(TransVarRightTypeNotNullOrUndefined);if (!(!(TransVarTernaryValue != TernaryValue.UNKNOWN))){if (!(!(TransVarNode.getType() == Token.NE))){TransVarTernaryValue=TransVarTernaryValue.not();}report(TransVarTraversal,TransVarNode,DETERMINISTIC_TEST,TransVarType.toString(),TransVarRightTypeValue.toString(),TransVarTernaryValue.toString());}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHEQ))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHNE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());JSType TransVarLeftTypeRestrictedNotNullOrUndefined=TransVarType.restrictByNotNullOrUndefined();JSType TransVarRightType=TransVarRightTypeValue.restrictByNotNullOrUndefined();if (!(!(!TransVarLeftTypeRestrictedNotNullOrUndefined.canTestForShallowEqualityWith(TransVarRightType)))){report(TransVarTraversal,TransVarNode,DETERMINISTIC_TEST_NO_RESULT,TransVarType.toString(),TransVarRightTypeValue.toString());}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());if (!(!(TransVarRightTypeValue.isNumber()))){validator.expectNumber(TransVarTraversal,TransVarNode,TransVarType,\"left side of numeric comparison\");} else if (!(!(TransVarType.isNumber()))){validator.expectNumber(TransVarTraversal,TransVarNode,TransVarRightTypeValue,\"right side of numeric comparison\");} else if (!(!(TransVarType.matchesNumberContext() && TransVarRightTypeValue.matchesNumberContext()))){} else {String TransVarMessage2=\"left side of comparison\";validator.expectString(TransVarTraversal,TransVarNode,TransVarType,TransVarMessage2);validator.expectNotNullOrUndefined(TransVarTraversal,TransVarNode,TransVarType,TransVarMessage2,getNativeType(STRING_TYPE));TransVarMessage2=\"right side of comparison\";validator.expectString(TransVarTraversal,TransVarNode,TransVarRightTypeValue,TransVarMessage2);validator.expectNotNullOrUndefined(TransVarTraversal,TransVarNode,TransVarRightTypeValue,TransVarMessage2,getNativeType(STRING_TYPE));}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IN))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();TransVarRightNode=TransVarNode.getLastChild();TransVarType=getJSType(TransVarLeftNode);TransVarRightTypeValue=getJSType(TransVarRightNode);validator.expectObject(TransVarTraversal,TransVarNode,TransVarRightTypeValue,\"'in' requires an object\");validator.expectString(TransVarTraversal,TransVarLeftNode,TransVarType,\"left side of 'in'\");ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INSTANCEOF))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();TransVarRightNode=TransVarNode.getLastChild();TransVarType=getJSType(TransVarLeftNode);TransVarRightTypeValue=getJSType(TransVarRightNode).restrictByNotNullOrUndefined();validator.expectAnyObject(TransVarTraversal,TransVarLeftNode,TransVarType,\"deterministic instanceof yields false\");validator.expectActualObject(TransVarTraversal,TransVarRightNode,TransVarRightTypeValue,\"instanceof requires an object\");ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN))))){TransBreakFlag0=false;visitAssign(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_LSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_RSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_URSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_DIV))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MOD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITXOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITAND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_SUB))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_ADD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MUL))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.URSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DIV))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MOD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITXOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITAND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SUB))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ADD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MUL))))){TransBreakFlag0=false;visitBinaryOperator(TransVarNode.getType(),TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DELPROP))))){TransBreakFlag0=false;if (!(!(!isReference(TransVarNode.getFirstChild())))){report(TransVarTraversal,TransVarNode,BAD_DELETE);}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CASE))))){TransBreakFlag0=false;JSType TransVarSwitchType2=getJSType(TransVarCurrentParent.getFirstChild());JSType TransVarCaseType2=getJSType(TransVarNode.getFirstChild());validator.expectSwitchMatchesCase(TransVarTraversal,TransVarNode,TransVarSwitchType2,TransVarCaseType2);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WITH))))){TransBreakFlag0=false;Node TransVarChildNode=TransVarNode.getFirstChild();TransVarChild=getJSType(TransVarChildNode);validator.expectObject(TransVarTraversal,TransVarChildNode,TransVarChild,\"with requires an object\");TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))){TransBreakFlag0=false;visitFunction(TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL_NAME))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SWITCH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BREAK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CATCH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRY))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EXPR_RESULT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EMPTY))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEFAULT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CONTINUE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEBUGGER))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THROW))))){TransBreakFlag0=false;TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))){TransBreakFlag0=false;TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OBJECTLIT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))){TransBreakFlag0=false;if (!(!(TransVarNode.getJSType() != null))){ensureTyped(TransVarTraversal,TransVarNode);} else {if (!(!((TransVarNode.getType() == Token.OBJECTLIT) && (TransVarCurrentParent.getJSType() instanceof EnumType)))){ensureTyped(TransVarTraversal,TransVarNode,TransVarCurrentParent.getJSType());} else {ensureTyped(TransVarTraversal,TransVarNode);}}if (!(!(TransVarNode.getType() == Token.OBJECTLIT))){for (Node TransVarChildKey:TransVarNode.children()){visitObjLitKey(TransVarTraversal,TransVarChildKey,TransVarNode);}}}if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))){report(TransVarTraversal,TransVarNode,UNEXPECTED_TOKEN,Token.name(TransVarNode.getType()));ensureTyped(TransVarTraversal,TransVarNode);}}\n\n    // Don't count externs since the user's code may not even use that part.\n    TransVarTypeValue = TransVarTypeValue && !inExterns;\n\n    if (!(!(TransVarTypeValue))) {\n      doPercentTypedAccounting(TransVarTraversal, TransVarNode);\n    }\n\n    checkNoTypeCheckSection(TransVarNode, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze the failed tests systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Step 1: Analysis of Common Patterns\n\n**Similarities across failed tests:**\n\n1. **Both tests expect 100% type coverage** but receive significantly lower percentages:\n   - testGetTypedPercent5: expected 100.0%, got 62.5% (37.5% untyped)\n   - testGetTypedPercent6: expected 100.0%, got 66.67% (33.33% untyped)\n\n2. **Both involve object/enum declarations**:\n   - testGetTypedPercent5: Enum declaration with `/** @enum {number} */`\n   - testGetTypedPercent6: Object literal with uppercase property names\n\n3. **Both use the same utility method**: `getTypedPercent()` which relies on `TypeCheck.getTypedPercent()`\n\n4. **The failure pattern suggests** that certain AST nodes in enum/object declarations are not being properly typed during type analysis.\n\n## Step 2: Root Cause Analysis\n\nThe key observation is that both tests involve object-like structures where the type checker is failing to assign types to specific nodes. Given that:\n\n- The enum in testGetTypedPercent5 has explicit type annotations but still shows only 62.5% coverage\n- The object literal in testGetTypedPercent6 shows 66.67% coverage despite having simple property assignments\n\n## Step 3: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The `TypeCheck` class in the production code likely has a bug in how it handles type assignment for **object property nodes** or **enum member nodes**.\n\n**Specific Location**: The defect is probably in the type checking logic that processes:\n- Object literal property nodes (`ObjectLit` AST nodes)\n- Enum member declarations\n- Property assignment nodes within object/enum structures\n\n**Root Cause Hypothesis**: The type checker is failing to properly propagate type information to all descendant nodes of object/enum declarations. Specifically:\n\n1. **For enums**: The enum type annotation `{number}` may not be properly applied to individual enum member values\n2. **For object literals**: Property names (like `TRUE`, `FALSE`) or their assigned values may not be receiving proper type inference\n\n**Affected Method**: The issue likely resides in `com.google.javascript.jscomp.TypeCheck.getTypedPercent()` or in the underlying type assignment logic within the type checking process, particularly in methods that handle:\n- `visitObjectLit()` or similar object traversal methods\n- Enum type resolution and propagation\n- Property type inference algorithms\n\nThe defect causes certain AST nodes within object/enum structures to be counted as \"untyped\" even when they should have inferable or explicitly declared types.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles OBJECTLIT token types but lacks proper type assignment for object literal property keys and enum members. The failed tests involve enum declarations and object literals where property nodes are not being properly typed, causing lower typed percentage calculations. The method's logic for OBJECTLIT nodes appears incomplete and doesn't ensure all descendant nodes receive appropriate type information."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::doPercentTypedAccounting(NodeTraversal,Node)",
            "method_code": "```java\n  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }\n\n```",
            "method_doc": " Counts the given node in the typed statistics. @param n a node that should be typed ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze the failed tests systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Step 1: Analysis of Common Patterns\n\n**Similarities across failed tests:**\n\n1. **Both tests expect 100% type coverage** but receive significantly lower percentages:\n   - testGetTypedPercent5: expected 100.0%, got 62.5% (37.5% untyped)\n   - testGetTypedPercent6: expected 100.0%, got 66.67% (33.33% untyped)\n\n2. **Both involve object/enum declarations**:\n   - testGetTypedPercent5: Enum declaration with `/** @enum {number} */`\n   - testGetTypedPercent6: Object literal with uppercase property names\n\n3. **Both use the same utility method**: `getTypedPercent()` which relies on `TypeCheck.getTypedPercent()`\n\n4. **The failure pattern suggests** that certain AST nodes in enum/object declarations are not being properly typed during type analysis.\n\n## Step 2: Root Cause Analysis\n\nThe key observation is that both tests involve object-like structures where the type checker is failing to assign types to specific nodes. Given that:\n\n- The enum in testGetTypedPercent5 has explicit type annotations but still shows only 62.5% coverage\n- The object literal in testGetTypedPercent6 shows 66.67% coverage despite having simple property assignments\n\n## Step 3: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The `TypeCheck` class in the production code likely has a bug in how it handles type assignment for **object property nodes** or **enum member nodes**.\n\n**Specific Location**: The defect is probably in the type checking logic that processes:\n- Object literal property nodes (`ObjectLit` AST nodes)\n- Enum member declarations\n- Property assignment nodes within object/enum structures\n\n**Root Cause Hypothesis**: The type checker is failing to properly propagate type information to all descendant nodes of object/enum declarations. Specifically:\n\n1. **For enums**: The enum type annotation `{number}` may not be properly applied to individual enum member values\n2. **For object literals**: Property names (like `TRUE`, `FALSE`) or their assigned values may not be receiving proper type inference\n\n**Affected Method**: The issue likely resides in `com.google.javascript.jscomp.TypeCheck.getTypedPercent()` or in the underlying type assignment logic within the type checking process, particularly in methods that handle:\n- `visitObjectLit()` or similar object traversal methods\n- Enum type resolution and propagation\n- Property type inference algorithms\n\nThe defect causes certain AST nodes within object/enum structures to be counted as \"untyped\" even when they should have inferable or explicitly declared types.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it directly handles the type accounting logic that determines what counts as \"typed\" vs \"untyped\" nodes. The failed tests show that enum members and object literal properties are being incorrectly counted as untyped (null or unknown types) even though they should have proper type information. The method's current logic only increments typedCount when a node has a non-null, non-unknown type, but it appears that enum member nodes and object property nodes are either not receiving proper type assignments or are being incorrectly classified as unknown types when they should have inferable types."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitObjLitKey(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {\n    // TODO(johnlenz): Validate get and set function declarations are valid\n    // as is the functions can have \"extraneous\" bits.\n\n    // For getter and setter property definitions the\n    // rvalue type != the property type.\n    Node rvalue = key.getFirstChild();\n    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n        key, getJSType(rvalue));\n    if (rightType == null) {\n      rightType = getNativeType(UNKNOWN_TYPE);\n    }\n\n    Node owner = objlit;\n\n    // Validate value is assignable to the key type.\n\n    JSType keyType = getJSType(key);\n    boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n        rightType, keyType,\n        owner, NodeUtil.getObjectLitKeyName(key));\n    if (valid) {\n      ensureTyped(t, key, rightType);\n    } else {\n      ensureTyped(t, key);\n    }\n\n    // Validate that the key type is assignable to the object property type.\n    // This is necessary as the objlit may have been cast to a non-literal\n    // object type.\n    // TODO(johnlenz): consider introducing a CAST node to the AST (or\n    // perhaps a parentheses node).\n\n    JSType objlitType = getJSType(objlit);\n    ObjectType type = ObjectType.cast(\n        objlitType.restrictByNotNullOrUndefined());\n    if (type != null) {\n      String property = NodeUtil.getObjectLitKeyName(key);\n      if (type.hasProperty(property) &&\n          !type.isPropertyTypeInferred(property) &&\n          !propertyIsImplicitCast(type, property)) {\n        validator.expectCanAssignToPropertyOf(\n            t, key, keyType,\n            type.getPropertyType(property), owner, property);\n      }\n      return;\n    }\n  }\n\n```",
            "method_doc": " Visits an object literal field definition <code>key : value</code>.  If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.  @param t the traversal @param key the assign node ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze the failed tests systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Step 1: Analysis of Common Patterns\n\n**Similarities across failed tests:**\n\n1. **Both tests expect 100% type coverage** but receive significantly lower percentages:\n   - testGetTypedPercent5: expected 100.0%, got 62.5% (37.5% untyped)\n   - testGetTypedPercent6: expected 100.0%, got 66.67% (33.33% untyped)\n\n2. **Both involve object/enum declarations**:\n   - testGetTypedPercent5: Enum declaration with `/** @enum {number} */`\n   - testGetTypedPercent6: Object literal with uppercase property names\n\n3. **Both use the same utility method**: `getTypedPercent()` which relies on `TypeCheck.getTypedPercent()`\n\n4. **The failure pattern suggests** that certain AST nodes in enum/object declarations are not being properly typed during type analysis.\n\n## Step 2: Root Cause Analysis\n\nThe key observation is that both tests involve object-like structures where the type checker is failing to assign types to specific nodes. Given that:\n\n- The enum in testGetTypedPercent5 has explicit type annotations but still shows only 62.5% coverage\n- The object literal in testGetTypedPercent6 shows 66.67% coverage despite having simple property assignments\n\n## Step 3: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The `TypeCheck` class in the production code likely has a bug in how it handles type assignment for **object property nodes** or **enum member nodes**.\n\n**Specific Location**: The defect is probably in the type checking logic that processes:\n- Object literal property nodes (`ObjectLit` AST nodes)\n- Enum member declarations\n- Property assignment nodes within object/enum structures\n\n**Root Cause Hypothesis**: The type checker is failing to properly propagate type information to all descendant nodes of object/enum declarations. Specifically:\n\n1. **For enums**: The enum type annotation `{number}` may not be properly applied to individual enum member values\n2. **For object literals**: Property names (like `TRUE`, `FALSE`) or their assigned values may not be receiving proper type inference\n\n**Affected Method**: The issue likely resides in `com.google.javascript.jscomp.TypeCheck.getTypedPercent()` or in the underlying type assignment logic within the type checking process, particularly in methods that handle:\n- `visitObjectLit()` or similar object traversal methods\n- Enum type resolution and propagation\n- Property type inference algorithms\n\nThe defect causes certain AST nodes within object/enum structures to be counted as \"untyped\" even when they should have inferable or explicitly declared types.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles object literal key typing, and both failed tests involve object/enum declarations where the type checker is incorrectly calculating typed percentage. The method contains logic for type assignment to object literal keys and values, and the failures suggest that certain nodes in enum/object structures are not being properly typed, which aligns with this method's responsibility for ensuring object literal keys receive correct type information."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)",
            "method_code": "```java\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n```",
            "method_doc": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze the failed tests systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Step 1: Analysis of Common Patterns\n\n**Similarities across failed tests:**\n\n1. **Both tests expect 100% type coverage** but receive significantly lower percentages:\n   - testGetTypedPercent5: expected 100.0%, got 62.5% (37.5% untyped)\n   - testGetTypedPercent6: expected 100.0%, got 66.67% (33.33% untyped)\n\n2. **Both involve object/enum declarations**:\n   - testGetTypedPercent5: Enum declaration with `/** @enum {number} */`\n   - testGetTypedPercent6: Object literal with uppercase property names\n\n3. **Both use the same utility method**: `getTypedPercent()` which relies on `TypeCheck.getTypedPercent()`\n\n4. **The failure pattern suggests** that certain AST nodes in enum/object declarations are not being properly typed during type analysis.\n\n## Step 2: Root Cause Analysis\n\nThe key observation is that both tests involve object-like structures where the type checker is failing to assign types to specific nodes. Given that:\n\n- The enum in testGetTypedPercent5 has explicit type annotations but still shows only 62.5% coverage\n- The object literal in testGetTypedPercent6 shows 66.67% coverage despite having simple property assignments\n\n## Step 3: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The `TypeCheck` class in the production code likely has a bug in how it handles type assignment for **object property nodes** or **enum member nodes**.\n\n**Specific Location**: The defect is probably in the type checking logic that processes:\n- Object literal property nodes (`ObjectLit` AST nodes)\n- Enum member declarations\n- Property assignment nodes within object/enum structures\n\n**Root Cause Hypothesis**: The type checker is failing to properly propagate type information to all descendant nodes of object/enum declarations. Specifically:\n\n1. **For enums**: The enum type annotation `{number}` may not be properly applied to individual enum member values\n2. **For object literals**: Property names (like `TRUE`, `FALSE`) or their assigned values may not be receiving proper type inference\n\n**Affected Method**: The issue likely resides in `com.google.javascript.jscomp.TypeCheck.getTypedPercent()` or in the underlying type assignment logic within the type checking process, particularly in methods that handle:\n- `visitObjectLit()` or similar object traversal methods\n- Enum type resolution and propagation\n- Property type inference algorithms\n\nThe defect causes certain AST nodes within object/enum structures to be counted as \"untyped\" even when they should have inferable or explicitly declared types.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The ensureTyped method is highly suspicious because it's responsible for assigning types to AST nodes, and the test failures show that certain nodes in enum/object declarations are not being properly typed. The method's logic for handling JSDocInfo and type assignment could be failing to properly type object property nodes or enum member values, which would explain why the typed percentage calculations are lower than expected in both test cases."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::getTypedPercent()",
            "method_code": "```java\n  double getTypedPercent() {\n    int total = nullCount + unknownCount + typedCount;\n    if (total == 0) {\n      return 0.0;\n    } else {\n      return (100.0 * typedCount) / total;\n    }\n  }\n\n```",
            "method_doc": " Returns the percentage of nodes typed by the type checker. @return a number between 0.0 and 100.0 ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze the failed tests systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Step 1: Analysis of Common Patterns\n\n**Similarities across failed tests:**\n\n1. **Both tests expect 100% type coverage** but receive significantly lower percentages:\n   - testGetTypedPercent5: expected 100.0%, got 62.5% (37.5% untyped)\n   - testGetTypedPercent6: expected 100.0%, got 66.67% (33.33% untyped)\n\n2. **Both involve object/enum declarations**:\n   - testGetTypedPercent5: Enum declaration with `/** @enum {number} */`\n   - testGetTypedPercent6: Object literal with uppercase property names\n\n3. **Both use the same utility method**: `getTypedPercent()` which relies on `TypeCheck.getTypedPercent()`\n\n4. **The failure pattern suggests** that certain AST nodes in enum/object declarations are not being properly typed during type analysis.\n\n## Step 2: Root Cause Analysis\n\nThe key observation is that both tests involve object-like structures where the type checker is failing to assign types to specific nodes. Given that:\n\n- The enum in testGetTypedPercent5 has explicit type annotations but still shows only 62.5% coverage\n- The object literal in testGetTypedPercent6 shows 66.67% coverage despite having simple property assignments\n\n## Step 3: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The `TypeCheck` class in the production code likely has a bug in how it handles type assignment for **object property nodes** or **enum member nodes**.\n\n**Specific Location**: The defect is probably in the type checking logic that processes:\n- Object literal property nodes (`ObjectLit` AST nodes)\n- Enum member declarations\n- Property assignment nodes within object/enum structures\n\n**Root Cause Hypothesis**: The type checker is failing to properly propagate type information to all descendant nodes of object/enum declarations. Specifically:\n\n1. **For enums**: The enum type annotation `{number}` may not be properly applied to individual enum member values\n2. **For object literals**: Property names (like `TRUE`, `FALSE`) or their assigned values may not be receiving proper type inference\n\n**Affected Method**: The issue likely resides in `com.google.javascript.jscomp.TypeCheck.getTypedPercent()` or in the underlying type assignment logic within the type checking process, particularly in methods that handle:\n- `visitObjectLit()` or similar object traversal methods\n- Enum type resolution and propagation\n- Property type inference algorithms\n\nThe defect causes certain AST nodes within object/enum structures to be counted as \"untyped\" even when they should have inferable or explicitly declared types.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 3,
            "reason": "#3# This method is not the best location to be fixed because it only calculates percentages based on counters (nullCount, unknownCount, typedCount) that are populated elsewhere in the type checking logic. The actual bug likely resides in the type assignment logic that determines which nodes get counted as typed vs untyped, particularly for object/enum property nodes."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarCurrentParent) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JSType TransVarChild;\n    JSType TransVarType, TransVarRightTypeValue;\n    Node TransVarLeftNode, TransVarRightNode;\n    // To be explicitly set to false if the node is not typeable.\n    boolean TransVarTypeValue = true;\n\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))){if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransBreakFlag0=false;TransVarTypeValue=visitName(TransVarTraversal,TransVarNode,TransVarCurrentParent);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LP))))){TransBreakFlag0=false;if (!(!(TransVarCurrentParent.getType() != Token.FUNCTION))){ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getFirstChild()));} else {TransVarTypeValue=false;}}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.COMMA))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getLastChild()));}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRUE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FALSE))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THIS))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,TransVarTraversal.getScope().getTypeOfThis());}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REF_SPECIAL))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET_REF))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,getJSType(TransVarNode.getFirstChild()));}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NULL))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,NULL_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NUMBER))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.STRING))))){TransBreakFlag0=false;if (!(!(!NodeUtil.isObjectLitKey(TransVarNode, TransVarNode.getParent())))){ensureTyped(TransVarTraversal,TransVarNode,STRING_TYPE);}}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SET))))){TransBreakFlag0=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ARRAYLIT))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,ARRAY_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REGEXP))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,REGEXP_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETPROP))))){TransBreakFlag0=false;visitGetProp(TransVarTraversal,TransVarNode,TransVarCurrentParent);TransVarTypeValue=!(TransVarCurrentParent.getType() == Token.ASSIGN && TransVarCurrentParent.getFirstChild() == TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETELEM))))){TransBreakFlag0=false;visitGetElem(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))){TransBreakFlag0=false;visitVar(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEW))))){TransBreakFlag0=false;visitNew(TransVarTraversal,TransVarNode);TransVarTypeValue=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CALL))))){TransBreakFlag0=false;visitCall(TransVarTraversal,TransVarNode);TransVarTypeValue=!NodeUtil.isExpressionNode(TransVarCurrentParent);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RETURN))))){TransBreakFlag0=false;visitReturn(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEC))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INC))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();validator.expectNumber(TransVarTraversal,TransVarLeftNode,getJSType(TransVarLeftNode),\"increment/decrement\");ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NOT))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VOID))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,VOID_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TYPEOF))))){TransBreakFlag0=false;ensureTyped(TransVarTraversal,TransVarNode,STRING_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITNOT))))){TransBreakFlag0=false;TransVarChild=getJSType(TransVarNode.getFirstChild());if (!(!(!TransVarChild.matchesInt32Context()))){report(TransVarTraversal,TransVarNode,BIT_OPERATION,NodeUtil.opToStr(TransVarNode.getType()),TransVarChild.toString());}ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.POS))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEG))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();validator.expectNumber(TransVarTraversal,TransVarLeftNode,getJSType(TransVarLeftNode),\"sign operator\");ensureTyped(TransVarTraversal,TransVarNode,NUMBER_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EQ))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());JSType TransVarLeftTypeValue=TransVarType.restrictByNotNullOrUndefined();JSType TransVarRightTypeNotNullOrUndefined=TransVarRightTypeValue.restrictByNotNullOrUndefined();TernaryValue TransVarTernaryValue=TransVarLeftTypeValue.testForEquality(TransVarRightTypeNotNullOrUndefined);if (!(!(TransVarTernaryValue != TernaryValue.UNKNOWN))){if (!(!(TransVarNode.getType() == Token.NE))){TransVarTernaryValue=TransVarTernaryValue.not();}report(TransVarTraversal,TransVarNode,DETERMINISTIC_TEST,TransVarType.toString(),TransVarRightTypeValue.toString(),TransVarTernaryValue.toString());}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHEQ))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHNE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());JSType TransVarLeftTypeRestrictedNotNullOrUndefined=TransVarType.restrictByNotNullOrUndefined();JSType TransVarRightType=TransVarRightTypeValue.restrictByNotNullOrUndefined();if (!(!(!TransVarLeftTypeRestrictedNotNullOrUndefined.canTestForShallowEqualityWith(TransVarRightType)))){report(TransVarTraversal,TransVarNode,DETERMINISTIC_TEST_NO_RESULT,TransVarType.toString(),TransVarRightTypeValue.toString());}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GE))))){TransBreakFlag0=false;TransVarType=getJSType(TransVarNode.getFirstChild());TransVarRightTypeValue=getJSType(TransVarNode.getLastChild());if (!(!(TransVarRightTypeValue.isNumber()))){validator.expectNumber(TransVarTraversal,TransVarNode,TransVarType,\"left side of numeric comparison\");} else if (!(!(TransVarType.isNumber()))){validator.expectNumber(TransVarTraversal,TransVarNode,TransVarRightTypeValue,\"right side of numeric comparison\");} else if (!(!(TransVarType.matchesNumberContext() && TransVarRightTypeValue.matchesNumberContext()))){} else {String TransVarMessage2=\"left side of comparison\";validator.expectString(TransVarTraversal,TransVarNode,TransVarType,TransVarMessage2);validator.expectNotNullOrUndefined(TransVarTraversal,TransVarNode,TransVarType,TransVarMessage2,getNativeType(STRING_TYPE));TransVarMessage2=\"right side of comparison\";validator.expectString(TransVarTraversal,TransVarNode,TransVarRightTypeValue,TransVarMessage2);validator.expectNotNullOrUndefined(TransVarTraversal,TransVarNode,TransVarRightTypeValue,TransVarMessage2,getNativeType(STRING_TYPE));}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IN))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();TransVarRightNode=TransVarNode.getLastChild();TransVarType=getJSType(TransVarLeftNode);TransVarRightTypeValue=getJSType(TransVarRightNode);validator.expectObject(TransVarTraversal,TransVarNode,TransVarRightTypeValue,\"'in' requires an object\");validator.expectString(TransVarTraversal,TransVarLeftNode,TransVarType,\"left side of 'in'\");ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INSTANCEOF))))){TransBreakFlag0=false;TransVarLeftNode=TransVarNode.getFirstChild();TransVarRightNode=TransVarNode.getLastChild();TransVarType=getJSType(TransVarLeftNode);TransVarRightTypeValue=getJSType(TransVarRightNode).restrictByNotNullOrUndefined();validator.expectAnyObject(TransVarTraversal,TransVarLeftNode,TransVarType,\"deterministic instanceof yields false\");validator.expectActualObject(TransVarTraversal,TransVarRightNode,TransVarRightTypeValue,\"instanceof requires an object\");ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN))))){TransBreakFlag0=false;visitAssign(TransVarTraversal,TransVarNode);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_LSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_RSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_URSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_DIV))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MOD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITXOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITAND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_SUB))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_ADD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MUL))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.URSH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DIV))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MOD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITXOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITAND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SUB))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ADD))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MUL))))){TransBreakFlag0=false;visitBinaryOperator(TransVarNode.getType(),TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DELPROP))))){TransBreakFlag0=false;if (!(!(!isReference(TransVarNode.getFirstChild())))){report(TransVarTraversal,TransVarNode,BAD_DELETE);}ensureTyped(TransVarTraversal,TransVarNode,BOOLEAN_TYPE);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CASE))))){TransBreakFlag0=false;JSType TransVarSwitchType2=getJSType(TransVarCurrentParent.getFirstChild());JSType TransVarCaseType2=getJSType(TransVarNode.getFirstChild());validator.expectSwitchMatchesCase(TransVarTraversal,TransVarNode,TransVarSwitchType2,TransVarCaseType2);TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WITH))))){TransBreakFlag0=false;Node TransVarChildNode=TransVarNode.getFirstChild();TransVarChild=getJSType(TransVarChildNode);validator.expectObject(TransVarTraversal,TransVarChildNode,TransVarChild,\"with requires an object\");TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))){TransBreakFlag0=false;visitFunction(TransVarTraversal,TransVarNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL_NAME))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SWITCH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BREAK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CATCH))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRY))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EXPR_RESULT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EMPTY))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEFAULT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CONTINUE))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEBUGGER))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THROW))))){TransBreakFlag0=false;TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))){TransBreakFlag0=false;TransVarTypeValue=false;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OBJECTLIT))))){TransFallThroughFlag0=true;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))){TransBreakFlag0=false;if (!(!(TransVarNode.getJSType() != null))){ensureTyped(TransVarTraversal,TransVarNode);} else {if (!(!((TransVarNode.getType() == Token.OBJECTLIT) && (TransVarCurrentParent.getJSType() instanceof EnumType)))){ensureTyped(TransVarTraversal,TransVarNode,TransVarCurrentParent.getJSType());} else {ensureTyped(TransVarTraversal,TransVarNode);}}if (!(!(TransVarNode.getType() == Token.OBJECTLIT))){for (Node TransVarChildKey:TransVarNode.children()){visitObjLitKey(TransVarTraversal,TransVarChildKey,TransVarNode);}}}if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))){report(TransVarTraversal,TransVarNode,UNEXPECTED_TOKEN,Token.name(TransVarNode.getType()));ensureTyped(TransVarTraversal,TransVarNode);}}\n\n    // Don't count externs since the user's code may not even use that part.\n    TransVarTypeValue = TransVarTypeValue && !inExterns;\n\n    if (!(!(TransVarTypeValue))) {\n      doPercentTypedAccounting(TransVarTraversal, TransVarNode);\n    }\n\n    checkNoTypeCheckSection(TransVarNode, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. "
        },
        "com.google.javascript.jscomp.TypeCheck::doPercentTypedAccounting(NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::doPercentTypedAccounting(NodeTraversal,Node)",
            "method_code": "```java\n  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }\n\n```",
            "method_doc": " Counts the given node in the typed statistics. @param n a node that should be typed "
        },
        "com.google.javascript.jscomp.TypeCheck::visitObjLitKey(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitObjLitKey(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {\n    // TODO(johnlenz): Validate get and set function declarations are valid\n    // as is the functions can have \"extraneous\" bits.\n\n    // For getter and setter property definitions the\n    // rvalue type != the property type.\n    Node rvalue = key.getFirstChild();\n    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n        key, getJSType(rvalue));\n    if (rightType == null) {\n      rightType = getNativeType(UNKNOWN_TYPE);\n    }\n\n    Node owner = objlit;\n\n    // Validate value is assignable to the key type.\n\n    JSType keyType = getJSType(key);\n    boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n        rightType, keyType,\n        owner, NodeUtil.getObjectLitKeyName(key));\n    if (valid) {\n      ensureTyped(t, key, rightType);\n    } else {\n      ensureTyped(t, key);\n    }\n\n    // Validate that the key type is assignable to the object property type.\n    // This is necessary as the objlit may have been cast to a non-literal\n    // object type.\n    // TODO(johnlenz): consider introducing a CAST node to the AST (or\n    // perhaps a parentheses node).\n\n    JSType objlitType = getJSType(objlit);\n    ObjectType type = ObjectType.cast(\n        objlitType.restrictByNotNullOrUndefined());\n    if (type != null) {\n      String property = NodeUtil.getObjectLitKeyName(key);\n      if (type.hasProperty(property) &&\n          !type.isPropertyTypeInferred(property) &&\n          !propertyIsImplicitCast(type, property)) {\n        validator.expectCanAssignToPropertyOf(\n            t, key, keyType,\n            type.getPropertyType(property), owner, property);\n      }\n      return;\n    }\n  }\n\n```",
            "method_doc": " Visits an object literal field definition <code>key : value</code>.  If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to.  @param t the traversal @param key the assign node "
        },
        "com.google.javascript.jscomp.TypeCheck::getTypedPercent()": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::getTypedPercent()",
            "method_code": "```java\n  double getTypedPercent() {\n    int total = nullCount + unknownCount + typedCount;\n    if (total == 0) {\n      return 0.0;\n    } else {\n      return (100.0 * typedCount) / total;\n    }\n  }\n\n```",
            "method_doc": " Returns the percentage of nodes typed by the type checker. @return a number between 0.0 and 100.0 "
        },
        "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)",
            "method_code": "```java\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n```",
            "method_doc": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. "
        }
    }
}