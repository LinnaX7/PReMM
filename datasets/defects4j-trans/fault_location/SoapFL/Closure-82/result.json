{
    "buggy_classes": [
        "com.google.javascript.rhino.jstype.FunctionType"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitGetProp(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // GETPROP nodes have an assigned type on their node by the scope creator\n    // if this is an enum declaration. The only namespaced enum declarations\n    // that we allow are of the form object.name = ...;\n    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {\n      return;\n    }\n\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    // TODO(user): remove in favor of flagging every property access on\n    // non-object.\n    if (!validator.expectNotNullOrUndefined(t, n, childType,\n            childType + \" has no properties\", getNativeType(OBJECT_TYPE))) {\n      ensureTyped(t, n);\n      return;\n    }\n\n    checkPropertyAccess(childType, property.getString(), t, n);\n    ensureTyped(t, n);\n  }\n\n```",
            "method_doc": " Visits a GETPROP node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of <code>n</code> ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll approach this systematically:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue301` is failing because it **expects a warning but doesn't receive one**. The test is designed to verify that the type checker correctly identifies when accessing an undefined property on a function.\n\nKey observations:\n- Test expects: \"Property indexOf never defined on String.prototype.toLowerCase\"\n- Actual result: No warning generated\n- Stack trace shows: \"expected a warning\" assertion failure\n\n## Step 2: Analyzing the JavaScript Code Logic\n\nThe problematic JavaScript code:\n```javascript\nArray.indexOf = function() {};\nvar s = 'hello';\nalert(s.toLowerCase.indexOf('1'));\n```\n\nThe issue here is:\n- `s.toLowerCase` returns a **function reference** (the toLowerCase method)\n- The code tries to access `.indexOf` on this function reference\n- Functions don't have an `indexOf` property by default\n- This should trigger a type checking warning\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe core problem appears to be in the **type inference and property access validation** logic. Specifically:\n\n**Possible Defect in Production Code:**\n\nThe type checker is likely failing to properly handle the case where:\n1. A method call (like `toLowerCase`) is accessed as a property rather than called\n2. The type system should recognize that accessing a method without calling it returns a function type\n3. The subsequent property access (`.indexOf`) on that function type should be validated\n4. Since functions don't have `indexOf` property, a warning should be generated\n\n**Specific areas to investigate in production code:**\n\n1. **Type inference for method properties**: The code that determines the return type when accessing a method as a property (without invocation)\n\n2. **Function type property validation**: The logic that checks what properties are valid on function types\n\n3. **Prototype chain resolution**: How the type checker resolves properties through the prototype chain for function objects\n\n4. **Warning generation logic**: The conditions under which \"property never defined\" warnings are triggered for function types\n\nThe defect likely resides in the type checking logic that handles property accesses on function-valued expressions, where it's not properly recognizing that certain properties (like `indexOf`) don't exist on the Function prototype and should generate warnings.\n\nThis is a **type system accuracy issue** rather than a test infrastructure problem, as the test is correctly designed to verify that invalid property accesses are caught by the type checker.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles GETPROP nodes (property accesses) and contains the checkPropertyAccess call that should validate whether properties exist on types. The test failure occurs when accessing 'indexOf' on a function type (s.toLowerCase), and this method is responsible for validating such property accesses but appears to be failing to generate the expected warning when the property doesn't exist on function types."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::checkPropertyAccess(JSType,String,NodeTraversal,Node)",
            "method_code": "```java\n  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    ObjectType objectType = childType.dereference();\n    if (objectType != null) {\n      JSType propType = getJSType(n);\n      if ((!objectType.hasProperty(propName) ||\n           objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&\n          propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n        if (objectType instanceof EnumType) {\n          report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n        } else if (!objectType.isEmptyType() &&\n            reportMissingProperties && !isPropertyTest(n)) {\n          if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n            report(t, n, INEXISTENT_PROPERTY, propName,\n                validator.getReadableJSTypeName(n.getFirstChild(), true));\n          }\n        }\n      }\n    } else {\n      // TODO(nicksantos): might want to flag the access on a non object when\n      // it's impossible to get a property from this type.\n    }\n  }\n\n```",
            "method_doc": " Make sure that the access of this property is ok. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll approach this systematically:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue301` is failing because it **expects a warning but doesn't receive one**. The test is designed to verify that the type checker correctly identifies when accessing an undefined property on a function.\n\nKey observations:\n- Test expects: \"Property indexOf never defined on String.prototype.toLowerCase\"\n- Actual result: No warning generated\n- Stack trace shows: \"expected a warning\" assertion failure\n\n## Step 2: Analyzing the JavaScript Code Logic\n\nThe problematic JavaScript code:\n```javascript\nArray.indexOf = function() {};\nvar s = 'hello';\nalert(s.toLowerCase.indexOf('1'));\n```\n\nThe issue here is:\n- `s.toLowerCase` returns a **function reference** (the toLowerCase method)\n- The code tries to access `.indexOf` on this function reference\n- Functions don't have an `indexOf` property by default\n- This should trigger a type checking warning\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe core problem appears to be in the **type inference and property access validation** logic. Specifically:\n\n**Possible Defect in Production Code:**\n\nThe type checker is likely failing to properly handle the case where:\n1. A method call (like `toLowerCase`) is accessed as a property rather than called\n2. The type system should recognize that accessing a method without calling it returns a function type\n3. The subsequent property access (`.indexOf`) on that function type should be validated\n4. Since functions don't have `indexOf` property, a warning should be generated\n\n**Specific areas to investigate in production code:**\n\n1. **Type inference for method properties**: The code that determines the return type when accessing a method as a property (without invocation)\n\n2. **Function type property validation**: The logic that checks what properties are valid on function types\n\n3. **Prototype chain resolution**: How the type checker resolves properties through the prototype chain for function objects\n\n4. **Warning generation logic**: The conditions under which \"property never defined\" warnings are triggered for function types\n\nThe defect likely resides in the type checking logic that handles property accesses on function-valued expressions, where it's not properly recognizing that certain properties (like `indexOf`) don't exist on the Function prototype and should generate warnings.\n\nThis is a **type system accuracy issue** rather than a test infrastructure problem, as the test is correctly designed to verify that invalid property accesses are caught by the type checker.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it's responsible for validating property accesses, and the test failure occurs when accessing 'indexOf' on a function type (String.prototype.toLowerCase). The method checks if a property exists on an object type, but it appears to have a logic flaw where it doesn't properly handle function types - specifically, when accessing properties on function objects that don't exist in the Function prototype. The condition checking propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE)) might be preventing the warning from being generated when it should be."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, NUMBER_TYPE);\n        }\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll approach this systematically:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue301` is failing because it **expects a warning but doesn't receive one**. The test is designed to verify that the type checker correctly identifies when accessing an undefined property on a function.\n\nKey observations:\n- Test expects: \"Property indexOf never defined on String.prototype.toLowerCase\"\n- Actual result: No warning generated\n- Stack trace shows: \"expected a warning\" assertion failure\n\n## Step 2: Analyzing the JavaScript Code Logic\n\nThe problematic JavaScript code:\n```javascript\nArray.indexOf = function() {};\nvar s = 'hello';\nalert(s.toLowerCase.indexOf('1'));\n```\n\nThe issue here is:\n- `s.toLowerCase` returns a **function reference** (the toLowerCase method)\n- The code tries to access `.indexOf` on this function reference\n- Functions don't have an `indexOf` property by default\n- This should trigger a type checking warning\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe core problem appears to be in the **type inference and property access validation** logic. Specifically:\n\n**Possible Defect in Production Code:**\n\nThe type checker is likely failing to properly handle the case where:\n1. A method call (like `toLowerCase`) is accessed as a property rather than called\n2. The type system should recognize that accessing a method without calling it returns a function type\n3. The subsequent property access (`.indexOf`) on that function type should be validated\n4. Since functions don't have `indexOf` property, a warning should be generated\n\n**Specific areas to investigate in production code:**\n\n1. **Type inference for method properties**: The code that determines the return type when accessing a method as a property (without invocation)\n\n2. **Function type property validation**: The logic that checks what properties are valid on function types\n\n3. **Prototype chain resolution**: How the type checker resolves properties through the prototype chain for function objects\n\n4. **Warning generation logic**: The conditions under which \"property never defined\" warnings are triggered for function types\n\nThe defect likely resides in the type checking logic that handles property accesses on function-valued expressions, where it's not properly recognizing that certain properties (like `indexOf`) don't exist on the Function prototype and should generate warnings.\n\nThis is a **type system accuracy issue** rather than a test infrastructure problem, as the test is correctly designed to verify that invalid property accesses are caught by the type checker.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the Token.GETPROP case which processes property accesses like \"s.toLowerCase.indexOf\". The visitGetProp method called from this switch statement is responsible for validating property accesses and should be detecting that \"indexOf\" is not a valid property on function types returned by method references like \"toLowerCase\". The test failure indicates the type checker isn't properly warning about undefined properties on function objects, which is exactly what the GETPROP case in this visit method should handle."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::getJSType(Node)",
            "method_code": "```java\n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n```",
            "method_doc": " This method gets the JSType from the Node argument and verifies that it is present. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll approach this systematically:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue301` is failing because it **expects a warning but doesn't receive one**. The test is designed to verify that the type checker correctly identifies when accessing an undefined property on a function.\n\nKey observations:\n- Test expects: \"Property indexOf never defined on String.prototype.toLowerCase\"\n- Actual result: No warning generated\n- Stack trace shows: \"expected a warning\" assertion failure\n\n## Step 2: Analyzing the JavaScript Code Logic\n\nThe problematic JavaScript code:\n```javascript\nArray.indexOf = function() {};\nvar s = 'hello';\nalert(s.toLowerCase.indexOf('1'));\n```\n\nThe issue here is:\n- `s.toLowerCase` returns a **function reference** (the toLowerCase method)\n- The code tries to access `.indexOf` on this function reference\n- Functions don't have an `indexOf` property by default\n- This should trigger a type checking warning\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe core problem appears to be in the **type inference and property access validation** logic. Specifically:\n\n**Possible Defect in Production Code:**\n\nThe type checker is likely failing to properly handle the case where:\n1. A method call (like `toLowerCase`) is accessed as a property rather than called\n2. The type system should recognize that accessing a method without calling it returns a function type\n3. The subsequent property access (`.indexOf`) on that function type should be validated\n4. Since functions don't have `indexOf` property, a warning should be generated\n\n**Specific areas to investigate in production code:**\n\n1. **Type inference for method properties**: The code that determines the return type when accessing a method as a property (without invocation)\n\n2. **Function type property validation**: The logic that checks what properties are valid on function types\n\n3. **Prototype chain resolution**: How the type checker resolves properties through the prototype chain for function objects\n\n4. **Warning generation logic**: The conditions under which \"property never defined\" warnings are triggered for function types\n\nThe defect likely resides in the type checking logic that handles property accesses on function-valued expressions, where it's not properly recognizing that certain properties (like `indexOf`) don't exist on the Function prototype and should generate warnings.\n\nThis is a **type system accuracy issue** rather than a test infrastructure problem, as the test is correctly designed to verify that invalid property accesses are caught by the type checker.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 3,
            "reason": "#3# This method is unlikely to be the best location to fix because it's a simple type retrieval method that only handles null types by returning UNKNOWN_TYPE. The actual issue appears to be in type inference logic for function property access validation, not in basic type retrieval. The test failure suggests problems with how function types are analyzed when accessing properties on them, which would be handled in more complex type checking logic elsewhere in the TypeCheck class."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)",
            "method_code": "```java\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n```",
            "method_doc": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "Based on my analysis of the failed test case and its behavior, I'll approach this systematically:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue301` is failing because it **expects a warning but doesn't receive one**. The test is designed to verify that the type checker correctly identifies when accessing an undefined property on a function.\n\nKey observations:\n- Test expects: \"Property indexOf never defined on String.prototype.toLowerCase\"\n- Actual result: No warning generated\n- Stack trace shows: \"expected a warning\" assertion failure\n\n## Step 2: Analyzing the JavaScript Code Logic\n\nThe problematic JavaScript code:\n```javascript\nArray.indexOf = function() {};\nvar s = 'hello';\nalert(s.toLowerCase.indexOf('1'));\n```\n\nThe issue here is:\n- `s.toLowerCase` returns a **function reference** (the toLowerCase method)\n- The code tries to access `.indexOf` on this function reference\n- Functions don't have an `indexOf` property by default\n- This should trigger a type checking warning\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe core problem appears to be in the **type inference and property access validation** logic. Specifically:\n\n**Possible Defect in Production Code:**\n\nThe type checker is likely failing to properly handle the case where:\n1. A method call (like `toLowerCase`) is accessed as a property rather than called\n2. The type system should recognize that accessing a method without calling it returns a function type\n3. The subsequent property access (`.indexOf`) on that function type should be validated\n4. Since functions don't have `indexOf` property, a warning should be generated\n\n**Specific areas to investigate in production code:**\n\n1. **Type inference for method properties**: The code that determines the return type when accessing a method as a property (without invocation)\n\n2. **Function type property validation**: The logic that checks what properties are valid on function types\n\n3. **Prototype chain resolution**: How the type checker resolves properties through the prototype chain for function objects\n\n4. **Warning generation logic**: The conditions under which \"property never defined\" warnings are triggered for function types\n\nThe defect likely resides in the type checking logic that handles property accesses on function-valued expressions, where it's not properly recognizing that certain properties (like `indexOf`) don't exist on the Function prototype and should generate warnings.\n\nThis is a **type system accuracy issue** rather than a test infrastructure problem, as the test is correctly designed to verify that invalid property accesses are caught by the type checker.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 3,
            "reason": "#3# The ensureTyped method handles type assignment and casting validation, but the core issue appears to be in type inference for method property access and function type property validation, which likely occurs elsewhere in the type checking logic rather than in this specific type assignment method."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
            "method_code": "```java\n  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }\n\n```",
            "method_doc": "Creates an instance for a function that might be a constructor. */",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following patterns and recommend a possible defect in the production code:\n\n**Step 1: Analyze the Test Behavior Pattern**\n\nThe test `testEmptyFunctionTypes` is failing on the first assertion:\n```java\nassertTrue(LEAST_FUNCTION_TYPE.isEmptyType());\n```\n\nThis indicates that `LEAST_FUNCTION_TYPE.isEmptyType()` is returning `false` when it should return `true`. The second assertion passes, confirming that `GREATEST_FUNCTION_TYPE.isEmptyType()` correctly returns `false`.\n\n**Step 2: Identify the Common Issue**\n\nThe common pattern across the failure is:\n- `LEAST_FUNCTION_TYPE` should represent the most minimal/empty function type\n- The `isEmptyType()` method is incorrectly returning `false` for `LEAST_FUNCTION_TYPE`\n- The method works correctly for `GREATEST_FUNCTION_TYPE`\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `isEmptyType()` method implementation within the `FunctionType` class (or its parent class). Specifically:\n\n**Possible Defect**: The `isEmptyType()` method in the function type implementation is not properly recognizing `LEAST_FUNCTION_TYPE` as an empty type. This could be due to:\n\n1. **Incomplete type checking logic**: The method may not be considering all the criteria that define an \"empty\" function type, particularly for the minimal function type instance.\n\n2. **Incorrect initialization**: `LEAST_FUNCTION_TYPE` might not be properly initialized with the characteristics that would make `isEmptyType()` return `true`.\n\n3. **Missing special case handling**: The implementation might not have special handling for the predefined `LEAST_FUNCTION_TYPE` constant that should always be considered empty.\n\nThe defect likely resides in the logic that determines when a function type should be considered \"empty\" - either missing the specific conditions that apply to the least function type or having incorrect default behavior for minimal function types.\n\n**Recommendation**: Focus the investigation on the `isEmptyType()` method implementation in the function type hierarchy and examine how `LEAST_FUNCTION_TYPE` is constructed and initialized.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 3,
            "reason": "#3# The constructor method initializes FunctionType instances but doesn't directly implement the isEmptyType() logic. The test failure indicates that LEAST_FUNCTION_TYPE.isEmptyType() returns false when it should return true, suggesting the issue is in the isEmptyType() method implementation or how LEAST_FUNCTION_TYPE is configured, not in this constructor."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isSubtype(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }\n\n```",
            "method_doc": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following patterns and recommend a possible defect in the production code:\n\n**Step 1: Analyze the Test Behavior Pattern**\n\nThe test `testEmptyFunctionTypes` is failing on the first assertion:\n```java\nassertTrue(LEAST_FUNCTION_TYPE.isEmptyType());\n```\n\nThis indicates that `LEAST_FUNCTION_TYPE.isEmptyType()` is returning `false` when it should return `true`. The second assertion passes, confirming that `GREATEST_FUNCTION_TYPE.isEmptyType()` correctly returns `false`.\n\n**Step 2: Identify the Common Issue**\n\nThe common pattern across the failure is:\n- `LEAST_FUNCTION_TYPE` should represent the most minimal/empty function type\n- The `isEmptyType()` method is incorrectly returning `false` for `LEAST_FUNCTION_TYPE`\n- The method works correctly for `GREATEST_FUNCTION_TYPE`\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `isEmptyType()` method implementation within the `FunctionType` class (or its parent class). Specifically:\n\n**Possible Defect**: The `isEmptyType()` method in the function type implementation is not properly recognizing `LEAST_FUNCTION_TYPE` as an empty type. This could be due to:\n\n1. **Incomplete type checking logic**: The method may not be considering all the criteria that define an \"empty\" function type, particularly for the minimal function type instance.\n\n2. **Incorrect initialization**: `LEAST_FUNCTION_TYPE` might not be properly initialized with the characteristics that would make `isEmptyType()` return `true`.\n\n3. **Missing special case handling**: The implementation might not have special handling for the predefined `LEAST_FUNCTION_TYPE` constant that should always be considered empty.\n\nThe defect likely resides in the logic that determines when a function type should be considered \"empty\" - either missing the specific conditions that apply to the least function type or having incorrect default behavior for minimal function types.\n\n**Recommendation**: Focus the investigation on the `isEmptyType()` method implementation in the function type hierarchy and examine how `LEAST_FUNCTION_TYPE` is constructed and initialized.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 2,
            "reason": "#2# The test failure is about the isEmptyType() method returning incorrect value for LEAST_FUNCTION_TYPE, but the suspicious method provided is isSubtype(). While isSubtype() might be related to type hierarchy, it doesn't directly implement the isEmptyType() logic that's causing the test failure. The issue likely resides in the isEmptyType() method implementation itself or in how LEAST_FUNCTION_TYPE is constructed."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isEquivalentTo(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }\n\n```",
            "method_doc": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following patterns and recommend a possible defect in the production code:\n\n**Step 1: Analyze the Test Behavior Pattern**\n\nThe test `testEmptyFunctionTypes` is failing on the first assertion:\n```java\nassertTrue(LEAST_FUNCTION_TYPE.isEmptyType());\n```\n\nThis indicates that `LEAST_FUNCTION_TYPE.isEmptyType()` is returning `false` when it should return `true`. The second assertion passes, confirming that `GREATEST_FUNCTION_TYPE.isEmptyType()` correctly returns `false`.\n\n**Step 2: Identify the Common Issue**\n\nThe common pattern across the failure is:\n- `LEAST_FUNCTION_TYPE` should represent the most minimal/empty function type\n- The `isEmptyType()` method is incorrectly returning `false` for `LEAST_FUNCTION_TYPE`\n- The method works correctly for `GREATEST_FUNCTION_TYPE`\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `isEmptyType()` method implementation within the `FunctionType` class (or its parent class). Specifically:\n\n**Possible Defect**: The `isEmptyType()` method in the function type implementation is not properly recognizing `LEAST_FUNCTION_TYPE` as an empty type. This could be due to:\n\n1. **Incomplete type checking logic**: The method may not be considering all the criteria that define an \"empty\" function type, particularly for the minimal function type instance.\n\n2. **Incorrect initialization**: `LEAST_FUNCTION_TYPE` might not be properly initialized with the characteristics that would make `isEmptyType()` return `true`.\n\n3. **Missing special case handling**: The implementation might not have special handling for the predefined `LEAST_FUNCTION_TYPE` constant that should always be considered empty.\n\nThe defect likely resides in the logic that determines when a function type should be considered \"empty\" - either missing the specific conditions that apply to the least function type or having incorrect default behavior for minimal function types.\n\n**Recommendation**: Focus the investigation on the `isEmptyType()` method implementation in the function type hierarchy and examine how `LEAST_FUNCTION_TYPE` is constructed and initialized.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 2,
            "reason": "#2# The test failure is specifically about the isEmptyType() method returning incorrect results for LEAST_FUNCTION_TYPE, but the suspicious method provided is isEquivalentTo(). While isEquivalentTo() might have some relationship to type equality checking, it doesn't directly implement the isEmptyType() functionality that's causing the test failure. The issue appears to be in the isEmptyType() method implementation or how LEAST_FUNCTION_TYPE is constructed, not in the type equivalence logic."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isFunctionType()",
            "method_code": "```java\n  @Override\n  public boolean isFunctionType() {\n    return true;\n  }\n\n```",
            "method_doc": "Always returns true since this is a function type",
            "class_name": "com.google.javascript.rhino.jstype.FunctionType",
            "class_doc": " This derived type provides extended information about a function, including its return type and argument types.<p>  Note: the parameters list is the LP node that is the parent of the actual NAME node containing the parsed argument list (annotated with JSDOC_TYPE_PROP's for the compile-time type of each argument. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I can identify the following patterns and recommend a possible defect in the production code:\n\n**Step 1: Analyze the Test Behavior Pattern**\n\nThe test `testEmptyFunctionTypes` is failing on the first assertion:\n```java\nassertTrue(LEAST_FUNCTION_TYPE.isEmptyType());\n```\n\nThis indicates that `LEAST_FUNCTION_TYPE.isEmptyType()` is returning `false` when it should return `true`. The second assertion passes, confirming that `GREATEST_FUNCTION_TYPE.isEmptyType()` correctly returns `false`.\n\n**Step 2: Identify the Common Issue**\n\nThe common pattern across the failure is:\n- `LEAST_FUNCTION_TYPE` should represent the most minimal/empty function type\n- The `isEmptyType()` method is incorrectly returning `false` for `LEAST_FUNCTION_TYPE`\n- The method works correctly for `GREATEST_FUNCTION_TYPE`\n\n**Step 3: Recommend Possible Defect in Production Code**\n\nThe likely defect is in the `isEmptyType()` method implementation within the `FunctionType` class (or its parent class). Specifically:\n\n**Possible Defect**: The `isEmptyType()` method in the function type implementation is not properly recognizing `LEAST_FUNCTION_TYPE` as an empty type. This could be due to:\n\n1. **Incomplete type checking logic**: The method may not be considering all the criteria that define an \"empty\" function type, particularly for the minimal function type instance.\n\n2. **Incorrect initialization**: `LEAST_FUNCTION_TYPE` might not be properly initialized with the characteristics that would make `isEmptyType()` return `true`.\n\n3. **Missing special case handling**: The implementation might not have special handling for the predefined `LEAST_FUNCTION_TYPE` constant that should always be considered empty.\n\nThe defect likely resides in the logic that determines when a function type should be considered \"empty\" - either missing the specific conditions that apply to the least function type or having incorrect default behavior for minimal function types.\n\n**Recommendation**: Focus the investigation on the `isEmptyType()` method implementation in the function type hierarchy and examine how `LEAST_FUNCTION_TYPE` is constructed and initialized.",
            "test_suite": "com.google.javascript.rhino.jstype.FunctionTypeTest",
            "score": 1,
            "reason": "#1# This method is not the best location that need to be fixed because the test failure is related to the isEmptyType() method returning incorrect results for LEAST_FUNCTION_TYPE, while the isFunctionType() method simply returns true as expected for all function types and has no logical connection to the empty type checking behavior."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.TypeCheck::visitGetProp(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitGetProp(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // GETPROP nodes have an assigned type on their node by the scope creator\n    // if this is an enum declaration. The only namespaced enum declarations\n    // that we allow are of the form object.name = ...;\n    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {\n      return;\n    }\n\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    // TODO(user): remove in favor of flagging every property access on\n    // non-object.\n    if (!validator.expectNotNullOrUndefined(t, n, childType,\n            childType + \" has no properties\", getNativeType(OBJECT_TYPE))) {\n      ensureTyped(t, n);\n      return;\n    }\n\n    checkPropertyAccess(childType, property.getString(), t, n);\n    ensureTyped(t, n);\n  }\n\n```",
            "method_doc": " Visits a GETPROP node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of <code>n</code> "
        },
        "com.google.javascript.jscomp.TypeCheck::getJSType(Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::getJSType(Node)",
            "method_code": "```java\n  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }\n\n```",
            "method_doc": " This method gets the JSType from the Node argument and verifies that it is present. "
        },
        "com.google.javascript.jscomp.TypeCheck::checkPropertyAccess(JSType,String,NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::checkPropertyAccess(JSType,String,NodeTraversal,Node)",
            "method_code": "```java\n  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    ObjectType objectType = childType.dereference();\n    if (objectType != null) {\n      JSType propType = getJSType(n);\n      if ((!objectType.hasProperty(propName) ||\n           objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&\n          propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n        if (objectType instanceof EnumType) {\n          report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n        } else if (!objectType.isEmptyType() &&\n            reportMissingProperties && !isPropertyTest(n)) {\n          if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n            report(t, n, INEXISTENT_PROPERTY, propName,\n                validator.getReadableJSTypeName(n.getFirstChild(), true));\n          }\n        }\n      }\n    } else {\n      // TODO(nicksantos): might want to flag the access on a non object when\n      // it's impossible to get a property from this type.\n    }\n  }\n\n```",
            "method_doc": " Make sure that the access of this property is ok. "
        },
        "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)",
            "method_code": "```java\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n```",
            "method_doc": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. "
        },
        "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, NUMBER_TYPE);\n        }\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. "
        },
        "com.google.javascript.rhino.jstype.FunctionType::FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
            "method_code": "```java\n  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }\n\n```",
            "method_doc": "Creates an instance for a function that might be a constructor. */"
        },
        "com.google.javascript.rhino.jstype.FunctionType::isSubtype(JSType)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isSubtype(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }\n\n```",
            "method_doc": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. "
        },
        "com.google.javascript.rhino.jstype.FunctionType::isFunctionType()": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isFunctionType()",
            "method_code": "```java\n  @Override\n  public boolean isFunctionType() {\n    return true;\n  }\n\n```",
            "method_doc": "Always returns true since this is a function type"
        },
        "com.google.javascript.rhino.jstype.FunctionType::isEquivalentTo(JSType)": {
            "method_name": "com.google.javascript.rhino.jstype.FunctionType::isEquivalentTo(JSType)",
            "method_code": "```java\n  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }\n\n```",
            "method_doc": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. "
        }
    }
}