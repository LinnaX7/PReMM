{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.deser.BeanDeserializer"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeUsingPropertyBasedWithExternalTypeId(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser TransVarParser, DeserializationContext TransVarContext)\n        throws IOException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final ExternalTypeHandler TransVarExternal = _externalTypeIdHandler.start();\n        final PropertyBasedCreator TransVarCreate = _propertyBasedCreator;\n        PropertyValueBuffer TransVarPropertyNameBuffer = TransVarCreate.startBuilding(TransVarParser, TransVarContext, _objectIdReader);\n\n        TokenBuffer TransVarTokenBuffer = new TokenBuffer(TransVarParser);\n        TransVarTokenBuffer.writeStartObject();\n\n        JsonToken TransVarToken = TransVarParser.getCurrentToken();\n        while (!(!(TransVarToken == JsonToken.FIELD_NAME))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarPropertyName = TransVarParser.getCurrentName();\n            TransVarParser.nextToken();\n            SettableBeanProperty TransVarCreatorProperty = TransVarCreate.findCreatorProperty(TransVarPropertyName);\n            if (!(!(TransVarCreatorProperty != null))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                if (!(!(TransVarExternal.handlePropertyValue(TransVarParser, TransVarContext, TransVarPropertyName,\n                        TransVarPropertyNameBuffer)))) {\n                    ;\n                } else {\n                    if (!(!(TransVarPropertyNameBuffer.assignParameter(TransVarCreatorProperty,\n                            _deserializeWithErrorWrapping(TransVarParser, TransVarContext, TransVarCreatorProperty))))) {\n                        TransVarToken = TransVarParser.nextToken();\n                        Object TransVarMyBean;\n                        try {\n                            TransVarMyBean = TransVarCreate.build(TransVarContext, TransVarPropertyNameBuffer);\n                        } catch (Exception TransVarEx) {\n                            wrapAndThrow(TransVarEx, _beanType.getRawClass(), TransVarPropertyName, TransVarContext);\n                            continue;\n                        }\n                        for (; !(!(TransVarToken == JsonToken.FIELD_NAME));) {\n                            TransVarParser.nextToken();\n                            TransVarTokenBuffer.copyCurrentStructure(TransVarParser);\n                            TransVarToken = TransVarParser.nextToken();\n                        }\n                        if (!(!(TransVarMyBean.getClass() != _beanType.getRawClass()))) {\n                            throw TransVarContext\n                                    .mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return TransVarExternal.complete(TransVarParser, TransVarContext, TransVarMyBean);\n                    }\n                }\n                continue;\n            }\n            if (!(!(TransVarPropertyNameBuffer.readIdProperty(TransVarPropertyName)))) {\n                continue;\n            }\n            SettableBeanProperty TransVarProp2 = _beanProperties.find(TransVarPropertyName);\n            if (!(!(TransVarProp2 != null))) {\n                TransVarPropertyNameBuffer.bufferProperty(TransVarProp2,\n                        TransVarProp2.deserialize(TransVarParser, TransVarContext));\n                continue;\n            }\n            if (!(!(TransVarExternal.handlePropertyValue(TransVarParser, TransVarContext, TransVarPropertyName, null)))) {\n                continue;\n            }\n            if (!(!(_ignorableProps != null && _ignorableProps.contains(TransVarPropertyName)))) {\n                handleIgnoredProperty(TransVarParser, TransVarContext, handledType(), TransVarPropertyName);\n                continue;\n            }\n            if (!(!(_anySetter != null))) {\n                TransVarPropertyNameBuffer.bufferAnyProperty(_anySetter, TransVarPropertyName,\n                        _anySetter.deserialize(TransVarParser, TransVarContext));\n            }\n            TransVarToken = TransVarParser.nextToken();\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return TransVarExternal.complete(TransVarParser, TransVarContext, TransVarPropertyNameBuffer, TransVarCreate);\n        } catch (Exception TransVarException) {\n            wrapInstantiationProblem(TransVarException, TransVarContext);\n            return null; // never gets here\n        }\n    }\n\n```",
            "method_doc": "Implements property-based deserialization with external type ID handling, using property-based creator and external type handler to construct objects.",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer",
            "class_doc": " Deserializer class that can deserialize instances of arbitrary bean objects, usually from JSON Object structs, ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Test Failure Pattern\n\nThe test `testInverseExternalId928` fails specifically when the JSON properties are in the order `\"class\"` followed by `\"payload\"`, while the reverse order works correctly. This indicates the issue is related to property ordering during deserialization with external type identifiers.\n\n## Step 2: Examine the Stack Trace\n\nThe stack trace shows:\n- **Root cause**: `IllegalArgumentException: Can not pass null property name`\n- **Location**: `BeanPropertyMap.find(BeanPropertyMap.java:311)`\n- **Call path**: The error occurs in `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` during polymorphic deserialization\n\n## Step 3: Identify the Core Issue\n\nThe test is using Jackson's polymorphic type handling with external type IDs (the `\"class\"` property). The failure occurs specifically when:\n- The type identifier (`\"class\"`) appears BEFORE the polymorphic property (`\"payload\"`) in JSON\n- Jackson attempts to deserialize using property-based deserialization with external type IDs\n- A null property name is being passed to `BeanPropertyMap.find()`\n\n## Step 4: Recommend Possible Production Code Defect\n\n**The likely defect is in Jackson's `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` method or related type resolution logic.**\n\nSpecifically, when processing JSON with external type identifiers where the type ID property appears before the polymorphic property, the deserialization logic may:\n\n1. **Premature type resolution**: Attempt to resolve the polymorphic type before the property name context is properly established\n2. **Property map lookup failure**: Pass a null or incorrect property name to `BeanPropertyMap.find()` when trying to locate the property deserializer\n3. **Order-dependent processing**: Fail to handle the case where type information is available but the target property hasn't been encountered yet in the JSON stream\n\nThe defect likely involves improper handling of the deserialization state machine when external type IDs are processed out-of-order relative to their associated polymorphic properties. The deserializer should be able to buffer type information and apply it correctly regardless of JSON property ordering.",
            "test_suite": "com.fasterxml.jackson.databind.jsontype.TestExternalId",
            "score": 9,
            "reason": "#9# This method is highly suspicious because the stack trace directly points to line 830 in this method where it calls BeanPropertyMap.find() with a null property name. The issue occurs specifically when processing external type IDs in different property orders, and this method handles the property-based deserialization with external type ID handling. The logic appears to have a path where a null property name is passed to the property map lookup, particularly when the type ID property appears before the polymorphic property in the JSON stream."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeFromObject(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n```",
            "method_doc": " General version used when handling needs more advanced features. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer",
            "class_doc": " Deserializer class that can deserialize instances of arbitrary bean objects, usually from JSON Object structs, ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Test Failure Pattern\n\nThe test `testInverseExternalId928` fails specifically when the JSON properties are in the order `\"class\"` followed by `\"payload\"`, while the reverse order works correctly. This indicates the issue is related to property ordering during deserialization with external type identifiers.\n\n## Step 2: Examine the Stack Trace\n\nThe stack trace shows:\n- **Root cause**: `IllegalArgumentException: Can not pass null property name`\n- **Location**: `BeanPropertyMap.find(BeanPropertyMap.java:311)`\n- **Call path**: The error occurs in `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` during polymorphic deserialization\n\n## Step 3: Identify the Core Issue\n\nThe test is using Jackson's polymorphic type handling with external type IDs (the `\"class\"` property). The failure occurs specifically when:\n- The type identifier (`\"class\"`) appears BEFORE the polymorphic property (`\"payload\"`) in JSON\n- Jackson attempts to deserialize using property-based deserialization with external type IDs\n- A null property name is being passed to `BeanPropertyMap.find()`\n\n## Step 4: Recommend Possible Production Code Defect\n\n**The likely defect is in Jackson's `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` method or related type resolution logic.**\n\nSpecifically, when processing JSON with external type identifiers where the type ID property appears before the polymorphic property, the deserialization logic may:\n\n1. **Premature type resolution**: Attempt to resolve the polymorphic type before the property name context is properly established\n2. **Property map lookup failure**: Pass a null or incorrect property name to `BeanPropertyMap.find()` when trying to locate the property deserializer\n3. **Order-dependent processing**: Fail to handle the case where type information is available but the target property hasn't been encountered yet in the JSON stream\n\nThe defect likely involves improper handling of the deserialization state machine when external type IDs are processed out-of-order relative to their associated polymorphic properties. The deserializer should be able to buffer type information and apply it correctly regardless of JSON property ordering.",
            "test_suite": "com.fasterxml.jackson.databind.jsontype.TestExternalId",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it contains the conditional logic that routes to `deserializeWithExternalTypeId()` when `_externalTypeIdHandler != null`, and the stack trace shows the failure occurs in the external type ID handling path. The method's structure shows it handles different deserialization strategies including external type IDs, and the property ordering issue in the test suggests the problem lies in how external type information is processed when encountered before the target property during object deserialization."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeWithExternalTypeId(JsonParser,DeserializationContext)",
            "method_code": "```java\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n```",
            "method_doc": "  Handling for cases where we have property/-ies with external type id  ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer",
            "class_doc": " Deserializer class that can deserialize instances of arbitrary bean objects, usually from JSON Object structs, ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Test Failure Pattern\n\nThe test `testInverseExternalId928` fails specifically when the JSON properties are in the order `\"class\"` followed by `\"payload\"`, while the reverse order works correctly. This indicates the issue is related to property ordering during deserialization with external type identifiers.\n\n## Step 2: Examine the Stack Trace\n\nThe stack trace shows:\n- **Root cause**: `IllegalArgumentException: Can not pass null property name`\n- **Location**: `BeanPropertyMap.find(BeanPropertyMap.java:311)`\n- **Call path**: The error occurs in `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` during polymorphic deserialization\n\n## Step 3: Identify the Core Issue\n\nThe test is using Jackson's polymorphic type handling with external type IDs (the `\"class\"` property). The failure occurs specifically when:\n- The type identifier (`\"class\"`) appears BEFORE the polymorphic property (`\"payload\"`) in JSON\n- Jackson attempts to deserialize using property-based deserialization with external type IDs\n- A null property name is being passed to `BeanPropertyMap.find()`\n\n## Step 4: Recommend Possible Production Code Defect\n\n**The likely defect is in Jackson's `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` method or related type resolution logic.**\n\nSpecifically, when processing JSON with external type identifiers where the type ID property appears before the polymorphic property, the deserialization logic may:\n\n1. **Premature type resolution**: Attempt to resolve the polymorphic type before the property name context is properly established\n2. **Property map lookup failure**: Pass a null or incorrect property name to `BeanPropertyMap.find()` when trying to locate the property deserializer\n3. **Order-dependent processing**: Fail to handle the case where type information is available but the target property hasn't been encountered yet in the JSON stream\n\nThe defect likely involves improper handling of the deserialization state machine when external type IDs are processed out-of-order relative to their associated polymorphic properties. The deserializer should be able to buffer type information and apply it correctly regardless of JSON property ordering.",
            "test_suite": "com.fasterxml.jackson.databind.jsontype.TestExternalId",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it directly handles external type ID deserialization and delegates to the problematic deserializeUsingPropertyBasedWithExternalTypeId method where the actual null property name error occurs. The test failure specifically involves external type IDs with property ordering issues, and this method is the entry point for that deserialization path."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserialize(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        JsonToken t = p.getCurrentToken();\n        return _deserializeOther(p, ctxt, t);\n    }\n\n```",
            "method_doc": " Main deserialization method for bean-based objects (POJOs). <p> NOTE: was declared 'final' in 2.2; should NOT be to let extensions like Afterburner change definition. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer",
            "class_doc": " Deserializer class that can deserialize instances of arbitrary bean objects, usually from JSON Object structs, ",
            "test_failure_causes": "Based on my analysis of the failed test, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Test Failure Pattern\n\nThe test `testInverseExternalId928` fails specifically when the JSON properties are in the order `\"class\"` followed by `\"payload\"`, while the reverse order works correctly. This indicates the issue is related to property ordering during deserialization with external type identifiers.\n\n## Step 2: Examine the Stack Trace\n\nThe stack trace shows:\n- **Root cause**: `IllegalArgumentException: Can not pass null property name`\n- **Location**: `BeanPropertyMap.find(BeanPropertyMap.java:311)`\n- **Call path**: The error occurs in `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` during polymorphic deserialization\n\n## Step 3: Identify the Core Issue\n\nThe test is using Jackson's polymorphic type handling with external type IDs (the `\"class\"` property). The failure occurs specifically when:\n- The type identifier (`\"class\"`) appears BEFORE the polymorphic property (`\"payload\"`) in JSON\n- Jackson attempts to deserialize using property-based deserialization with external type IDs\n- A null property name is being passed to `BeanPropertyMap.find()`\n\n## Step 4: Recommend Possible Production Code Defect\n\n**The likely defect is in Jackson's `BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId()` method or related type resolution logic.**\n\nSpecifically, when processing JSON with external type identifiers where the type ID property appears before the polymorphic property, the deserialization logic may:\n\n1. **Premature type resolution**: Attempt to resolve the polymorphic type before the property name context is properly established\n2. **Property map lookup failure**: Pass a null or incorrect property name to `BeanPropertyMap.find()` when trying to locate the property deserializer\n3. **Order-dependent processing**: Fail to handle the case where type information is available but the target property hasn't been encountered yet in the JSON stream\n\nThe defect likely involves improper handling of the deserialization state machine when external type IDs are processed out-of-order relative to their associated polymorphic properties. The deserializer should be able to buffer type information and apply it correctly regardless of JSON property ordering.",
            "test_suite": "com.fasterxml.jackson.databind.jsontype.TestExternalId",
            "score": 3,
            "reason": "#3# This method is a high-level entry point that delegates to specific deserialization logic, but the actual failure occurs in deserializeUsingPropertyBasedWithExternalTypeId which is called deeper in the call chain. While this method handles the initial routing, the root cause is in the polymorphic type handling logic that gets invoked later."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeUsingPropertyBasedWithExternalTypeId(JsonParser,DeserializationContext)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeUsingPropertyBasedWithExternalTypeId(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @SuppressWarnings(\"resource\")\n    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser TransVarParser, DeserializationContext TransVarContext)\n        throws IOException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final ExternalTypeHandler TransVarExternal = _externalTypeIdHandler.start();\n        final PropertyBasedCreator TransVarCreate = _propertyBasedCreator;\n        PropertyValueBuffer TransVarPropertyNameBuffer = TransVarCreate.startBuilding(TransVarParser, TransVarContext, _objectIdReader);\n\n        TokenBuffer TransVarTokenBuffer = new TokenBuffer(TransVarParser);\n        TransVarTokenBuffer.writeStartObject();\n\n        JsonToken TransVarToken = TransVarParser.getCurrentToken();\n        while (!(!(TransVarToken == JsonToken.FIELD_NAME))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarPropertyName = TransVarParser.getCurrentName();\n            TransVarParser.nextToken();\n            SettableBeanProperty TransVarCreatorProperty = TransVarCreate.findCreatorProperty(TransVarPropertyName);\n            if (!(!(TransVarCreatorProperty != null))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                if (!(!(TransVarExternal.handlePropertyValue(TransVarParser, TransVarContext, TransVarPropertyName,\n                        TransVarPropertyNameBuffer)))) {\n                    ;\n                } else {\n                    if (!(!(TransVarPropertyNameBuffer.assignParameter(TransVarCreatorProperty,\n                            _deserializeWithErrorWrapping(TransVarParser, TransVarContext, TransVarCreatorProperty))))) {\n                        TransVarToken = TransVarParser.nextToken();\n                        Object TransVarMyBean;\n                        try {\n                            TransVarMyBean = TransVarCreate.build(TransVarContext, TransVarPropertyNameBuffer);\n                        } catch (Exception TransVarEx) {\n                            wrapAndThrow(TransVarEx, _beanType.getRawClass(), TransVarPropertyName, TransVarContext);\n                            continue;\n                        }\n                        for (; !(!(TransVarToken == JsonToken.FIELD_NAME));) {\n                            TransVarParser.nextToken();\n                            TransVarTokenBuffer.copyCurrentStructure(TransVarParser);\n                            TransVarToken = TransVarParser.nextToken();\n                        }\n                        if (!(!(TransVarMyBean.getClass() != _beanType.getRawClass()))) {\n                            throw TransVarContext\n                                    .mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                        }\n                        return TransVarExternal.complete(TransVarParser, TransVarContext, TransVarMyBean);\n                    }\n                }\n                continue;\n            }\n            if (!(!(TransVarPropertyNameBuffer.readIdProperty(TransVarPropertyName)))) {\n                continue;\n            }\n            SettableBeanProperty TransVarProp2 = _beanProperties.find(TransVarPropertyName);\n            if (!(!(TransVarProp2 != null))) {\n                TransVarPropertyNameBuffer.bufferProperty(TransVarProp2,\n                        TransVarProp2.deserialize(TransVarParser, TransVarContext));\n                continue;\n            }\n            if (!(!(TransVarExternal.handlePropertyValue(TransVarParser, TransVarContext, TransVarPropertyName, null)))) {\n                continue;\n            }\n            if (!(!(_ignorableProps != null && _ignorableProps.contains(TransVarPropertyName)))) {\n                handleIgnoredProperty(TransVarParser, TransVarContext, handledType(), TransVarPropertyName);\n                continue;\n            }\n            if (!(!(_anySetter != null))) {\n                TransVarPropertyNameBuffer.bufferAnyProperty(_anySetter, TransVarPropertyName,\n                        _anySetter.deserialize(TransVarParser, TransVarContext));\n            }\n            TransVarToken = TransVarParser.nextToken();\n        }\n\n        // We hit END_OBJECT; resolve the pieces:\n        try {\n            return TransVarExternal.complete(TransVarParser, TransVarContext, TransVarPropertyNameBuffer, TransVarCreate);\n        } catch (Exception TransVarException) {\n            wrapInstantiationProblem(TransVarException, TransVarContext);\n            return null; // never gets here\n        }\n    }\n\n```",
            "method_doc": "Implements property-based deserialization with external type ID handling, using property-based creator and external type handler to construct objects."
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeFromObject(JsonParser,DeserializationContext)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeFromObject(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @Override\n    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n         *   to come in as JSON Objects as well; but for now assume they will\n         *   be simple, single-property references, which means that we can\n         *   recognize them without having to buffer anything.\n         *   Once again, if we must, we can do more complex handling with buffering,\n         *   but let's only do that if and when that becomes necessary.\n         */\n        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n            if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)\n                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n                return deserializeFromObjectId(p, ctxt);\n            }\n        }\n        if (_nonStandardCreation) {\n            if (_unwrappedPropertyHandler != null) {\n                return deserializeWithUnwrapped(p, ctxt);\n            }\n            if (_externalTypeIdHandler != null) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            }\n            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n            if (_injectables != null) {\n                injectValues(ctxt, bean);\n            }\n            /* 27-May-2014, tatu: I don't think view processing would work\n             *   at this point, so commenting it out; but leaving in place\n             *   just in case I forgot something fundamental...\n             */\n            /*\n            if (_needViewProcesing) {\n                Class<?> view = ctxt.getActiveView();\n                if (view != null) {\n                    return deserializeWithView(p, ctxt, bean, view);\n                }\n            }\n            */\n            return bean;\n        }\n        final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(bean);\n        if (p.canReadObjectId()) {\n            Object id = p.getObjectId();\n            if (id != null) {\n                _handleTypedObjectId(p, ctxt, bean, id);\n            }\n        }\n        if (_injectables != null) {\n            injectValues(ctxt, bean);\n        }\n        if (_needViewProcesing) {\n            Class<?> view = ctxt.getActiveView();\n            if (view != null) {\n                return deserializeWithView(p, ctxt, bean, view);\n            }\n        }\n        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n            String propName = p.getCurrentName();\n            do {\n                p.nextToken();\n                SettableBeanProperty prop = _beanProperties.find(propName);\n                if (prop != null) { // normal case\n                    try {\n                        prop.deserializeAndSet(p, ctxt, bean);\n                    } catch (Exception e) {\n                        wrapAndThrow(e, bean, propName, ctxt);\n                    }\n                    continue;\n                }\n                handleUnknownVanilla(p, ctxt, bean, propName);\n            } while ((propName = p.nextFieldName()) != null);\n        }\n        return bean;\n    }\n\n```",
            "method_doc": " General version used when handling needs more advanced features. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeWithExternalTypeId(JsonParser,DeserializationContext)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserializeWithExternalTypeId(JsonParser,DeserializationContext)",
            "method_code": "```java\n    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n        throws IOException\n    {\n        if (_propertyBasedCreator != null) {\n            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n        }\n        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n    }\n\n```",
            "method_doc": "  Handling for cases where we have property/-ies with external type id  "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserialize(JsonParser,DeserializationContext)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializer::deserialize(JsonParser,DeserializationContext)",
            "method_code": "```java\n    @Override\n    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // common case first\n        if (p.isExpectedStartObjectToken()) {\n            if (_vanillaProcessing) {\n                return vanillaDeserialize(p, ctxt, p.nextToken());\n            }\n            p.nextToken();\n            if (_objectIdReader != null) {\n                return deserializeWithObjectId(p, ctxt);\n            }\n            return deserializeFromObject(p, ctxt);\n        }\n        JsonToken t = p.getCurrentToken();\n        return _deserializeOther(p, ctxt, t);\n    }\n\n```",
            "method_doc": " Main deserialization method for bean-based objects (POJOs). <p> NOTE: was declared 'final' in 2.2; should NOT be to let extensions like Afterburner change definition. "
        }
    }
}