{
    "buggy_classes": [
        "org.apache.commons.lang3.StringUtils",
        "org.apache.commons.lang3.ArrayUtils"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.lang3.StringUtils::containsAny(CharSequence,String)",
            "method_code": "```java\n    public static boolean containsAny(CharSequence cs, String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(cs, searchChars.toCharArray());\n    }\n\n```",
            "method_doc": " <p> Checks if the CharSequence contains any character in the given set of characters. </p>  <p> A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return <code>false</code>. </p>  <pre> StringUtils.containsAny(null, *)            = false StringUtils.containsAny(\"\", *)              = false StringUtils.containsAny(*, null)            = false StringUtils.containsAny(*, \"\")              = false StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true StringUtils.containsAny(\"aba\",\"z\")          = false </pre>  @param cs the CharSequence to check, may be null @param searchChars the chars to search for, may be null @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input @since 2.4 ",
            "class_name": "org.apache.commons.lang3.StringUtils",
            "class_doc": "@Immutable",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **Same Failure Pattern**: Both tests fail at the exact same logical point - when checking that different supplementary Unicode characters should NOT match each other.\n\n2. **Consistent Behavior**: The failures occur in both method variants:\n   - `StringUtils.containsAny(CharSequence, char[])`\n   - `StringUtils.containsAny(CharSequence, CharSequence)`\n\n3. **Supplementary Character Issue**: Both tests specifically deal with Unicode supplementary characters (characters outside the Basic Multilingual Plane, U+10000 to U+10FFFF), which are represented as surrogate pairs in Java.\n\n4. **Surrogate Pair Mismatch**: The sanity checks reveal the root issue:\n   - `CharU20000.indexOf(CharU20001.charAt(0))` returns 0, indicating that the first code unit (high surrogate) of `CharU20001` matches the first code unit of `CharU20000`\n   - This suggests both supplementary characters share the same high surrogate but have different low surrogates\n\n## Recommended Defect in Production Code:\n\nThe defect likely exists in the `StringUtils.containsAny` implementation where it **incorrectly handles Unicode supplementary characters by processing individual code units (surrogates) rather than complete Unicode code points**.\n\n**Specific Issue**: The method is probably comparing surrogate code units individually instead of treating surrogate pairs as single logical characters. When two different supplementary characters share the same high surrogate but have different low surrogates, the method incorrectly reports a match when it encounters the common high surrogate.\n\n**Expected Behavior**: The method should treat supplementary characters as complete entities (code points) and only return true when the exact same supplementary character is found.\n\n**Affected Code**: The bug likely affects the core character comparison logic in both `containsAny` method variants, where they iterate through characters and fail to properly handle surrogate pairs as single units for comparison purposes.\n\nThis defect would explain why both test variants fail in the same way - they both rely on the same underlying character comparison logic that doesn't properly handle Unicode supplementary characters.",
            "test_suite": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest",
            "score": 10,
            "reason": "#10# This method is the best location to be fixed because it directly calls the problematic containsAny(CharSequence, char[]) method that handles the character array comparison. The test failures show that both containsAny variants (with String and char[] parameters) fail in the same way when dealing with supplementary Unicode characters, indicating the core issue lies in the character comparison logic that this method ultimately relies on. Since this method simply delegates to the char[] version, fixing the underlying character comparison logic would resolve both test failures."
        },
        {
            "method_name": "org.apache.commons.lang3.StringUtils::containsAny(CharSequence,char[])",
            "method_code": "```java\n    public static boolean containsAny(CharSequence TransVarSequence, char[] TransVarCharSequence) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(isEmpty(TransVarSequence) || ArrayUtils.isEmpty(TransVarCharSequence)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n\t\t\treturn false;\n\t\t}\n        int TransVarCharSequenceLength = TransVarSequence.length();\n        int TransVarSearchLengthOfSearchChars = TransVarCharSequence.length;\n        int TransVarJ = 0;\n        while (!(!(TransVarJ < TransVarCharSequenceLength))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n\t\t\t\t\t\t}\n            char TransVarCharSeq = TransVarSequence.charAt(TransVarJ);\n            int TransVarJ1 = 0;\n            while (!(!(TransVarJ1 < TransVarSearchLengthOfSearchChars))) {\n                if (!(!(TransVarCharSequence[TransVarJ1] == TransVarCharSeq))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n                TransVarJ1++;\n\t\t\t\t}\n            TransVarJ++;\n\t\t}\n\t\treturn false;\n\t}\n\n```",
            "method_doc": " <p>Checks if the CharSequence contains any character in the given set of characters.</p>  <p>A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> or zero length search array will return <code>false</code>.</p>  <pre> StringUtils.containsAny(null, *)                = false StringUtils.containsAny(\"\", *)                  = false StringUtils.containsAny(*, null)                = false StringUtils.containsAny(*, [])                  = false StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true StringUtils.containsAny(\"aba\", ['z'])           = false </pre>  @param cs  the CharSequence to check, may be null @param searchChars  the chars to search for, may be null @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input @since 2.4 ",
            "class_name": "org.apache.commons.lang3.StringUtils",
            "class_doc": "@Immutable",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **Same Failure Pattern**: Both tests fail at the exact same logical point - when checking that different supplementary Unicode characters should NOT match each other.\n\n2. **Consistent Behavior**: The failures occur in both method variants:\n   - `StringUtils.containsAny(CharSequence, char[])`\n   - `StringUtils.containsAny(CharSequence, CharSequence)`\n\n3. **Supplementary Character Issue**: Both tests specifically deal with Unicode supplementary characters (characters outside the Basic Multilingual Plane, U+10000 to U+10FFFF), which are represented as surrogate pairs in Java.\n\n4. **Surrogate Pair Mismatch**: The sanity checks reveal the root issue:\n   - `CharU20000.indexOf(CharU20001.charAt(0))` returns 0, indicating that the first code unit (high surrogate) of `CharU20001` matches the first code unit of `CharU20000`\n   - This suggests both supplementary characters share the same high surrogate but have different low surrogates\n\n## Recommended Defect in Production Code:\n\nThe defect likely exists in the `StringUtils.containsAny` implementation where it **incorrectly handles Unicode supplementary characters by processing individual code units (surrogates) rather than complete Unicode code points**.\n\n**Specific Issue**: The method is probably comparing surrogate code units individually instead of treating surrogate pairs as single logical characters. When two different supplementary characters share the same high surrogate but have different low surrogates, the method incorrectly reports a match when it encounters the common high surrogate.\n\n**Expected Behavior**: The method should treat supplementary characters as complete entities (code points) and only return true when the exact same supplementary character is found.\n\n**Affected Code**: The bug likely affects the core character comparison logic in both `containsAny` method variants, where they iterate through characters and fail to properly handle surrogate pairs as single units for comparison purposes.\n\nThis defect would explain why both test variants fail in the same way - they both rely on the same underlying character comparison logic that doesn't properly handle Unicode supplementary characters.",
            "test_suite": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it processes Unicode supplementary characters incorrectly by comparing individual code units (surrogates) instead of complete code points. The test failures show that when two different supplementary characters share the same high surrogate but have different low surrogates, the method incorrectly returns true due to matching the common high surrogate. The method iterates through characters using charAt() which returns 16-bit code units, not handling surrogate pairs as single logical characters, which explains why both test variants fail with the same Unicode supplementary character issue."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.lang3.StringUtils::containsAny(CharSequence,String)": {
            "method_name": "org.apache.commons.lang3.StringUtils::containsAny(CharSequence,String)",
            "method_code": "```java\n    public static boolean containsAny(CharSequence cs, String searchChars) {\n        if (searchChars == null) {\n            return false;\n        }\n        return containsAny(cs, searchChars.toCharArray());\n    }\n\n```",
            "method_doc": " <p> Checks if the CharSequence contains any character in the given set of characters. </p>  <p> A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return <code>false</code>. </p>  <pre> StringUtils.containsAny(null, *)            = false StringUtils.containsAny(\"\", *)              = false StringUtils.containsAny(*, null)            = false StringUtils.containsAny(*, \"\")              = false StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true StringUtils.containsAny(\"aba\",\"z\")          = false </pre>  @param cs the CharSequence to check, may be null @param searchChars the chars to search for, may be null @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input @since 2.4 "
        },
        "org.apache.commons.lang3.StringUtils::containsAny(CharSequence,char[])": {
            "method_name": "org.apache.commons.lang3.StringUtils::containsAny(CharSequence,char[])",
            "method_code": "```java\n    public static boolean containsAny(CharSequence TransVarSequence, char[] TransVarCharSequence) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(isEmpty(TransVarSequence) || ArrayUtils.isEmpty(TransVarCharSequence)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n\t\t\treturn false;\n\t\t}\n        int TransVarCharSequenceLength = TransVarSequence.length();\n        int TransVarSearchLengthOfSearchChars = TransVarCharSequence.length;\n        int TransVarJ = 0;\n        while (!(!(TransVarJ < TransVarCharSequenceLength))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n\t\t\t\t\t\t}\n            char TransVarCharSeq = TransVarSequence.charAt(TransVarJ);\n            int TransVarJ1 = 0;\n            while (!(!(TransVarJ1 < TransVarSearchLengthOfSearchChars))) {\n                if (!(!(TransVarCharSequence[TransVarJ1] == TransVarCharSeq))) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n                TransVarJ1++;\n\t\t\t\t}\n            TransVarJ++;\n\t\t}\n\t\treturn false;\n\t}\n\n```",
            "method_doc": " <p>Checks if the CharSequence contains any character in the given set of characters.</p>  <p>A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> or zero length search array will return <code>false</code>.</p>  <pre> StringUtils.containsAny(null, *)                = false StringUtils.containsAny(\"\", *)                  = false StringUtils.containsAny(*, null)                = false StringUtils.containsAny(*, [])                  = false StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true StringUtils.containsAny(\"aba\", ['z'])           = false </pre>  @param cs  the CharSequence to check, may be null @param searchChars  the chars to search for, may be null @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input @since 2.4 "
        }
    }
}