{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.deser.DeserializerCache"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::modifyTypeByAnnotation(DeserializationContext,Annotated,JavaType)",
            "method_code": "```java\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        // First things first: find explicitly annotated deserializer(s)\n\n        // then key/value handlers  (annotated deserializers)?\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n            //   (not 100% why or how, but this does seem to get called more than once, which\n            //   is not good: for now, let's just avoid errors)\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n\n        // And after handlers, possible type refinements\n        // (note: could possibly avoid this if explicit deserializer was invoked?)\n        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);\n        \n        return type;\n    }\n\n```",
            "method_doc": " Method called to see if given method has annotations that indicate a more specific type than what the argument specifies. If annotations are present, they must specify compatible Class; instance of which can be assigned using the method. This means that the Class has to be raw class of type, or its sub-class (or, implementing class if original Class instance is an interface).  @param a Method or field that the type is associated with @param type Type derived from the setter argument  @return Original type if no annotations are present; or a more specific type derived from it if type annotation(s) was found  @throws JsonMappingException if invalid annotation is found ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles custom key deserializer assignment for map types, which directly relates to the test failure where custom key deserializers aren't being applied. The method checks for key deserializer annotations and assigns them, but the caching issue suggests it may not be properly updating the cached deserializer when different annotation contexts require different key handling behaviors."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCacheValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            // Or perhaps being resolved right now?\n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            // Nope: need to create and possibly cache\n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                // also: any deserializers that have been created are complete by now\n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " Method that will try to create a deserializer for given type, and resolve and cache it if necessary  @param ctxt Currently active deserialization context @param type Type of property to deserialize ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles deserializer caching logic, and the test failure indicates a caching issue where a previously cached map deserializer without custom key handling is incorrectly reused for a subsequent deserialization that requires custom key deserializers. The method's synchronization and caching mechanism may not properly account for differences in key deserialization requirements between different map property types, leading to the observed caching pollution problem."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCache2(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method that handles actual construction (via factory) and caching (both intermediate and eventual) ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles deserializer creation and caching logic. The test failure shows a caching issue where a previously cached map deserializer is incorrectly reused for a different deserialization context that requires custom key handling. The method's caching decision based on `_hasCustomHandlers(type)` and `deser.isCachable()` may not properly account for differences in key deserialization requirements between different map property declarations, leading to the observed caching pollution problem."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::findValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            // If not, need to request factory to construct (or recycle)\n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                /* Should we let caller handle it? Let's have a helper method\n                 * decide it; can throw an exception, or return a valid\n                 * deserializer\n                 */\n                deser = _handleUnknownValueDeserializer(ctxt, propertyType);\n            }\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method called to get hold of a deserializer for a value of given type; or if no such deserializer can be found, a default handler (which may do a best-effort generic serialization or just simply throw an exception when invoked). <p> Note: this method is only called for value types; not for keys. Key deserializers can be accessed using {@link #findKeyDeserializer}. <p> Note also that deserializer returned is guaranteed to be resolved (if it is of type {@link ResolvableDeserializer}), but not contextualized (wrt {@link ContextualDeserializer}): caller has to handle latter if necessary.  @param ctxt Deserialization context @param propertyType Declared type of the value to deserializer (obtained using 'setter' method signature and/or type annotations  @throws JsonMappingException if there are fatal problems with accessing suitable deserializer; including that of not finding any serializer ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the deserializer caching mechanism where the test failure occurs. The method uses _findCachedDeserializer to retrieve cached deserializers and _createAndCacheValueDeserializer to create new ones, but the caching logic appears to not properly account for differences in key deserialization requirements between different map types, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed for the MapHolder class."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { // nope, just construct in normal way\n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [databind#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n```",
            "method_doc": " Method that does the heavy lifting of checking for per-type annotations, find out full type, and figure out which actual factory method to call. ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles deserializer creation and caching logic. The test failure indicates a caching issue where a previously cached map deserializer is incorrectly reused for a different deserialization context that requires custom key handling. The _createDeserializer method is responsible for creating and potentially caching deserializers based on JavaType, but it appears the cache key doesn't properly account for differences in key deserialization requirements between different map property declarations with custom annotations."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_findCachedDeserializer(JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomHandlers(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n```",
            "method_doc": "  Helper methods that handle cache lookups  ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it implements the core caching logic that appears to be causing the test failure. The test demonstrates a caching issue where a previously cached deserializer for NonAnnotatedMapHolderClass is incorrectly reused for MapHolder which requires custom key deserialization. The method _findCachedDeserializer uses only JavaType as the cache key, which doesn't account for differences in custom key deserialization requirements between different map property declarations, leading to the observed caching pollution."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_hasCustomHandlers(JavaType)",
            "method_code": "```java\n    private boolean _hasCustomHandlers(JavaType TransVarType) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n                }\n        if (!(!(TransVarType.isContainerType()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // First: value types may have both value and type handlers\n            JavaType TransVarCtType = TransVarType.getContentType();\n            if (!(!(TransVarCtType != null))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                return (TransVarCtType.getValueHandler() != null) || (TransVarCtType.getTypeHandler() != null);\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            }\n        }\n        return false;\n    }\n\n```",
            "method_doc": " Helper method used to prevent both caching and cache lookups for structured types that have custom value handlers  @since 2.8.11 ",
            "class_name": "com.fasterxml.jackson.databind.deser.DeserializerCache",
            "class_doc": " Class that defines caching layer between callers (like {@link ObjectMapper}, {@link com.fasterxml.jackson.databind.DeserializationContext}) and classes that construct deserializers ({@link com.fasterxml.jackson.databind.deser.DeserializerFactory}). ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test logic, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Pattern\n\n**Common Pattern Identified:**\nThe test demonstrates a caching issue where a previously cached deserializer interferes with subsequent deserialization that requires different behavior. Specifically:\n\n1. **First deserialization**: Uses `NonAnnotatedMapHolderClass` with standard map deserialization\n2. **Second deserialization**: Uses `MapHolder` class that should apply custom key deserializers\n3. **Failure**: The second deserialization doesn't apply the custom key transformation, suggesting it's reusing the cached deserializer from the first operation\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in **Jackson's deserializer caching mechanism** within `MapDeserializer` or related components. The caching logic appears to be incorrectly reusing a previously cached map deserializer when it should create or retrieve a different deserializer that accounts for custom key handling.\n\n**Specific areas to investigate:**\n\n1. **`MapDeserializer` caching implementation** - The cache key may not properly distinguish between maps with custom key deserializers vs. standard maps\n2. **Deserializer resolution logic** - When retrieving cached deserializers, the system may not be checking if the current context requires custom key deserialization\n3. **Cache invalidation/selection** - The mechanism for selecting the appropriate cached deserializer may be overly simplistic, not considering annotation-based customizations\n\n**Root cause hypothesis**: The deserializer cache is keyed by the map value type but fails to account for differences in key deserialization requirements between different map property declarations, leading to incorrect reuse of a generic map deserializer when a custom-key-aware deserializer is needed.\n\nThis represents a **caching pollution issue** where one deserialization operation contaminates the cache with a deserializer that gets incorrectly reused in a different deserialization context.",
            "test_suite": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles custom handler detection for container types, which directly relates to the caching issue where map deserializers with custom key handlers are not being properly distinguished from standard map deserializers. The method currently only checks content type handlers but fails to properly handle map key handlers, which is exactly what's causing the test failure where custom key deserializers are not being applied in the second deserialization."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.deser.DeserializerCache::modifyTypeByAnnotation(DeserializationContext,Annotated,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::modifyTypeByAnnotation(DeserializationContext,Annotated,JavaType)",
            "method_code": "```java\n    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        if (intr == null) {\n            return type;\n        }\n\n        // First things first: find explicitly annotated deserializer(s)\n\n        // then key/value handlers  (annotated deserializers)?\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            // 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n            //   (not 100% why or how, but this does seem to get called more than once, which\n            //   is not good: for now, let's just avoid errors)\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n\n        // And after handlers, possible type refinements\n        // (note: could possibly avoid this if explicit deserializer was invoked?)\n        type = intr.refineDeserializationType(ctxt.getConfig(), a, type);\n        \n        return type;\n    }\n\n```",
            "method_doc": " Method called to see if given method has annotations that indicate a more specific type than what the argument specifies. If annotations are present, they must specify compatible Class; instance of which can be assigned using the method. This means that the Class has to be raw class of type, or its sub-class (or, implementing class if original Class instance is an interface).  @param a Method or field that the type is associated with @param type Type derived from the setter argument  @return Original type if no annotations are present; or a more specific type derived from it if type annotation(s) was found  @throws JsonMappingException if invalid annotation is found "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCacheValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCacheValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _createAndCacheValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        /* Only one thread to construct deserializers at any given point in time;\n         * limitations necessary to ensure that only completely initialized ones\n         * are visible and used.\n         */\n        synchronized (_incompleteDeserializers) {\n            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n            if (deser != null) {\n                return deser;\n            }\n            int count = _incompleteDeserializers.size();\n            // Or perhaps being resolved right now?\n            if (count > 0) {\n                deser = _incompleteDeserializers.get(type);\n                if (deser != null) {\n                    return deser;\n                }\n            }\n            // Nope: need to create and possibly cache\n            try {\n                return _createAndCache2(ctxt, factory, type);\n            } finally {\n                // also: any deserializers that have been created are complete by now\n                if (count == 0 && _incompleteDeserializers.size() > 0) {\n                    _incompleteDeserializers.clear();\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " Method that will try to create a deserializer for given type, and resolve and cache it if necessary  @param ctxt Currently active deserialization context @param type Type of property to deserialize "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCache2(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createAndCache2(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n         * (but can be re-defined for sub-classes by using @JsonCachable!)\n         */\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n\n        /* we will temporarily hold on to all created deserializers (to\n         * handle cyclic references, and possibly reuse non-cached\n         * deserializers (list, map))\n         */\n        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n         *   resolution of a reference -- couple of ways to prevent this;\n         *   either not add Lists or Maps, or clear references eagerly.\n         *   Let's actually do both; since both seem reasonable.\n         */\n        /* Need to resolve? Mostly done for bean deserializers; required for\n         * resolving cyclic references.\n         */\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer)deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache) {\n            _cachedDeserializers.put(type, deser);\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method that handles actual construction (via factory) and caching (both intermediate and eventual) "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::findValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::findValueDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType propertyType)\n        throws JsonMappingException\n    {\n        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n        if (deser == null) {\n            // If not, need to request factory to construct (or recycle)\n            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n            if (deser == null) {\n                /* Should we let caller handle it? Let's have a helper method\n                 * decide it; can throw an exception, or return a valid\n                 * deserializer\n                 */\n                deser = _handleUnknownValueDeserializer(ctxt, propertyType);\n            }\n        }\n        return deser;\n    }\n\n```",
            "method_doc": " Method called to get hold of a deserializer for a value of given type; or if no such deserializer can be found, a default handler (which may do a best-effort generic serialization or just simply throw an exception when invoked). <p> Note: this method is only called for value types; not for keys. Key deserializers can be accessed using {@link #findKeyDeserializer}. <p> Note also that deserializer returned is guaranteed to be resolved (if it is of type {@link ResolvableDeserializer}), but not contextualized (wrt {@link ContextualDeserializer}): caller has to handle latter if necessary.  @param ctxt Deserialization context @param propertyType Declared type of the value to deserializer (obtained using 'setter' method signature and/or type annotations  @throws JsonMappingException if there are fatal problems with accessing suitable deserializer; including that of not finding any serializer "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_createDeserializer(DeserializationContext,DeserializerFactory,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_createDeserializer(DeserializationContext,DeserializerFactory,JavaType)",
            "method_code": "```java\n    @SuppressWarnings(\"unchecked\")\n    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n            DeserializerFactory factory, JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n\n        // First things first: do we need to use abstract type mapping?\n        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n            type = factory.mapAbstractType(config, type);\n        }\n        BeanDescription beanDesc = config.introspect(type);\n        // Then: does type define explicit deserializer to use, with annotation(s)?\n        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                beanDesc.getClassInfo());\n        if (deser != null) {\n            return deser;\n        }\n\n        // If not, may have further type-modification annotations to check:\n        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n        if (newType != type) {\n            type = newType;\n            beanDesc = config.introspect(newType);\n        }\n\n        // We may also have a Builder type to consider...\n        Class<?> builder = beanDesc.findPOJOBuilder();\n        if (builder != null) {\n            return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(\n            \t\tctxt, type, beanDesc, builder);\n        }\n\n        // Or perhaps a Converter?\n        Converter<Object,Object> conv = beanDesc.findDeserializationConverter();\n        if (conv == null) { // nope, just construct in normal way\n            return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n        }\n        // otherwise need to do bit of introspection\n        JavaType delegateType = conv.getInputType(ctxt.getTypeFactory());\n        // One more twist, as per [databind#288]; probably need to get new BeanDesc\n        if (!delegateType.hasRawClass(type.getRawClass())) {\n            beanDesc = config.introspect(delegateType);\n        }\n        return new StdDelegatingDeserializer<Object>(conv, delegateType,\n                _createDeserializer2(ctxt, factory, delegateType, beanDesc));\n    }\n\n```",
            "method_doc": " Method that does the heavy lifting of checking for per-type annotations, find out full type, and figure out which actual factory method to call. "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_findCachedDeserializer(JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_findCachedDeserializer(JavaType)",
            "method_code": "```java\n    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n    {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null JavaType passed\");\n        }\n        if (_hasCustomHandlers(type)) {\n            return null;\n        }\n        return _cachedDeserializers.get(type);\n    }\n\n```",
            "method_doc": "  Helper methods that handle cache lookups  "
        },
        "com.fasterxml.jackson.databind.deser.DeserializerCache::_hasCustomHandlers(JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.deser.DeserializerCache::_hasCustomHandlers(JavaType)",
            "method_code": "```java\n    private boolean _hasCustomHandlers(JavaType TransVarType) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n                }\n        if (!(!(TransVarType.isContainerType()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // First: value types may have both value and type handlers\n            JavaType TransVarCtType = TransVarType.getContentType();\n            if (!(!(TransVarCtType != null))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                return (TransVarCtType.getValueHandler() != null) || (TransVarCtType.getTypeHandler() != null);\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            }\n        }\n        return false;\n    }\n\n```",
            "method_doc": " Helper method used to prevent both caching and cache lookups for structured types that have custom value handlers  @since 2.8.11 "
        }
    }
}