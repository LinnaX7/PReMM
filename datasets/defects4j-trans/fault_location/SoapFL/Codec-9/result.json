{
    "buggy_classes": [
        "org.apache.commons.codec.binary.Base64"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean,int)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] TransVarBinaryValue, boolean TransVarIsChunk, boolean TransVarUrlSafeBoolean, int TransVarChunkSize) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarBinaryValue == null || TransVarBinaryValue.length == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarBinaryValue;\n        }\n\n        long TransVarChunk = getEncodeLength(TransVarBinaryValue, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (!(!(TransVarChunk > TransVarChunkSize))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                TransVarChunk +\n                \") than the specified maxium size of \" +\n                TransVarChunkSize);\n        }\n                \n        Base64 TransVarBase64 = TransVarIsChunk ? new Base64(TransVarUrlSafeBoolean) : new Base64(0, CHUNK_SEPARATOR, TransVarUrlSafeBoolean);\n        return TransVarBase64.encode(TransVarBinaryValue);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @param urlSafe if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters. @param maxResultSize The maximum result size to accept. @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than maxResultSize @since 1.4 ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test and the provided information, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Patterns\n\n**1. Common Failure Pattern:**\n- All failures occur in the same test method `testCodec112`\n- The failure manifests as an `IllegalArgumentException` with the message \"Input array too big, the output array would be bigger than the specified maximum size\"\n- The failure occurs specifically when calling `Base64.encodeBase64(in, false, false, out.length)`\n\n**2. Key Observations from Test Behavior:**\n- The test creates a 1-byte input array `{0}`\n- It first encodes this using the simple `Base64.encodeBase64(in)` method successfully\n- It then uses the result length (`out.length`) as the `maxResultSize` parameter in the more complex encoding call\n- The test comment indicates \"size calculation assumes always chunked\" but the test passes `false` for chunked encoding\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **size calculation logic within the `Base64.encodeBase64(byte[] in, boolean isChunked, boolean urlSafe, int maxResultSize)` method** at line 838 of Base64.java.\n\n**Specific Defect Hypothesis:**\n\nThe production code incorrectly calculates the required output buffer size when `isChunked = false`. The method appears to be using chunked encoding calculations regardless of the actual `isChunked` parameter value, leading to an incorrect size requirement estimation.\n\n**Root Cause Analysis:**\n\n1. When `isChunked = true`, the Base64 encoding typically adds line separators, requiring more output buffer space\n2. When `isChunked = false`, the encoding should be more compact without line separators\n3. The defect likely causes the method to always calculate buffer requirements as if chunked encoding were enabled, resulting in an overestimated size requirement\n4. This causes the method to reject valid input sizes that would actually fit in the provided `maxResultSize` when non-chunked encoding is used\n\nThe test is correctly designed to verify that a 1-byte input with non-chunked encoding should fit within the previously calculated output length, but the production code's flawed size calculation logic incorrectly determines that the output would exceed the maximum size.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 10,
            "reason": "#10# This method is definitely the best location to be fixed because the test failure occurs directly at line 838 in this method, and the core issue is in the size calculation logic. The method incorrectly uses MIME_CHUNK_SIZE (76) and CHUNK_SEPARATOR when calculating the encode length, regardless of the isChunked parameter value. This causes it to always calculate buffer requirements as if chunked encoding were enabled, leading to the IllegalArgumentException when the test passes false for chunked encoding but the method still uses chunked size calculations."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::getEncodeLength(byte[],int,byte[])",
            "method_code": "```java\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n```",
            "method_doc": " Pre-calculates the amount of space needed to base64-encode the supplied array.  @param pArray byte[] array which will later be encoded @param chunkSize line-length of the output (<= 0 means no chunking) between each chunkSeparator (e.g. CRLF). @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).  @return amount of space needed to encoded the supplied array.  Returns a long since a max-len array will require Integer.MAX_VALUE + 33%. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test and the provided information, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Patterns\n\n**1. Common Failure Pattern:**\n- All failures occur in the same test method `testCodec112`\n- The failure manifests as an `IllegalArgumentException` with the message \"Input array too big, the output array would be bigger than the specified maximum size\"\n- The failure occurs specifically when calling `Base64.encodeBase64(in, false, false, out.length)`\n\n**2. Key Observations from Test Behavior:**\n- The test creates a 1-byte input array `{0}`\n- It first encodes this using the simple `Base64.encodeBase64(in)` method successfully\n- It then uses the result length (`out.length`) as the `maxResultSize` parameter in the more complex encoding call\n- The test comment indicates \"size calculation assumes always chunked\" but the test passes `false` for chunked encoding\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **size calculation logic within the `Base64.encodeBase64(byte[] in, boolean isChunked, boolean urlSafe, int maxResultSize)` method** at line 838 of Base64.java.\n\n**Specific Defect Hypothesis:**\n\nThe production code incorrectly calculates the required output buffer size when `isChunked = false`. The method appears to be using chunked encoding calculations regardless of the actual `isChunked` parameter value, leading to an incorrect size requirement estimation.\n\n**Root Cause Analysis:**\n\n1. When `isChunked = true`, the Base64 encoding typically adds line separators, requiring more output buffer space\n2. When `isChunked = false`, the encoding should be more compact without line separators\n3. The defect likely causes the method to always calculate buffer requirements as if chunked encoding were enabled, resulting in an overestimated size requirement\n4. This causes the method to reject valid input sizes that would actually fit in the provided `maxResultSize` when non-chunked encoding is used\n\nThe test is correctly designed to verify that a 1-byte input with non-chunked encoding should fit within the previously calculated output length, but the production code's flawed size calculation logic incorrectly determines that the output would exceed the maximum size.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 9,
            "reason": "#9# The getEncodeLength method is highly suspicious because it incorrectly calculates output buffer size when chunkSize is 0. The test calls encodeBase64 with isChunked=false, which should result in chunkSize=0, but the method still performs chunking calculations. Specifically, when chunkSize=0, the condition \"if (chunkSize > 0)\" should be false, but the method first modifies chunkSize with \"chunkSize = (chunkSize / 4) * 4\" which makes chunkSize=0, so the chunking calculations are skipped. However, the fundamental issue is that the method's calculation logic doesn't match what the encodeBase64 method expects, causing it to overestimate the required buffer size for non-chunked encoding scenarios."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[],int,int)",
            "method_code": "```java\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            // Don't want to append the CRLF two times in a row, so make sure previous\n            // character is not from CRLF!\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " <p> Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 3). </p> <p> Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ </p>  @param in byte[] array of binary data to base64 encode. @param inPos Position to start reading data from. @param inAvail Amount of bytes available from input for encoding. ",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test and the provided information, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Patterns\n\n**1. Common Failure Pattern:**\n- All failures occur in the same test method `testCodec112`\n- The failure manifests as an `IllegalArgumentException` with the message \"Input array too big, the output array would be bigger than the specified maximum size\"\n- The failure occurs specifically when calling `Base64.encodeBase64(in, false, false, out.length)`\n\n**2. Key Observations from Test Behavior:**\n- The test creates a 1-byte input array `{0}`\n- It first encodes this using the simple `Base64.encodeBase64(in)` method successfully\n- It then uses the result length (`out.length`) as the `maxResultSize` parameter in the more complex encoding call\n- The test comment indicates \"size calculation assumes always chunked\" but the test passes `false` for chunked encoding\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **size calculation logic within the `Base64.encodeBase64(byte[] in, boolean isChunked, boolean urlSafe, int maxResultSize)` method** at line 838 of Base64.java.\n\n**Specific Defect Hypothesis:**\n\nThe production code incorrectly calculates the required output buffer size when `isChunked = false`. The method appears to be using chunked encoding calculations regardless of the actual `isChunked` parameter value, leading to an incorrect size requirement estimation.\n\n**Root Cause Analysis:**\n\n1. When `isChunked = true`, the Base64 encoding typically adds line separators, requiring more output buffer space\n2. When `isChunked = false`, the encoding should be more compact without line separators\n3. The defect likely causes the method to always calculate buffer requirements as if chunked encoding were enabled, resulting in an overestimated size requirement\n4. This causes the method to reject valid input sizes that would actually fit in the provided `maxResultSize` when non-chunked encoding is used\n\nThe test is correctly designed to verify that a 1-byte input with non-chunked encoding should fit within the previously calculated output length, but the production code's flawed size calculation logic incorrectly determines that the output would exceed the maximum size.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because the test failure occurs during Base64 encoding with specific parameters (isChunked=false), and this encode method contains the core logic for handling chunked vs non-chunked encoding, including line separator insertion logic that directly affects output size calculations. The method's handling of line separators and buffer management could be incorrectly calculating output size requirements when chunked encoding is disabled, which matches the test failure pattern where the method rejects valid input sizes."
        },
        {
            "method_name": "org.apache.commons.codec.binary.Base64::resizeBuffer()",
            "method_code": "```java\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n```",
            "method_doc": "Doubles our buffer. */",
            "class_name": "org.apache.commons.codec.binary.Base64",
            "class_doc": " Provides Base64 encoding and decoding as defined by RFC 2045.  <p> This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein. </p> <p> The class can be parameterized in the following manner with various constructors: <ul> <li>URL-safe mode: Default off.</li> <li>Line length: Default 76. Line length that aren't multiples of 4 will still essentially end up being multiples of 4 in the encoded data. <li>Line separator: Default is CRLF (\"\\r\\n\")</li> </ul> </p> <p> Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). </p>  @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045</a> @since 1.0 @version $Id$ ",
            "test_failure_causes": "Based on my analysis of the failed test and the provided information, here's my step-by-step reasoning:\n\n## Analysis of Test Failure Patterns\n\n**1. Common Failure Pattern:**\n- All failures occur in the same test method `testCodec112`\n- The failure manifests as an `IllegalArgumentException` with the message \"Input array too big, the output array would be bigger than the specified maximum size\"\n- The failure occurs specifically when calling `Base64.encodeBase64(in, false, false, out.length)`\n\n**2. Key Observations from Test Behavior:**\n- The test creates a 1-byte input array `{0}`\n- It first encodes this using the simple `Base64.encodeBase64(in)` method successfully\n- It then uses the result length (`out.length`) as the `maxResultSize` parameter in the more complex encoding call\n- The test comment indicates \"size calculation assumes always chunked\" but the test passes `false` for chunked encoding\n\n## Recommended Possible Defect in Production Code\n\nThe likely defect is in the **size calculation logic within the `Base64.encodeBase64(byte[] in, boolean isChunked, boolean urlSafe, int maxResultSize)` method** at line 838 of Base64.java.\n\n**Specific Defect Hypothesis:**\n\nThe production code incorrectly calculates the required output buffer size when `isChunked = false`. The method appears to be using chunked encoding calculations regardless of the actual `isChunked` parameter value, leading to an incorrect size requirement estimation.\n\n**Root Cause Analysis:**\n\n1. When `isChunked = true`, the Base64 encoding typically adds line separators, requiring more output buffer space\n2. When `isChunked = false`, the encoding should be more compact without line separators\n3. The defect likely causes the method to always calculate buffer requirements as if chunked encoding were enabled, resulting in an overestimated size requirement\n4. This causes the method to reject valid input sizes that would actually fit in the provided `maxResultSize` when non-chunked encoding is used\n\nThe test is correctly designed to verify that a 1-byte input with non-chunked encoding should fit within the previously calculated output length, but the production code's flawed size calculation logic incorrectly determines that the output would exceed the maximum size.",
            "test_suite": "org.apache.commons.codec.binary.Base64Test",
            "score": 3,
            "reason": "#3# The resizeBuffer() method appears to be a general buffer management utility that doubles buffer size when needed, but the test failure specifically relates to incorrect size calculations in the encodeBase64 method when determining if the output would exceed maxResultSize. The resizeBuffer method doesn't handle the core logic of calculating output buffer requirements based on chunked vs non-chunked encoding modes."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.codec.binary.Base64::getEncodeLength(byte[],int,byte[])": {
            "method_name": "org.apache.commons.codec.binary.Base64::getEncodeLength(byte[],int,byte[])",
            "method_code": "```java\n    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {\n        // base64 always encodes to multiples of 4.\n        chunkSize = (chunkSize / 4) * 4;\n\n        long len = (pArray.length * 4) / 3;\n        long mod = len % 4;\n        if (mod != 0) {\n            len += 4 - mod;\n        }\n        if (chunkSize > 0) {\n            boolean lenChunksPerfectly = len % chunkSize == 0;\n            len += (len / chunkSize) * chunkSeparator.length;\n            if (!lenChunksPerfectly) {\n                len += chunkSeparator.length;\n            }\n        }\n        return len;\n    }\n\n```",
            "method_doc": " Pre-calculates the amount of space needed to base64-encode the supplied array.  @param pArray byte[] array which will later be encoded @param chunkSize line-length of the output (<= 0 means no chunking) between each chunkSeparator (e.g. CRLF). @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).  @return amount of space needed to encoded the supplied array.  Returns a long since a max-len array will require Integer.MAX_VALUE + 33%. "
        },
        "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::encodeBase64(byte[],boolean,boolean,int)",
            "method_code": "```java\n    public static byte[] encodeBase64(byte[] TransVarBinaryValue, boolean TransVarIsChunk, boolean TransVarUrlSafeBoolean, int TransVarChunkSize) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarBinaryValue == null || TransVarBinaryValue.length == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarBinaryValue;\n        }\n\n        long TransVarChunk = getEncodeLength(TransVarBinaryValue, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (!(!(TransVarChunk > TransVarChunkSize))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                TransVarChunk +\n                \") than the specified maxium size of \" +\n                TransVarChunkSize);\n        }\n                \n        Base64 TransVarBase64 = TransVarIsChunk ? new Base64(TransVarUrlSafeBoolean) : new Base64(0, CHUNK_SEPARATOR, TransVarUrlSafeBoolean);\n        return TransVarBase64.encode(TransVarBinaryValue);\n    }\n\n```",
            "method_doc": " Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.  @param binaryData Array containing binary data to encode. @param isChunked if <code>true</code> this encoder will chunk the base64 output into 76 character blocks @param urlSafe if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters. @param maxResultSize The maximum result size to accept. @return Base64-encoded data. @throws IllegalArgumentException Thrown when the input array needs an output array bigger than maxResultSize @since 1.4 "
        },
        "org.apache.commons.codec.binary.Base64::resizeBuffer()": {
            "method_name": "org.apache.commons.codec.binary.Base64::resizeBuffer()",
            "method_code": "```java\n    private void resizeBuffer() {\n        if (buffer == null) {\n            buffer = new byte[DEFAULT_BUFFER_SIZE];\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }\n    }\n\n```",
            "method_doc": "Doubles our buffer. */"
        },
        "org.apache.commons.codec.binary.Base64::encode(byte[],int,int)": {
            "method_name": "org.apache.commons.codec.binary.Base64::encode(byte[],int,int)",
            "method_code": "```java\n    void encode(byte[] in, int inPos, int inAvail) {\n        if (eof) {\n            return;\n        }\n        // inAvail < 0 is how we're informed of EOF in the underlying data we're\n        // encoding.\n        if (inAvail < 0) {\n            eof = true;\n            if (buffer == null || buffer.length - pos < encodeSize) {\n                resizeBuffer();\n            }\n            switch (modulus) {\n                case 1 :\n                    buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n\n                case 2 :\n                    buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buffer[pos++] = PAD;\n                    }\n                    break;\n            }\n            // Don't want to append the CRLF two times in a row, so make sure previous\n            // character is not from CRLF!\n            byte b = lineSeparator[lineSeparator.length - 1];\n            if (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\n                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buffer == null || buffer.length - pos < encodeSize) {\n                    resizeBuffer();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) {\n                    b += 256;\n                }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buffer[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n                    if (lineLength > 0 && lineLength <= currentLinePos) {\n                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\n                        pos += lineSeparator.length;\n                        currentLinePos = 0;\n                    }\n                }\n            }\n        }\n    }\n\n```",
            "method_doc": " <p> Encodes all of the provided data, starting at inPos, for inAvail bytes. Must be called at least twice: once with the data to encode, and once with inAvail set to \"-1\" to alert encoder that EOF has been reached, so flush last remaining bytes (if not multiple of 3). </p> <p> Thanks to \"commons\" project in ws.apache.org for the bitwise operations, and general approach. http://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/ </p>  @param in byte[] array of binary data to base64 encode. @param inPos Position to start reading data from. @param inAvail Amount of bytes available from input for encoding. "
        }
    }
}