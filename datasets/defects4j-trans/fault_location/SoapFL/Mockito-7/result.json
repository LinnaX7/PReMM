{
    "buggy_classes": [
        "org.mockito.internal.util.reflection.GenericMetadataSupport"
    ],
    "buggy_methods": [
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::extractRawTypeOf(Type)",
            "method_code": "```java\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n```",
            "method_doc": "Extracts the raw Class from various Type implementations (Class, ParameterizedType, BoundedType, TypeVariable) recursively.",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n**Step 1: Analyze the Stack Trace Pattern**\nThe stack trace consistently points to the same issue:\n- `Raw extraction not supported for : 'null'`\n- The error originates from `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`\n- The failure occurs in Mockito's deep stubbing mechanism at `ReturnsDeepStubs.answer()`\n\n**Step 2: Identify the Common Failure Pattern**\nAll failures occur when:\n- Using `RETURNS_DEEP_STUBS` mode\n- Chaining method calls on generic types (`getNested().getNested()`)\n- The system encounters raw types in generic nested structures\n- Mockito attempts to extract raw type information but receives `null`\n\n**Step 3: Trace the Execution Flow**\nThe failure path is:\n1. Test creates deep stub: `mock(MyClass1.class, RETURNS_DEEP_STUBS)`\n2. During stubbing setup: `when(myMock1.getNested().getNested().returnSomething())`\n3. Mockito internally tries to create deep stubs for intermediate calls\n4. When processing generic return types, the raw type extraction fails with null\n\n**Step 4: Identify the Root Cause in Production Code**\nBased on the analysis, the likely defect is in **Mockito's generic type handling in deep stubbing**:\n\n**Possible Defect**: In `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`, when processing nested generic types that are used as raw types, the method fails to properly handle cases where the generic type information becomes `null` during deep stub creation. The method doesn't have adequate null-checking or fallback logic for raw type extraction when dealing with deeply nested generic structures.\n\n**Specific Issue**: The production code assumes that generic type metadata will always be available when creating deep stubs, but in cases of raw type usage within nested generic chains, this metadata can be `null`, causing the raw extraction to fail.\n\n**Recommendation**: The production code should be enhanced to handle null generic metadata gracefully when performing raw type extraction in deep stubbing scenarios, potentially by providing default behavior or better error recovery mechanisms.",
            "test_suite": "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it throws the exact exception \"Raw extraction not supported for : 'null'\" seen in the stack trace. The method lacks null handling when processing TypeVariable types - when `contextualActualTypeParameters.get(type)` returns null, the recursive call `extractRawTypeOf(null)` will reach the final throw statement, causing the observed failure. The test failure occurs during deep stubbing of nested generics where type resolution returns null, which this method doesn't handle gracefully."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::rawType()",
            "method_code": "```java\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n```",
            "method_doc": "Returns the raw type of the type variable, computing it if not already cached. This method calls method \"extractRawTypeOf\" to perform the extraction.",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n**Step 1: Analyze the Stack Trace Pattern**\nThe stack trace consistently points to the same issue:\n- `Raw extraction not supported for : 'null'`\n- The error originates from `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`\n- The failure occurs in Mockito's deep stubbing mechanism at `ReturnsDeepStubs.answer()`\n\n**Step 2: Identify the Common Failure Pattern**\nAll failures occur when:\n- Using `RETURNS_DEEP_STUBS` mode\n- Chaining method calls on generic types (`getNested().getNested()`)\n- The system encounters raw types in generic nested structures\n- Mockito attempts to extract raw type information but receives `null`\n\n**Step 3: Trace the Execution Flow**\nThe failure path is:\n1. Test creates deep stub: `mock(MyClass1.class, RETURNS_DEEP_STUBS)`\n2. During stubbing setup: `when(myMock1.getNested().getNested().returnSomething())`\n3. Mockito internally tries to create deep stubs for intermediate calls\n4. When processing generic return types, the raw type extraction fails with null\n\n**Step 4: Identify the Root Cause in Production Code**\nBased on the analysis, the likely defect is in **Mockito's generic type handling in deep stubbing**:\n\n**Possible Defect**: In `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`, when processing nested generic types that are used as raw types, the method fails to properly handle cases where the generic type information becomes `null` during deep stub creation. The method doesn't have adequate null-checking or fallback logic for raw type extraction when dealing with deeply nested generic structures.\n\n**Specific Issue**: The production code assumes that generic type metadata will always be available when creating deep stubs, but in cases of raw type usage within nested generic chains, this metadata can be `null`, causing the raw extraction to fail.\n\n**Recommendation**: The production code should be enhanced to handle null generic metadata gracefully when performing raw type extraction in deep stubbing scenarios, potentially by providing default behavior or better error recovery mechanisms.",
            "test_suite": "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it directly calls extractRawTypeOf() which is shown in the stack trace to fail with \"Raw extraction not supported for : 'null'\", and it lacks null checking when assigning the rawType field, allowing null values to propagate through the deep stubbing mechanism causing the MockitoException."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::boundsOf(TypeVariable)",
            "method_code": "```java\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n```",
            "method_doc": " @param typeParameter The TypeVariable parameter @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable then retrieve BoundedType of this TypeVariable ",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n**Step 1: Analyze the Stack Trace Pattern**\nThe stack trace consistently points to the same issue:\n- `Raw extraction not supported for : 'null'`\n- The error originates from `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`\n- The failure occurs in Mockito's deep stubbing mechanism at `ReturnsDeepStubs.answer()`\n\n**Step 2: Identify the Common Failure Pattern**\nAll failures occur when:\n- Using `RETURNS_DEEP_STUBS` mode\n- Chaining method calls on generic types (`getNested().getNested()`)\n- The system encounters raw types in generic nested structures\n- Mockito attempts to extract raw type information but receives `null`\n\n**Step 3: Trace the Execution Flow**\nThe failure path is:\n1. Test creates deep stub: `mock(MyClass1.class, RETURNS_DEEP_STUBS)`\n2. During stubbing setup: `when(myMock1.getNested().getNested().returnSomething())`\n3. Mockito internally tries to create deep stubs for intermediate calls\n4. When processing generic return types, the raw type extraction fails with null\n\n**Step 4: Identify the Root Cause in Production Code**\nBased on the analysis, the likely defect is in **Mockito's generic type handling in deep stubbing**:\n\n**Possible Defect**: In `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`, when processing nested generic types that are used as raw types, the method fails to properly handle cases where the generic type information becomes `null` during deep stub creation. The method doesn't have adequate null-checking or fallback logic for raw type extraction when dealing with deeply nested generic structures.\n\n**Specific Issue**: The production code assumes that generic type metadata will always be available when creating deep stubs, but in cases of raw type usage within nested generic chains, this metadata can be `null`, causing the raw extraction to fail.\n\n**Recommendation**: The production code should be enhanced to handle null generic metadata gracefully when performing raw type extraction in deep stubbing scenarios, potentially by providing default behavior or better error recovery mechanisms.",
            "test_suite": "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it recursively processes TypeVariable bounds without proper null checking. The stack trace shows \"Raw extraction not supported for : 'null'\" which indicates the method encounters a null value when trying to extract raw types from generic metadata. The recursive call `boundsOf((TypeVariable) typeParameter.getBounds()[0])` could lead to infinite recursion or null pointer exceptions when dealing with deeply nested generic types used as raw types, which matches the failure scenario in the test where chained generic method calls (`getNested().getNested()`) cause the deep stubbing mechanism to fail."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::extractActualBoundedTypeOf(Type)",
            "method_code": "```java\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }\n\n```",
            "method_doc": "Recursively extracts the actual bounded type from TypeVariable and BoundedType, resolving through contextualActualTypeParameters.",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n**Step 1: Analyze the Stack Trace Pattern**\nThe stack trace consistently points to the same issue:\n- `Raw extraction not supported for : 'null'`\n- The error originates from `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`\n- The failure occurs in Mockito's deep stubbing mechanism at `ReturnsDeepStubs.answer()`\n\n**Step 2: Identify the Common Failure Pattern**\nAll failures occur when:\n- Using `RETURNS_DEEP_STUBS` mode\n- Chaining method calls on generic types (`getNested().getNested()`)\n- The system encounters raw types in generic nested structures\n- Mockito attempts to extract raw type information but receives `null`\n\n**Step 3: Trace the Execution Flow**\nThe failure path is:\n1. Test creates deep stub: `mock(MyClass1.class, RETURNS_DEEP_STUBS)`\n2. During stubbing setup: `when(myMock1.getNested().getNested().returnSomething())`\n3. Mockito internally tries to create deep stubs for intermediate calls\n4. When processing generic return types, the raw type extraction fails with null\n\n**Step 4: Identify the Root Cause in Production Code**\nBased on the analysis, the likely defect is in **Mockito's generic type handling in deep stubbing**:\n\n**Possible Defect**: In `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`, when processing nested generic types that are used as raw types, the method fails to properly handle cases where the generic type information becomes `null` during deep stub creation. The method doesn't have adequate null-checking or fallback logic for raw type extraction when dealing with deeply nested generic structures.\n\n**Specific Issue**: The production code assumes that generic type metadata will always be available when creating deep stubs, but in cases of raw type usage within nested generic chains, this metadata can be `null`, causing the raw extraction to fail.\n\n**Recommendation**: The production code should be enhanced to handle null generic metadata gracefully when performing raw type extraction in deep stubbing scenarios, potentially by providing default behavior or better error recovery mechanisms.",
            "test_suite": "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it recursively processes TypeVariable and BoundedType but lacks proper null checking when accessing contextualActualTypeParameters.get(type). The stack trace shows \"Raw extraction not supported for : 'null'\" which indicates the method is receiving null input, likely when contextualActualTypeParameters.get(type) returns null for raw types in nested generic structures. The method should handle null cases gracefully instead of passing null to recursive calls."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::resolveGenericReturnType(Method)",
            "method_code": "```java\n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n```",
            "method_doc": " Resolve current method generic return type to a {@link GenericMetadataSupport}.  @param method Method to resolve the return type. @return {@link GenericMetadataSupport} representing this generic return type. ",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n**Step 1: Analyze the Stack Trace Pattern**\nThe stack trace consistently points to the same issue:\n- `Raw extraction not supported for : 'null'`\n- The error originates from `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`\n- The failure occurs in Mockito's deep stubbing mechanism at `ReturnsDeepStubs.answer()`\n\n**Step 2: Identify the Common Failure Pattern**\nAll failures occur when:\n- Using `RETURNS_DEEP_STUBS` mode\n- Chaining method calls on generic types (`getNested().getNested()`)\n- The system encounters raw types in generic nested structures\n- Mockito attempts to extract raw type information but receives `null`\n\n**Step 3: Trace the Execution Flow**\nThe failure path is:\n1. Test creates deep stub: `mock(MyClass1.class, RETURNS_DEEP_STUBS)`\n2. During stubbing setup: `when(myMock1.getNested().getNested().returnSomething())`\n3. Mockito internally tries to create deep stubs for intermediate calls\n4. When processing generic return types, the raw type extraction fails with null\n\n**Step 4: Identify the Root Cause in Production Code**\nBased on the analysis, the likely defect is in **Mockito's generic type handling in deep stubbing**:\n\n**Possible Defect**: In `GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf()`, when processing nested generic types that are used as raw types, the method fails to properly handle cases where the generic type information becomes `null` during deep stub creation. The method doesn't have adequate null-checking or fallback logic for raw type extraction when dealing with deeply nested generic structures.\n\n**Specific Issue**: The production code assumes that generic type metadata will always be available when creating deep stubs, but in cases of raw type usage within nested generic chains, this metadata can be `null`, causing the raw extraction to fail.\n\n**Recommendation**: The production code should be enhanced to handle null generic metadata gracefully when performing raw type extraction in deep stubbing scenarios, potentially by providing default behavior or better error recovery mechanisms.",
            "test_suite": "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles generic return type resolution, which is exactly what fails in the deep stubbing scenario. The stack trace shows the failure occurs in TypeVariableReturnType.extractRawTypeOf() when processing null, and this method is responsible for creating TypeVariableReturnType instances when encountering TypeVariable generic types. The method doesn't handle cases where the resolved generic metadata becomes null during deep stub creation of nested generic types used as raw types."
        }
    ],
    "buggy_codes": {
        "org.mockito.internal.util.reflection.GenericMetadataSupport::boundsOf(TypeVariable)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::boundsOf(TypeVariable)",
            "method_code": "```java\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n```",
            "method_doc": " @param typeParameter The TypeVariable parameter @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable then retrieve BoundedType of this TypeVariable "
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::extractActualBoundedTypeOf(Type)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::extractActualBoundedTypeOf(Type)",
            "method_code": "```java\n        private Type extractActualBoundedTypeOf(Type type) {\n            if (type instanceof TypeVariable) {\n                /*\n                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                on the class definition, such as such as List<E>.\n                */\n                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n            }\n            if (type instanceof BoundedType) {\n                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n                if (!(actualFirstBound instanceof BoundedType)) {\n                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n                }\n                return actualFirstBound;\n            }\n            return type; // irrelevant, we don't manage other types as they are not bounded.\n        }\n\n```",
            "method_doc": "Recursively extracts the actual bounded type from TypeVariable and BoundedType, resolving through contextualActualTypeParameters."
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport::resolveGenericReturnType(Method)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::resolveGenericReturnType(Method)",
            "method_code": "```java\n    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n        Type genericReturnType = method.getGenericReturnType();\n        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n\n        if (genericReturnType instanceof Class) {\n            return new NotGenericReturnTypeSupport(genericReturnType);\n        }\n        if (genericReturnType instanceof ParameterizedType) {\n            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n        }\n        if (genericReturnType instanceof TypeVariable) {\n            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n        }\n\n        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n    }\n\n```",
            "method_doc": " Resolve current method generic return type to a {@link GenericMetadataSupport}.  @param method Method to resolve the return type. @return {@link GenericMetadataSupport} representing this generic return type. "
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::extractRawTypeOf(Type)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::extractRawTypeOf(Type)",
            "method_code": "```java\n        private Class<?> extractRawTypeOf(Type type) {\n            if (type instanceof Class) {\n                return (Class<?>) type;\n            }\n            if (type instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) type).getRawType();\n            }\n            if (type instanceof BoundedType) {\n                return extractRawTypeOf(((BoundedType) type).firstBound());\n            }\n            if (type instanceof TypeVariable) {\n                /*\n                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n                 * on the class definition, such as such as List<E>.\n                 */\n                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n            }\n            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n        }\n\n```",
            "method_doc": "Extracts the raw Class from various Type implementations (Class, ParameterizedType, BoundedType, TypeVariable) recursively."
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::rawType()": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::rawType()",
            "method_code": "```java\n        @Override\n        public Class<?> rawType() {\n            if (rawType == null) {\n                rawType = extractRawTypeOf(typeVariable);\n            }\n            return rawType;\n        }\n\n```",
            "method_doc": "Returns the raw type of the type variable, computing it if not already cached. This method calls method \"extractRawTypeOf\" to perform the extraction."
        }
    }
}