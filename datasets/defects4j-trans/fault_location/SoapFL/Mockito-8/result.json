{
    "buggy_classes": [
        "org.mockito.internal.util.Checks",
        "org.mockito.internal.util.reflection.GenericMetadataSupport"
    ],
    "buggy_methods": [
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::getActualTypeArgumentFor(TypeVariable)",
            "method_code": "```java\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n```",
            "method_doc": "Retrieves the actual type argument for a type parameter from contextualActualTypeParameters, recursively resolving TypeVariable chains. This method calls itself recursively when encountering nested TypeVariables.",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the key issue:\n\n**Analysis of the Failure:**\n\n1. **Common Pattern**: The test fails with a `StackOverflowError` in `GenericMetadataSupport.getActualTypeArgumentFor()` at lines 191 and 194, indicating infinite recursion.\n\n2. **Test Behavior**: The test is dealing with self-referential generic types in the `GenericsSelfReference` class. When resolving the generic return type of a method that returns a self-referential type variable, the system enters an infinite recursion loop.\n\n3. **Root Cause**: The stack trace shows the recursion happening within `getActualTypeArgumentFor()` method, where it appears to be calling itself repeatedly without a proper termination condition for self-referential type scenarios.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect is likely in the `GenericMetadataSupport.getActualTypeArgumentFor()` method (around lines 191-194), where there is insufficient handling for self-referential type variables. Specifically:\n\n- The method lacks proper cycle detection when traversing type variable bounds\n- When encountering a type variable that refers back to itself (either directly or through its bounds), the recursive resolution continues indefinitely\n- There should be a mechanism to detect circular references and break the recursion, either by returning a sensible default or handling self-references explicitly\n\nThe production code needs to be modified to:\n1. Detect when a type variable is being resolved recursively\n2. Handle self-referential type variables by breaking the recursion\n3. Potentially cache intermediate results to avoid redundant computations\n\nThis is a classic infinite recursion problem when dealing with complex generic type systems that involve self-references, and the fix should focus on adding proper cycle detection in the type resolution logic.",
            "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
            "score": 10,
            "reason": "#10# This method is highly likely to be the best location to fix because it contains clear infinite recursion - when a TypeVariable resolves to another TypeVariable, it recursively calls itself without any cycle detection mechanism, which directly causes the StackOverflowError when dealing with self-referential generic types like in the failing test."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::boundsOf(TypeVariable)",
            "method_code": "```java\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n```",
            "method_doc": " @param typeParameter The TypeVariable parameter @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable then retrieve BoundedType of this TypeVariable ",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the key issue:\n\n**Analysis of the Failure:**\n\n1. **Common Pattern**: The test fails with a `StackOverflowError` in `GenericMetadataSupport.getActualTypeArgumentFor()` at lines 191 and 194, indicating infinite recursion.\n\n2. **Test Behavior**: The test is dealing with self-referential generic types in the `GenericsSelfReference` class. When resolving the generic return type of a method that returns a self-referential type variable, the system enters an infinite recursion loop.\n\n3. **Root Cause**: The stack trace shows the recursion happening within `getActualTypeArgumentFor()` method, where it appears to be calling itself repeatedly without a proper termination condition for self-referential type scenarios.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect is likely in the `GenericMetadataSupport.getActualTypeArgumentFor()` method (around lines 191-194), where there is insufficient handling for self-referential type variables. Specifically:\n\n- The method lacks proper cycle detection when traversing type variable bounds\n- When encountering a type variable that refers back to itself (either directly or through its bounds), the recursive resolution continues indefinitely\n- There should be a mechanism to detect circular references and break the recursion, either by returning a sensible default or handling self-references explicitly\n\nThe production code needs to be modified to:\n1. Detect when a type variable is being resolved recursively\n2. Handle self-referential type variables by breaking the recursion\n3. Potentially cache intermediate results to avoid redundant computations\n\nThis is a classic infinite recursion problem when dealing with complex generic type systems that involve self-references, and the fix should focus on adding proper cycle detection in the type resolution logic.",
            "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it directly causes the infinite recursion shown in the stack trace. The method calls itself recursively when encountering TypeVariable bounds without any cycle detection mechanism, which perfectly explains the StackOverflowError when dealing with self-referential generic types like in the GenericsSelfReference test case."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::readTypeVariables()",
            "method_code": "```java\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n```",
            "method_doc": "Registers type variables from bounds and actual type argument of TypeVariable. This method calls method \"registerTypeVariablesOn\" and method \"getActualTypeArgumentFor\".",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the key issue:\n\n**Analysis of the Failure:**\n\n1. **Common Pattern**: The test fails with a `StackOverflowError` in `GenericMetadataSupport.getActualTypeArgumentFor()` at lines 191 and 194, indicating infinite recursion.\n\n2. **Test Behavior**: The test is dealing with self-referential generic types in the `GenericsSelfReference` class. When resolving the generic return type of a method that returns a self-referential type variable, the system enters an infinite recursion loop.\n\n3. **Root Cause**: The stack trace shows the recursion happening within `getActualTypeArgumentFor()` method, where it appears to be calling itself repeatedly without a proper termination condition for self-referential type scenarios.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect is likely in the `GenericMetadataSupport.getActualTypeArgumentFor()` method (around lines 191-194), where there is insufficient handling for self-referential type variables. Specifically:\n\n- The method lacks proper cycle detection when traversing type variable bounds\n- When encountering a type variable that refers back to itself (either directly or through its bounds), the recursive resolution continues indefinitely\n- There should be a mechanism to detect circular references and break the recursion, either by returning a sensible default or handling self-references explicitly\n\nThe production code needs to be modified to:\n1. Detect when a type variable is being resolved recursively\n2. Handle self-referential type variables by breaking the recursion\n3. Potentially cache intermediate results to avoid redundant computations\n\nThis is a classic infinite recursion problem when dealing with complex generic type systems that involve self-references, and the fix should focus on adding proper cycle detection in the type resolution logic.",
            "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it directly calls getActualTypeArgumentFor() which appears in the stack trace causing infinite recursion. The method processes type variable bounds and then recursively calls getActualTypeArgumentFor() on the same typeVariable, creating a cycle when dealing with self-referential generic types. The lack of cycle detection in this recursive resolution logic makes it the prime candidate for the StackOverflowError."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::registerTypeVariableIfNotPresent(TypeVariable)",
            "method_code": "```java\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n```",
            "method_doc": "Registers a type variable in contextualActualTypeParameters if not present, using its bounds. This method calls method \"boundsOf\" to get bounded type information.",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the key issue:\n\n**Analysis of the Failure:**\n\n1. **Common Pattern**: The test fails with a `StackOverflowError` in `GenericMetadataSupport.getActualTypeArgumentFor()` at lines 191 and 194, indicating infinite recursion.\n\n2. **Test Behavior**: The test is dealing with self-referential generic types in the `GenericsSelfReference` class. When resolving the generic return type of a method that returns a self-referential type variable, the system enters an infinite recursion loop.\n\n3. **Root Cause**: The stack trace shows the recursion happening within `getActualTypeArgumentFor()` method, where it appears to be calling itself repeatedly without a proper termination condition for self-referential type scenarios.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect is likely in the `GenericMetadataSupport.getActualTypeArgumentFor()` method (around lines 191-194), where there is insufficient handling for self-referential type variables. Specifically:\n\n- The method lacks proper cycle detection when traversing type variable bounds\n- When encountering a type variable that refers back to itself (either directly or through its bounds), the recursive resolution continues indefinitely\n- There should be a mechanism to detect circular references and break the recursion, either by returning a sensible default or handling self-references explicitly\n\nThe production code needs to be modified to:\n1. Detect when a type variable is being resolved recursively\n2. Handle self-referential type variables by breaking the recursion\n3. Potentially cache intermediate results to avoid redundant computations\n\nThis is a classic infinite recursion problem when dealing with complex generic type systems that involve self-references, and the fix should focus on adding proper cycle detection in the type resolution logic.",
            "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it directly handles TypeVariable registration and calls boundsOf() method, which likely triggers the recursive type resolution that causes the StackOverflowError when dealing with self-referential generics. The infinite recursion occurs when resolving type variable bounds that reference themselves, and this method is the entry point for registering type variables in the contextual parameters map."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::registerTypeVariablesOn(Type)",
            "method_code": "```java\n    protected void registerTypeVariablesOn(Type TransVarObjectType) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(!(TransVarObjectType instanceof ParameterizedType)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return;\n        }\n        ParameterizedType TransVarType = (ParameterizedType) TransVarObjectType;\n        TypeVariable[] TransVarTypeVars = ((Class<?>) TransVarType.getRawType()).getTypeParameters();\n        Type[] TransVarTypeVariables = TransVarType.getActualTypeArguments();\n        int TransVarIdx = 0;\n        while (!(!(TransVarIdx < TransVarTypeVariables.length))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TypeVariable TransVarTypeVar = TransVarTypeVars[TransVarIdx];\n            Type TransVarTypeArgument = TransVarTypeVariables[TransVarIdx];\n            if (!(!(TransVarTypeArgument instanceof WildcardType))) {\n                contextualActualTypeParameters.put(TransVarTypeVar, boundsOf((WildcardType) TransVarTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(TransVarTypeVar, TransVarTypeArgument);\n            }\n            TransVarIdx++;\n        }\n    }\n\n```",
            "method_doc": "Registers type variables from a ParameterizedType by mapping type parameters to their actual type arguments. This method calls method \"boundsOf\" to handle WildcardType bounds.",
            "class_name": "org.mockito.internal.util.reflection.GenericMetadataSupport",
            "class_doc": " This class can retrieve generic meta-data that the compiler stores on classes and accessible members.  <p> The main idea of this code is to create a Map that will help to resolve return types. In order to actually work with nested generics, this map will have to be passed along new instances as a type context. </p>  <p> Hence : <ul> <li>A new instance representing the metadata is created using the {@link #inferFrom(Type)} method from a real <code>Class</code> or from a <code>ParameterizedType</code>, other types are not yet supported.</li>  <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using {@link #resolveGenericReturnType(Method)}.</li> </ul> </p>  <p> For now this code support the following kind of generic declarations : <pre class=\"code\"><code class=\"java\"> interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; { Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound(); List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound(); List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound(); K returningK(); &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params(); &lt;S, T extends S&gt; T two_type_params(); &lt;O extends K&gt; O typeVar_with_type_params(); Number returningNonGeneric(); } </code></pre>  @see #inferFrom(Type) @see #resolveGenericReturnType(Method) @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the key issue:\n\n**Analysis of the Failure:**\n\n1. **Common Pattern**: The test fails with a `StackOverflowError` in `GenericMetadataSupport.getActualTypeArgumentFor()` at lines 191 and 194, indicating infinite recursion.\n\n2. **Test Behavior**: The test is dealing with self-referential generic types in the `GenericsSelfReference` class. When resolving the generic return type of a method that returns a self-referential type variable, the system enters an infinite recursion loop.\n\n3. **Root Cause**: The stack trace shows the recursion happening within `getActualTypeArgumentFor()` method, where it appears to be calling itself repeatedly without a proper termination condition for self-referential type scenarios.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect is likely in the `GenericMetadataSupport.getActualTypeArgumentFor()` method (around lines 191-194), where there is insufficient handling for self-referential type variables. Specifically:\n\n- The method lacks proper cycle detection when traversing type variable bounds\n- When encountering a type variable that refers back to itself (either directly or through its bounds), the recursive resolution continues indefinitely\n- There should be a mechanism to detect circular references and break the recursion, either by returning a sensible default or handling self-references explicitly\n\nThe production code needs to be modified to:\n1. Detect when a type variable is being resolved recursively\n2. Handle self-referential type variables by breaking the recursion\n3. Potentially cache intermediate results to avoid redundant computations\n\nThis is a classic infinite recursion problem when dealing with complex generic type systems that involve self-references, and the fix should focus on adding proper cycle detection in the type resolution logic.",
            "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
            "score": 3,
            "reason": "#3# While the registerTypeVariablesOn method handles type variable registration, the stack trace clearly shows the infinite recursion occurring in getActualTypeArgumentFor method at lines 191-194. The test failure is specifically about resolving self-referential type variables, which happens during type resolution in getActualTypeArgumentFor, not during the initial type variable registration in registerTypeVariablesOn. The infinite recursion pattern suggests the bug is in the recursive type resolution logic rather than the type registration phase."
        },
        {
            "method_name": "org.mockito.internal.util.Checks::checkNotNull(T,String)",
            "method_code": "```java\n    public static <T> T checkNotNull(T value, String checkedValue) {\n        if(value == null) {\n            throw new NullPointerException(checkedValue + \" should not be null\");\n        }\n        return value;\n    }\n\n```",
            "method_doc": "",
            "class_name": "org.mockito.internal.util.Checks",
            "class_doc": " Pre-made preconditions ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the key issue:\n\n**Analysis of the Failure:**\n\n1. **Common Pattern**: The test fails with a `StackOverflowError` in `GenericMetadataSupport.getActualTypeArgumentFor()` at lines 191 and 194, indicating infinite recursion.\n\n2. **Test Behavior**: The test is dealing with self-referential generic types in the `GenericsSelfReference` class. When resolving the generic return type of a method that returns a self-referential type variable, the system enters an infinite recursion loop.\n\n3. **Root Cause**: The stack trace shows the recursion happening within `getActualTypeArgumentFor()` method, where it appears to be calling itself repeatedly without a proper termination condition for self-referential type scenarios.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect is likely in the `GenericMetadataSupport.getActualTypeArgumentFor()` method (around lines 191-194), where there is insufficient handling for self-referential type variables. Specifically:\n\n- The method lacks proper cycle detection when traversing type variable bounds\n- When encountering a type variable that refers back to itself (either directly or through its bounds), the recursive resolution continues indefinitely\n- There should be a mechanism to detect circular references and break the recursion, either by returning a sensible default or handling self-references explicitly\n\nThe production code needs to be modified to:\n1. Detect when a type variable is being resolved recursively\n2. Handle self-referential type variables by breaking the recursion\n3. Potentially cache intermediate results to avoid redundant computations\n\nThis is a classic infinite recursion problem when dealing with complex generic type systems that involve self-references, and the fix should focus on adding proper cycle detection in the type resolution logic.",
            "test_suite": "org.mockito.internal.util.reflection.GenericMetadataSupportTest",
            "score": 1,
            "reason": "#1# This method is not the best location that need to be fixed because the checkNotNull method is a simple null check utility that doesn't contain any recursive logic or type resolution code. The StackOverflowError clearly originates from GenericMetadataSupport.getActualTypeArgumentFor() method where infinite recursion occurs when handling self-referential generic types, and the null check method has no relation to this type resolution logic."
        }
    ],
    "buggy_codes": {
        "org.mockito.internal.util.Checks::checkNotNull(T,String)": {
            "method_name": "org.mockito.internal.util.Checks::checkNotNull(T,String)",
            "method_code": "```java\n    public static <T> T checkNotNull(T value, String checkedValue) {\n        if(value == null) {\n            throw new NullPointerException(checkedValue + \" should not be null\");\n        }\n        return value;\n    }\n\n```",
            "method_doc": ""
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport::getActualTypeArgumentFor(TypeVariable)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::getActualTypeArgumentFor(TypeVariable)",
            "method_code": "```java\n    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n        Type type = this.contextualActualTypeParameters.get(typeParameter);\n        if (type instanceof TypeVariable) {\n            TypeVariable typeVariable = (TypeVariable) type;\n            return getActualTypeArgumentFor(typeVariable);\n        }\n\n        return type;\n    }\n\n```",
            "method_doc": "Retrieves the actual type argument for a type parameter from contextualActualTypeParameters, recursively resolving TypeVariable chains. This method calls itself recursively when encountering nested TypeVariables."
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::readTypeVariables()": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType::readTypeVariables()",
            "method_code": "```java\n        private void readTypeVariables() {\n            for (Type type : typeVariable.getBounds()) {\n                registerTypeVariablesOn(type);\n            }\n            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n        }\n\n```",
            "method_doc": "Registers type variables from bounds and actual type argument of TypeVariable. This method calls method \"registerTypeVariablesOn\" and method \"getActualTypeArgumentFor\"."
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport::registerTypeVariableIfNotPresent(TypeVariable)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::registerTypeVariableIfNotPresent(TypeVariable)",
            "method_code": "```java\n    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n        }\n    }\n\n```",
            "method_doc": "Registers a type variable in contextualActualTypeParameters if not present, using its bounds. This method calls method \"boundsOf\" to get bounded type information."
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport::boundsOf(TypeVariable)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::boundsOf(TypeVariable)",
            "method_code": "```java\n    private BoundedType boundsOf(TypeVariable typeParameter) {\n        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n        }\n        return new TypeVarBoundedType(typeParameter);\n    }\n\n```",
            "method_doc": " @param typeParameter The TypeVariable parameter @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable then retrieve BoundedType of this TypeVariable "
        },
        "org.mockito.internal.util.reflection.GenericMetadataSupport::registerTypeVariablesOn(Type)": {
            "method_name": "org.mockito.internal.util.reflection.GenericMetadataSupport::registerTypeVariablesOn(Type)",
            "method_code": "```java\n    protected void registerTypeVariablesOn(Type TransVarObjectType) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(!(TransVarObjectType instanceof ParameterizedType)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return;\n        }\n        ParameterizedType TransVarType = (ParameterizedType) TransVarObjectType;\n        TypeVariable[] TransVarTypeVars = ((Class<?>) TransVarType.getRawType()).getTypeParameters();\n        Type[] TransVarTypeVariables = TransVarType.getActualTypeArguments();\n        int TransVarIdx = 0;\n        while (!(!(TransVarIdx < TransVarTypeVariables.length))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TypeVariable TransVarTypeVar = TransVarTypeVars[TransVarIdx];\n            Type TransVarTypeArgument = TransVarTypeVariables[TransVarIdx];\n            if (!(!(TransVarTypeArgument instanceof WildcardType))) {\n                contextualActualTypeParameters.put(TransVarTypeVar, boundsOf((WildcardType) TransVarTypeArgument));\n            } else {\n                contextualActualTypeParameters.put(TransVarTypeVar, TransVarTypeArgument);\n            }\n            TransVarIdx++;\n        }\n    }\n\n```",
            "method_doc": "Registers type variables from a ParameterizedType by mapping type parameters to their actual type arguments. This method calls method \"boundsOf\" to handle WildcardType bounds."
        }
    }
}