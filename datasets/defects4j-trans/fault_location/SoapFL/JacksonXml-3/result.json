{
    "buggy_classes": [
        "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::nextTextValue()",
            "method_code": "```java\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _binaryValue = null;\n        if (!(!(_nextToken != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            JsonToken TransVarNextToken = _nextToken;\n            _currToken = TransVarNextToken;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (!(!(TransVarNextToken == JsonToken.VALUE_STRING))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                return _currText;\n            }\n            _updateState(TransVarNextToken);\n            return null;\n        }\n\n        int TransVarNextXMLToken = _xmlTokens.next();\n\n        for (; !(!(TransVarNextXMLToken == XmlTokenStream.XML_START_ELEMENT));) {\n            if (!(!(_mayBeLeaf))) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (!(!(_parsingContext.inArray()))) {\n                TransVarNextXMLToken = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String TransVarElementName = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(TransVarElementName);\n            if (!(!(_namesToWrap != null && _namesToWrap.contains(TransVarElementName)))) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_END_ELEMENT))))) {\n                TransBreakFlag0 = false;\n                if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            }\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_ATTRIBUTE_NAME))))) {\n                TransBreakFlag0 = false;\n                if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            }\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_ATTRIBUTE_VALUE))))) {\n                TransBreakFlag0 = false;\n                _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_TEXT))))) {\n                TransBreakFlag0 = false;\n            _currText = _xmlTokens.getText();\n                if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _xmlTokens.skipEndElement();\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_END))))) {\n            _currToken = null;\n            }\n        }\n        return null;\n    }\n\n```",
            "method_doc": " Method overridden to support more reliable deserialization of String collections. ",
            "class_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
            "class_doc": " {@link JsonParser} implementation that exposes XML structure as set of JSON events that can be used for data binding. ",
            "test_failure_causes": "Based on my analysis of the failed test case and the provided information, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns from Test Behavior\n\nThe test `testXmlAttributesWithNextTextValue` demonstrates a consistent pattern:\n- It processes XML attributes as field-value pairs in the JSON token stream\n- The failure occurs specifically when calling `nextTextValue()` on XML attribute values\n- The test expects `nextTextValue()` to return the attribute value (\"7\"), but it returns `null`\n\n## Step 2: Analyze the Failure Point\n\nThe critical failure occurs at this sequence:\n1. Parser encounters `JsonToken.FIELD_NAME` for attribute \"max\"\n2. Test calls `xp.nextTextValue()` expecting \"7\" (the attribute value)\n3. Instead, `nextTextValue()` returns `null`\n\nThis indicates that when the parser is positioned at a FIELD_NAME token representing an XML attribute, the `nextTextValue()` method is not correctly advancing to and returning the attribute's text value.\n\n## Step 3: Recommended Possible Defect in Production Code\n\nThe likely defect is in the `FromXmlParser.nextTextValue()` method implementation. Specifically:\n\n**The `nextTextValue()` method may not be properly handling the case when the current token is a FIELD_NAME representing an XML attribute, and fails to advance to and return the attribute's text value.**\n\nPossible root causes in the production code:\n1. **Missing state transition**: When `nextTextValue()` is called on a FIELD_NAME token for an XML attribute, the method may not be advancing the parser state to read the attribute value\n2. **Incorrect token handling**: The method might be checking for VALUE_STRING tokens but not properly handling the XML attribute-to-value transition\n3. **XML-specific parsing logic**: The XML parser's implementation of `nextTextValue()` may have a bug in how it processes attribute values compared to element text content\n\nThe defect appears to be in the XML parser's implementation of the `nextTextValue()` method when dealing with attribute values, where it should advance from FIELD_NAME to the attribute value but instead returns null without proper state progression.",
            "test_suite": "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it contains complex XML token handling logic that fails to properly process attribute values when nextTextValue() is called. The test failure occurs specifically when trying to get attribute text values, and the method's state machine appears to have issues transitioning from FIELD_NAME tokens representing XML attributes to returning their corresponding VALUE_STRING values. The method returns null instead of the expected attribute text, indicating a defect in the attribute value retrieval path."
        },
        {
            "method_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::nextToken()",
            "method_code": "```java\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n            switch (token) {\n            case XmlTokenStream.XML_END_ELEMENT:\n                // Simple, except that if this is a leaf, need to suppress end:\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    if (_parsingContext.inArray()) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_NULL);\n                }\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If there was a chance of leaf node, no more...\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText();\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // One more refinement (pronunced like \"hack\") is that if\n                    // we had an empty String (or all white space), and we are\n                    // deserializing an array, we better hide the empty text.\n                    // Also: must skip following END_ELEMENT\n                    _xmlTokens.skipEndElement();\n                    if (_parsingContext.inArray()) {\n                        if (_isEmpty(_currText)) {\n                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                            //    expose as empty Object, not null (or, worse, as used to\n                            //    be done, by swallowing the token)\n                            _nextToken = JsonToken.END_OBJECT;\n                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                            return (_currToken = JsonToken.START_OBJECT);\n                        }\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // [dataformat-xml#177]: empty text may also need to be skipped\n                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n                    // loop over again\n                    if (_parsingContext.inObject()) {\n                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                            token = _xmlTokens.next();\n                            continue;\n                        }\n                    }\n                }\n                // If not a leaf (or otherwise ignorable), need to transform into property...\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n        }\n    }\n\n```",
            "method_doc": " @Override public JsonToken nextToken() throws IOException { JsonToken t = nextToken0(); if (t != null) { switch (t) { case FIELD_NAME: System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\"); break; case VALUE_STRING: System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\"); break; default: System.out.println(\"JsonToken: \"+t); } } return t; }  public JsonToken nextToken0() throws IOException ",
            "class_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
            "class_doc": " {@link JsonParser} implementation that exposes XML structure as set of JSON events that can be used for data binding. ",
            "test_failure_causes": "Based on my analysis of the failed test case and the provided information, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns from Test Behavior\n\nThe test `testXmlAttributesWithNextTextValue` demonstrates a consistent pattern:\n- It processes XML attributes as field-value pairs in the JSON token stream\n- The failure occurs specifically when calling `nextTextValue()` on XML attribute values\n- The test expects `nextTextValue()` to return the attribute value (\"7\"), but it returns `null`\n\n## Step 2: Analyze the Failure Point\n\nThe critical failure occurs at this sequence:\n1. Parser encounters `JsonToken.FIELD_NAME` for attribute \"max\"\n2. Test calls `xp.nextTextValue()` expecting \"7\" (the attribute value)\n3. Instead, `nextTextValue()` returns `null`\n\nThis indicates that when the parser is positioned at a FIELD_NAME token representing an XML attribute, the `nextTextValue()` method is not correctly advancing to and returning the attribute's text value.\n\n## Step 3: Recommended Possible Defect in Production Code\n\nThe likely defect is in the `FromXmlParser.nextTextValue()` method implementation. Specifically:\n\n**The `nextTextValue()` method may not be properly handling the case when the current token is a FIELD_NAME representing an XML attribute, and fails to advance to and return the attribute's text value.**\n\nPossible root causes in the production code:\n1. **Missing state transition**: When `nextTextValue()` is called on a FIELD_NAME token for an XML attribute, the method may not be advancing the parser state to read the attribute value\n2. **Incorrect token handling**: The method might be checking for VALUE_STRING tokens but not properly handling the XML attribute-to-value transition\n3. **XML-specific parsing logic**: The XML parser's implementation of `nextTextValue()` may have a bug in how it processes attribute values compared to element text content\n\nThe defect appears to be in the XML parser's implementation of the `nextTextValue()` method when dealing with attribute values, where it should advance from FIELD_NAME to the attribute value but instead returns null without proper state progression.",
            "test_suite": "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest",
            "score": 8,
            "reason": "#8# The nextToken() method is highly suspicious because it handles XML_ATTRIBUTE_NAME and XML_ATTRIBUTE_VALUE tokens, and the test failure occurs when nextTextValue() is called after a FIELD_NAME token representing an XML attribute. The issue likely stems from how nextToken() processes attribute sequences - when it returns FIELD_NAME for an attribute, the subsequent call to nextTextValue() should advance to and return the attribute value, but the current implementation may not properly handle this state transition for attributes."
        },
        {
            "method_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::getCurrentName()",
            "method_code": "```java\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n```",
            "method_doc": " Method that can be called to get the name associated with the current event. ",
            "class_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser",
            "class_doc": " {@link JsonParser} implementation that exposes XML structure as set of JSON events that can be used for data binding. ",
            "test_failure_causes": "Based on my analysis of the failed test case and the provided information, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns from Test Behavior\n\nThe test `testXmlAttributesWithNextTextValue` demonstrates a consistent pattern:\n- It processes XML attributes as field-value pairs in the JSON token stream\n- The failure occurs specifically when calling `nextTextValue()` on XML attribute values\n- The test expects `nextTextValue()` to return the attribute value (\"7\"), but it returns `null`\n\n## Step 2: Analyze the Failure Point\n\nThe critical failure occurs at this sequence:\n1. Parser encounters `JsonToken.FIELD_NAME` for attribute \"max\"\n2. Test calls `xp.nextTextValue()` expecting \"7\" (the attribute value)\n3. Instead, `nextTextValue()` returns `null`\n\nThis indicates that when the parser is positioned at a FIELD_NAME token representing an XML attribute, the `nextTextValue()` method is not correctly advancing to and returning the attribute's text value.\n\n## Step 3: Recommended Possible Defect in Production Code\n\nThe likely defect is in the `FromXmlParser.nextTextValue()` method implementation. Specifically:\n\n**The `nextTextValue()` method may not be properly handling the case when the current token is a FIELD_NAME representing an XML attribute, and fails to advance to and return the attribute's text value.**\n\nPossible root causes in the production code:\n1. **Missing state transition**: When `nextTextValue()` is called on a FIELD_NAME token for an XML attribute, the method may not be advancing the parser state to read the attribute value\n2. **Incorrect token handling**: The method might be checking for VALUE_STRING tokens but not properly handling the XML attribute-to-value transition\n3. **XML-specific parsing logic**: The XML parser's implementation of `nextTextValue()` may have a bug in how it processes attribute values compared to element text content\n\nThe defect appears to be in the XML parser's implementation of the `nextTextValue()` method when dealing with attribute values, where it should advance from FIELD_NAME to the attribute value but instead returns null without proper state progression.",
            "test_suite": "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest",
            "score": 3,
            "reason": "#3# While the getCurrentName() method is involved in the test flow, the actual failure occurs in nextTextValue() returning null instead of the expected attribute value. The getCurrentName() method appears to be working correctly as it successfully returns \"max\" and \"offset\" as expected in the test. The root cause is more likely in the nextTextValue() method's handling of XML attribute values."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::nextTextValue()": {
            "method_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::nextTextValue()",
            "method_code": "```java\n    @Override\n    public String nextTextValue() throws IOException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _binaryValue = null;\n        if (!(!(_nextToken != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            JsonToken TransVarNextToken = _nextToken;\n            _currToken = TransVarNextToken;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (!(!(TransVarNextToken == JsonToken.VALUE_STRING))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                return _currText;\n            }\n            _updateState(TransVarNextToken);\n            return null;\n        }\n\n        int TransVarNextXMLToken = _xmlTokens.next();\n\n        for (; !(!(TransVarNextXMLToken == XmlTokenStream.XML_START_ELEMENT));) {\n            if (!(!(_mayBeLeaf))) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (!(!(_parsingContext.inArray()))) {\n                TransVarNextXMLToken = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String TransVarElementName = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(TransVarElementName);\n            if (!(!(_namesToWrap != null && _namesToWrap.contains(TransVarElementName)))) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_END_ELEMENT))))) {\n                TransBreakFlag0 = false;\n                if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            }\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_ATTRIBUTE_NAME))))) {\n                TransBreakFlag0 = false;\n                if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            }\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_ATTRIBUTE_VALUE))))) {\n                TransBreakFlag0 = false;\n                _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_TEXT))))) {\n                TransBreakFlag0 = false;\n            _currText = _xmlTokens.getText();\n                if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _xmlTokens.skipEndElement();\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_END))))) {\n            _currToken = null;\n            }\n        }\n        return null;\n    }\n\n```",
            "method_doc": " Method overridden to support more reliable deserialization of String collections. "
        },
        "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::getCurrentName()": {
            "method_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::getCurrentName()",
            "method_code": "```java\n    @Override\n    public String getCurrentName() throws IOException\n    {\n        // start markers require information from parent\n        String name;\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            XmlReadContext parent = _parsingContext.getParent();\n            name = parent.getCurrentName();\n        } else {\n            name = _parsingContext.getCurrentName();\n        }\n        // sanity check\n        if (name == null) {\n            throw new IllegalStateException(\"Missing name, in state: \"+_currToken);\n        }\n        return name;\n    }\n\n```",
            "method_doc": " Method that can be called to get the name associated with the current event. "
        },
        "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::nextToken()": {
            "method_name": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser::nextToken()",
            "method_code": "```java\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n            switch (t) {\n            case START_OBJECT:\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                break;\n            case START_ARRAY:\n                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n                break;\n            case END_OBJECT:\n            case END_ARRAY:\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                break;\n            case FIELD_NAME:\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                break;\n            default: // VALUE_STRING, VALUE_NULL\n                // should be fine as is?\n            }\n            return t;\n        }\n        int token = _xmlTokens.next();\n\n        // Need to have a loop just because we may have to eat/convert\n        // a start-element that indicates an array element.\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            // If we thought we might get leaf, no such luck\n            if (_mayBeLeaf) {\n                // leave _mayBeLeaf set, as we start a new context\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            if (_parsingContext.inArray()) {\n                // Yup: in array, so this element could be verified; but it won't be\n                // reported anyway, and we need to process following event.\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n\n            // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n            // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n\n            _mayBeLeaf = true;\n            // Ok: in array context we need to skip reporting field names.\n            // But what's the best way to find next token?\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n\n        // Ok; beyond start element, what do we get?\n        while (true) {\n            switch (token) {\n            case XmlTokenStream.XML_END_ELEMENT:\n                // Simple, except that if this is a leaf, need to suppress end:\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    if (_parsingContext.inArray()) {\n                        // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                        //    expose as empty Object, not null\n                        _nextToken = JsonToken.END_OBJECT;\n                        _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                        return (_currToken = JsonToken.START_OBJECT);\n                    }\n                    return (_currToken = JsonToken.VALUE_NULL);\n                }\n                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n                _parsingContext = _parsingContext.getParent();\n                _namesToWrap = _parsingContext.getNamesToWrap();\n                return _currToken;\n                \n            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n                // If there was a chance of leaf node, no more...\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    _nextToken = JsonToken.FIELD_NAME;\n                    _currText = _xmlTokens.getText();\n                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                    return (_currToken = JsonToken.START_OBJECT);\n                }\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n                _currText = _xmlTokens.getText();\n                return (_currToken = JsonToken.VALUE_STRING);\n            case XmlTokenStream.XML_TEXT:\n                _currText = _xmlTokens.getText();\n                if (_mayBeLeaf) {\n                    _mayBeLeaf = false;\n                    // One more refinement (pronunced like \"hack\") is that if\n                    // we had an empty String (or all white space), and we are\n                    // deserializing an array, we better hide the empty text.\n                    // Also: must skip following END_ELEMENT\n                    _xmlTokens.skipEndElement();\n                    if (_parsingContext.inArray()) {\n                        if (_isEmpty(_currText)) {\n                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n                            //    expose as empty Object, not null (or, worse, as used to\n                            //    be done, by swallowing the token)\n                            _nextToken = JsonToken.END_OBJECT;\n                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                            return (_currToken = JsonToken.START_OBJECT);\n                        }\n                    }\n                    return (_currToken = JsonToken.VALUE_STRING);\n                } else {\n                    // [dataformat-xml#177]: empty text may also need to be skipped\n                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n                    // loop over again\n                    if (_parsingContext.inObject()) {\n                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n                            token = _xmlTokens.next();\n                            continue;\n                        }\n                    }\n                }\n                // If not a leaf (or otherwise ignorable), need to transform into property...\n                _parsingContext.setCurrentName(_cfgNameForTextElement);\n                _nextToken = JsonToken.VALUE_STRING;\n                return (_currToken = JsonToken.FIELD_NAME);\n            case XmlTokenStream.XML_END:\n                return (_currToken = null);\n            }\n        }\n    }\n\n```",
            "method_doc": " @Override public JsonToken nextToken() throws IOException { JsonToken t = nextToken0(); if (t != null) { switch (t) { case FIELD_NAME: System.out.println(\"JsonToken: FIELD_NAME '\"+_parsingContext.getCurrentName()+\"'\"); break; case VALUE_STRING: System.out.println(\"JsonToken: VALUE_STRING '\"+getText()+\"'\"); break; default: System.out.println(\"JsonToken: \"+t); } } return t; }  public JsonToken nextToken0() throws IOException "
        }
    }
}