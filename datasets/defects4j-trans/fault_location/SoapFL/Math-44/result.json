{
    "buggy_classes": [
        "org.apache.commons.math.ode.events.EventState"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math.ode.events.EventState::evaluateStep(StepInterpolator)",
            "method_code": "```java\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws ConvergenceException {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n            if (FastMath.abs(dt) < convergence) {\n                // we cannot do anything on such a small step, don't trigger any events\n                return false;\n            }\n            final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n            final double h = dt / n;\n\n            final UnivariateRealFunction f = new UnivariateRealFunction() {\n                public double value(final double t) {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, interpolator.getInterpolatedState());\n                }\n            };\n\n            double ta = t0;\n            double ga = g0;\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    // find the event time making sure we select a solution just at or past the exact root\n                    final double root;\n                    if (solver instanceof BracketedUnivariateRealSolver<?>) {\n                        @SuppressWarnings(\"unchecked\")\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n                        root = forward ?\n                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                    } else {\n                        final double baseRoot = forward ?\n                                                solver.solve(maxIterationCount, f, ta, tb) :\n                                                solver.solve(maxIterationCount, f, tb, ta);\n                        final int remainingEval = maxIterationCount - solver.getEvaluations();\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                        root = forward ?\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                    }\n\n                    if ((!Double.isNaN(previousEventTime)) &&\n                        (FastMath.abs(root - ta) <= convergence) &&\n                        (FastMath.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event,\n                        // retry the substep excluding this value\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                        --i;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (FastMath.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        pendingEvent = true;\n                        return true;\n                    } else {\n                        // no sign change: there is no event for now\n                        ta = tb;\n                        ga = gb;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n    }\n\n```",
            "method_doc": "Evaluate the impact of the proposed step on the event handler. @param interpolator step interpolator for the proposed step @return true if the event handler triggers an event before the end of the proposed step @exception ConvergenceException if an event cannot be located ",
            "class_name": "org.apache.commons.math.ode.events.EventState",
            "class_doc": "This class handles the state for one {@link EventHandler event handler} during integration steps.  <p>Each time the integrator proposes a step, the event handler switching function should be checked. This class handles the state of one handler during one integration step, with references to the state at the end of the preceding step. This information is used to decide if the handler should trigger an event or not during the proposed step.</p>  @version $Id$ @since 1.2 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test code, here's my step-by-step reasoning:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue695` fails with an assertion error: \"going backard in time! (7.796578226186635 < 10.99)\". This occurs in the `ResettingEvent.g()` method when the event evaluation receives a time (7.796) that is earlier than the expected event time (10.99).\n\n## Step 2: Analyzing the Test Scenario\n\nThe test sets up:\n- Two reset events at times 10.99 and 11.01\n- A large initial step size of 3.0\n- Integration from time 0.0 to 30.0\n\nThe key observation is that the integrator is evaluating an event at time 7.796 when it should be evaluating events around times 10.99 and 11.01. This suggests the event handling logic is processing events out of temporal order.\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe stack trace shows the failure occurs in:\n```\nEventState.evaluateStep(EventState.java:214)\nAbstractIntegrator.acceptStep(AbstractIntegrator.java:311)\n```\n\nThis indicates the defect is in the event evaluation logic within the ODE integration process. The test is specifically designed to catch temporal ordering issues in event handling (JIRA MATH-695).\n\n## Step 4: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The event evaluation logic in `EventState.evaluateStep()` or related methods may not properly handle the case when multiple events are scheduled close together and the integrator takes large steps. Specifically, the code might be:\n\n1. **Incorrect event time interpolation**: When the integrator detects an event crossing within a step, it may be incorrectly interpolating back to earlier times that have already been processed.\n\n2. **Improper event state management**: The event handling system may not properly track which events have been triggered and may be re-evaluating events that should no longer be considered active.\n\n3. **Step size adaptation issue**: The adaptive step size control may be allowing backward time evaluation when refining around event boundaries, particularly when multiple events occur in close proximity.\n\nThe defect likely resides in the event localization algorithm within `EventState.evaluateStep()` or the step acceptance logic in `AbstractIntegrator.acceptStep()`, where the system fails to maintain proper temporal ordering when multiple events are present and large initial step sizes are used.\n\nThis would explain why the test fails with a \"going backward in time\" error - the event evaluation is occurring at a time that should have been superseded by later event processing.",
            "test_suite": "org.apache.commons.math.ode.events.EventStateTest",
            "score": 9,
            "reason": "#9# The method is highly suspicious because it contains logic for handling event detection during integration steps, and the test failure shows a \"going backward in time\" error occurring during event evaluation. The code has complex time interpolation logic with multiple substeps and event root finding that could incorrectly evaluate events at earlier times when multiple events are scheduled close together with large step sizes. The temporal ordering issue in the test failure directly relates to how this method manages event time progression and substep evaluation."
        },
        {
            "method_name": "org.apache.commons.math.ode.events.EventState::stepAccepted(double,double[])",
            "method_code": "```java\n    public void stepAccepted(final double t, final double[] y) {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) {\n            // force the sign to its value \"just after the event\"\n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.Action.CONTINUE;\n        }\n    }\n\n```",
            "method_doc": "Acknowledge the fact the step has been accepted by the integrator. @param t value of the independent <i>time</i> variable at the end of the step @param y array containing the current value of the state vector at the end of the step ",
            "class_name": "org.apache.commons.math.ode.events.EventState",
            "class_doc": "This class handles the state for one {@link EventHandler event handler} during integration steps.  <p>Each time the integrator proposes a step, the event handler switching function should be checked. This class handles the state of one handler during one integration step, with references to the state at the end of the preceding step. This information is used to decide if the handler should trigger an event or not during the proposed step.</p>  @version $Id$ @since 1.2 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test code, here's my step-by-step reasoning:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue695` fails with an assertion error: \"going backard in time! (7.796578226186635 < 10.99)\". This occurs in the `ResettingEvent.g()` method when the event evaluation receives a time (7.796) that is earlier than the expected event time (10.99).\n\n## Step 2: Analyzing the Test Scenario\n\nThe test sets up:\n- Two reset events at times 10.99 and 11.01\n- A large initial step size of 3.0\n- Integration from time 0.0 to 30.0\n\nThe key observation is that the integrator is evaluating an event at time 7.796 when it should be evaluating events around times 10.99 and 11.01. This suggests the event handling logic is processing events out of temporal order.\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe stack trace shows the failure occurs in:\n```\nEventState.evaluateStep(EventState.java:214)\nAbstractIntegrator.acceptStep(AbstractIntegrator.java:311)\n```\n\nThis indicates the defect is in the event evaluation logic within the ODE integration process. The test is specifically designed to catch temporal ordering issues in event handling (JIRA MATH-695).\n\n## Step 4: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The event evaluation logic in `EventState.evaluateStep()` or related methods may not properly handle the case when multiple events are scheduled close together and the integrator takes large steps. Specifically, the code might be:\n\n1. **Incorrect event time interpolation**: When the integrator detects an event crossing within a step, it may be incorrectly interpolating back to earlier times that have already been processed.\n\n2. **Improper event state management**: The event handling system may not properly track which events have been triggered and may be re-evaluating events that should no longer be considered active.\n\n3. **Step size adaptation issue**: The adaptive step size control may be allowing backward time evaluation when refining around event boundaries, particularly when multiple events occur in close proximity.\n\nThe defect likely resides in the event localization algorithm within `EventState.evaluateStep()` or the step acceptance logic in `AbstractIntegrator.acceptStep()`, where the system fails to maintain proper temporal ordering when multiple events are present and large initial step sizes are used.\n\nThis would explain why the test fails with a \"going backward in time\" error - the event evaluation is occurring at a time that should have been superseded by later event processing.",
            "test_suite": "org.apache.commons.math.ode.events.EventStateTest",
            "score": 8,
            "reason": "#8# The stepAccepted method is highly suspicious because it updates the event state (t0, g0, g0Positive) when a step is accepted, but the test failure shows temporal ordering issues where event evaluation occurs at incorrect times (7.796 vs 10.99). The method's logic for handling pending events and updating previousEventTime could be causing the system to lose track of proper event sequencing, especially when multiple events occur close together and large step sizes are used. The conditional check for pendingEvent with convergence tolerance may be incorrectly resetting event state, leading to backward time evaluations."
        },
        {
            "method_name": "org.apache.commons.math.ode.events.EventState::reinitializeBegin(StepInterpolator)",
            "method_code": "```java\n    public void reinitializeBegin(final StepInterpolator interpolator) {\n\n        t0 = interpolator.getPreviousTime();\n        interpolator.setInterpolatedTime(t0);\n        g0 = handler.g(t0, interpolator.getInterpolatedState());\n        if (g0 == 0) {\n            // excerpt from MATH-421 issue:\n            // If an ODE solver is setup with an EventHandler that return STOP\n            // when the even is triggered, the integrator stops (which is exactly\n            // the expected behavior). If however the user wants to restart the\n            // solver from the final state reached at the event with the same\n            // configuration (expecting the event to be triggered again at a\n            // later time), then the integrator may fail to start. It can get stuck\n            // at the previous event. The use case for the bug MATH-421 is fairly\n            // general, so events occurring exactly at start in the first step should\n            // be ignored.\n\n            // extremely rare case: there is a zero EXACTLY at interval start\n            // we will use the sign slightly after step beginning to force ignoring this zero\n            final double epsilon = FastMath.max(solver.getAbsoluteAccuracy(),\n                                                FastMath.abs(solver.getRelativeAccuracy() * t0));\n            final double tStart = t0 + 0.5 * epsilon;\n            interpolator.setInterpolatedTime(tStart);\n            g0 = handler.g(tStart, interpolator.getInterpolatedState());\n        }\n        g0Positive = g0 >= 0;\n\n    }\n\n```",
            "method_doc": "Reinitialize the beginning of the step. @param interpolator valid for the current step ",
            "class_name": "org.apache.commons.math.ode.events.EventState",
            "class_doc": "This class handles the state for one {@link EventHandler event handler} during integration steps.  <p>Each time the integrator proposes a step, the event handler switching function should be checked. This class handles the state of one handler during one integration step, with references to the state at the end of the preceding step. This information is used to decide if the handler should trigger an event or not during the proposed step.</p>  @version $Id$ @since 1.2 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test code, here's my step-by-step reasoning:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue695` fails with an assertion error: \"going backard in time! (7.796578226186635 < 10.99)\". This occurs in the `ResettingEvent.g()` method when the event evaluation receives a time (7.796) that is earlier than the expected event time (10.99).\n\n## Step 2: Analyzing the Test Scenario\n\nThe test sets up:\n- Two reset events at times 10.99 and 11.01\n- A large initial step size of 3.0\n- Integration from time 0.0 to 30.0\n\nThe key observation is that the integrator is evaluating an event at time 7.796 when it should be evaluating events around times 10.99 and 11.01. This suggests the event handling logic is processing events out of temporal order.\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe stack trace shows the failure occurs in:\n```\nEventState.evaluateStep(EventState.java:214)\nAbstractIntegrator.acceptStep(AbstractIntegrator.java:311)\n```\n\nThis indicates the defect is in the event evaluation logic within the ODE integration process. The test is specifically designed to catch temporal ordering issues in event handling (JIRA MATH-695).\n\n## Step 4: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The event evaluation logic in `EventState.evaluateStep()` or related methods may not properly handle the case when multiple events are scheduled close together and the integrator takes large steps. Specifically, the code might be:\n\n1. **Incorrect event time interpolation**: When the integrator detects an event crossing within a step, it may be incorrectly interpolating back to earlier times that have already been processed.\n\n2. **Improper event state management**: The event handling system may not properly track which events have been triggered and may be re-evaluating events that should no longer be considered active.\n\n3. **Step size adaptation issue**: The adaptive step size control may be allowing backward time evaluation when refining around event boundaries, particularly when multiple events occur in close proximity.\n\nThe defect likely resides in the event localization algorithm within `EventState.evaluateStep()` or the step acceptance logic in `AbstractIntegrator.acceptStep()`, where the system fails to maintain proper temporal ordering when multiple events are present and large initial step sizes are used.\n\nThis would explain why the test fails with a \"going backward in time\" error - the event evaluation is occurring at a time that should have been superseded by later event processing.",
            "test_suite": "org.apache.commons.math.ode.events.EventStateTest",
            "score": 8,
            "reason": "#8# The reinitializeBegin method is highly suspicious because it sets the initial event state (t0 and g0) at the beginning of integration steps. In the failing test, the error occurs when evaluating events at incorrect times (7.796 vs 10.99), suggesting improper initialization of event timing. The method's logic for handling g0 == 0 cases by adjusting time with epsilon could interfere with proper temporal ordering when multiple events are scheduled close together, especially with large initial step sizes. This could cause the integrator to evaluate events at unexpected times, leading to the \"going backward in time\" error."
        },
        {
            "method_name": "org.apache.commons.math.ode.events.EventState::reset(double,double[])",
            "method_code": "```java\n    public boolean reset(final double t, final double[] y) {\n\n        if (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.Action.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.Action.RESET_STATE) ||\n               (nextAction == EventHandler.Action.RESET_DERIVATIVES);\n\n    }\n\n```",
            "method_doc": "Let the event handler reset the state if it wants. @param t value of the independent <i>time</i> variable at the beginning of the next step @param y array were to put the desired state vector at the beginning of the next step @return true if the integrator should reset the derivatives too ",
            "class_name": "org.apache.commons.math.ode.events.EventState",
            "class_doc": "This class handles the state for one {@link EventHandler event handler} during integration steps.  <p>Each time the integrator proposes a step, the event handler switching function should be checked. This class handles the state of one handler during one integration step, with references to the state at the end of the preceding step. This information is used to decide if the handler should trigger an event or not during the proposed step.</p>  @version $Id$ @since 1.2 ",
            "test_failure_causes": "Based on my analysis of the failed test behavior, stack trace, and test code, here's my step-by-step reasoning:\n\n## Step 1: Understanding the Test Failure Pattern\n\nThe test `testIssue695` fails with an assertion error: \"going backard in time! (7.796578226186635 < 10.99)\". This occurs in the `ResettingEvent.g()` method when the event evaluation receives a time (7.796) that is earlier than the expected event time (10.99).\n\n## Step 2: Analyzing the Test Scenario\n\nThe test sets up:\n- Two reset events at times 10.99 and 11.01\n- A large initial step size of 3.0\n- Integration from time 0.0 to 30.0\n\nThe key observation is that the integrator is evaluating an event at time 7.796 when it should be evaluating events around times 10.99 and 11.01. This suggests the event handling logic is processing events out of temporal order.\n\n## Step 3: Identifying the Common Defect Pattern\n\nThe stack trace shows the failure occurs in:\n```\nEventState.evaluateStep(EventState.java:214)\nAbstractIntegrator.acceptStep(AbstractIntegrator.java:311)\n```\n\nThis indicates the defect is in the event evaluation logic within the ODE integration process. The test is specifically designed to catch temporal ordering issues in event handling (JIRA MATH-695).\n\n## Step 4: Recommended Possible Defect in Production Code\n\n**Possible Defect**: The event evaluation logic in `EventState.evaluateStep()` or related methods may not properly handle the case when multiple events are scheduled close together and the integrator takes large steps. Specifically, the code might be:\n\n1. **Incorrect event time interpolation**: When the integrator detects an event crossing within a step, it may be incorrectly interpolating back to earlier times that have already been processed.\n\n2. **Improper event state management**: The event handling system may not properly track which events have been triggered and may be re-evaluating events that should no longer be considered active.\n\n3. **Step size adaptation issue**: The adaptive step size control may be allowing backward time evaluation when refining around event boundaries, particularly when multiple events occur in close proximity.\n\nThe defect likely resides in the event localization algorithm within `EventState.evaluateStep()` or the step acceptance logic in `AbstractIntegrator.acceptStep()`, where the system fails to maintain proper temporal ordering when multiple events are present and large initial step sizes are used.\n\nThis would explain why the test fails with a \"going backward in time\" error - the event evaluation is occurring at a time that should have been superseded by later event processing.",
            "test_suite": "org.apache.commons.math.ode.events.EventStateTest",
            "score": 8,
            "reason": "#8# The reset method is highly suspicious because it contains the convergence tolerance check that could cause temporal ordering issues. When multiple events occur close together (like at 10.99 and 11.01), the condition `FastMath.abs(pendingEventTime - t) <= convergence` might incorrectly match events that should be considered distinct, leading to the \"going backward in time\" error when the integrator processes events out of order. The convergence tolerance comparison doesn't properly handle the case where multiple pending events exist with similar times."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math.ode.events.EventState::evaluateStep(StepInterpolator)": {
            "method_name": "org.apache.commons.math.ode.events.EventState::evaluateStep(StepInterpolator)",
            "method_code": "```java\n    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws ConvergenceException {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n            if (FastMath.abs(dt) < convergence) {\n                // we cannot do anything on such a small step, don't trigger any events\n                return false;\n            }\n            final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n            final double h = dt / n;\n\n            final UnivariateRealFunction f = new UnivariateRealFunction() {\n                public double value(final double t) {\n                    interpolator.setInterpolatedTime(t);\n                    return handler.g(t, interpolator.getInterpolatedState());\n                }\n            };\n\n            double ta = t0;\n            double ga = g0;\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    // find the event time making sure we select a solution just at or past the exact root\n                    final double root;\n                    if (solver instanceof BracketedUnivariateRealSolver<?>) {\n                        @SuppressWarnings(\"unchecked\")\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n                        root = forward ?\n                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                    } else {\n                        final double baseRoot = forward ?\n                                                solver.solve(maxIterationCount, f, ta, tb) :\n                                                solver.solve(maxIterationCount, f, tb, ta);\n                        final int remainingEval = maxIterationCount - solver.getEvaluations();\n                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                        root = forward ?\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                    }\n\n                    if ((!Double.isNaN(previousEventTime)) &&\n                        (FastMath.abs(root - ta) <= convergence) &&\n                        (FastMath.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event,\n                        // retry the substep excluding this value\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                        --i;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (FastMath.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        pendingEvent = true;\n                        return true;\n                    } else {\n                        // no sign change: there is no event for now\n                        ta = tb;\n                        ga = gb;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n    }\n\n```",
            "method_doc": "Evaluate the impact of the proposed step on the event handler. @param interpolator step interpolator for the proposed step @return true if the event handler triggers an event before the end of the proposed step @exception ConvergenceException if an event cannot be located "
        },
        "org.apache.commons.math.ode.events.EventState::stepAccepted(double,double[])": {
            "method_name": "org.apache.commons.math.ode.events.EventState::stepAccepted(double,double[])",
            "method_code": "```java\n    public void stepAccepted(final double t, final double[] y) {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) {\n            // force the sign to its value \"just after the event\"\n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.Action.CONTINUE;\n        }\n    }\n\n```",
            "method_doc": "Acknowledge the fact the step has been accepted by the integrator. @param t value of the independent <i>time</i> variable at the end of the step @param y array containing the current value of the state vector at the end of the step "
        },
        "org.apache.commons.math.ode.events.EventState::reinitializeBegin(StepInterpolator)": {
            "method_name": "org.apache.commons.math.ode.events.EventState::reinitializeBegin(StepInterpolator)",
            "method_code": "```java\n    public void reinitializeBegin(final StepInterpolator interpolator) {\n\n        t0 = interpolator.getPreviousTime();\n        interpolator.setInterpolatedTime(t0);\n        g0 = handler.g(t0, interpolator.getInterpolatedState());\n        if (g0 == 0) {\n            // excerpt from MATH-421 issue:\n            // If an ODE solver is setup with an EventHandler that return STOP\n            // when the even is triggered, the integrator stops (which is exactly\n            // the expected behavior). If however the user wants to restart the\n            // solver from the final state reached at the event with the same\n            // configuration (expecting the event to be triggered again at a\n            // later time), then the integrator may fail to start. It can get stuck\n            // at the previous event. The use case for the bug MATH-421 is fairly\n            // general, so events occurring exactly at start in the first step should\n            // be ignored.\n\n            // extremely rare case: there is a zero EXACTLY at interval start\n            // we will use the sign slightly after step beginning to force ignoring this zero\n            final double epsilon = FastMath.max(solver.getAbsoluteAccuracy(),\n                                                FastMath.abs(solver.getRelativeAccuracy() * t0));\n            final double tStart = t0 + 0.5 * epsilon;\n            interpolator.setInterpolatedTime(tStart);\n            g0 = handler.g(tStart, interpolator.getInterpolatedState());\n        }\n        g0Positive = g0 >= 0;\n\n    }\n\n```",
            "method_doc": "Reinitialize the beginning of the step. @param interpolator valid for the current step "
        },
        "org.apache.commons.math.ode.events.EventState::reset(double,double[])": {
            "method_name": "org.apache.commons.math.ode.events.EventState::reset(double,double[])",
            "method_code": "```java\n    public boolean reset(final double t, final double[] y) {\n\n        if (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.Action.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.Action.RESET_STATE) ||\n               (nextAction == EventHandler.Action.RESET_DERIVATIVES);\n\n    }\n\n```",
            "method_doc": "Let the event handler reset the state if it wants. @param t value of the independent <i>time</i> variable at the beginning of the next step @param y array were to put the desired state vector at the beginning of the next step @return true if the integrator should reset the derivatives too "
        }
    }
}