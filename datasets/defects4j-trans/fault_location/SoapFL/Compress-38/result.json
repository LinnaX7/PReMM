{
    "buggy_classes": [
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::paxHeaders()",
            "method_code": "```java\n    private void paxHeaders() throws IOException{\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n```",
            "method_doc": "Processes PAX headers for the current entry. This method calls methods \"parsePaxHeaders\" and \"getNextEntry\".",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Let me analyze this test failure step by step to identify the root cause in the production code.\n\n## Analysis of Test Failure\n\n**Test Purpose**: The test verifies that `TarArchiveInputStream` can handle PAX headers with names ending in slashes (specifically addressing COMPRESS-356 issue).\n\n**Failure Point**: The error occurs at `is.getNextTarEntry()` when parsing the TAR archive header.\n\n**Key Error Information**:\n- Primary exception: `java.io.IOException: Error detected parsing the header`\n- Root cause: `java.lang.IllegalArgumentException: Invalid byte 115 at offset 0 in 's.1=.git' len=8`\n- The error happens during `paxHeaders()` processing in `TarArchiveInputStream`\n\n## Pattern Identification\n\nThe critical pattern here is:\n1. The failure occurs during PAX header parsing\n2. The specific error mentions an \"Invalid byte 115\" (ASCII 's') in the string `'s.1=.git'`\n3. This suggests the PAX header parsing logic is encountering malformed or unexpected header data\n\n## Recommended Defect in Production Code\n\nBased on the analysis, the likely defect is in the **PAX header parsing logic** in `TarArchiveInputStream`, specifically in the `paxHeaders()` method around line 445.\n\n**Possible Defect Scenarios**:\n\n1. **Insufficient validation of PAX header key-value pairs**: The parser may not properly handle PAX headers where the key contains unexpected characters or formatting, particularly when dealing with headers that have names ending with slashes.\n\n2. **Character encoding/decoding issue**: The byte-to-string conversion for PAX header parsing may be using incorrect character encoding or failing to properly handle certain byte sequences.\n\n3. **Boundary condition in header parsing**: The logic that splits PAX headers into key-value pairs may not account for edge cases where header names have special characters or specific formatting patterns.\n\n4. **Missing error recovery**: When encountering malformed PAX headers, the code may throw an exception instead of implementing graceful fallback behavior for non-critical header issues.\n\nThe specific error with `'s.1=.git'` suggests the PAX header parser is encountering what it considers an invalid key format, but this might be a valid PAX header extension that the current implementation doesn't properly recognize or handle.\n\n**Recommended Focus Area**: The `paxHeaders()` method in `TarArchiveInputStream` and its associated header parsing utilities, particularly the logic that validates and processes PAX header key-value format.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 9,
            "reason": "#9# The paxHeaders() method is highly suspicious because the stack trace shows the failure occurs during PAX header processing, specifically when parsing the header with the malformed string 's.1=.git'. The method calls parsePaxHeaders() which likely contains the validation logic that's incorrectly rejecting valid PAX headers with names ending in slashes, and the error occurs during the getNextEntry() call within this method."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::parsePaxHeaders(InputStream)",
            "method_code": "```java\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '\\n') { // blank line in header\n                    break;\n                } else if (ch == ' '){ // End of length string\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }\n\n```",
            "method_doc": "https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Let me analyze this test failure step by step to identify the root cause in the production code.\n\n## Analysis of Test Failure\n\n**Test Purpose**: The test verifies that `TarArchiveInputStream` can handle PAX headers with names ending in slashes (specifically addressing COMPRESS-356 issue).\n\n**Failure Point**: The error occurs at `is.getNextTarEntry()` when parsing the TAR archive header.\n\n**Key Error Information**:\n- Primary exception: `java.io.IOException: Error detected parsing the header`\n- Root cause: `java.lang.IllegalArgumentException: Invalid byte 115 at offset 0 in 's.1=.git' len=8`\n- The error happens during `paxHeaders()` processing in `TarArchiveInputStream`\n\n## Pattern Identification\n\nThe critical pattern here is:\n1. The failure occurs during PAX header parsing\n2. The specific error mentions an \"Invalid byte 115\" (ASCII 's') in the string `'s.1=.git'`\n3. This suggests the PAX header parsing logic is encountering malformed or unexpected header data\n\n## Recommended Defect in Production Code\n\nBased on the analysis, the likely defect is in the **PAX header parsing logic** in `TarArchiveInputStream`, specifically in the `paxHeaders()` method around line 445.\n\n**Possible Defect Scenarios**:\n\n1. **Insufficient validation of PAX header key-value pairs**: The parser may not properly handle PAX headers where the key contains unexpected characters or formatting, particularly when dealing with headers that have names ending with slashes.\n\n2. **Character encoding/decoding issue**: The byte-to-string conversion for PAX header parsing may be using incorrect character encoding or failing to properly handle certain byte sequences.\n\n3. **Boundary condition in header parsing**: The logic that splits PAX headers into key-value pairs may not account for edge cases where header names have special characters or specific formatting patterns.\n\n4. **Missing error recovery**: When encountering malformed PAX headers, the code may throw an exception instead of implementing graceful fallback behavior for non-critical header issues.\n\nThe specific error with `'s.1=.git'` suggests the PAX header parser is encountering what it considers an invalid key format, but this might be a valid PAX header extension that the current implementation doesn't properly recognize or handle.\n\n**Recommended Focus Area**: The `paxHeaders()` method in `TarArchiveInputStream` and its associated header parsing utilities, particularly the logic that validates and processes PAX header key-value format.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 9,
            "reason": "#9# The parsePaxHeaders method is highly suspicious because the test failure occurs during PAX header parsing with the specific error \"Invalid byte 115 at offset 0 in 's.1=.git' len=8\". The method's logic for parsing PAX header key-value pairs appears to have issues with certain header formats, particularly when encountering keys like 's.1' that may not follow expected patterns. The method's character-by-character parsing and validation logic likely fails to properly handle edge cases in PAX header formatting, causing the IllegalArgumentException when it encounters what it considers invalid byte sequences in header keys."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getNextTarEntry()",
            "method_code": "```java\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            /* Skip will only go to the end of the current entry */\n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            /* skip to the end of the last record */\n            skipRecordPadding();\n        }\n\n        final byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            /* hit EOF */\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (final IllegalArgumentException e) {\n            throw new IOException(\"Error detected parsing the header\", e);\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            final byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long link entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            final byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers\n            readGlobalPaxHeaders();\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        } else if (!globalPaxHeaders.isEmpty()) {\n            applyPaxHeadersToCurrentEntry(globalPaxHeaders);\n        }\n\n        if (currEntry.isOldGNUSparse()){ // Process sparse files\n            readOldGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n\n```",
            "method_doc": " Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.  @return The next TarEntry in the archive, or null. @throws IOException on error ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Let me analyze this test failure step by step to identify the root cause in the production code.\n\n## Analysis of Test Failure\n\n**Test Purpose**: The test verifies that `TarArchiveInputStream` can handle PAX headers with names ending in slashes (specifically addressing COMPRESS-356 issue).\n\n**Failure Point**: The error occurs at `is.getNextTarEntry()` when parsing the TAR archive header.\n\n**Key Error Information**:\n- Primary exception: `java.io.IOException: Error detected parsing the header`\n- Root cause: `java.lang.IllegalArgumentException: Invalid byte 115 at offset 0 in 's.1=.git' len=8`\n- The error happens during `paxHeaders()` processing in `TarArchiveInputStream`\n\n## Pattern Identification\n\nThe critical pattern here is:\n1. The failure occurs during PAX header parsing\n2. The specific error mentions an \"Invalid byte 115\" (ASCII 's') in the string `'s.1=.git'`\n3. This suggests the PAX header parsing logic is encountering malformed or unexpected header data\n\n## Recommended Defect in Production Code\n\nBased on the analysis, the likely defect is in the **PAX header parsing logic** in `TarArchiveInputStream`, specifically in the `paxHeaders()` method around line 445.\n\n**Possible Defect Scenarios**:\n\n1. **Insufficient validation of PAX header key-value pairs**: The parser may not properly handle PAX headers where the key contains unexpected characters or formatting, particularly when dealing with headers that have names ending with slashes.\n\n2. **Character encoding/decoding issue**: The byte-to-string conversion for PAX header parsing may be using incorrect character encoding or failing to properly handle certain byte sequences.\n\n3. **Boundary condition in header parsing**: The logic that splits PAX headers into key-value pairs may not account for edge cases where header names have special characters or specific formatting patterns.\n\n4. **Missing error recovery**: When encountering malformed PAX headers, the code may throw an exception instead of implementing graceful fallback behavior for non-critical header issues.\n\nThe specific error with `'s.1=.git'` suggests the PAX header parser is encountering what it considers an invalid key format, but this might be a valid PAX header extension that the current implementation doesn't properly recognize or handle.\n\n**Recommended Focus Area**: The `paxHeaders()` method in `TarArchiveInputStream` and its associated header parsing utilities, particularly the logic that validates and processes PAX header key-value format.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because the test failure occurs specifically at the getNextTarEntry() call, and the stack trace shows the error propagates from paxHeaders() method which is called within getNextTarEntry(). The method contains the logic flow that processes PAX headers, and the error \"Invalid byte 115 at offset 0 in 's.1=.git'\" indicates a problem in PAX header parsing that happens during the execution path controlled by this method."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getRecord()",
            "method_code": "```java\n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n```",
            "method_doc": " Get the next record in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry.  <p>If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.  At the same time the {@code hasHitEOF} marker will be set to true.</p>  @return The next header in the archive, or null. @throws IOException on error ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream",
            "class_doc": " The TarInputStream reads a UNIX tar archive as an InputStream. methods are provided to position at each successive entry in the archive, and the read each entry as a normal input stream using read(). @NotThreadSafe ",
            "test_failure_causes": "Let me analyze this test failure step by step to identify the root cause in the production code.\n\n## Analysis of Test Failure\n\n**Test Purpose**: The test verifies that `TarArchiveInputStream` can handle PAX headers with names ending in slashes (specifically addressing COMPRESS-356 issue).\n\n**Failure Point**: The error occurs at `is.getNextTarEntry()` when parsing the TAR archive header.\n\n**Key Error Information**:\n- Primary exception: `java.io.IOException: Error detected parsing the header`\n- Root cause: `java.lang.IllegalArgumentException: Invalid byte 115 at offset 0 in 's.1=.git' len=8`\n- The error happens during `paxHeaders()` processing in `TarArchiveInputStream`\n\n## Pattern Identification\n\nThe critical pattern here is:\n1. The failure occurs during PAX header parsing\n2. The specific error mentions an \"Invalid byte 115\" (ASCII 's') in the string `'s.1=.git'`\n3. This suggests the PAX header parsing logic is encountering malformed or unexpected header data\n\n## Recommended Defect in Production Code\n\nBased on the analysis, the likely defect is in the **PAX header parsing logic** in `TarArchiveInputStream`, specifically in the `paxHeaders()` method around line 445.\n\n**Possible Defect Scenarios**:\n\n1. **Insufficient validation of PAX header key-value pairs**: The parser may not properly handle PAX headers where the key contains unexpected characters or formatting, particularly when dealing with headers that have names ending with slashes.\n\n2. **Character encoding/decoding issue**: The byte-to-string conversion for PAX header parsing may be using incorrect character encoding or failing to properly handle certain byte sequences.\n\n3. **Boundary condition in header parsing**: The logic that splits PAX headers into key-value pairs may not account for edge cases where header names have special characters or specific formatting patterns.\n\n4. **Missing error recovery**: When encountering malformed PAX headers, the code may throw an exception instead of implementing graceful fallback behavior for non-critical header issues.\n\nThe specific error with `'s.1=.git'` suggests the PAX header parser is encountering what it considers an invalid key format, but this might be a valid PAX header extension that the current implementation doesn't properly recognize or handle.\n\n**Recommended Focus Area**: The `paxHeaders()` method in `TarArchiveInputStream` and its associated header parsing utilities, particularly the logic that validates and processes PAX header key-value format.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest",
            "score": 3,
            "reason": "#3# The getRecord() method is primarily responsible for reading raw TAR records and handling EOF conditions, but the actual test failure occurs during PAX header parsing in the paxHeaders() method where the specific IllegalArgumentException is thrown. While getRecord() provides the raw data, the root cause appears to be in the PAX header parsing logic that processes this data."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::paxHeaders()": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::paxHeaders()",
            "method_code": "```java\n    private void paxHeaders() throws IOException{\n        final Map<String, String> headers = parsePaxHeaders(this);\n        getNextEntry(); // Get the actual file entry\n        applyPaxHeadersToCurrentEntry(headers);\n    }\n\n```",
            "method_doc": "Processes PAX headers for the current entry. This method calls methods \"parsePaxHeaders\" and \"getNextEntry\"."
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getRecord()": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getRecord()",
            "method_code": "```java\n    private byte[] getRecord() throws IOException {\n        byte[] headerBuf = readRecord();\n        hasHitEOF = isEOFRecord(headerBuf);\n        if (hasHitEOF && headerBuf != null) {\n            tryToConsumeSecondEOFRecord();\n            consumeRemainderOfLastBlock();\n            headerBuf = null;\n        }\n        return headerBuf;\n    }\n\n```",
            "method_doc": " Get the next record in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry.  <p>If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.  At the same time the {@code hasHitEOF} marker will be set to true.</p>  @return The next header in the archive, or null. @throws IOException on error "
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getNextTarEntry()": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::getNextTarEntry()",
            "method_code": "```java\n    public TarArchiveEntry getNextTarEntry() throws IOException {\n        if (hasHitEOF) {\n            return null;\n        }\n\n        if (currEntry != null) {\n            /* Skip will only go to the end of the current entry */\n            IOUtils.skip(this, Long.MAX_VALUE);\n\n            /* skip to the end of the last record */\n            skipRecordPadding();\n        }\n\n        final byte[] headerBuf = getRecord();\n\n        if (headerBuf == null) {\n            /* hit EOF */\n            currEntry = null;\n            return null;\n        }\n\n        try {\n            currEntry = new TarArchiveEntry(headerBuf, zipEncoding);\n        } catch (final IllegalArgumentException e) {\n            throw new IOException(\"Error detected parsing the header\", e);\n        }\n\n        entryOffset = 0;\n        entrySize = currEntry.getSize();\n\n        if (currEntry.isGNULongLinkEntry()) {\n            final byte[] longLinkData = getLongNameData();\n            if (longLinkData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long link entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setLinkName(zipEncoding.decode(longLinkData));\n        }\n\n        if (currEntry.isGNULongNameEntry()) {\n            final byte[] longNameData = getLongNameData();\n            if (longNameData == null) {\n                // Bugzilla: 40334\n                // Malformed tar file - long entry name not followed by\n                // entry\n                return null;\n            }\n            currEntry.setName(zipEncoding.decode(longNameData));\n        }\n\n        if (currEntry.isGlobalPaxHeader()){ // Process Global Pax headers\n            readGlobalPaxHeaders();\n        }\n\n        if (currEntry.isPaxHeader()){ // Process Pax headers\n            paxHeaders();\n        } else if (!globalPaxHeaders.isEmpty()) {\n            applyPaxHeadersToCurrentEntry(globalPaxHeaders);\n        }\n\n        if (currEntry.isOldGNUSparse()){ // Process sparse files\n            readOldGNUSparse();\n        }\n\n        // If the size of the next element in the archive has changed\n        // due to a new size being reported in the posix header\n        // information, we update entrySize here so that it contains\n        // the correct value.\n        entrySize = currEntry.getSize();\n\n        return currEntry;\n    }\n\n```",
            "method_doc": " Get the next entry in this tar archive. This will skip over any remaining data in the current entry, if there is one, and place the input stream at the header of the next entry, and read the header and instantiate a new TarEntry from the header bytes and return that entry. If there are no more entries in the archive, null will be returned to indicate that the end of the archive has been reached.  @return The next TarEntry in the archive, or null. @throws IOException on error "
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::parsePaxHeaders(InputStream)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream::parsePaxHeaders(InputStream)",
            "method_code": "```java\n    Map<String, String> parsePaxHeaders(final InputStream i)\n        throws IOException {\n        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n        // Format is \"length keyword=value\\n\";\n        while(true){ // get length\n            int ch;\n            int len = 0;\n            int read = 0;\n            while((ch = i.read()) != -1) {\n                read++;\n                if (ch == '\\n') { // blank line in header\n                    break;\n                } else if (ch == ' '){ // End of length string\n                    // Get keyword\n                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n                    while((ch = i.read()) != -1) {\n                        read++;\n                        if (ch == '='){ // end of keyword\n                            final String keyword = coll.toString(CharsetNames.UTF_8);\n                            // Get rest of entry\n                            final int restLen = len - read;\n                            if (restLen == 1) { // only NL\n                                headers.remove(keyword);\n                            } else {\n                                final byte[] rest = new byte[restLen];\n                                final int got = IOUtils.readFully(i, rest);\n                                if (got != restLen) {\n                                    throw new IOException(\"Failed to read \"\n                                                          + \"Paxheader. Expected \"\n                                                          + restLen\n                                                          + \" bytes, read \"\n                                                          + got);\n                                }\n                                // Drop trailing NL\n                                final String value = new String(rest, 0,\n                                                          restLen - 1, CharsetNames.UTF_8);\n                                headers.put(keyword, value);\n                            }\n                            break;\n                        }\n                        coll.write((byte) ch);\n                    }\n                    break; // Processed single header\n                }\n                len *= 10;\n                len += ch - '0';\n            }\n            if (ch == -1){ // EOF\n                break;\n            }\n        }\n        return headers;\n    }\n\n```",
            "method_doc": "https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188"
        }
    }
}