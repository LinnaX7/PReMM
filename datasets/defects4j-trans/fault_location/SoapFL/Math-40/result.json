{
    "buggy_classes": [
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::doSolve()",
            "method_code": "```java\n    @Override\n    protected double doSolve() {\n\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // prepare arrays with the first points\n        final double[] TransVarX1 = new double[maximalOrder + 1];\n        final double[] TransVarY1 = new double[maximalOrder + 1];\n        TransVarX1[0] = getMin();\n        TransVarX1[1] = getStartValue();\n        TransVarX1[2] = getMax();\n        verifySequence(TransVarX1[0], TransVarX1[1], TransVarX1[2]);\n\n        // evaluate initial guess\n        TransVarY1[1] = computeObjectiveValue(TransVarX1[1]);\n        if (!(!(Precision.equals(TransVarY1[1], 0.0, 1)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // return the initial guess if it is a perfect root.\n            return TransVarX1[1];\n        }\n\n        // evaluate first  endpoint\n        TransVarY1[0] = computeObjectiveValue(TransVarX1[0]);\n        if (!(!(Precision.equals(TransVarY1[0], 0.0, 1)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // return the first endpoint if it is a perfect root.\n            return TransVarX1[0];\n        }\n\n        int TransVarNbElements;\n        int TransVarSignChange;\n        if (!(!(TransVarY1[0] * TransVarY1[1] < 0))) {\n\n            // reduce interval if it brackets the root\n            TransVarNbElements        = 2;\n            TransVarSignChange = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            TransVarY1[2] = computeObjectiveValue(TransVarX1[2]);\n            if (!(!(Precision.equals(TransVarY1[2], 0.0, 1)))) {\n                // return the second endpoint if it is a perfect root.\n                return TransVarX1[2];\n            }\n\n            if (!(!(TransVarY1[1] * TransVarY1[2] < 0))) {\n                // use all computed point as a start sampling array for solving\n                TransVarNbElements        = 3;\n                TransVarSignChange = 2;\n            } else {\n                throw new NoBracketingException(TransVarX1[0], TransVarX1[2], TransVarY1[0], TransVarY1[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] TransVarTmpX_ = new double[TransVarX1.length];\n\n        // current tightest bracketing of the root\n        double TransVarX3    = TransVarX1[TransVarSignChange - 1];\n        double TransVarY2    = TransVarY1[TransVarSignChange - 1];\n        double TransVarAbsY = FastMath.abs(TransVarY2);\n        int TransVarAgingB   = 0;\n        double TransVarTmpX    = TransVarX1[TransVarSignChange];\n        double TransVarYB1    = TransVarY1[TransVarSignChange];\n        double TransVarAbsY1 = FastMath.abs(TransVarYB1);\n        int TransVarAgingA   = 0;\n\n        for (; !(!(true));) {\n            final double TransVarXTol_ = getAbsoluteAccuracy()\n                    + getRelativeAccuracy() * FastMath.max(FastMath.abs(TransVarX3), FastMath.abs(TransVarTmpX));\n            if (!(!(((TransVarTmpX - TransVarX3) <= TransVarXTol_)\n                    || (FastMath.max(TransVarAbsY, TransVarAbsY1) < getFunctionValueAccuracy())))) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return TransVarAbsY < TransVarAbsY1 ? TransVarX3 : TransVarTmpX;\n                case LEFT_SIDE:\n                    return TransVarX3;\n                case RIGHT_SIDE:\n                    return TransVarTmpX;\n                case BELOW_SIDE:\n                    return (TransVarY2 <= 0) ? TransVarX3 : TransVarTmpX;\n                case ABOVE_SIDE:\n                    return (TransVarY2 < 0) ? TransVarTmpX : TransVarX3;\n                default:\n                    throw new MathInternalError(null);\n                }\n            }\n            double TransVarY;\n            if (!(!(TransVarAgingB >= MAXIMAL_AGING))) {\n                TransVarY = -REDUCTION_FACTOR * TransVarYB1;\n            } else if (!(!(TransVarAgingA >= MAXIMAL_AGING))) {\n                TransVarY = -REDUCTION_FACTOR * TransVarY2;\n            } else {\n                TransVarY = 0;\n            }\n            double TransVarX;\n            int TransVarStartIndex = 0;\n            int TransVarEndPoint = TransVarNbElements;\n            do {\n                System.arraycopy(TransVarX1, TransVarStartIndex, TransVarTmpX_, TransVarStartIndex,\n                        TransVarEndPoint - TransVarStartIndex);\n                TransVarX = guessX(TransVarY, TransVarTmpX_, TransVarY1, TransVarStartIndex, TransVarEndPoint);\n                if (!(!(!((TransVarX > TransVarX3) && (TransVarX < TransVarTmpX))))) {\n                    if (!(!(TransVarSignChange - TransVarStartIndex >= TransVarEndPoint - TransVarSignChange))) {\n                        ++TransVarStartIndex;\n                    } else {\n                        --TransVarEndPoint;\n                    }\n                    TransVarX = Double.NaN;\n                }\n            } while (!(!(Double.isNaN(TransVarX) && (TransVarEndPoint - TransVarStartIndex > 1))));\n            if (!(!(Double.isNaN(TransVarX)))) {\n                TransVarX = TransVarX3 + 0.5 * (TransVarTmpX - TransVarX3);\n                TransVarStartIndex = TransVarSignChange - 1;\n                TransVarEndPoint = TransVarSignChange;\n            }\n            final double TransVarNextY1 = computeObjectiveValue(TransVarX);\n            if (!(!(Precision.equals(TransVarNextY1, 0.0, 1)))) {\n                return TransVarX;\n            }\n            if (!(!((TransVarNbElements > 2) && (TransVarEndPoint - TransVarStartIndex != TransVarNbElements)))) {\n                TransVarNbElements = TransVarEndPoint - TransVarStartIndex;\n                System.arraycopy(TransVarX1, TransVarStartIndex, TransVarX1, 0, TransVarNbElements);\n                System.arraycopy(TransVarY1, TransVarStartIndex, TransVarY1, 0, TransVarNbElements);\n                TransVarSignChange -= TransVarStartIndex;\n            } else if (!(!(TransVarNbElements == TransVarX1.length))) {\n                TransVarNbElements--;\n                if (!(!(TransVarSignChange >= (TransVarX1.length + 1) / 2))) {\n                    System.arraycopy(TransVarX1, 1, TransVarX1, 0, TransVarNbElements);\n                    System.arraycopy(TransVarY1, 1, TransVarY1, 0, TransVarNbElements);\n                    --TransVarSignChange;\n                }\n            }\n            System.arraycopy(TransVarX1, TransVarSignChange, TransVarX1, TransVarSignChange + 1,\n                    TransVarNbElements - TransVarSignChange);\n            TransVarX1[TransVarSignChange] = TransVarX;\n            System.arraycopy(TransVarY1, TransVarSignChange, TransVarY1, TransVarSignChange + 1,\n                    TransVarNbElements - TransVarSignChange);\n            TransVarY1[TransVarSignChange] = TransVarNextY1;\n            ++TransVarNbElements;\n            if (!(!(TransVarNextY1 * TransVarY2 <= 0))) {\n                TransVarTmpX = TransVarX;\n                TransVarYB1 = TransVarNextY1;\n                TransVarAbsY1 = FastMath.abs(TransVarYB1);\n                ++TransVarAgingB;\n                TransVarAgingA = 0;\n            } else {\n                TransVarX3 = TransVarX;\n                TransVarY2 = TransVarNextY1;\n                TransVarAbsY = FastMath.abs(TransVarY2);\n                TransVarAgingB = 0;\n                ++TransVarAgingA;\n                TransVarSignChange++;\n            }\n        }\n\n    }\n\n```",
            "method_doc": " {@inheritDoc} ",
            "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
            "class_doc": " This class implements a modification of the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\"> Brent algorithm</a>. <p> The changes with respect to the original Brent algorithm are: <ul> <li>the returned value is chosen in the current interval according to user specified {@link AllowedSolution},</li> <li>the maximal order for the invert polynomial root search is user-specified instead of being invert quadratic only</li> </ul> </p> The given interval must bracket the root.  @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n## Analysis of Test Failure\n\n**Common Pattern Identified:**\n- Single test failure: `testIssue716`\n- Failure type: `TooManyEvaluationsException` - maximum evaluation count (100) exceeded\n- The solver fails to converge within the allowed iterations\n- Test involves a function with a sharp turn near a singularity (x = -1)\n\n## Root Cause Analysis\n\nThe test is designed to solve the function `f(x) = (2x + 1) / (1.0e9 * (x + 1))` which has:\n- A root at x = -0.5\n- A singularity at x = -1 (denominator becomes zero)\n- The search interval is [-0.9999999, 30], very close to the singularity\n\n## Possible Defect in Production Code\n\nBased on the analysis, I recommend investigating the following potential defects in `BracketingNthOrderBrentSolver`:\n\n1. **Insufficient handling of functions with sharp turns near singularities**: The algorithm may be getting stuck oscillating or making poor progress when dealing with the extreme gradient changes near x = -1.\n\n2. **Inefficient bracketing behavior**: The solver might be failing to properly narrow the bracket around the actual root (-0.5) when the function exhibits rapid changes, causing it to exceed the maximum evaluation limit.\n\n3. **Poor initial guess utilization**: With the initial guess of 15 (far from the actual root at -0.5), the algorithm may be struggling to efficiently navigate toward the correct region.\n\n4. **Numerical precision issues with extreme tolerances**: The function value accuracy of 1.0e-22 is extremely strict and may be causing convergence problems when combined with the function's sharp behavior.\n\nThe defect likely resides in the `doSolve()` method (line 265) where the core root-finding algorithm is implemented, specifically in how it handles functions with steep gradients near singular boundaries while maintaining the bracketing property required by Brent's method with higher-order interpolation.",
            "test_suite": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest",
            "score": 9,
            "reason": "#9# The doSolve() method is highly suspicious as it contains the core root-finding algorithm that fails to converge for functions with sharp turns near singularities. The test failure occurs when the solver exceeds maximum evaluations while trying to solve a function with extreme gradient changes near x=-1. The method's handling of bracketing, interpolation, and convergence criteria appears problematic when dealing with such pathological functions, particularly in how it manages the search interval and polynomial interpolation near boundaries."
        },
        {
            "method_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::guessX(double,double[],double[],int,int)",
            "method_code": "```java\n    private double guessX(final double targetY, final double[] x, final double[] y,\n                          final int start, final int end) {\n\n        // compute Q Newton coefficients by divided differences\n        for (int i = start; i < end - 1; ++i) {\n            final int delta = i + 1 - start;\n            for (int j = end - 1; j > i; --j) {\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n            }\n        }\n\n        // evaluate Q(targetY)\n        double x0 = 0;\n        for (int j = end - 1; j >= start; --j) {\n            x0 = x[j] + x0 * (targetY - y[j]);\n        }\n\n        return x0;\n\n    }\n\n```",
            "method_doc": "Guess an x value by n<sup>th</sup> order inverse polynomial interpolation. <p> The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>), Q(y<sub>i</sub>) = x<sub>i</sub>. </p> @param targetY target value for y @param x reference points abscissas for interpolation, note that this array <em>is</em> modified during computation @param y reference points ordinates for interpolation @param start start index of the points to consider (inclusive) @param end end index of the points to consider (exclusive) @return guessed root (will be a NaN if two points share the same y) ",
            "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
            "class_doc": " This class implements a modification of the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\"> Brent algorithm</a>. <p> The changes with respect to the original Brent algorithm are: <ul> <li>the returned value is chosen in the current interval according to user specified {@link AllowedSolution},</li> <li>the maximal order for the invert polynomial root search is user-specified instead of being invert quadratic only</li> </ul> </p> The given interval must bracket the root.  @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n## Analysis of Test Failure\n\n**Common Pattern Identified:**\n- Single test failure: `testIssue716`\n- Failure type: `TooManyEvaluationsException` - maximum evaluation count (100) exceeded\n- The solver fails to converge within the allowed iterations\n- Test involves a function with a sharp turn near a singularity (x = -1)\n\n## Root Cause Analysis\n\nThe test is designed to solve the function `f(x) = (2x + 1) / (1.0e9 * (x + 1))` which has:\n- A root at x = -0.5\n- A singularity at x = -1 (denominator becomes zero)\n- The search interval is [-0.9999999, 30], very close to the singularity\n\n## Possible Defect in Production Code\n\nBased on the analysis, I recommend investigating the following potential defects in `BracketingNthOrderBrentSolver`:\n\n1. **Insufficient handling of functions with sharp turns near singularities**: The algorithm may be getting stuck oscillating or making poor progress when dealing with the extreme gradient changes near x = -1.\n\n2. **Inefficient bracketing behavior**: The solver might be failing to properly narrow the bracket around the actual root (-0.5) when the function exhibits rapid changes, causing it to exceed the maximum evaluation limit.\n\n3. **Poor initial guess utilization**: With the initial guess of 15 (far from the actual root at -0.5), the algorithm may be struggling to efficiently navigate toward the correct region.\n\n4. **Numerical precision issues with extreme tolerances**: The function value accuracy of 1.0e-22 is extremely strict and may be causing convergence problems when combined with the function's sharp behavior.\n\nThe defect likely resides in the `doSolve()` method (line 265) where the core root-finding algorithm is implemented, specifically in how it handles functions with steep gradients near singular boundaries while maintaining the bracketing property required by Brent's method with higher-order interpolation.",
            "test_suite": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest",
            "score": 8,
            "reason": "#8# The guessX method is highly suspicious because it performs polynomial interpolation for root guessing, which can be numerically unstable when dealing with functions that have sharp turns or near-singularities. The test involves a function with a sharp turn near x=-1, and the interpolation in guessX may produce poor estimates when y-values are very close together or when there are extreme gradients, causing the solver to exceed evaluation limits. The method modifies the x array in-place during computation, which could lead to accumulated numerical errors in iterative calls."
        },
        {
            "method_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::solve(int,UnivariateFunction,double,double,double,AllowedSolution)",
            "method_code": "```java\n    public double solve(int maxEval, UnivariateFunction f, double min,\n                        double max, double startValue,\n                        AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n\n```",
            "method_doc": "{@inheritDoc} */",
            "class_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver",
            "class_doc": " This class implements a modification of the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\"> Brent algorithm</a>. <p> The changes with respect to the original Brent algorithm are: <ul> <li>the returned value is chosen in the current interval according to user specified {@link AllowedSolution},</li> <li>the maximal order for the invert polynomial root search is user-specified instead of being invert quadratic only</li> </ul> </p> The given interval must bracket the root.  @version $Id$ ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze this failure systematically:\n\n## Analysis of Test Failure\n\n**Common Pattern Identified:**\n- Single test failure: `testIssue716`\n- Failure type: `TooManyEvaluationsException` - maximum evaluation count (100) exceeded\n- The solver fails to converge within the allowed iterations\n- Test involves a function with a sharp turn near a singularity (x = -1)\n\n## Root Cause Analysis\n\nThe test is designed to solve the function `f(x) = (2x + 1) / (1.0e9 * (x + 1))` which has:\n- A root at x = -0.5\n- A singularity at x = -1 (denominator becomes zero)\n- The search interval is [-0.9999999, 30], very close to the singularity\n\n## Possible Defect in Production Code\n\nBased on the analysis, I recommend investigating the following potential defects in `BracketingNthOrderBrentSolver`:\n\n1. **Insufficient handling of functions with sharp turns near singularities**: The algorithm may be getting stuck oscillating or making poor progress when dealing with the extreme gradient changes near x = -1.\n\n2. **Inefficient bracketing behavior**: The solver might be failing to properly narrow the bracket around the actual root (-0.5) when the function exhibits rapid changes, causing it to exceed the maximum evaluation limit.\n\n3. **Poor initial guess utilization**: With the initial guess of 15 (far from the actual root at -0.5), the algorithm may be struggling to efficiently navigate toward the correct region.\n\n4. **Numerical precision issues with extreme tolerances**: The function value accuracy of 1.0e-22 is extremely strict and may be causing convergence problems when combined with the function's sharp behavior.\n\nThe defect likely resides in the `doSolve()` method (line 265) where the core root-finding algorithm is implemented, specifically in how it handles functions with steep gradients near singular boundaries while maintaining the bracketing property required by Brent's method with higher-order interpolation.",
            "test_suite": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest",
            "score": 3,
            "reason": "#3# This method is simply a wrapper that delegates to the parent class solve method and sets the allowed solution parameter. The actual root-finding algorithm logic is implemented in the doSolve() method of the parent class, which is where the convergence issues and excessive evaluations are occurring. The failure is in the core numerical algorithm, not in this parameter-passing wrapper method."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::guessX(double,double[],double[],int,int)": {
            "method_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::guessX(double,double[],double[],int,int)",
            "method_code": "```java\n    private double guessX(final double targetY, final double[] x, final double[] y,\n                          final int start, final int end) {\n\n        // compute Q Newton coefficients by divided differences\n        for (int i = start; i < end - 1; ++i) {\n            final int delta = i + 1 - start;\n            for (int j = end - 1; j > i; --j) {\n                x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n            }\n        }\n\n        // evaluate Q(targetY)\n        double x0 = 0;\n        for (int j = end - 1; j >= start; --j) {\n            x0 = x[j] + x0 * (targetY - y[j]);\n        }\n\n        return x0;\n\n    }\n\n```",
            "method_doc": "Guess an x value by n<sup>th</sup> order inverse polynomial interpolation. <p> The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q is built such that for all considered points (x<sub>i</sub>, y<sub>i</sub>), Q(y<sub>i</sub>) = x<sub>i</sub>. </p> @param targetY target value for y @param x reference points abscissas for interpolation, note that this array <em>is</em> modified during computation @param y reference points ordinates for interpolation @param start start index of the points to consider (inclusive) @param end end index of the points to consider (exclusive) @return guessed root (will be a NaN if two points share the same y) "
        },
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::solve(int,UnivariateFunction,double,double,double,AllowedSolution)": {
            "method_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::solve(int,UnivariateFunction,double,double,double,AllowedSolution)",
            "method_code": "```java\n    public double solve(int maxEval, UnivariateFunction f, double min,\n                        double max, double startValue,\n                        AllowedSolution allowedSolution) {\n        this.allowed = allowedSolution;\n        return super.solve(maxEval, f, min, max, startValue);\n    }\n\n```",
            "method_doc": "{@inheritDoc} */"
        },
        "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::doSolve()": {
            "method_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver::doSolve()",
            "method_code": "```java\n    @Override\n    protected double doSolve() {\n\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // prepare arrays with the first points\n        final double[] TransVarX1 = new double[maximalOrder + 1];\n        final double[] TransVarY1 = new double[maximalOrder + 1];\n        TransVarX1[0] = getMin();\n        TransVarX1[1] = getStartValue();\n        TransVarX1[2] = getMax();\n        verifySequence(TransVarX1[0], TransVarX1[1], TransVarX1[2]);\n\n        // evaluate initial guess\n        TransVarY1[1] = computeObjectiveValue(TransVarX1[1]);\n        if (!(!(Precision.equals(TransVarY1[1], 0.0, 1)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // return the initial guess if it is a perfect root.\n            return TransVarX1[1];\n        }\n\n        // evaluate first  endpoint\n        TransVarY1[0] = computeObjectiveValue(TransVarX1[0]);\n        if (!(!(Precision.equals(TransVarY1[0], 0.0, 1)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // return the first endpoint if it is a perfect root.\n            return TransVarX1[0];\n        }\n\n        int TransVarNbElements;\n        int TransVarSignChange;\n        if (!(!(TransVarY1[0] * TransVarY1[1] < 0))) {\n\n            // reduce interval if it brackets the root\n            TransVarNbElements        = 2;\n            TransVarSignChange = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            TransVarY1[2] = computeObjectiveValue(TransVarX1[2]);\n            if (!(!(Precision.equals(TransVarY1[2], 0.0, 1)))) {\n                // return the second endpoint if it is a perfect root.\n                return TransVarX1[2];\n            }\n\n            if (!(!(TransVarY1[1] * TransVarY1[2] < 0))) {\n                // use all computed point as a start sampling array for solving\n                TransVarNbElements        = 3;\n                TransVarSignChange = 2;\n            } else {\n                throw new NoBracketingException(TransVarX1[0], TransVarX1[2], TransVarY1[0], TransVarY1[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] TransVarTmpX_ = new double[TransVarX1.length];\n\n        // current tightest bracketing of the root\n        double TransVarX3    = TransVarX1[TransVarSignChange - 1];\n        double TransVarY2    = TransVarY1[TransVarSignChange - 1];\n        double TransVarAbsY = FastMath.abs(TransVarY2);\n        int TransVarAgingB   = 0;\n        double TransVarTmpX    = TransVarX1[TransVarSignChange];\n        double TransVarYB1    = TransVarY1[TransVarSignChange];\n        double TransVarAbsY1 = FastMath.abs(TransVarYB1);\n        int TransVarAgingA   = 0;\n\n        for (; !(!(true));) {\n            final double TransVarXTol_ = getAbsoluteAccuracy()\n                    + getRelativeAccuracy() * FastMath.max(FastMath.abs(TransVarX3), FastMath.abs(TransVarTmpX));\n            if (!(!(((TransVarTmpX - TransVarX3) <= TransVarXTol_)\n                    || (FastMath.max(TransVarAbsY, TransVarAbsY1) < getFunctionValueAccuracy())))) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return TransVarAbsY < TransVarAbsY1 ? TransVarX3 : TransVarTmpX;\n                case LEFT_SIDE:\n                    return TransVarX3;\n                case RIGHT_SIDE:\n                    return TransVarTmpX;\n                case BELOW_SIDE:\n                    return (TransVarY2 <= 0) ? TransVarX3 : TransVarTmpX;\n                case ABOVE_SIDE:\n                    return (TransVarY2 < 0) ? TransVarTmpX : TransVarX3;\n                default:\n                    throw new MathInternalError(null);\n                }\n            }\n            double TransVarY;\n            if (!(!(TransVarAgingB >= MAXIMAL_AGING))) {\n                TransVarY = -REDUCTION_FACTOR * TransVarYB1;\n            } else if (!(!(TransVarAgingA >= MAXIMAL_AGING))) {\n                TransVarY = -REDUCTION_FACTOR * TransVarY2;\n            } else {\n                TransVarY = 0;\n            }\n            double TransVarX;\n            int TransVarStartIndex = 0;\n            int TransVarEndPoint = TransVarNbElements;\n            do {\n                System.arraycopy(TransVarX1, TransVarStartIndex, TransVarTmpX_, TransVarStartIndex,\n                        TransVarEndPoint - TransVarStartIndex);\n                TransVarX = guessX(TransVarY, TransVarTmpX_, TransVarY1, TransVarStartIndex, TransVarEndPoint);\n                if (!(!(!((TransVarX > TransVarX3) && (TransVarX < TransVarTmpX))))) {\n                    if (!(!(TransVarSignChange - TransVarStartIndex >= TransVarEndPoint - TransVarSignChange))) {\n                        ++TransVarStartIndex;\n                    } else {\n                        --TransVarEndPoint;\n                    }\n                    TransVarX = Double.NaN;\n                }\n            } while (!(!(Double.isNaN(TransVarX) && (TransVarEndPoint - TransVarStartIndex > 1))));\n            if (!(!(Double.isNaN(TransVarX)))) {\n                TransVarX = TransVarX3 + 0.5 * (TransVarTmpX - TransVarX3);\n                TransVarStartIndex = TransVarSignChange - 1;\n                TransVarEndPoint = TransVarSignChange;\n            }\n            final double TransVarNextY1 = computeObjectiveValue(TransVarX);\n            if (!(!(Precision.equals(TransVarNextY1, 0.0, 1)))) {\n                return TransVarX;\n            }\n            if (!(!((TransVarNbElements > 2) && (TransVarEndPoint - TransVarStartIndex != TransVarNbElements)))) {\n                TransVarNbElements = TransVarEndPoint - TransVarStartIndex;\n                System.arraycopy(TransVarX1, TransVarStartIndex, TransVarX1, 0, TransVarNbElements);\n                System.arraycopy(TransVarY1, TransVarStartIndex, TransVarY1, 0, TransVarNbElements);\n                TransVarSignChange -= TransVarStartIndex;\n            } else if (!(!(TransVarNbElements == TransVarX1.length))) {\n                TransVarNbElements--;\n                if (!(!(TransVarSignChange >= (TransVarX1.length + 1) / 2))) {\n                    System.arraycopy(TransVarX1, 1, TransVarX1, 0, TransVarNbElements);\n                    System.arraycopy(TransVarY1, 1, TransVarY1, 0, TransVarNbElements);\n                    --TransVarSignChange;\n                }\n            }\n            System.arraycopy(TransVarX1, TransVarSignChange, TransVarX1, TransVarSignChange + 1,\n                    TransVarNbElements - TransVarSignChange);\n            TransVarX1[TransVarSignChange] = TransVarX;\n            System.arraycopy(TransVarY1, TransVarSignChange, TransVarY1, TransVarSignChange + 1,\n                    TransVarNbElements - TransVarSignChange);\n            TransVarY1[TransVarSignChange] = TransVarNextY1;\n            ++TransVarNbElements;\n            if (!(!(TransVarNextY1 * TransVarY2 <= 0))) {\n                TransVarTmpX = TransVarX;\n                TransVarYB1 = TransVarNextY1;\n                TransVarAbsY1 = FastMath.abs(TransVarYB1);\n                ++TransVarAgingB;\n                TransVarAgingA = 0;\n            } else {\n                TransVarX3 = TransVarX;\n                TransVarY2 = TransVarNextY1;\n                TransVarAbsY = FastMath.abs(TransVarY2);\n                TransVarAgingB = 0;\n                ++TransVarAgingA;\n                TransVarSignChange++;\n            }\n        }\n\n    }\n\n```",
            "method_doc": " {@inheritDoc} "
        }
    }
}