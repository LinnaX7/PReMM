{
    "buggy_classes": [
        "org.joda.time.Period"
    ],
    "buggy_methods": [
        {
            "method_name": "org.joda.time.Period::normalizedStandard(PeriodType)",
            "method_code": "```java\n    public Period normalizedStandard(PeriodType TransVarTypePeriod) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n            }\n        TransVarTypePeriod = DateTimeUtils.getPeriodType(TransVarTypePeriod);\n        long TransVarTime = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        TransVarTime += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        TransVarTime += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        TransVarTime += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        TransVarTime += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        TransVarTime += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period TransVarPeriod = new Period(TransVarTime, TransVarTypePeriod, ISOChronology.getInstanceUTC());\n        int TransVarYrs = getYears();\n        int TransVarMonth = getMonths();\n        if (!(!(TransVarYrs != 0 || TransVarMonth != 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarYrs = FieldUtils.safeAdd(TransVarYrs, TransVarMonth / 12);\n            TransVarMonth = TransVarMonth % 12;\n            if (!(!(TransVarYrs != 0))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n            }\n                TransVarPeriod = TransVarPeriod.withYears(TransVarYrs);\n        }\n            if (!(!(TransVarMonth != 0))) {\n                TransVarPeriod = TransVarPeriod.withMonths(TransVarMonth);\n            }\n        }\n        return TransVarPeriod;\n    }\n\n```",
            "method_doc": " Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute, providing control over how the result is split into fields. <p> This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules. <p> If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days. <p> The PeriodType parameter controls how the result is created. It allows you to omit certain fields from the result if desired. For example, you may not want the result to include weeks, in which case you pass in <code>PeriodType.yearMonthDayTime()</code>.  @param type  the period type of the new period, null means standard type @return a normalized period equivalent to this period @throws ArithmeticException if any field is too large to be represented @throws UnsupportedOperationException if this period contains non-zero years or months but the specified period type does not support them @since 1.5 ",
            "class_name": "org.joda.time.Period",
            "class_doc": " An immutable time period specifying a set of duration field values. <p> A time period is divided into a number of fields, such as hours and seconds. Which fields are supported is defined by the PeriodType class. The default is the standard period type, which supports years, months, weeks, days, hours, minutes, seconds and millis. <p> When this time period is added to an instant, the effect is of adding each field in turn. As a result, this takes into account daylight savings time. Adding a time period of 1 day to the day before daylight savings starts will only add 23 hours rather than 24 to ensure that the time remains the same. If this is not the behaviour you want, then see {@link Duration}. <p> The definition of a period also affects the equals method. A period of 1 day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes. This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary). To compare the actual duration of two periods, convert both to durations using toDuration, an operation that emphasises that the result may differ according to the date you choose. <p> Period is thread-safe and immutable, provided that the PeriodType is as well. All standard PeriodType classes supplied are thread-safe and immutable.  @since 1.0 @see MutablePeriod ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across all failed tests:**\n- All tests call `normalizedStandard()` method with a restricted `PeriodType`\n- All stack traces show the same error: `UnsupportedOperationException: Field is not supported`\n- The error originates from `PeriodType.setIndexedField()` at line 690\n- The call chain shows `Period.withYears()` is being called from `Period.normalizedStandard()` at line 1640\n- All tests use `PeriodType` that excludes years field (months-only or custom types without years)\n\n**Key observation:** The tests are trying to normalize periods by converting years to months, but the `PeriodType` being used doesn't support the years field.\n\n## Step 2: Analyze the Root Cause\n\nThe issue occurs in the `normalizedStandard()` method implementation. Looking at the stack trace pattern:\n\n1. `normalizedStandard()` is called with a `PeriodType` that doesn't include years\n2. Inside `normalizedStandard()`, the code attempts to call `withYears(0)` \n3. `withYears()` internally calls `setIndexedField()` on the `PeriodType`\n4. Since the `PeriodType` doesn't support years field, `setIndexedField()` throws `UnsupportedOperationException`\n\n## Step 3: Recommended Defect in Production Code\n\n**Defect Location:** `org.joda.time.Period.normalizedStandard()` method at line 1640\n\n**Problem:** The `normalizedStandard()` method is incorrectly attempting to set fields (specifically years) to zero on the result period, even when the provided `PeriodType` doesn't support those fields.\n\n**Expected Behavior:** When normalizing with a restricted `PeriodType`, the method should only manipulate and zero out fields that are actually supported by the given period type.\n\n**Root Cause:** The normalization logic doesn't properly check field support in the target `PeriodType` before attempting field operations. The method should skip operations on unsupported fields rather than trying to set them to zero.\n\nThe defect is in the production code's handling of field normalization when working with restricted period types that don't include all standard chronological fields.",
            "test_suite": "org.joda.time.TestPeriod_Basics",
            "score": 10,
            "reason": "#10# This method is definitely the best location to be fixed because the stack traces clearly show the UnsupportedOperationException originates from line 1640 in normalizedStandard() when it calls withYears() on a PeriodType that doesn't support the years field. The method attempts to set years to zero even when the provided PeriodType restricts which fields are supported, causing the \"Field is not supported\" exception. The normalization logic should check if fields are supported by the PeriodType before attempting to modify them."
        },
        {
            "method_name": "org.joda.time.Period::withYears(int)",
            "method_code": "```java\n    public Period withYears(int years) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }\n\n```",
            "method_doc": " Returns a new period with the specified number of years. <p> This period instance is immutable and unaffected by this method call.  @param years  the amount of years to add, may be negative @return the new period with the increased years @throws UnsupportedOperationException if the field is not supported ",
            "class_name": "org.joda.time.Period",
            "class_doc": " An immutable time period specifying a set of duration field values. <p> A time period is divided into a number of fields, such as hours and seconds. Which fields are supported is defined by the PeriodType class. The default is the standard period type, which supports years, months, weeks, days, hours, minutes, seconds and millis. <p> When this time period is added to an instant, the effect is of adding each field in turn. As a result, this takes into account daylight savings time. Adding a time period of 1 day to the day before daylight savings starts will only add 23 hours rather than 24 to ensure that the time remains the same. If this is not the behaviour you want, then see {@link Duration}. <p> The definition of a period also affects the equals method. A period of 1 day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes. This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary). To compare the actual duration of two periods, convert both to durations using toDuration, an operation that emphasises that the result may differ according to the date you choose. <p> Period is thread-safe and immutable, provided that the PeriodType is as well. All standard PeriodType classes supplied are thread-safe and immutable.  @since 1.0 @see MutablePeriod ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across all failed tests:**\n- All tests call `normalizedStandard()` method with a restricted `PeriodType`\n- All stack traces show the same error: `UnsupportedOperationException: Field is not supported`\n- The error originates from `PeriodType.setIndexedField()` at line 690\n- The call chain shows `Period.withYears()` is being called from `Period.normalizedStandard()` at line 1640\n- All tests use `PeriodType` that excludes years field (months-only or custom types without years)\n\n**Key observation:** The tests are trying to normalize periods by converting years to months, but the `PeriodType` being used doesn't support the years field.\n\n## Step 2: Analyze the Root Cause\n\nThe issue occurs in the `normalizedStandard()` method implementation. Looking at the stack trace pattern:\n\n1. `normalizedStandard()` is called with a `PeriodType` that doesn't include years\n2. Inside `normalizedStandard()`, the code attempts to call `withYears(0)` \n3. `withYears()` internally calls `setIndexedField()` on the `PeriodType`\n4. Since the `PeriodType` doesn't support years field, `setIndexedField()` throws `UnsupportedOperationException`\n\n## Step 3: Recommended Defect in Production Code\n\n**Defect Location:** `org.joda.time.Period.normalizedStandard()` method at line 1640\n\n**Problem:** The `normalizedStandard()` method is incorrectly attempting to set fields (specifically years) to zero on the result period, even when the provided `PeriodType` doesn't support those fields.\n\n**Expected Behavior:** When normalizing with a restricted `PeriodType`, the method should only manipulate and zero out fields that are actually supported by the given period type.\n\n**Root Cause:** The normalization logic doesn't properly check field support in the target `PeriodType` before attempting field operations. The method should skip operations on unsupported fields rather than trying to set them to zero.\n\nThe defect is in the production code's handling of field normalization when working with restricted period types that don't include all standard chronological fields.",
            "test_suite": "org.joda.time.TestPeriod_Basics",
            "score": 3,
            "reason": "#3# The withYears method itself is correctly implemented and follows the expected pattern for period field modification. The actual issue is in the normalizedStandard method which incorrectly calls withYears(0) when the PeriodType doesn't support years field. The UnsupportedOperationException is thrown from PeriodType.setIndexedField, which is the correct behavior when trying to set an unsupported field. The fix should be made in normalizedStandard to check field support before calling withYears."
        },
        {
            "method_name": "org.joda.time.Period::getMonths()",
            "method_code": "```java\n    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n\n```",
            "method_doc": " Gets the months field part of the period.  @return the number of months in the period, zero if unsupported ",
            "class_name": "org.joda.time.Period",
            "class_doc": " An immutable time period specifying a set of duration field values. <p> A time period is divided into a number of fields, such as hours and seconds. Which fields are supported is defined by the PeriodType class. The default is the standard period type, which supports years, months, weeks, days, hours, minutes, seconds and millis. <p> When this time period is added to an instant, the effect is of adding each field in turn. As a result, this takes into account daylight savings time. Adding a time period of 1 day to the day before daylight savings starts will only add 23 hours rather than 24 to ensure that the time remains the same. If this is not the behaviour you want, then see {@link Duration}. <p> The definition of a period also affects the equals method. A period of 1 day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes. This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary). To compare the actual duration of two periods, convert both to durations using toDuration, an operation that emphasises that the result may differ according to the date you choose. <p> Period is thread-safe and immutable, provided that the PeriodType is as well. All standard PeriodType classes supplied are thread-safe and immutable.  @since 1.0 @see MutablePeriod ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across all failed tests:**\n- All tests call `normalizedStandard()` method with a restricted `PeriodType`\n- All stack traces show the same error: `UnsupportedOperationException: Field is not supported`\n- The error originates from `PeriodType.setIndexedField()` at line 690\n- The call chain shows `Period.withYears()` is being called from `Period.normalizedStandard()` at line 1640\n- All tests use `PeriodType` that excludes years field (months-only or custom types without years)\n\n**Key observation:** The tests are trying to normalize periods by converting years to months, but the `PeriodType` being used doesn't support the years field.\n\n## Step 2: Analyze the Root Cause\n\nThe issue occurs in the `normalizedStandard()` method implementation. Looking at the stack trace pattern:\n\n1. `normalizedStandard()` is called with a `PeriodType` that doesn't include years\n2. Inside `normalizedStandard()`, the code attempts to call `withYears(0)` \n3. `withYears()` internally calls `setIndexedField()` on the `PeriodType`\n4. Since the `PeriodType` doesn't support years field, `setIndexedField()` throws `UnsupportedOperationException`\n\n## Step 3: Recommended Defect in Production Code\n\n**Defect Location:** `org.joda.time.Period.normalizedStandard()` method at line 1640\n\n**Problem:** The `normalizedStandard()` method is incorrectly attempting to set fields (specifically years) to zero on the result period, even when the provided `PeriodType` doesn't support those fields.\n\n**Expected Behavior:** When normalizing with a restricted `PeriodType`, the method should only manipulate and zero out fields that are actually supported by the given period type.\n\n**Root Cause:** The normalization logic doesn't properly check field support in the target `PeriodType` before attempting field operations. The method should skip operations on unsupported fields rather than trying to set them to zero.\n\nThe defect is in the production code's handling of field normalization when working with restricted period types that don't include all standard chronological fields.",
            "test_suite": "org.joda.time.TestPeriod_Basics",
            "score": 2,
            "reason": "#2# The getMonths() method is not the best location to fix because the stack traces clearly show the error occurs in normalizedStandard() method when calling withYears(), not in getMonths(). The issue is that normalizedStandard() is trying to set years field to zero even when the PeriodType doesn't support years, which causes the UnsupportedOperationException. The getMonths() method simply retrieves the months value and doesn't modify any state or interact with unsupported fields."
        },
        {
            "method_name": "org.joda.time.Period::getYears()",
            "method_code": "```java\n    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n\n```",
            "method_doc": " Gets the years field part of the period.  @return the number of years in the period, zero if unsupported ",
            "class_name": "org.joda.time.Period",
            "class_doc": " An immutable time period specifying a set of duration field values. <p> A time period is divided into a number of fields, such as hours and seconds. Which fields are supported is defined by the PeriodType class. The default is the standard period type, which supports years, months, weeks, days, hours, minutes, seconds and millis. <p> When this time period is added to an instant, the effect is of adding each field in turn. As a result, this takes into account daylight savings time. Adding a time period of 1 day to the day before daylight savings starts will only add 23 hours rather than 24 to ensure that the time remains the same. If this is not the behaviour you want, then see {@link Duration}. <p> The definition of a period also affects the equals method. A period of 1 day is not equal to a period of 24 hours, nor 1 hour equal to 60 minutes. This is because periods represent an abstracted definition of a time period (eg. a day may not actually be 24 hours, it might be 23 or 25 at daylight savings boundary). To compare the actual duration of two periods, convert both to durations using toDuration, an operation that emphasises that the result may differ according to the date you choose. <p> Period is thread-safe and immutable, provided that the PeriodType is as well. All standard PeriodType classes supplied are thread-safe and immutable.  @since 1.0 @see MutablePeriod ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here's my step-by-step reasoning:\n\n## Step 1: Identify Common Patterns\n\n**Similarities across all failed tests:**\n- All tests call `normalizedStandard()` method with a restricted `PeriodType`\n- All stack traces show the same error: `UnsupportedOperationException: Field is not supported`\n- The error originates from `PeriodType.setIndexedField()` at line 690\n- The call chain shows `Period.withYears()` is being called from `Period.normalizedStandard()` at line 1640\n- All tests use `PeriodType` that excludes years field (months-only or custom types without years)\n\n**Key observation:** The tests are trying to normalize periods by converting years to months, but the `PeriodType` being used doesn't support the years field.\n\n## Step 2: Analyze the Root Cause\n\nThe issue occurs in the `normalizedStandard()` method implementation. Looking at the stack trace pattern:\n\n1. `normalizedStandard()` is called with a `PeriodType` that doesn't include years\n2. Inside `normalizedStandard()`, the code attempts to call `withYears(0)` \n3. `withYears()` internally calls `setIndexedField()` on the `PeriodType`\n4. Since the `PeriodType` doesn't support years field, `setIndexedField()` throws `UnsupportedOperationException`\n\n## Step 3: Recommended Defect in Production Code\n\n**Defect Location:** `org.joda.time.Period.normalizedStandard()` method at line 1640\n\n**Problem:** The `normalizedStandard()` method is incorrectly attempting to set fields (specifically years) to zero on the result period, even when the provided `PeriodType` doesn't support those fields.\n\n**Expected Behavior:** When normalizing with a restricted `PeriodType`, the method should only manipulate and zero out fields that are actually supported by the given period type.\n\n**Root Cause:** The normalization logic doesn't properly check field support in the target `PeriodType` before attempting field operations. The method should skip operations on unsupported fields rather than trying to set them to zero.\n\nThe defect is in the production code's handling of field normalization when working with restricted period types that don't include all standard chronological fields.",
            "test_suite": "org.joda.time.TestPeriod_Basics",
            "score": 2,
            "reason": "#2# The getYears() method is not the root cause of the test failures. The stack traces clearly show the issue occurs in normalizedStandard() method when it calls withYears(), which then fails because the PeriodType doesn't support the years field. The getYears() method simply retrieves the years value and doesn't modify any state or interact with PeriodType validation. The actual bug is in the normalization logic that attempts to manipulate unsupported fields."
        }
    ],
    "buggy_codes": {
        "org.joda.time.Period::getMonths()": {
            "method_name": "org.joda.time.Period::getMonths()",
            "method_code": "```java\n    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }\n\n```",
            "method_doc": " Gets the months field part of the period.  @return the number of months in the period, zero if unsupported "
        },
        "org.joda.time.Period::getYears()": {
            "method_name": "org.joda.time.Period::getYears()",
            "method_code": "```java\n    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }\n\n```",
            "method_doc": " Gets the years field part of the period.  @return the number of years in the period, zero if unsupported "
        },
        "org.joda.time.Period::normalizedStandard(PeriodType)": {
            "method_name": "org.joda.time.Period::normalizedStandard(PeriodType)",
            "method_code": "```java\n    public Period normalizedStandard(PeriodType TransVarTypePeriod) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n            }\n        TransVarTypePeriod = DateTimeUtils.getPeriodType(TransVarTypePeriod);\n        long TransVarTime = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        TransVarTime += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        TransVarTime += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        TransVarTime += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        TransVarTime += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        TransVarTime += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period TransVarPeriod = new Period(TransVarTime, TransVarTypePeriod, ISOChronology.getInstanceUTC());\n        int TransVarYrs = getYears();\n        int TransVarMonth = getMonths();\n        if (!(!(TransVarYrs != 0 || TransVarMonth != 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarYrs = FieldUtils.safeAdd(TransVarYrs, TransVarMonth / 12);\n            TransVarMonth = TransVarMonth % 12;\n            if (!(!(TransVarYrs != 0))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n            }\n                TransVarPeriod = TransVarPeriod.withYears(TransVarYrs);\n        }\n            if (!(!(TransVarMonth != 0))) {\n                TransVarPeriod = TransVarPeriod.withMonths(TransVarMonth);\n            }\n        }\n        return TransVarPeriod;\n    }\n\n```",
            "method_doc": " Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute, providing control over how the result is split into fields. <p> This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules. <p> If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days. <p> The PeriodType parameter controls how the result is created. It allows you to omit certain fields from the result if desired. For example, you may not want the result to include weeks, in which case you pass in <code>PeriodType.yearMonthDayTime()</code>.  @param type  the period type of the new period, null means standard type @return a normalized period equivalent to this period @throws ArithmeticException if any field is too large to be represented @throws UnsupportedOperationException if this period contains non-zero years or months but the specified period type does not support them @since 1.5 "
        },
        "org.joda.time.Period::withYears(int)": {
            "method_name": "org.joda.time.Period::withYears(int)",
            "method_code": "```java\n    public Period withYears(int years) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }\n\n```",
            "method_doc": " Returns a new period with the specified number of years. <p> This period instance is immutable and unaffected by this method call.  @param years  the amount of years to add, may be negative @return the new period with the increased years @throws UnsupportedOperationException if the field is not supported "
        }
    }
}