{
    "buggy_classes": [
        "org.apache.commons.math3.optimization.linear.SimplexSolver"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::getPivotColumn(SimplexTableau)",
            "method_code": "```java\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            // check if the entry is strictly smaller than the current minimum\n            // do not use a ulp/epsilon check\n            if (entry < minValue) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n```",
            "method_doc": " Returns the column with the most negative coefficient in the objective function row. @param tableau simple tableau for the problem @return column with the most negative coefficient ",
            "class_name": "org.apache.commons.math3.optimization.linear.SimplexSolver",
            "class_doc": " Solves a linear problem using the Two-Phase Simplex Method. @version $Id$ @since 2.0 ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze this test failure systematically to identify the root cause in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- Single test failure: `testMath828Cycle`\n- Failure mode: `MaxCountExceededException` with \"maximal count (100) exceeded\"\n- The test specifically targets cycling behavior in the simplex algorithm (referencing MATH-828)\n- The algorithm gets stuck in an infinite loop during optimization\n\n## Root Cause Analysis\n\n**Key Observations:**\n1. **Cycling Detection**: The test name explicitly indicates it's testing for \"cycle\" behavior\n2. **Degenerate Problem**: The linear programming problem appears to be degenerate (multiple solutions or redundant constraints)\n3. **Algorithm Stagnation**: The simplex algorithm fails to make progress and exceeds the iteration limit\n\n## Recommended Defect in Production Code\n\n**Primary Defect**: **Insufficient cycling prevention mechanism in SimplexSolver**\n\nThe production code in `SimplexSolver.doIteration()` (line 162) lacks proper anti-cycling measures for degenerate linear programming problems. Specifically:\n\n1. **Missing Bland's Rule Implementation**: The simplex algorithm should implement Bland's rule (smallest subscript rule) to prevent cycling when degenerate pivots occur.\n\n2. **Inadequate Pivot Selection**: The pivot selection logic doesn't properly handle cases where multiple entering/leaving variables could be chosen, leading to repeated basis cycles.\n\n3. **No Degeneracy Detection**: The algorithm fails to detect when it's entering a degenerate cycle and apply corrective measures.\n\n**Expected Fix Location**: \n- `SimplexSolver.doIteration()` method\n- Pivot selection logic in the tableau processing\n- Additional cycling detection and prevention mechanisms\n\n**Impact**: This defect causes the simplex algorithm to enter infinite loops on degenerate problems, making it unreliable for certain classes of linear programming problems that commonly occur in real-world optimization scenarios.\n\nThe fix should implement established anti-cycling techniques from linear programming literature to ensure the algorithm terminates correctly even with degenerate problems.",
            "test_suite": "org.apache.commons.math3.optimization.linear.SimplexSolverTest",
            "score": 9,
            "reason": "#9# The getPivotColumn method is highly suspicious because it implements the standard pivot selection rule that can lead to cycling in degenerate linear programming problems. The method selects the column with the most negative coefficient without any anti-cycling mechanism like Bland's rule, which explains why the simplex algorithm gets stuck in an infinite loop in the testMath828Cycle test case. Implementing proper cycling prevention in this pivot selection logic would resolve the MaxCountExceededException."
        },
        {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::doIteration(SimplexTableau)",
            "method_code": "```java\n    protected void doIteration(final SimplexTableau tableau)\n        throws MaxCountExceededException, UnboundedSolutionException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(tableau, pivotCol);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        // set the pivot element to 1\n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        // set the rest of the pivot column to 0\n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                final double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n```",
            "method_doc": " Runs one iteration of the Simplex method on the given model. @param tableau simple tableau for the problem @throws MaxCountExceededException if the maximal iteration count has been exceeded @throws UnboundedSolutionException if the model is found not to have a bounded solution ",
            "class_name": "org.apache.commons.math3.optimization.linear.SimplexSolver",
            "class_doc": " Solves a linear problem using the Two-Phase Simplex Method. @version $Id$ @since 2.0 ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze this test failure systematically to identify the root cause in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- Single test failure: `testMath828Cycle`\n- Failure mode: `MaxCountExceededException` with \"maximal count (100) exceeded\"\n- The test specifically targets cycling behavior in the simplex algorithm (referencing MATH-828)\n- The algorithm gets stuck in an infinite loop during optimization\n\n## Root Cause Analysis\n\n**Key Observations:**\n1. **Cycling Detection**: The test name explicitly indicates it's testing for \"cycle\" behavior\n2. **Degenerate Problem**: The linear programming problem appears to be degenerate (multiple solutions or redundant constraints)\n3. **Algorithm Stagnation**: The simplex algorithm fails to make progress and exceeds the iteration limit\n\n## Recommended Defect in Production Code\n\n**Primary Defect**: **Insufficient cycling prevention mechanism in SimplexSolver**\n\nThe production code in `SimplexSolver.doIteration()` (line 162) lacks proper anti-cycling measures for degenerate linear programming problems. Specifically:\n\n1. **Missing Bland's Rule Implementation**: The simplex algorithm should implement Bland's rule (smallest subscript rule) to prevent cycling when degenerate pivots occur.\n\n2. **Inadequate Pivot Selection**: The pivot selection logic doesn't properly handle cases where multiple entering/leaving variables could be chosen, leading to repeated basis cycles.\n\n3. **No Degeneracy Detection**: The algorithm fails to detect when it's entering a degenerate cycle and apply corrective measures.\n\n**Expected Fix Location**: \n- `SimplexSolver.doIteration()` method\n- Pivot selection logic in the tableau processing\n- Additional cycling detection and prevention mechanisms\n\n**Impact**: This defect causes the simplex algorithm to enter infinite loops on degenerate problems, making it unreliable for certain classes of linear programming problems that commonly occur in real-world optimization scenarios.\n\nThe fix should implement established anti-cycling techniques from linear programming literature to ensure the algorithm terminates correctly even with degenerate problems.",
            "test_suite": "org.apache.commons.math3.optimization.linear.SimplexSolverTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious as the best location to fix because the test failure shows the simplex algorithm enters an infinite cycle, and the doIteration method contains the core pivot selection and tableau update logic where cycling prevention mechanisms should be implemented. The method lacks anti-cycling safeguards like Bland's rule for degenerate problems, which directly causes the MaxCountExceededException when the algorithm repeatedly cycles through the same bases without making progress."
        },
        {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::getPivotRow(SimplexTableau,int)",
            "method_code": "```java\n    private Integer getPivotRow(SimplexTableau TransVarTableau1, final int TransVarColName) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> TransVarMinRatioPositionsList = new ArrayList<Integer>();\n        double TransVarMinRatioPositions = Double.MAX_VALUE;\n        int TransVarColumnNumber = TransVarTableau1.getNumObjectiveFunctions();\n        while (!(!(TransVarColumnNumber < TransVarTableau1.getHeight()))){if (!(!(false))) {\n                System.out.println(\"log\");\n                }\n        final double TransVarEntryValue=TransVarTableau1.getEntry(TransVarColumnNumber,TransVarTableau1.getWidth() - 1);final double TransVarEntry2=TransVarTableau1.getEntry(TransVarColumnNumber,TransVarColName);if (!(!(Precision.compareTo(TransVarEntry2, 0d, maxUlps) > 0))){if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        final double TransVarRatio2=TransVarEntryValue / TransVarEntry2;final int TransVarC=Double.compare(TransVarRatio2,TransVarMinRatioPositions);if (!(!(TransVarC == 0))){TransVarMinRatioPositionsList.add(TransVarColumnNumber);} else if (!(!(TransVarC < 0))){TransVarMinRatioPositions=TransVarRatio2;TransVarMinRatioPositionsList=new ArrayList<Integer>();TransVarMinRatioPositionsList.add(TransVarColumnNumber);}}TransVarColumnNumber++;}\n\n        if (!(!(TransVarMinRatioPositionsList.size() == 0))) {\n            return null;\n        } else if (!(!(TransVarMinRatioPositionsList.size() > 1))) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer TransVarRowNum : TransVarMinRatioPositionsList) {\n                    int TransVarColNum = 0;\n                    while (!(!(TransVarColNum < TransVarTableau1.getNumArtificialVariables()))) {\n                        int TransVarColumnName = TransVarColNum + TransVarTableau1.getArtificialVariableOffset();\n                        final double TransVarEntry3 = TransVarTableau1.getEntry(TransVarRowNum, TransVarColumnName);\n                        if (!(!(Precision.equals(TransVarEntry3, 1d, maxUlps)\n                                && TransVarRowNum.equals(TransVarTableau1.getBasicRow(TransVarColumnName))))) {\n                            return TransVarRowNum;\n                        }\n                        TransVarColNum++;\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer TransVarMinRowNumber = null;\n                int TransVarMinColIndex = TransVarTableau1.getWidth();\n                for (Integer TransVarRowIndex : TransVarMinRatioPositionsList) {\n                    int TransVarIndex = TransVarTableau1.getNumObjectiveFunctions();\n                    while (!(!(TransVarIndex < TransVarTableau1.getWidth() - 1 && TransVarMinRowNumber != TransVarRowIndex))) {\n                        if (!(!(TransVarRowIndex == TransVarTableau1.getBasicRow(TransVarIndex)))) {\n                            if (!(!(TransVarIndex < TransVarMinColIndex))) {\n                                TransVarMinColIndex = TransVarIndex;\n                                TransVarMinRowNumber = TransVarRowIndex;\n                            }\n                        }\n                        TransVarIndex++;\n                    }\n                }\n                return TransVarMinRowNumber;\n            }\n        return TransVarMinRatioPositionsList.get(0);\n    }\n\n```",
            "method_doc": " Returns the row with the minimum ratio as given by the minimum ratio test (MRT). @param tableau simple tableau for the problem @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)} @return row with the minimum ratio ",
            "class_name": "org.apache.commons.math3.optimization.linear.SimplexSolver",
            "class_doc": " Solves a linear problem using the Two-Phase Simplex Method. @version $Id$ @since 2.0 ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze this test failure systematically to identify the root cause in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- Single test failure: `testMath828Cycle`\n- Failure mode: `MaxCountExceededException` with \"maximal count (100) exceeded\"\n- The test specifically targets cycling behavior in the simplex algorithm (referencing MATH-828)\n- The algorithm gets stuck in an infinite loop during optimization\n\n## Root Cause Analysis\n\n**Key Observations:**\n1. **Cycling Detection**: The test name explicitly indicates it's testing for \"cycle\" behavior\n2. **Degenerate Problem**: The linear programming problem appears to be degenerate (multiple solutions or redundant constraints)\n3. **Algorithm Stagnation**: The simplex algorithm fails to make progress and exceeds the iteration limit\n\n## Recommended Defect in Production Code\n\n**Primary Defect**: **Insufficient cycling prevention mechanism in SimplexSolver**\n\nThe production code in `SimplexSolver.doIteration()` (line 162) lacks proper anti-cycling measures for degenerate linear programming problems. Specifically:\n\n1. **Missing Bland's Rule Implementation**: The simplex algorithm should implement Bland's rule (smallest subscript rule) to prevent cycling when degenerate pivots occur.\n\n2. **Inadequate Pivot Selection**: The pivot selection logic doesn't properly handle cases where multiple entering/leaving variables could be chosen, leading to repeated basis cycles.\n\n3. **No Degeneracy Detection**: The algorithm fails to detect when it's entering a degenerate cycle and apply corrective measures.\n\n**Expected Fix Location**: \n- `SimplexSolver.doIteration()` method\n- Pivot selection logic in the tableau processing\n- Additional cycling detection and prevention mechanisms\n\n**Impact**: This defect causes the simplex algorithm to enter infinite loops on degenerate problems, making it unreliable for certain classes of linear programming problems that commonly occur in real-world optimization scenarios.\n\nThe fix should implement established anti-cycling techniques from linear programming literature to ensure the algorithm terminates correctly even with degenerate problems.",
            "test_suite": "org.apache.commons.math3.optimization.linear.SimplexSolverTest",
            "score": 9,
            "reason": "#9# The getPivotRow method is highly suspicious because it implements the minimum ratio test which is critical for preventing cycling in the simplex algorithm. The test failure shows the algorithm enters an infinite loop (MaxCountExceededException), indicating cycling behavior. The method contains complex logic for handling degeneracy and implements Bland's rule, but there appear to be issues in the tie-breaking logic and variable name confusion that could cause incorrect pivot selection, leading to cycling in degenerate problems like the one in testMath828Cycle."
        },
        {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::doOptimize()",
            "method_code": "```java\n    @Override\n    public PointValuePair doOptimize()\n        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n        final SimplexTableau tableau =\n            new SimplexTableau(getFunction(),\n                               getConstraints(),\n                               getGoalType(),\n                               restrictToNonNegative(),\n                               epsilon,\n                               maxUlps);\n\n        solvePhase1(tableau);\n        tableau.dropPhase1Objective();\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n```",
            "method_doc": "{@inheritDoc} */",
            "class_name": "org.apache.commons.math3.optimization.linear.SimplexSolver",
            "class_doc": " Solves a linear problem using the Two-Phase Simplex Method. @version $Id$ @since 2.0 ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze this test failure systematically to identify the root cause in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- Single test failure: `testMath828Cycle`\n- Failure mode: `MaxCountExceededException` with \"maximal count (100) exceeded\"\n- The test specifically targets cycling behavior in the simplex algorithm (referencing MATH-828)\n- The algorithm gets stuck in an infinite loop during optimization\n\n## Root Cause Analysis\n\n**Key Observations:**\n1. **Cycling Detection**: The test name explicitly indicates it's testing for \"cycle\" behavior\n2. **Degenerate Problem**: The linear programming problem appears to be degenerate (multiple solutions or redundant constraints)\n3. **Algorithm Stagnation**: The simplex algorithm fails to make progress and exceeds the iteration limit\n\n## Recommended Defect in Production Code\n\n**Primary Defect**: **Insufficient cycling prevention mechanism in SimplexSolver**\n\nThe production code in `SimplexSolver.doIteration()` (line 162) lacks proper anti-cycling measures for degenerate linear programming problems. Specifically:\n\n1. **Missing Bland's Rule Implementation**: The simplex algorithm should implement Bland's rule (smallest subscript rule) to prevent cycling when degenerate pivots occur.\n\n2. **Inadequate Pivot Selection**: The pivot selection logic doesn't properly handle cases where multiple entering/leaving variables could be chosen, leading to repeated basis cycles.\n\n3. **No Degeneracy Detection**: The algorithm fails to detect when it's entering a degenerate cycle and apply corrective measures.\n\n**Expected Fix Location**: \n- `SimplexSolver.doIteration()` method\n- Pivot selection logic in the tableau processing\n- Additional cycling detection and prevention mechanisms\n\n**Impact**: This defect causes the simplex algorithm to enter infinite loops on degenerate problems, making it unreliable for certain classes of linear programming problems that commonly occur in real-world optimization scenarios.\n\nThe fix should implement established anti-cycling techniques from linear programming literature to ensure the algorithm terminates correctly even with degenerate problems.",
            "test_suite": "org.apache.commons.math3.optimization.linear.SimplexSolverTest",
            "score": 8,
            "reason": "#8# The doOptimize() method is highly suspicious because it contains the main optimization loop that calls doIteration() repeatedly until optimality is reached. The MaxCountExceededException occurs when this loop exceeds 100 iterations, indicating the algorithm gets stuck in a cycle. Since this method controls the iterative process and lacks cycling detection/prevention mechanisms, it's the appropriate location to implement anti-cycling fixes like Bland's rule or cycle detection logic."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math3.optimization.linear.SimplexSolver::doOptimize()": {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::doOptimize()",
            "method_code": "```java\n    @Override\n    public PointValuePair doOptimize()\n        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n        final SimplexTableau tableau =\n            new SimplexTableau(getFunction(),\n                               getConstraints(),\n                               getGoalType(),\n                               restrictToNonNegative(),\n                               epsilon,\n                               maxUlps);\n\n        solvePhase1(tableau);\n        tableau.dropPhase1Objective();\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n```",
            "method_doc": "{@inheritDoc} */"
        },
        "org.apache.commons.math3.optimization.linear.SimplexSolver::getPivotColumn(SimplexTableau)": {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::getPivotColumn(SimplexTableau)",
            "method_code": "```java\n    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            // check if the entry is strictly smaller than the current minimum\n            // do not use a ulp/epsilon check\n            if (entry < minValue) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    }\n\n```",
            "method_doc": " Returns the column with the most negative coefficient in the objective function row. @param tableau simple tableau for the problem @return column with the most negative coefficient "
        },
        "org.apache.commons.math3.optimization.linear.SimplexSolver::doIteration(SimplexTableau)": {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::doIteration(SimplexTableau)",
            "method_code": "```java\n    protected void doIteration(final SimplexTableau tableau)\n        throws MaxCountExceededException, UnboundedSolutionException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(tableau, pivotCol);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        // set the pivot element to 1\n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        // set the rest of the pivot column to 0\n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                final double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n```",
            "method_doc": " Runs one iteration of the Simplex method on the given model. @param tableau simple tableau for the problem @throws MaxCountExceededException if the maximal iteration count has been exceeded @throws UnboundedSolutionException if the model is found not to have a bounded solution "
        },
        "org.apache.commons.math3.optimization.linear.SimplexSolver::getPivotRow(SimplexTableau,int)": {
            "method_name": "org.apache.commons.math3.optimization.linear.SimplexSolver::getPivotRow(SimplexTableau,int)",
            "method_code": "```java\n    private Integer getPivotRow(SimplexTableau TransVarTableau1, final int TransVarColName) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> TransVarMinRatioPositionsList = new ArrayList<Integer>();\n        double TransVarMinRatioPositions = Double.MAX_VALUE;\n        int TransVarColumnNumber = TransVarTableau1.getNumObjectiveFunctions();\n        while (!(!(TransVarColumnNumber < TransVarTableau1.getHeight()))){if (!(!(false))) {\n                System.out.println(\"log\");\n                }\n        final double TransVarEntryValue=TransVarTableau1.getEntry(TransVarColumnNumber,TransVarTableau1.getWidth() - 1);final double TransVarEntry2=TransVarTableau1.getEntry(TransVarColumnNumber,TransVarColName);if (!(!(Precision.compareTo(TransVarEntry2, 0d, maxUlps) > 0))){if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        final double TransVarRatio2=TransVarEntryValue / TransVarEntry2;final int TransVarC=Double.compare(TransVarRatio2,TransVarMinRatioPositions);if (!(!(TransVarC == 0))){TransVarMinRatioPositionsList.add(TransVarColumnNumber);} else if (!(!(TransVarC < 0))){TransVarMinRatioPositions=TransVarRatio2;TransVarMinRatioPositionsList=new ArrayList<Integer>();TransVarMinRatioPositionsList.add(TransVarColumnNumber);}}TransVarColumnNumber++;}\n\n        if (!(!(TransVarMinRatioPositionsList.size() == 0))) {\n            return null;\n        } else if (!(!(TransVarMinRatioPositionsList.size() > 1))) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer TransVarRowNum : TransVarMinRatioPositionsList) {\n                    int TransVarColNum = 0;\n                    while (!(!(TransVarColNum < TransVarTableau1.getNumArtificialVariables()))) {\n                        int TransVarColumnName = TransVarColNum + TransVarTableau1.getArtificialVariableOffset();\n                        final double TransVarEntry3 = TransVarTableau1.getEntry(TransVarRowNum, TransVarColumnName);\n                        if (!(!(Precision.equals(TransVarEntry3, 1d, maxUlps)\n                                && TransVarRowNum.equals(TransVarTableau1.getBasicRow(TransVarColumnName))))) {\n                            return TransVarRowNum;\n                        }\n                        TransVarColNum++;\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer TransVarMinRowNumber = null;\n                int TransVarMinColIndex = TransVarTableau1.getWidth();\n                for (Integer TransVarRowIndex : TransVarMinRatioPositionsList) {\n                    int TransVarIndex = TransVarTableau1.getNumObjectiveFunctions();\n                    while (!(!(TransVarIndex < TransVarTableau1.getWidth() - 1 && TransVarMinRowNumber != TransVarRowIndex))) {\n                        if (!(!(TransVarRowIndex == TransVarTableau1.getBasicRow(TransVarIndex)))) {\n                            if (!(!(TransVarIndex < TransVarMinColIndex))) {\n                                TransVarMinColIndex = TransVarIndex;\n                                TransVarMinRowNumber = TransVarRowIndex;\n                            }\n                        }\n                        TransVarIndex++;\n                    }\n                }\n                return TransVarMinRowNumber;\n            }\n        return TransVarMinRatioPositionsList.get(0);\n    }\n\n```",
            "method_doc": " Returns the row with the minimum ratio as given by the minimum ratio test (MRT). @param tableau simple tableau for the problem @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)} @return row with the minimum ratio "
        }
    }
}