{
    "buggy_classes": [
        "org.apache.commons.compress.archivers.zip.ZipFile"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::getEntry(String)",
            "method_code": "```java\n    public ZipArchiveEntry getEntry(String name) {\n        return nameMap.get(name);\n    }\n\n```",
            "method_doc": " Returns a named entry - or <code>null</code> if no entry by that name exists. @param name name of the entry. @return the ZipArchiveEntry corresponding to the given name - or <code>null</code> if not present. ",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipFile",
            "class_doc": " Replacement for <code>java.util.ZipFile</code>.  <p>This class adds support for file name encodings other than UTF-8 (which is required to work on ZIP files created by native zip tools and is able to skip a preamble like the one found in self extracting archives.  Furthermore it returns instances of <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instead of <code>java.util.zip.ZipEntry</code>.</p>  <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would have to reimplement all methods anyway.  Like <code>java.util.ZipFile</code>, it uses RandomAccessFile under the covers and supports compressed and uncompressed entries.  As of Apache Commons Compress it also transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  <p>The method signatures mimic the ones of <code>java.util.zip.ZipFile</code>, with a couple of exceptions:  <ul> <li>There is no getName method.</li> <li>entries has been renamed to getEntries.</li> <li>getEntries and getEntry return <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instances.</li> <li>close is allowed to throw IOException.</li> </ul>  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, here's my step-by-step reasoning:\n\n## Step 1: Test Behavior Analysis\n\nThe test `testWinzipBackSlashWorkaround` is designed to verify that:\n- Entries with backslashes in their paths (non-standard ZIP separator) should return `null`\n- Entries with forward slashes (standard ZIP separator) should be found successfully\n\nThe test failed because `zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\")` returned an entry instead of `null`.\n\n## Step 2: Common Pattern Identification\n\nThe key pattern here is the handling of backslash characters in ZIP entry names:\n- The test expects backslash-separated paths to be treated as invalid/not found\n- The actual behavior shows that backslash-separated paths are being recognized as valid entries\n\n## Step 3: Production Code Defect Recommendation\n\n**Possible defect in the production code (`ZipFile` class):**\n\nThe `ZipFile.getEntry(String name)` method is likely not properly filtering out or rejecting entry names that contain backslashes as path separators. Instead of returning `null` for such malformed entries, it's incorrectly matching them to actual entries in the ZIP file.\n\n**Root cause hypothesis:** The entry lookup logic in `ZipFile` may be:\n- Not normalizing backslashes to forward slashes before comparison\n- Or not implementing the WinZip backslash workaround properly\n- Or incorrectly treating backslash-separated paths as valid ZIP entries\n\nThe defect appears to be in how the ZIP file parsing or entry matching logic handles non-standard path separators, specifically failing to reject entries with backslashes when they should be considered invalid in the context of this compatibility workaround.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipFileTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because it directly implements the entry lookup logic that's failing the test. The test expects getEntry to return null for backslash-separated paths, but the current implementation simply performs a direct map lookup without any path normalization or validation. The method should handle the WinZip backslash workaround by either normalizing backslashes to forward slashes before lookup or explicitly rejecting entries with backslashes, but it currently does neither."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::getNextZipEntry()",
            "method_code": "```java\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n        }\n        byte[] lfh = new byte[LFH_LEN];\n        try {\n            readFully(lfh);\n        } catch (EOFException e) {\n            return null;\n        }\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.CFH_SIG)) {\n            hitCentralDirectory = true;\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(lfh, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                                  & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(lfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            cSize = new ZipLong(lfh, off);\n            off += WORD;\n\n            size = new ZipLong(lfh, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(lfh, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(lfh, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName,\n                                                     null);\n        }\n\n        processZip64Extra(size, cSize);\n        return current.entry;\n    }\n\n```",
            "method_doc": "Reads the next ZIP archive entry from the stream, parsing local file header data and setting up entry metadata. This method calls method \"readFully\" to read header bytes and file name/extra data, and calls method \"processZip64Extra\" to handle Zip64 extended information.",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
            "class_doc": " Implements an input stream that can read Zip archives.  <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the DEFLATE algorithm is used, as the size information is not available from the header.</p>  <p>The {@link ZipFile} class is preferred when reading from files.</p>  <p>As of Apache Commons Compress it transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  @see ZipFile @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test, I can identify the key pattern and recommend the likely defect in the production code.\n\n## Common Pattern Analysis\n\nThe test failure reveals a consistent pattern:\n\n1. **Character Encoding Issue**: The test expects a forward slash (\"/\") but receives a backslash (\"\\\") in the ZIP entry name\n2. **Path Separator Problem**: The discrepancy specifically involves directory separators in ZIP entry names\n3. **WinZip Compatibility**: The test is designed to verify WinZip compatibility workaround (referencing COMPRESS-176)\n4. **Non-ASCII Characters**: The entry name contains the Unicode character \"\\u00e4\" (\u00e4), indicating potential encoding issues with special characters\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **ZipArchiveInputStream class's entry name parsing logic**, specifically in how it handles path separators and character encoding when reading ZIP entries created by WinZip.\n\n**Probable Location**: `ZipArchiveInputStream.getNextZipEntry()` method or its related parsing logic\n\n**Root Cause**: The production code is likely failing to properly normalize backslashes to forward slashes in ZIP entry names, particularly when dealing with non-ASCII characters. WinZip historically uses backslashes as path separators, while the ZIP specification and other tools typically use forward slashes.\n\n**Specific Defect**: The code that processes ZIP entry names is not correctly:\n- Converting backslash path separators to forward slashes\n- Handling the combination of non-ASCII characters with path separator normalization\n- Implementing the WinZip backslash workaround referenced in COMPRESS-176\n\nThe fix should ensure that when reading ZIP entries, all backslash characters used as path separators are converted to forward slashes, regardless of the character encoding context.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it directly handles ZIP entry name parsing and decoding. The test failure shows a backslash vs forward slash issue in entry names, and this method contains the logic that reads and decodes the file name from the ZIP header using entryEncoding.decode(fileName). The method processes the GeneralPurposeBit flags and selects the appropriate encoding, but doesn't appear to normalize path separators from backslashes to forward slashes as required by the WinZip compatibility workaround referenced in COMPRESS-176."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::resolveLocalFileHeaderData(Map)",
            "method_code": "```java\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        Map<ZipArchiveEntry, OffsetEntry> origMap =\n            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n        entries.clear();\n        for (ZipArchiveEntry ze : origMap.keySet()) {\n            OffsetEntry offsetEntry = origMap.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new IOException(\"failed to skip file name in\"\n                                          + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            entries.put(ze, offsetEntry);\n        }\n    }\n\n```",
            "method_doc": " Walks through all recorded entries and adds the data available from the local file header.  <p>Also records the offsets for the data to read from the entries.</p> ",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipFile",
            "class_doc": " Replacement for <code>java.util.ZipFile</code>.  <p>This class adds support for file name encodings other than UTF-8 (which is required to work on ZIP files created by native zip tools and is able to skip a preamble like the one found in self extracting archives.  Furthermore it returns instances of <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instead of <code>java.util.zip.ZipEntry</code>.</p>  <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would have to reimplement all methods anyway.  Like <code>java.util.ZipFile</code>, it uses RandomAccessFile under the covers and supports compressed and uncompressed entries.  As of Apache Commons Compress it also transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  <p>The method signatures mimic the ones of <code>java.util.zip.ZipFile</code>, with a couple of exceptions:  <ul> <li>There is no getName method.</li> <li>entries has been renamed to getEntries.</li> <li>getEntries and getEntry return <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instances.</li> <li>close is allowed to throw IOException.</li> </ul>  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, here's my step-by-step reasoning:\n\n## Step 1: Test Behavior Analysis\n\nThe test `testWinzipBackSlashWorkaround` is designed to verify that:\n- Entries with backslashes in their paths (non-standard ZIP separator) should return `null`\n- Entries with forward slashes (standard ZIP separator) should be found successfully\n\nThe test failed because `zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\")` returned an entry instead of `null`.\n\n## Step 2: Common Pattern Identification\n\nThe key pattern here is the handling of backslash characters in ZIP entry names:\n- The test expects backslash-separated paths to be treated as invalid/not found\n- The actual behavior shows that backslash-separated paths are being recognized as valid entries\n\n## Step 3: Production Code Defect Recommendation\n\n**Possible defect in the production code (`ZipFile` class):**\n\nThe `ZipFile.getEntry(String name)` method is likely not properly filtering out or rejecting entry names that contain backslashes as path separators. Instead of returning `null` for such malformed entries, it's incorrectly matching them to actual entries in the ZIP file.\n\n**Root cause hypothesis:** The entry lookup logic in `ZipFile` may be:\n- Not normalizing backslashes to forward slashes before comparison\n- Or not implementing the WinZip backslash workaround properly\n- Or incorrectly treating backslash-separated paths as valid ZIP entries\n\nThe defect appears to be in how the ZIP file parsing or entry matching logic handles non-standard path separators, specifically failing to reject entries with backslashes when they should be considered invalid in the context of this compatibility workaround.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipFileTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles ZIP entry name processing and contains logic that modifies entry names through the ZipUtil.setNameAndCommentFromExtraFields call. The test failure indicates that entries with backslashes are not being properly filtered out, and this method processes the local file header data where entry names are read and potentially normalized. The name mapping logic (nameMap.remove and nameMap.put) suggests this method plays a key role in how entries are looked up by name, which directly relates to the test's expectation that backslash-separated paths should return null."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::readCentralDirectoryEntry(Map)",
            "method_code": "```java\n    private void\n        readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n        throws IOException {\n        byte[] cfh = new byte[CFH_LEN];\n\n        archive.readFully(cfh);\n        int off = 0;\n        ZipArchiveEntry ze = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(cfh, off);\n        off += SHORT;\n        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n        off += SHORT; // skip version info\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        ze.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        ze.setMethod(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n        ze.setTime(time);\n        off += WORD;\n\n        ze.setCrc(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        int fileNameLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int commentLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int diskStart = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        byte[] fileName = new byte[fileNameLen];\n        archive.readFully(fileName);\n        ze.setName(entryEncoding.decode(fileName), fileName);\n\n        // LFH offset,\n        OffsetEntry offset = new OffsetEntry();\n        offset.headerOffset = ZipLong.getValue(cfh, off);\n        // data offset will be filled later\n        entries.put(ze, offset);\n\n        nameMap.put(ze.getName(), ze);\n\n        byte[] cdExtraData = new byte[extraLen];\n        archive.readFully(cdExtraData);\n        ze.setCentralDirectoryExtra(cdExtraData);\n\n        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\n        byte[] comment = new byte[commentLen];\n        archive.readFully(comment);\n        ze.setComment(entryEncoding.decode(comment));\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n        }\n    }\n\n```",
            "method_doc": " Reads an individual entry of the central directory, creats an ZipArchiveEntry from it and adds it to the global maps.  @param noUTF8Flag map used to collect entries that don't have their UTF-8 flag set and whose name will be set by data read from the local file header later.  The current entry may be added to this map. ",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipFile",
            "class_doc": " Replacement for <code>java.util.ZipFile</code>.  <p>This class adds support for file name encodings other than UTF-8 (which is required to work on ZIP files created by native zip tools and is able to skip a preamble like the one found in self extracting archives.  Furthermore it returns instances of <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instead of <code>java.util.zip.ZipEntry</code>.</p>  <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would have to reimplement all methods anyway.  Like <code>java.util.ZipFile</code>, it uses RandomAccessFile under the covers and supports compressed and uncompressed entries.  As of Apache Commons Compress it also transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  <p>The method signatures mimic the ones of <code>java.util.zip.ZipFile</code>, with a couple of exceptions:  <ul> <li>There is no getName method.</li> <li>entries has been renamed to getEntries.</li> <li>getEntries and getEntry return <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instances.</li> <li>close is allowed to throw IOException.</li> </ul>  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, here's my step-by-step reasoning:\n\n## Step 1: Test Behavior Analysis\n\nThe test `testWinzipBackSlashWorkaround` is designed to verify that:\n- Entries with backslashes in their paths (non-standard ZIP separator) should return `null`\n- Entries with forward slashes (standard ZIP separator) should be found successfully\n\nThe test failed because `zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\")` returned an entry instead of `null`.\n\n## Step 2: Common Pattern Identification\n\nThe key pattern here is the handling of backslash characters in ZIP entry names:\n- The test expects backslash-separated paths to be treated as invalid/not found\n- The actual behavior shows that backslash-separated paths are being recognized as valid entries\n\n## Step 3: Production Code Defect Recommendation\n\n**Possible defect in the production code (`ZipFile` class):**\n\nThe `ZipFile.getEntry(String name)` method is likely not properly filtering out or rejecting entry names that contain backslashes as path separators. Instead of returning `null` for such malformed entries, it's incorrectly matching them to actual entries in the ZIP file.\n\n**Root cause hypothesis:** The entry lookup logic in `ZipFile` may be:\n- Not normalizing backslashes to forward slashes before comparison\n- Or not implementing the WinZip backslash workaround properly\n- Or incorrectly treating backslash-separated paths as valid ZIP entries\n\nThe defect appears to be in how the ZIP file parsing or entry matching logic handles non-standard path separators, specifically failing to reject entries with backslashes when they should be considered invalid in the context of this compatibility workaround.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipFileTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it processes ZIP entry names and stores them in the nameMap. The test failure occurs when looking up an entry with backslashes, and this method is responsible for reading entry names from the central directory and populating the nameMap with the decoded names. If backslashes in entry names are not properly handled or normalized during this process, it would cause the getEntry method to incorrectly find entries with backslashes instead of returning null."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::populateFromCentralDirectory()",
            "method_code": "```java\n    private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n        throws IOException {\n        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n            new HashMap<ZipArchiveEntry, NameAndComment>();\n\n        positionAtCentralDirectory();\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n\n        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n\n        while (sig == CFH_SIG) {\n            readCentralDirectoryEntry(noUTF8Flag);\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n        }\n        return noUTF8Flag;\n    }\n\n```",
            "method_doc": " Reads the central directory of the given archive and populates the internal tables with ZipArchiveEntry instances.  <p>The ZipArchiveEntrys will know all data that can be obtained from the central directory alone, but not the data that requires the local file header or additional data to be read.</p>  @return a map of zipentries that didn't have the language encoding flag set when read. ",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipFile",
            "class_doc": " Replacement for <code>java.util.ZipFile</code>.  <p>This class adds support for file name encodings other than UTF-8 (which is required to work on ZIP files created by native zip tools and is able to skip a preamble like the one found in self extracting archives.  Furthermore it returns instances of <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instead of <code>java.util.zip.ZipEntry</code>.</p>  <p>It doesn't extend <code>java.util.zip.ZipFile</code> as it would have to reimplement all methods anyway.  Like <code>java.util.ZipFile</code>, it uses RandomAccessFile under the covers and supports compressed and uncompressed entries.  As of Apache Commons Compress it also transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  <p>The method signatures mimic the ones of <code>java.util.zip.ZipFile</code>, with a couple of exceptions:  <ul> <li>There is no getName method.</li> <li>entries has been renamed to getEntries.</li> <li>getEntries and getEntry return <code>org.apache.commons.compress.archivers.zip.ZipArchiveEntry</code> instances.</li> <li>close is allowed to throw IOException.</li> </ul>  ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, here's my step-by-step reasoning:\n\n## Step 1: Test Behavior Analysis\n\nThe test `testWinzipBackSlashWorkaround` is designed to verify that:\n- Entries with backslashes in their paths (non-standard ZIP separator) should return `null`\n- Entries with forward slashes (standard ZIP separator) should be found successfully\n\nThe test failed because `zf.getEntry(\"\\u00e4\\\\\\u00fc.txt\")` returned an entry instead of `null`.\n\n## Step 2: Common Pattern Identification\n\nThe key pattern here is the handling of backslash characters in ZIP entry names:\n- The test expects backslash-separated paths to be treated as invalid/not found\n- The actual behavior shows that backslash-separated paths are being recognized as valid entries\n\n## Step 3: Production Code Defect Recommendation\n\n**Possible defect in the production code (`ZipFile` class):**\n\nThe `ZipFile.getEntry(String name)` method is likely not properly filtering out or rejecting entry names that contain backslashes as path separators. Instead of returning `null` for such malformed entries, it's incorrectly matching them to actual entries in the ZIP file.\n\n**Root cause hypothesis:** The entry lookup logic in `ZipFile` may be:\n- Not normalizing backslashes to forward slashes before comparison\n- Or not implementing the WinZip backslash workaround properly\n- Or incorrectly treating backslash-separated paths as valid ZIP entries\n\nThe defect appears to be in how the ZIP file parsing or entry matching logic handles non-standard path separators, specifically failing to reject entries with backslashes when they should be considered invalid in the context of this compatibility workaround.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipFileTest",
            "score": 8,
            "reason": "#8# The populateFromCentralDirectory method is very likely to be the best location to fix because it's responsible for reading and processing ZIP file entries from the central directory. The test failure indicates that entries with backslashes are incorrectly being recognized as valid, which suggests the issue occurs during the initial population of entries when reading the central directory. This method calls readCentralDirectoryEntry which likely processes entry names, and any normalization or filtering of backslash characters should happen during this initial parsing phase rather than later during lookup operations."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::ZipArchiveInputStream(InputStream,String,boolean,boolean)",
            "method_code": "```java\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.buf.length);\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n    }\n\n```",
            "method_doc": " @param encoding the encoding to use for file names, use null for the platform's default encoding @param useUnicodeExtraFields whether to use InfoZIP Unicode Extra Fields (if present) to set the file names. @param allowStoredEntriesWithDataDescriptor whether the stream will try to read STORED entries that use a data descriptor @since Apache Commons Compress 1.1 ",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
            "class_doc": " Implements an input stream that can read Zip archives.  <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the DEFLATE algorithm is used, as the size information is not available from the header.</p>  <p>The {@link ZipFile} class is preferred when reading from files.</p>  <p>As of Apache Commons Compress it transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  @see ZipFile @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test, I can identify the key pattern and recommend the likely defect in the production code.\n\n## Common Pattern Analysis\n\nThe test failure reveals a consistent pattern:\n\n1. **Character Encoding Issue**: The test expects a forward slash (\"/\") but receives a backslash (\"\\\") in the ZIP entry name\n2. **Path Separator Problem**: The discrepancy specifically involves directory separators in ZIP entry names\n3. **WinZip Compatibility**: The test is designed to verify WinZip compatibility workaround (referencing COMPRESS-176)\n4. **Non-ASCII Characters**: The entry name contains the Unicode character \"\\u00e4\" (\u00e4), indicating potential encoding issues with special characters\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **ZipArchiveInputStream class's entry name parsing logic**, specifically in how it handles path separators and character encoding when reading ZIP entries created by WinZip.\n\n**Probable Location**: `ZipArchiveInputStream.getNextZipEntry()` method or its related parsing logic\n\n**Root Cause**: The production code is likely failing to properly normalize backslashes to forward slashes in ZIP entry names, particularly when dealing with non-ASCII characters. WinZip historically uses backslashes as path separators, while the ZIP specification and other tools typically use forward slashes.\n\n**Specific Defect**: The code that processes ZIP entry names is not correctly:\n- Converting backslash path separators to forward slashes\n- Handling the combination of non-ASCII characters with path separator normalization\n- Implementing the WinZip backslash workaround referenced in COMPRESS-176\n\nThe fix should ensure that when reading ZIP entries, all backslash characters used as path separators are converted to forward slashes, regardless of the character encoding context.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest",
            "score": 2,
            "reason": "#2# This constructor method only initializes encoding settings and input streams but doesn't contain the actual logic for parsing ZIP entry names or handling path separator normalization, which is the core issue causing the test failure. The real problem likely resides in the getNextZipEntry() method or related parsing logic where entry names are processed."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::readFully(byte[])",
            "method_code": "```java\n    private void readFully(byte[] b) throws IOException {\n        int count = 0, x = 0;\n        while (count != b.length) {\n            count += x = in.read(b, count, b.length - count);\n            if (x == -1) {\n                throw new EOFException();\n            }\n            count(x);\n        }\n    }\n\n```",
            "method_doc": "Reads the entire byte array from the input stream, ensuring all requested bytes are read or throwing EOFException if stream ends prematurely.",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
            "class_doc": " Implements an input stream that can read Zip archives.  <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the DEFLATE algorithm is used, as the size information is not available from the header.</p>  <p>The {@link ZipFile} class is preferred when reading from files.</p>  <p>As of Apache Commons Compress it transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  @see ZipFile @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test, I can identify the key pattern and recommend the likely defect in the production code.\n\n## Common Pattern Analysis\n\nThe test failure reveals a consistent pattern:\n\n1. **Character Encoding Issue**: The test expects a forward slash (\"/\") but receives a backslash (\"\\\") in the ZIP entry name\n2. **Path Separator Problem**: The discrepancy specifically involves directory separators in ZIP entry names\n3. **WinZip Compatibility**: The test is designed to verify WinZip compatibility workaround (referencing COMPRESS-176)\n4. **Non-ASCII Characters**: The entry name contains the Unicode character \"\\u00e4\" (\u00e4), indicating potential encoding issues with special characters\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **ZipArchiveInputStream class's entry name parsing logic**, specifically in how it handles path separators and character encoding when reading ZIP entries created by WinZip.\n\n**Probable Location**: `ZipArchiveInputStream.getNextZipEntry()` method or its related parsing logic\n\n**Root Cause**: The production code is likely failing to properly normalize backslashes to forward slashes in ZIP entry names, particularly when dealing with non-ASCII characters. WinZip historically uses backslashes as path separators, while the ZIP specification and other tools typically use forward slashes.\n\n**Specific Defect**: The code that processes ZIP entry names is not correctly:\n- Converting backslash path separators to forward slashes\n- Handling the combination of non-ASCII characters with path separator normalization\n- Implementing the WinZip backslash workaround referenced in COMPRESS-176\n\nThe fix should ensure that when reading ZIP entries, all backslash characters used as path separators are converted to forward slashes, regardless of the character encoding context.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest",
            "score": 2,
            "reason": "#2# The readFully method is a general-purpose byte array reading utility that doesn't handle ZIP entry name parsing or path separator normalization. The actual issue is likely in the ZIP entry parsing logic that processes the read data, not in the low-level byte reading mechanism."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::ZipArchiveInputStream(InputStream,String,boolean)",
            "method_code": "```java\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n```",
            "method_doc": " @param encoding the encoding to use for file names, use null for the platform's default encoding @param useUnicodeExtraFields whether to use InfoZIP Unicode Extra Fields (if present) to set the file names. ",
            "class_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream",
            "class_doc": " Implements an input stream that can read Zip archives.  <p>Note that {@link ZipArchiveEntry#getSize()} may return -1 if the DEFLATE algorithm is used, as the size information is not available from the header.</p>  <p>The {@link ZipFile} class is preferred when reading from files.</p>  <p>As of Apache Commons Compress it transparently supports Zip64 extensions and thus individual entries and archives larger than 4 GB or with more than 65536 entries.</p>  @see ZipFile @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test, I can identify the key pattern and recommend the likely defect in the production code.\n\n## Common Pattern Analysis\n\nThe test failure reveals a consistent pattern:\n\n1. **Character Encoding Issue**: The test expects a forward slash (\"/\") but receives a backslash (\"\\\") in the ZIP entry name\n2. **Path Separator Problem**: The discrepancy specifically involves directory separators in ZIP entry names\n3. **WinZip Compatibility**: The test is designed to verify WinZip compatibility workaround (referencing COMPRESS-176)\n4. **Non-ASCII Characters**: The entry name contains the Unicode character \"\\u00e4\" (\u00e4), indicating potential encoding issues with special characters\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **ZipArchiveInputStream class's entry name parsing logic**, specifically in how it handles path separators and character encoding when reading ZIP entries created by WinZip.\n\n**Probable Location**: `ZipArchiveInputStream.getNextZipEntry()` method or its related parsing logic\n\n**Root Cause**: The production code is likely failing to properly normalize backslashes to forward slashes in ZIP entry names, particularly when dealing with non-ASCII characters. WinZip historically uses backslashes as path separators, while the ZIP specification and other tools typically use forward slashes.\n\n**Specific Defect**: The code that processes ZIP entry names is not correctly:\n- Converting backslash path separators to forward slashes\n- Handling the combination of non-ASCII characters with path separator normalization\n- Implementing the WinZip backslash workaround referenced in COMPRESS-176\n\nThe fix should ensure that when reading ZIP entries, all backslash characters used as path separators are converted to forward slashes, regardless of the character encoding context.",
            "test_suite": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest",
            "score": 2,
            "reason": "#2# This method is just a constructor that delegates to another constructor and doesn't contain any logic for processing ZIP entry names or path separators. The actual issue with backslash/forward slash conversion likely occurs in the getNextZipEntry() method or related parsing logic, not in this constructor."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::ZipArchiveInputStream(InputStream,String,boolean,boolean)": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::ZipArchiveInputStream(InputStream,String,boolean,boolean)",
            "method_code": "```java\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.buf.length);\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n    }\n\n```",
            "method_doc": " @param encoding the encoding to use for file names, use null for the platform's default encoding @param useUnicodeExtraFields whether to use InfoZIP Unicode Extra Fields (if present) to set the file names. @param allowStoredEntriesWithDataDescriptor whether the stream will try to read STORED entries that use a data descriptor @since Apache Commons Compress 1.1 "
        },
        "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::getNextZipEntry()": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::getNextZipEntry()",
            "method_code": "```java\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n        }\n        byte[] lfh = new byte[LFH_LEN];\n        try {\n            readFully(lfh);\n        } catch (EOFException e) {\n            return null;\n        }\n        ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.CFH_SIG)) {\n            hitCentralDirectory = true;\n            return null;\n        }\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            return null;\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        int versionMadeBy = ZipShort.getValue(lfh, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT)\n                                  & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(lfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfh, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(lfh, off));\n            off += WORD;\n\n            cSize = new ZipLong(lfh, off);\n            off += WORD;\n\n            size = new ZipLong(lfh, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        int fileNameLen = ZipShort.getValue(lfh, off);\n\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(lfh, off);\n        off += SHORT;\n\n        byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n\n        byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName,\n                                                     null);\n        }\n\n        processZip64Extra(size, cSize);\n        return current.entry;\n    }\n\n```",
            "method_doc": "Reads the next ZIP archive entry from the stream, parsing local file header data and setting up entry metadata. This method calls method \"readFully\" to read header bytes and file name/extra data, and calls method \"processZip64Extra\" to handle Zip64 extended information."
        },
        "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::readFully(byte[])": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::readFully(byte[])",
            "method_code": "```java\n    private void readFully(byte[] b) throws IOException {\n        int count = 0, x = 0;\n        while (count != b.length) {\n            count += x = in.read(b, count, b.length - count);\n            if (x == -1) {\n                throw new EOFException();\n            }\n            count(x);\n        }\n    }\n\n```",
            "method_doc": "Reads the entire byte array from the input stream, ensuring all requested bytes are read or throwing EOFException if stream ends prematurely."
        },
        "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::ZipArchiveInputStream(InputStream,String,boolean)": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream::ZipArchiveInputStream(InputStream,String,boolean)",
            "method_code": "```java\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n```",
            "method_doc": " @param encoding the encoding to use for file names, use null for the platform's default encoding @param useUnicodeExtraFields whether to use InfoZIP Unicode Extra Fields (if present) to set the file names. "
        },
        "org.apache.commons.compress.archivers.zip.ZipFile::getEntry(String)": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::getEntry(String)",
            "method_code": "```java\n    public ZipArchiveEntry getEntry(String name) {\n        return nameMap.get(name);\n    }\n\n```",
            "method_doc": " Returns a named entry - or <code>null</code> if no entry by that name exists. @param name name of the entry. @return the ZipArchiveEntry corresponding to the given name - or <code>null</code> if not present. "
        },
        "org.apache.commons.compress.archivers.zip.ZipFile::resolveLocalFileHeaderData(Map)": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::resolveLocalFileHeaderData(Map)",
            "method_code": "```java\n    private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                            entriesWithoutUTF8Flag)\n        throws IOException {\n        // changing the name of a ZipArchiveEntry is going to change\n        // the hashcode - see COMPRESS-164\n        // Map needs to be reconstructed in order to keep central\n        // directory order\n        Map<ZipArchiveEntry, OffsetEntry> origMap =\n            new LinkedHashMap<ZipArchiveEntry, OffsetEntry>(entries);\n        entries.clear();\n        for (ZipArchiveEntry ze : origMap.keySet()) {\n            OffsetEntry offsetEntry = origMap.get(ze);\n            long offset = offsetEntry.headerOffset;\n            archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n            byte[] b = new byte[SHORT];\n            archive.readFully(b);\n            int fileNameLen = ZipShort.getValue(b);\n            archive.readFully(b);\n            int extraFieldLen = ZipShort.getValue(b);\n            int lenToSkip = fileNameLen;\n            while (lenToSkip > 0) {\n                int skipped = archive.skipBytes(lenToSkip);\n                if (skipped <= 0) {\n                    throw new IOException(\"failed to skip file name in\"\n                                          + \" local file header\");\n                }\n                lenToSkip -= skipped;\n            }\n            byte[] localExtraData = new byte[extraFieldLen];\n            archive.readFully(localExtraData);\n            ze.setExtra(localExtraData);\n            offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n                + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n            if (entriesWithoutUTF8Flag.containsKey(ze)) {\n                String orig = ze.getName();\n                NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                         nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n            entries.put(ze, offsetEntry);\n        }\n    }\n\n```",
            "method_doc": " Walks through all recorded entries and adds the data available from the local file header.  <p>Also records the offsets for the data to read from the entries.</p> "
        },
        "org.apache.commons.compress.archivers.zip.ZipFile::readCentralDirectoryEntry(Map)": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::readCentralDirectoryEntry(Map)",
            "method_code": "```java\n    private void\n        readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag)\n        throws IOException {\n        byte[] cfh = new byte[CFH_LEN];\n\n        archive.readFully(cfh);\n        int off = 0;\n        ZipArchiveEntry ze = new ZipArchiveEntry();\n\n        int versionMadeBy = ZipShort.getValue(cfh, off);\n        off += SHORT;\n        ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK);\n\n        off += SHORT; // skip version info\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding =\n            hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        ze.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        ze.setMethod(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off));\n        ze.setTime(time);\n        off += WORD;\n\n        ze.setCrc(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setCompressedSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        ze.setSize(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        int fileNameLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int extraLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int commentLen = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        int diskStart = ZipShort.getValue(cfh, off);\n        off += SHORT;\n\n        ze.setInternalAttributes(ZipShort.getValue(cfh, off));\n        off += SHORT;\n\n        ze.setExternalAttributes(ZipLong.getValue(cfh, off));\n        off += WORD;\n\n        byte[] fileName = new byte[fileNameLen];\n        archive.readFully(fileName);\n        ze.setName(entryEncoding.decode(fileName), fileName);\n\n        // LFH offset,\n        OffsetEntry offset = new OffsetEntry();\n        offset.headerOffset = ZipLong.getValue(cfh, off);\n        // data offset will be filled later\n        entries.put(ze, offset);\n\n        nameMap.put(ze.getName(), ze);\n\n        byte[] cdExtraData = new byte[extraLen];\n        archive.readFully(cdExtraData);\n        ze.setCentralDirectoryExtra(cdExtraData);\n\n        setSizesAndOffsetFromZip64Extra(ze, offset, diskStart);\n\n        byte[] comment = new byte[commentLen];\n        archive.readFully(comment);\n        ze.setComment(entryEncoding.decode(comment));\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            noUTF8Flag.put(ze, new NameAndComment(fileName, comment));\n        }\n    }\n\n```",
            "method_doc": " Reads an individual entry of the central directory, creats an ZipArchiveEntry from it and adds it to the global maps.  @param noUTF8Flag map used to collect entries that don't have their UTF-8 flag set and whose name will be set by data read from the local file header later.  The current entry may be added to this map. "
        },
        "org.apache.commons.compress.archivers.zip.ZipFile::populateFromCentralDirectory()": {
            "method_name": "org.apache.commons.compress.archivers.zip.ZipFile::populateFromCentralDirectory()",
            "method_code": "```java\n    private Map<ZipArchiveEntry, NameAndComment> populateFromCentralDirectory()\n        throws IOException {\n        HashMap<ZipArchiveEntry, NameAndComment> noUTF8Flag =\n            new HashMap<ZipArchiveEntry, NameAndComment>();\n\n        positionAtCentralDirectory();\n\n        byte[] signatureBytes = new byte[WORD];\n        archive.readFully(signatureBytes);\n        long sig = ZipLong.getValue(signatureBytes);\n\n        if (sig != CFH_SIG && startsWithLocalFileHeader()) {\n            throw new IOException(\"central directory is empty, can't expand\"\n                                  + \" corrupt archive.\");\n        }\n\n        while (sig == CFH_SIG) {\n            readCentralDirectoryEntry(noUTF8Flag);\n            archive.readFully(signatureBytes);\n            sig = ZipLong.getValue(signatureBytes);\n        }\n        return noUTF8Flag;\n    }\n\n```",
            "method_doc": " Reads the central directory of the given archive and populates the internal tables with ZipArchiveEntry instances.  <p>The ZipArchiveEntrys will know all data that can be obtained from the central directory alone, but not the data that requires the local file header or additional data to be read.</p>  @return a map of zipentries that didn't have the language encoding flag set when read. "
        }
    }
}