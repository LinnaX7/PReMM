{
    "buggy_classes": [
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::writePaxHeaders(String,Map)",
            "method_code": "```java\n    void writePaxHeaders(String TransVarEntry,\n                         Map<String, String> TransVarHeaderMap) throws IOException {\n        if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n        String TransVarEntryName = \"./PaxHeaders.X/\" + stripTo7Bits(TransVarEntry);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n        if (!(!(TransVarEntryName.length() >= TarConstants.NAMELEN))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            TransVarEntryName = TransVarEntryName.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry TransVarPexEntry = new TarArchiveEntry(TransVarEntryName,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter TransVarWriter = new StringWriter();\n        for (Map.Entry<String, String> TransVarHeader : TransVarHeaderMap.entrySet()) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarKeyName = TransVarHeader.getKey();\n            String TransVarVal = TransVarHeader.getValue();\n            int TransVarLength = TransVarKeyName.length() + TransVarVal.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String TransVarEntryLine = TransVarLength + \" \" + TransVarKeyName + \"=\" + TransVarVal + \"\\n\";\n            int TransVarActualLen = TransVarEntryLine.getBytes(CharsetNames.UTF_8).length;\n            for (; !(!(TransVarLength != TransVarActualLen));) {\n                TransVarLength = TransVarActualLen;\n                TransVarEntryLine = TransVarLength + \" \" + TransVarKeyName + \"=\" + TransVarVal + \"\\n\";\n                TransVarActualLen = TransVarEntryLine.getBytes(CharsetNames.UTF_8).length;\n            }\n            TransVarWriter.write(TransVarEntryLine);\n        }\n        byte[] TransVarB = TransVarWriter.toString().getBytes(CharsetNames.UTF_8);\n        TransVarPexEntry.setSize(TransVarB.length);\n        putArchiveEntry(TransVarPexEntry);\n        write(TransVarB);\n        closeArchiveEntry();\n    }\n\n```",
            "method_doc": " Writes a PAX extended header with the given map as contents. @since 1.4 ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
            "class_doc": " The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe single failed test `testWriteNonAsciiDirectoryNamePosixMode` exhibits a consistent failure pattern:\n\n- **Failure Point**: All failures occur at `putArchiveEntry()` method call\n- **Error Type**: `IOException` with message \"request to write '15' bytes exceeds size in header of '0' bytes\"\n- **Context**: The error happens specifically when writing PAX headers for non-ASCII directory names\n- **Location**: The stack trace consistently points to `TarArchiveOutputStream.write()` at line 387\n\n## Step 2: Examine the Specific Error\n\nThe error message indicates:\n- The code is trying to write 15 bytes of PAX header data\n- However, the header size is set to 0 bytes for the entry `./PaxHeaders.X/fvv/`\n- This creates a mismatch between the expected data size and the actual data being written\n\n## Step 3: Identify the Root Cause Pattern\n\nThe common issue across this failure is related to **PAX header handling for non-ASCII directory names**. Specifically:\n\n1. When `setAddPaxHeadersForNonAsciiNames(true)` is enabled\n2. And a directory entry with non-ASCII characters is being written\n3. The code creates PAX headers but incorrectly sets the size field to 0\n4. Later, when actually writing the PAX header data, it tries to write non-zero bytes (15 bytes in this case)\n5. This causes the size validation to fail\n\n## Step 4: Recommend Possible Defect in Production Code\n\n**Possible Defect**: In `TarArchiveOutputStream`, when creating PAX headers for directory entries with non-ASCII names, the size field for the PAX header entry is not being properly calculated and set before the actual data is written.\n\n**Specific Location**: The defect likely exists in the `writePaxHeaders()` method (line 493) or in the logic that prepares PAX header entries in `putArchiveEntry()` (line 314).\n\n**Root Cause**: The code is either:\n- Not calculating the correct size for PAX headers when the entry is a directory\n- Setting the size to 0 for directory PAX headers incorrectly\n- Failing to account for directory entries when computing PAX header sizes\n\nThe production code should ensure that when PAX headers are generated for non-ASCII directory names, the size field accurately reflects the actual byte length of the PAX header data that will be written.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it creates a PAX header entry with the correct size (TransVarPexEntry.setSize(TransVarB.length)), but the error indicates the header size is 0. The issue likely occurs when putArchiveEntry(TransVarPexEntry) is called - the directory nature of the PAX header entry may be interfering with proper size handling, or the parent class logic may be overriding the size for directory entries. The method directly handles PAX header creation for non-ASCII names and the stack trace shows the failure occurs during PAX header writing."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::putArchiveEntry(ArchiveEntry)",
            "method_code": "```java\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        final ByteBuffer encodedName = encoding.encode(entryName);\n        final int nameLen = encodedName.limit() - encodedName.position();\n        boolean paxHeaderContainsPath = false;\n        if (nameLen >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(\"path\", entryName);\n                paxHeaderContainsPath = true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                longLinkEntry.setSize(nameLen + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), nameLen);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entryName\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(entry.getLinkName())) {\n            paxHeaders.put(\"linkpath\", entry.getLinkName());\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, encoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n```",
            "method_doc": " Put an entry on the output stream. This writes the entry's header record and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry's contents. Once the contents are written, closeArchiveEntry() <B>MUST</B> be called to ensure that all buffered data is completely written to the output stream.  @param archiveEntry The TarEntry to be written to the archive. @throws IOException on error @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
            "class_doc": " The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe single failed test `testWriteNonAsciiDirectoryNamePosixMode` exhibits a consistent failure pattern:\n\n- **Failure Point**: All failures occur at `putArchiveEntry()` method call\n- **Error Type**: `IOException` with message \"request to write '15' bytes exceeds size in header of '0' bytes\"\n- **Context**: The error happens specifically when writing PAX headers for non-ASCII directory names\n- **Location**: The stack trace consistently points to `TarArchiveOutputStream.write()` at line 387\n\n## Step 2: Examine the Specific Error\n\nThe error message indicates:\n- The code is trying to write 15 bytes of PAX header data\n- However, the header size is set to 0 bytes for the entry `./PaxHeaders.X/fvv/`\n- This creates a mismatch between the expected data size and the actual data being written\n\n## Step 3: Identify the Root Cause Pattern\n\nThe common issue across this failure is related to **PAX header handling for non-ASCII directory names**. Specifically:\n\n1. When `setAddPaxHeadersForNonAsciiNames(true)` is enabled\n2. And a directory entry with non-ASCII characters is being written\n3. The code creates PAX headers but incorrectly sets the size field to 0\n4. Later, when actually writing the PAX header data, it tries to write non-zero bytes (15 bytes in this case)\n5. This causes the size validation to fail\n\n## Step 4: Recommend Possible Defect in Production Code\n\n**Possible Defect**: In `TarArchiveOutputStream`, when creating PAX headers for directory entries with non-ASCII names, the size field for the PAX header entry is not being properly calculated and set before the actual data is written.\n\n**Specific Location**: The defect likely exists in the `writePaxHeaders()` method (line 493) or in the logic that prepares PAX header entries in `putArchiveEntry()` (line 314).\n\n**Root Cause**: The code is either:\n- Not calculating the correct size for PAX headers when the entry is a directory\n- Setting the size to 0 for directory PAX headers incorrectly\n- Failing to account for directory entries when computing PAX header sizes\n\nThe production code should ensure that when PAX headers are generated for non-ASCII directory names, the size field accurately reflects the actual byte length of the PAX header data that will be written.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location that needs to be fixed because the stack trace shows the failure occurs specifically at the putArchiveEntry method call when writing PAX headers for non-ASCII directory names. The method contains the logic for handling PAX headers and calls writePaxHeaders, but when dealing with directory entries, it sets currSize = 0, which may conflict with the actual size of PAX header data being written later. The error about writing 15 bytes exceeding the header size of 0 bytes directly relates to this size mismatch in PAX header handling for directories."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::write(byte[],int,int)",
            "method_code": "```java\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n```",
            "method_doc": " Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by TarBuffer, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers.  @param wBuf The buffer to write to the archive. @param wOffset The offset in the buffer from which to get bytes. @param numToWrite The number of bytes to write. @throws IOException on error ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
            "class_doc": " The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe single failed test `testWriteNonAsciiDirectoryNamePosixMode` exhibits a consistent failure pattern:\n\n- **Failure Point**: All failures occur at `putArchiveEntry()` method call\n- **Error Type**: `IOException` with message \"request to write '15' bytes exceeds size in header of '0' bytes\"\n- **Context**: The error happens specifically when writing PAX headers for non-ASCII directory names\n- **Location**: The stack trace consistently points to `TarArchiveOutputStream.write()` at line 387\n\n## Step 2: Examine the Specific Error\n\nThe error message indicates:\n- The code is trying to write 15 bytes of PAX header data\n- However, the header size is set to 0 bytes for the entry `./PaxHeaders.X/fvv/`\n- This creates a mismatch between the expected data size and the actual data being written\n\n## Step 3: Identify the Root Cause Pattern\n\nThe common issue across this failure is related to **PAX header handling for non-ASCII directory names**. Specifically:\n\n1. When `setAddPaxHeadersForNonAsciiNames(true)` is enabled\n2. And a directory entry with non-ASCII characters is being written\n3. The code creates PAX headers but incorrectly sets the size field to 0\n4. Later, when actually writing the PAX header data, it tries to write non-zero bytes (15 bytes in this case)\n5. This causes the size validation to fail\n\n## Step 4: Recommend Possible Defect in Production Code\n\n**Possible Defect**: In `TarArchiveOutputStream`, when creating PAX headers for directory entries with non-ASCII names, the size field for the PAX header entry is not being properly calculated and set before the actual data is written.\n\n**Specific Location**: The defect likely exists in the `writePaxHeaders()` method (line 493) or in the logic that prepares PAX header entries in `putArchiveEntry()` (line 314).\n\n**Root Cause**: The code is either:\n- Not calculating the correct size for PAX headers when the entry is a directory\n- Setting the size to 0 for directory PAX headers incorrectly\n- Failing to account for directory entries when computing PAX header sizes\n\nThe production code should ensure that when PAX headers are generated for non-ASCII directory names, the size field accurately reflects the actual byte length of the PAX header data that will be written.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest",
            "score": 3,
            "reason": "#3# The write method itself appears to be correctly implementing size validation logic, but the issue is likely upstream where the currSize field is being set incorrectly for PAX header entries. The write method is throwing the exception because it's detecting a mismatch between expected and actual data sizes, but the root cause is probably in the putArchiveEntry or writePaxHeaders methods that set up the entry parameters before writing begins."
        },
        {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::setAddPaxHeadersForNonAsciiNames(boolean)",
            "method_code": "```java\n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }\n\n```",
            "method_doc": " Whether to add a PAX extension header for non-ASCII file names. @since 1.4 ",
            "class_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream",
            "class_doc": " The TarOutputStream writes a UNIX tar archive as an OutputStream. Methods are provided to put entries, and then write their contents by writing to this stream using write(). @NotThreadSafe ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe single failed test `testWriteNonAsciiDirectoryNamePosixMode` exhibits a consistent failure pattern:\n\n- **Failure Point**: All failures occur at `putArchiveEntry()` method call\n- **Error Type**: `IOException` with message \"request to write '15' bytes exceeds size in header of '0' bytes\"\n- **Context**: The error happens specifically when writing PAX headers for non-ASCII directory names\n- **Location**: The stack trace consistently points to `TarArchiveOutputStream.write()` at line 387\n\n## Step 2: Examine the Specific Error\n\nThe error message indicates:\n- The code is trying to write 15 bytes of PAX header data\n- However, the header size is set to 0 bytes for the entry `./PaxHeaders.X/fvv/`\n- This creates a mismatch between the expected data size and the actual data being written\n\n## Step 3: Identify the Root Cause Pattern\n\nThe common issue across this failure is related to **PAX header handling for non-ASCII directory names**. Specifically:\n\n1. When `setAddPaxHeadersForNonAsciiNames(true)` is enabled\n2. And a directory entry with non-ASCII characters is being written\n3. The code creates PAX headers but incorrectly sets the size field to 0\n4. Later, when actually writing the PAX header data, it tries to write non-zero bytes (15 bytes in this case)\n5. This causes the size validation to fail\n\n## Step 4: Recommend Possible Defect in Production Code\n\n**Possible Defect**: In `TarArchiveOutputStream`, when creating PAX headers for directory entries with non-ASCII names, the size field for the PAX header entry is not being properly calculated and set before the actual data is written.\n\n**Specific Location**: The defect likely exists in the `writePaxHeaders()` method (line 493) or in the logic that prepares PAX header entries in `putArchiveEntry()` (line 314).\n\n**Root Cause**: The code is either:\n- Not calculating the correct size for PAX headers when the entry is a directory\n- Setting the size to 0 for directory PAX headers incorrectly\n- Failing to account for directory entries when computing PAX header sizes\n\nThe production code should ensure that when PAX headers are generated for non-ASCII directory names, the size field accurately reflects the actual byte length of the PAX header data that will be written.",
            "test_suite": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest",
            "score": 1,
            "reason": "#1# This method is not the best location that needs to be fixed because it's a simple setter method that only assigns a boolean value to a field, and the actual bug occurs in the PAX header writing logic during putArchiveEntry operations."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::setAddPaxHeadersForNonAsciiNames(boolean)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::setAddPaxHeadersForNonAsciiNames(boolean)",
            "method_code": "```java\n    public void setAddPaxHeadersForNonAsciiNames(boolean b) {\n        addPaxHeadersForNonAsciiNames = b;\n    }\n\n```",
            "method_doc": " Whether to add a PAX extension header for non-ASCII file names. @since 1.4 "
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::writePaxHeaders(String,Map)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::writePaxHeaders(String,Map)",
            "method_code": "```java\n    void writePaxHeaders(String TransVarEntry,\n                         Map<String, String> TransVarHeaderMap) throws IOException {\n        if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n        String TransVarEntryName = \"./PaxHeaders.X/\" + stripTo7Bits(TransVarEntry);\n            // TarEntry's constructor would think this is a directory\n            // and not allow any data to be written\n        if (!(!(TransVarEntryName.length() >= TarConstants.NAMELEN))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            TransVarEntryName = TransVarEntryName.substring(0, TarConstants.NAMELEN - 1);\n        }\n        TarArchiveEntry TransVarPexEntry = new TarArchiveEntry(TransVarEntryName,\n                                                  TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n        StringWriter TransVarWriter = new StringWriter();\n        for (Map.Entry<String, String> TransVarHeader : TransVarHeaderMap.entrySet()) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarKeyName = TransVarHeader.getKey();\n            String TransVarVal = TransVarHeader.getValue();\n            int TransVarLength = TransVarKeyName.length() + TransVarVal.length()\n                + 3 /* blank, equals and newline */\n                + 2 /* guess 9 < actual length < 100 */;\n            String TransVarEntryLine = TransVarLength + \" \" + TransVarKeyName + \"=\" + TransVarVal + \"\\n\";\n            int TransVarActualLen = TransVarEntryLine.getBytes(CharsetNames.UTF_8).length;\n            for (; !(!(TransVarLength != TransVarActualLen));) {\n                TransVarLength = TransVarActualLen;\n                TransVarEntryLine = TransVarLength + \" \" + TransVarKeyName + \"=\" + TransVarVal + \"\\n\";\n                TransVarActualLen = TransVarEntryLine.getBytes(CharsetNames.UTF_8).length;\n            }\n            TransVarWriter.write(TransVarEntryLine);\n        }\n        byte[] TransVarB = TransVarWriter.toString().getBytes(CharsetNames.UTF_8);\n        TransVarPexEntry.setSize(TransVarB.length);\n        putArchiveEntry(TransVarPexEntry);\n        write(TransVarB);\n        closeArchiveEntry();\n    }\n\n```",
            "method_doc": " Writes a PAX extended header with the given map as contents. @since 1.4 "
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::putArchiveEntry(ArchiveEntry)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::putArchiveEntry(ArchiveEntry)",
            "method_code": "```java\n    @Override\n    public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n        if(finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n        Map<String, String> paxHeaders = new HashMap<String, String>();\n        final String entryName = entry.getName();\n        final ByteBuffer encodedName = encoding.encode(entryName);\n        final int nameLen = encodedName.limit() - encodedName.position();\n        boolean paxHeaderContainsPath = false;\n        if (nameLen >= TarConstants.NAMELEN) {\n\n            if (longFileMode == LONGFILE_POSIX) {\n                paxHeaders.put(\"path\", entryName);\n                paxHeaderContainsPath = true;\n            } else if (longFileMode == LONGFILE_GNU) {\n                // create a TarEntry for the LongLink, the contents\n                // of which are the entry's name\n                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n                                                                    TarConstants.LF_GNUTYPE_LONGNAME);\n\n                longLinkEntry.setSize(nameLen + 1); // +1 for NUL\n                putArchiveEntry(longLinkEntry);\n                write(encodedName.array(), encodedName.arrayOffset(), nameLen);\n                write(0); // NUL terminator\n                closeArchiveEntry();\n            } else if (longFileMode != LONGFILE_TRUNCATE) {\n                throw new RuntimeException(\"file name '\" + entryName\n                                           + \"' is too long ( > \"\n                                           + TarConstants.NAMELEN + \" bytes)\");\n            }\n        }\n\n        if (bigNumberMode == BIGNUMBER_POSIX) {\n            addPaxHeadersForBigNumbers(paxHeaders, entry);\n        } else if (bigNumberMode != BIGNUMBER_STAR) {\n            failForBigNumbers(entry);\n        }\n\n        if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath\n            && !ASCII.canEncode(entryName)) {\n            paxHeaders.put(\"path\", entryName);\n        }\n\n        if (addPaxHeadersForNonAsciiNames\n            && (entry.isLink() || entry.isSymbolicLink())\n            && !ASCII.canEncode(entry.getLinkName())) {\n            paxHeaders.put(\"linkpath\", entry.getLinkName());\n        }\n\n        if (paxHeaders.size() > 0) {\n            writePaxHeaders(entryName, paxHeaders);\n        }\n\n        entry.writeEntryHeader(recordBuf, encoding,\n                               bigNumberMode == BIGNUMBER_STAR);\n        buffer.writeRecord(recordBuf);\n\n        currBytes = 0;\n\n        if (entry.isDirectory()) {\n            currSize = 0;\n        } else {\n            currSize = entry.getSize();\n        }\n        currName = entryName;\n        haveUnclosedEntry = true;\n    }\n\n```",
            "method_doc": " Put an entry on the output stream. This writes the entry's header record and positions the output stream for writing the contents of the entry. Once this method is called, the stream is ready for calls to write() to write the entry's contents. Once the contents are written, closeArchiveEntry() <B>MUST</B> be called to ensure that all buffered data is completely written to the output stream.  @param archiveEntry The TarEntry to be written to the archive. @throws IOException on error @throws ClassCastException if archiveEntry is not an instance of TarArchiveEntry "
        },
        "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::write(byte[],int,int)": {
            "method_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream::write(byte[],int,int)",
            "method_code": "```java\n    @Override\n    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n        if ((currBytes + numToWrite) > currSize) {\n            throw new IOException(\"request to write '\" + numToWrite\n                                  + \"' bytes exceeds size in header of '\"\n                                  + currSize + \"' bytes for entry '\"\n                                  + currName + \"'\");\n\n            //\n            // We have to deal with assembly!!!\n            // The programmer can be writing little 32 byte chunks for all\n            // we know, and we must assemble complete records for writing.\n            // REVIEW Maybe this should be in TarBuffer? Could that help to\n            // eliminate some of the buffer copying.\n            //\n        }\n\n        if (assemLen > 0) {\n            if ((assemLen + numToWrite) >= recordBuf.length) {\n                int aLen = recordBuf.length - assemLen;\n\n                System.arraycopy(assemBuf, 0, recordBuf, 0,\n                                 assemLen);\n                System.arraycopy(wBuf, wOffset, recordBuf,\n                                 assemLen, aLen);\n                buffer.writeRecord(recordBuf);\n\n                currBytes += recordBuf.length;\n                wOffset += aLen;\n                numToWrite -= aLen;\n                assemLen = 0;\n            } else {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                wOffset += numToWrite;\n                assemLen += numToWrite;\n                numToWrite = 0;\n            }\n        }\n\n        //\n        // When we get here we have EITHER:\n        // o An empty \"assemble\" buffer.\n        // o No bytes to write (numToWrite == 0)\n        //\n        while (numToWrite > 0) {\n            if (numToWrite < recordBuf.length) {\n                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n                                 numToWrite);\n\n                assemLen += numToWrite;\n\n                break;\n            }\n\n            buffer.writeRecord(wBuf, wOffset);\n\n            int num = recordBuf.length;\n\n            currBytes += num;\n            numToWrite -= num;\n            wOffset += num;\n        }\n    }\n\n```",
            "method_doc": " Writes bytes to the current tar archive entry. This method is aware of the current entry and will throw an exception if you attempt to write bytes past the length specified for the current entry. The method is also (painfully) aware of the record buffering required by TarBuffer, and manages buffers that are not a multiple of recordsize in length, including assembling records from small buffers.  @param wBuf The buffer to write to the archive. @param wOffset The offset in the buffer from which to get bytes. @param numToWrite The number of bytes to write. @throws IOException on error "
        }
    }
}