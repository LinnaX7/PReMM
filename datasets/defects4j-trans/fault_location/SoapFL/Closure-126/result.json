{
    "buggy_classes": [
        "com.google.javascript.jscomp.MinimizeExitPoints"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.MinimizeExitPoints::tryMinimizeExits(Node,int,String)",
            "method_code": "```java\n  void tryMinimizeExits(Node TransVarNode, int TransVarExitCode, String TransVarName) {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Just an 'exit'.\n    if (!(!(matchingExitNode(TransVarNode, TransVarExitCode, TransVarName)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    NodeUtil.removeChild(TransVarNode.getParent(), TransVarNode);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (!(!(TransVarNode.isIf()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n      }\n    Node TransVarIfNode = TransVarNode.getFirstChild().getNext();\n      tryMinimizeExits(TransVarIfNode, TransVarExitCode, TransVarName);\n      Node TransVarElseNode = TransVarIfNode.getNext();\n      if (!(!(TransVarElseNode != null))) {\n        tryMinimizeExits(TransVarElseNode, TransVarExitCode, TransVarName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (!(!(TransVarNode.isTry()))) {\n      Node TransVarTryNode = TransVarNode.getFirstChild();\n      tryMinimizeExits(TransVarTryNode, TransVarExitCode, TransVarName);\n      Node TransVarAllCatch = NodeUtil.getCatchBlock(TransVarNode);\n      if (!(!(NodeUtil.hasCatchHandler(TransVarAllCatch)))) {\n        Preconditions.checkState(TransVarAllCatch.hasOneChild());\n        Node TransVarCatchNode2 = TransVarAllCatch.getFirstChild();\n        Node TransVarCatchCodeBlockInCatch = TransVarCatchNode2.getLastChild();\n        tryMinimizeExits(TransVarCatchCodeBlockInCatch, TransVarExitCode, TransVarName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (!(!(NodeUtil.hasFinally(TransVarNode)))) {\n        Node TransVarFinallyBlockNode = TransVarNode.getLastChild();\n        tryMinimizeExits(TransVarFinallyBlockNode, TransVarExitCode, TransVarName);\n    }\n    }\n\n    // Just a 'label'.\n    if (!(!(TransVarNode.isLabel()))) {\n      Node TransVarLabel = TransVarNode.getLastChild();\n      tryMinimizeExits(TransVarLabel, TransVarExitCode, TransVarName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!(!(!TransVarNode.isBlock() || TransVarNode.getLastChild() == null))) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node TransVarD : TransVarNode.children()) {\n\n      // An 'if' block to process below.\n      if (!(!(TransVarD.isIf()))) {\n        Node TransVarNode3 = TransVarD;\n        Node TransVarTrueBlockNode, TransVarFalseBlockNode;\n\n        // First, the true condition block.\n        TransVarTrueBlockNode = TransVarNode3.getFirstChild().getNext();\n        TransVarFalseBlockNode = TransVarTrueBlockNode.getNext();\n        tryMinimizeIfBlockExits(TransVarTrueBlockNode, TransVarFalseBlockNode,\n            TransVarNode3, TransVarExitCode, TransVarName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        TransVarTrueBlockNode = TransVarNode3.getFirstChild().getNext();\n        TransVarFalseBlockNode = TransVarTrueBlockNode.getNext();\n        if (!(!(TransVarFalseBlockNode != null))) {\n          tryMinimizeIfBlockExits(TransVarFalseBlockNode, TransVarTrueBlockNode,\n              TransVarNode3, TransVarExitCode, TransVarName);\n        }\n      }\n\n      if (!(!(TransVarD == TransVarNode.getLastChild()))) {\n        break;\n      }\n    }\n\n    Node TransVarCNode = TransVarNode.getLastChild();\n    while (!(!(TransVarCNode != null))) {\n        tryMinimizeExits(TransVarCNode, TransVarExitCode, TransVarName);\n        if (!(!(TransVarCNode == TransVarNode.getLastChild()))) {\n        break;\n      }\n        TransVarCNode = TransVarNode.getLastChild();\n    }\n  }\n\n```",
            "method_doc": " Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example:  function () { if (x) return; else blah(); foo(); }  becomes:  function () { if (x) ; else { blah(); foo(); }  @param n The execution node of a parent to inspect. @param exitType The type of exit to look for. @param labelName If parent is a label the name of the label to look for, null otherwise. @nullable labelName non-null only for breaks within labels. ",
            "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
            "class_doc": " Transform the structure of the AST so that the number of explicit exits are minimized.  ",
            "test_failure_causes": "Looking at these two test failures, I can identify a clear common pattern and recommend the likely defect in the production code.\n\n## Analysis of Common Patterns\n\n**Similarity 1: Control Flow in Finally Blocks**\nBoth test failures involve incorrect handling of control flow statements within `finally` blocks:\n- `testDontRemoveBreakInTryFinally`: The `break` statement in the `finally` block is being incorrectly removed\n- `testFunctionReturnOptimization`: The `return` statement in the `finally` block is being incorrectly removed\n\n**Similarity 2: Exit Point Optimization Gone Wrong**\nIn both cases, the `MinimizeExitPoints` compiler pass is being too aggressive in removing exit points that should be preserved:\n- Test 1: `break b` in `finally {break b}` is removed when it should be kept\n- Test 2: `return` in `finally{return}` is removed when it should be kept\n\n**Similarity 3: Context-Sensitive Behavior**\nThe failures occur specifically when exit points appear in `finally` blocks that are part of more complex control structures (labeled try blocks and try-catch-finally combinations).\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `MinimizeExitPoints` compiler pass where the logic for determining when to remove exit points fails to properly account for the special semantics of `finally` blocks in JavaScript.\n\n**Specifically, the defect appears to be:** The optimization logic incorrectly treats exit points (`break`, `return`) in `finally` blocks as removable when they are actually essential for correct program behavior.\n\nIn JavaScript, `finally` blocks have unique control flow semantics - they always execute (unless the process terminates), and exit points within them can affect the overall control flow. The current implementation seems to be applying the same removal criteria to `finally` blocks as it does to regular blocks, without considering that exit points in `finally` blocks may be targeting outer labeled statements or affecting the function's return behavior.\n\nThe fix should ensure that exit points in `finally` blocks are preserved when they are necessary for correct control flow, particularly when they reference outer labels or when they are the only exit point from a function in certain code paths.",
            "test_suite": "com.google.javascript.jscomp.MinimizeExitPointsTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it contains the specific logic for handling try-finally blocks where the bug manifests. The method processes try blocks and their finally blocks, and the comment explicitly mentions not minimizing exits in finally blocks due to potential problems with completion types, yet the code still calls tryMinimizeExits on finally blocks, which is incorrectly removing break and return statements that should be preserved according to ECMA 262 semantics."
        },
        {
            "method_name": "com.google.javascript.jscomp.MinimizeExitPoints::matchingExitNode(Node,int,String)",
            "method_code": "```java\n  private static boolean matchingExitNode(Node n, int type, String labelName) {\n    if (n.getType() == type) {\n      if (type == Token.RETURN) {\n        // only returns without expressions.\n        return !n.hasChildren();\n      } else {\n        if (labelName == null) {\n          return !n.hasChildren();\n        } else {\n          return n.hasChildren()\n            && labelName.equals(n.getFirstChild().getString());\n        }\n      }\n    }\n    return false;\n  }\n\n```",
            "method_doc": " Determines if n matches the type and name for the following types of \"exits\": - return without values - continues and breaks with or without names. @param n The node to inspect. @param type The Token type to look for. @param labelName The name that must be associated with the exit type. @nullable labelName non-null only for breaks associated with labels. @return Whether the node matches the specified block-exit type. ",
            "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
            "class_doc": " Transform the structure of the AST so that the number of explicit exits are minimized.  ",
            "test_failure_causes": "Looking at these two test failures, I can identify a clear common pattern and recommend the likely defect in the production code.\n\n## Analysis of Common Patterns\n\n**Similarity 1: Control Flow in Finally Blocks**\nBoth test failures involve incorrect handling of control flow statements within `finally` blocks:\n- `testDontRemoveBreakInTryFinally`: The `break` statement in the `finally` block is being incorrectly removed\n- `testFunctionReturnOptimization`: The `return` statement in the `finally` block is being incorrectly removed\n\n**Similarity 2: Exit Point Optimization Gone Wrong**\nIn both cases, the `MinimizeExitPoints` compiler pass is being too aggressive in removing exit points that should be preserved:\n- Test 1: `break b` in `finally {break b}` is removed when it should be kept\n- Test 2: `return` in `finally{return}` is removed when it should be kept\n\n**Similarity 3: Context-Sensitive Behavior**\nThe failures occur specifically when exit points appear in `finally` blocks that are part of more complex control structures (labeled try blocks and try-catch-finally combinations).\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `MinimizeExitPoints` compiler pass where the logic for determining when to remove exit points fails to properly account for the special semantics of `finally` blocks in JavaScript.\n\n**Specifically, the defect appears to be:** The optimization logic incorrectly treats exit points (`break`, `return`) in `finally` blocks as removable when they are actually essential for correct program behavior.\n\nIn JavaScript, `finally` blocks have unique control flow semantics - they always execute (unless the process terminates), and exit points within them can affect the overall control flow. The current implementation seems to be applying the same removal criteria to `finally` blocks as it does to regular blocks, without considering that exit points in `finally` blocks may be targeting outer labeled statements or affecting the function's return behavior.\n\nThe fix should ensure that exit points in `finally` blocks are preserved when they are necessary for correct control flow, particularly when they reference outer labels or when they are the only exit point from a function in certain code paths.",
            "test_suite": "com.google.javascript.jscomp.MinimizeExitPointsTest",
            "score": 8,
            "reason": "#8# The matchingExitNode method is highly suspicious because it's the core logic that determines which exit points to remove, and both test failures involve incorrect removal of break/return statements in finally blocks. The method currently only checks if nodes match certain exit types but doesn't consider the critical context of finally blocks, where exit points should be preserved due to JavaScript's unique control flow semantics. The failures show break and return statements being incorrectly removed from finally blocks, indicating this method's matching logic needs enhancement to properly handle finally block contexts."
        },
        {
            "method_name": "com.google.javascript.jscomp.MinimizeExitPoints::tryMinimizeIfBlockExits(Node,Node,Node,int,String)",
            "method_code": "```java\n  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\n      if (!srcBlock.hasChildren()) {\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n      compiler.reportCodeChange();\n    }\n  }\n\n```",
            "method_doc": " Look for exits (returns, breaks, or continues, depending on the context) at the end of a block and removes them by moving the if node's siblings, if any, into the opposite condition block.  @param srcBlock The block to inspect. @param destBlock The block to move sibling nodes into. @param ifNode The if node to work with. @param exitType The type of exit to look for. @param labelName The name associated with the exit, if any. @nullable labelName null for anything excepted for named-break associated with a label. ",
            "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
            "class_doc": " Transform the structure of the AST so that the number of explicit exits are minimized.  ",
            "test_failure_causes": "Looking at these two test failures, I can identify a clear common pattern and recommend the likely defect in the production code.\n\n## Analysis of Common Patterns\n\n**Similarity 1: Control Flow in Finally Blocks**\nBoth test failures involve incorrect handling of control flow statements within `finally` blocks:\n- `testDontRemoveBreakInTryFinally`: The `break` statement in the `finally` block is being incorrectly removed\n- `testFunctionReturnOptimization`: The `return` statement in the `finally` block is being incorrectly removed\n\n**Similarity 2: Exit Point Optimization Gone Wrong**\nIn both cases, the `MinimizeExitPoints` compiler pass is being too aggressive in removing exit points that should be preserved:\n- Test 1: `break b` in `finally {break b}` is removed when it should be kept\n- Test 2: `return` in `finally{return}` is removed when it should be kept\n\n**Similarity 3: Context-Sensitive Behavior**\nThe failures occur specifically when exit points appear in `finally` blocks that are part of more complex control structures (labeled try blocks and try-catch-finally combinations).\n\n## Recommended Defect in Production Code\n\nThe likely defect is in the `MinimizeExitPoints` compiler pass where the logic for determining when to remove exit points fails to properly account for the special semantics of `finally` blocks in JavaScript.\n\n**Specifically, the defect appears to be:** The optimization logic incorrectly treats exit points (`break`, `return`) in `finally` blocks as removable when they are actually essential for correct program behavior.\n\nIn JavaScript, `finally` blocks have unique control flow semantics - they always execute (unless the process terminates), and exit points within them can affect the overall control flow. The current implementation seems to be applying the same removal criteria to `finally` blocks as it does to regular blocks, without considering that exit points in `finally` blocks may be targeting outer labeled statements or affecting the function's return behavior.\n\nThe fix should ensure that exit points in `finally` blocks are preserved when they are necessary for correct control flow, particularly when they reference outer labels or when they are the only exit point from a function in certain code paths.",
            "test_suite": "com.google.javascript.jscomp.MinimizeExitPointsTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles exit point optimization and both test failures involve incorrect removal of exit statements (break and return) in finally blocks. The method's logic for identifying and removing exit nodes doesn't properly account for the special semantics of finally blocks where exit points should be preserved when they reference outer labels or affect function return behavior."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.MinimizeExitPoints::tryMinimizeExits(Node,int,String)": {
            "method_name": "com.google.javascript.jscomp.MinimizeExitPoints::tryMinimizeExits(Node,int,String)",
            "method_code": "```java\n  void tryMinimizeExits(Node TransVarNode, int TransVarExitCode, String TransVarName) {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Just an 'exit'.\n    if (!(!(matchingExitNode(TransVarNode, TransVarExitCode, TransVarName)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    NodeUtil.removeChild(TransVarNode.getParent(), TransVarNode);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (!(!(TransVarNode.isIf()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n      }\n    Node TransVarIfNode = TransVarNode.getFirstChild().getNext();\n      tryMinimizeExits(TransVarIfNode, TransVarExitCode, TransVarName);\n      Node TransVarElseNode = TransVarIfNode.getNext();\n      if (!(!(TransVarElseNode != null))) {\n        tryMinimizeExits(TransVarElseNode, TransVarExitCode, TransVarName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (!(!(TransVarNode.isTry()))) {\n      Node TransVarTryNode = TransVarNode.getFirstChild();\n      tryMinimizeExits(TransVarTryNode, TransVarExitCode, TransVarName);\n      Node TransVarAllCatch = NodeUtil.getCatchBlock(TransVarNode);\n      if (!(!(NodeUtil.hasCatchHandler(TransVarAllCatch)))) {\n        Preconditions.checkState(TransVarAllCatch.hasOneChild());\n        Node TransVarCatchNode2 = TransVarAllCatch.getFirstChild();\n        Node TransVarCatchCodeBlockInCatch = TransVarCatchNode2.getLastChild();\n        tryMinimizeExits(TransVarCatchCodeBlockInCatch, TransVarExitCode, TransVarName);\n      }\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (!(!(NodeUtil.hasFinally(TransVarNode)))) {\n        Node TransVarFinallyBlockNode = TransVarNode.getLastChild();\n        tryMinimizeExits(TransVarFinallyBlockNode, TransVarExitCode, TransVarName);\n    }\n    }\n\n    // Just a 'label'.\n    if (!(!(TransVarNode.isLabel()))) {\n      Node TransVarLabel = TransVarNode.getLastChild();\n      tryMinimizeExits(TransVarLabel, TransVarExitCode, TransVarName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!(!(!TransVarNode.isBlock() || TransVarNode.getLastChild() == null))) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node TransVarD : TransVarNode.children()) {\n\n      // An 'if' block to process below.\n      if (!(!(TransVarD.isIf()))) {\n        Node TransVarNode3 = TransVarD;\n        Node TransVarTrueBlockNode, TransVarFalseBlockNode;\n\n        // First, the true condition block.\n        TransVarTrueBlockNode = TransVarNode3.getFirstChild().getNext();\n        TransVarFalseBlockNode = TransVarTrueBlockNode.getNext();\n        tryMinimizeIfBlockExits(TransVarTrueBlockNode, TransVarFalseBlockNode,\n            TransVarNode3, TransVarExitCode, TransVarName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        TransVarTrueBlockNode = TransVarNode3.getFirstChild().getNext();\n        TransVarFalseBlockNode = TransVarTrueBlockNode.getNext();\n        if (!(!(TransVarFalseBlockNode != null))) {\n          tryMinimizeIfBlockExits(TransVarFalseBlockNode, TransVarTrueBlockNode,\n              TransVarNode3, TransVarExitCode, TransVarName);\n        }\n      }\n\n      if (!(!(TransVarD == TransVarNode.getLastChild()))) {\n        break;\n      }\n    }\n\n    Node TransVarCNode = TransVarNode.getLastChild();\n    while (!(!(TransVarCNode != null))) {\n        tryMinimizeExits(TransVarCNode, TransVarExitCode, TransVarName);\n        if (!(!(TransVarCNode == TransVarNode.getLastChild()))) {\n        break;\n      }\n        TransVarCNode = TransVarNode.getLastChild();\n    }\n  }\n\n```",
            "method_doc": " Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example:  function () { if (x) return; else blah(); foo(); }  becomes:  function () { if (x) ; else { blah(); foo(); }  @param n The execution node of a parent to inspect. @param exitType The type of exit to look for. @param labelName If parent is a label the name of the label to look for, null otherwise. @nullable labelName non-null only for breaks within labels. "
        },
        "com.google.javascript.jscomp.MinimizeExitPoints::matchingExitNode(Node,int,String)": {
            "method_name": "com.google.javascript.jscomp.MinimizeExitPoints::matchingExitNode(Node,int,String)",
            "method_code": "```java\n  private static boolean matchingExitNode(Node n, int type, String labelName) {\n    if (n.getType() == type) {\n      if (type == Token.RETURN) {\n        // only returns without expressions.\n        return !n.hasChildren();\n      } else {\n        if (labelName == null) {\n          return !n.hasChildren();\n        } else {\n          return n.hasChildren()\n            && labelName.equals(n.getFirstChild().getString());\n        }\n      }\n    }\n    return false;\n  }\n\n```",
            "method_doc": " Determines if n matches the type and name for the following types of \"exits\": - return without values - continues and breaks with or without names. @param n The node to inspect. @param type The Token type to look for. @param labelName The name that must be associated with the exit type. @nullable labelName non-null only for breaks associated with labels. @return Whether the node matches the specified block-exit type. "
        },
        "com.google.javascript.jscomp.MinimizeExitPoints::tryMinimizeIfBlockExits(Node,Node,Node,int,String)": {
            "method_name": "com.google.javascript.jscomp.MinimizeExitPoints::tryMinimizeIfBlockExits(Node,Node,Node,int,String)",
            "method_code": "```java\n  private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,\n      Node ifNode, int exitType, String labelName) {\n    Node exitNodeParent = null;\n    Node exitNode = null;\n\n    // Pick an exit node candidate.\n    if (srcBlock.isBlock()) {\n      if (!srcBlock.hasChildren()) {\n        return;\n      }\n      exitNodeParent = srcBlock;\n      exitNode = exitNodeParent.getLastChild();\n    } else {\n      // Just a single statement, if it isn't an exit bail.\n      exitNodeParent = ifNode;\n      exitNode = srcBlock;\n    }\n\n    // Verify the candidate.\n    if (!matchingExitNode(exitNode, exitType, labelName)) {\n      return;\n    }\n\n    // Take case of the if nodes siblings, if any.\n    if (ifNode.getNext() != null) {\n      // Move siblings of the if block into the opposite\n      // logic block of the exit.\n      Node newDestBlock = IR.block().srcref(ifNode);\n      if (destBlock == null) {\n        // Only possible if this is the false block.\n        ifNode.addChildToBack(newDestBlock);\n      } else if (destBlock.isEmpty()) {\n        // Use the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n      } else if (destBlock.isBlock()) {\n        // Reuse the existing block.\n        newDestBlock = destBlock;\n      } else {\n        // Add the existing statement to the new block.\n        ifNode.replaceChild(destBlock, newDestBlock);\n        newDestBlock.addChildToBack(destBlock);\n      }\n\n      // Move all the if node's following siblings.\n      moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);\n      compiler.reportCodeChange();\n    }\n  }\n\n```",
            "method_doc": " Look for exits (returns, breaks, or continues, depending on the context) at the end of a block and removes them by moving the if node's siblings, if any, into the opposite condition block.  @param srcBlock The block to inspect. @param destBlock The block to move sibling nodes into. @param ifNode The if node to work with. @param exitType The type of exit to look for. @param labelName The name associated with the exit, if any. @nullable labelName null for anything excepted for named-break associated with a label. "
        }
    }
}