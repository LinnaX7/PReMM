{
    "buggy_classes": [
        "org.mockito.internal.invocation.InvocationMatcher",
        "org.mockito.internal.matchers.AnyVararg"
    ],
    "buggy_methods": [
        {
            "method_name": "org.mockito.internal.invocation.InvocationMatcher::captureArgumentsFrom(Invocation)",
            "method_code": "```java\n    public void captureArgumentsFrom(Invocation TransVarInvocation0) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n                }\n        if (!(!(TransVarInvocation0.getMethod().isVarArgs()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarIndexOfLastArg = TransVarInvocation0.getRawArguments().length - 1;\n            throw new UnsupportedOperationException();\n\n        } else {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n                }\n            int TransVarIndex = 0;\n            while (!(!(TransVarIndex < matchers.size()))) {\n                Matcher TransVarMatcher = matchers.get(TransVarIndex);\n                if (!(!(TransVarMatcher instanceof CapturesArguments))) {\n                    ((CapturesArguments) TransVarMatcher)\n                            .captureFrom(TransVarInvocation0.getArgumentAt(TransVarIndex, Object.class));\n                }\n                TransVarIndex++;\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }\n\n```",
            "method_doc": "Captures arguments from the given invocation for matchers that implement CapturesArguments. Handles varargs invocations by throwing UnsupportedOperationException and processes regular arguments by iterating through matchers.",
            "class_name": "org.mockito.internal.invocation.InvocationMatcher",
            "class_doc": "",
            "test_failure_causes": "Looking at the test failures, I can identify a clear common pattern:\n\n## Common Patterns Identified:\n\n1. **Same Exception Location**: All tests fail with `UnsupportedOperationException` at the same line:\n   `org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:129)`\n\n2. **Varargs-Related Operations**: All failing tests involve varargs methods in different scenarios:\n   - Mixed regular parameters + varargs\n   - Object varargs\n   - Empty varargs\n   - String varargs\n   - Verification with matchers on varargs\n\n3. **Critical Operations**: The failures occur during core Mockito operations:\n   - Method invocation handling (stubbing)\n   - Verification of method calls\n   - Argument capturing/matching\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the `InvocationMatcher.captureArgumentsFrom()` method at line 129, specifically in how it handles varargs parameters during argument capturing. The `UnsupportedOperationException` suggests that an operation that should be supported is not implemented or is failing when processing varargs.\n\n**Likely Root Cause**: The argument capturing logic in `InvocationMatcher` is not properly handling varargs arrays, particularly when:\n- Varargs arrays are null\n- Varargs arrays are empty  \n- Varargs contain mixed object types\n- Varargs are used with matchers like `anyObject()` or `anyVararg()`\n\nThe method is likely attempting to perform an unsupported operation on varargs arrays, such as trying to modify an immutable array, accessing out-of-bounds elements, or improperly handling null/empty varargs scenarios.\n\nThis would explain why all varargs-related tests are failing consistently at the same point in the argument processing pipeline, regardless of whether the operation is stubbing, verification, or argument matching.",
            "test_suite": "org.mockitousage.basicapi.UsingVarargsTest",
            "score": 10,
            "reason": "#10# This method is definitely the best location that needs to be fixed because it explicitly throws UnsupportedOperationException for all varargs invocations at line 129, which directly matches the stack traces of all failed tests. The method's current implementation completely fails to handle varargs scenarios, instead throwing an exception that prevents any varargs-related operations from working properly, including stubbing, verification, and argument capturing with varargs methods."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.FieldInitializer$ParameterizedConstructorInstantiator::instantiate()",
            "method_code": "```java\n        public FieldInitializationReport instantiate() {\n            final AccessibilityChanger changer = new AccessibilityChanger();\n            Constructor<?> constructor = null;\n            try {\n                constructor = biggestConstructor(field.getType());\n                changer.enableAccess(constructor);\n\n                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());\n                Object newFieldInstance = constructor.newInstance(args);\n                new FieldSetter(testClass, field).set(newFieldInstance);\n\n                return new FieldInitializationReport(field.get(testClass), false, true);\n            } catch (IllegalArgumentException e) {\n                throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n            } catch (InvocationTargetException e) {\n                throw new MockitoException(\"the constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n            } catch (InstantiationException e) {\n                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n            } catch (IllegalAccessException e) {\n                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n            } finally {\n                if(constructor != null) {\n                    changer.safelyDisableAccess(constructor);\n                }\n            }\n        }\n\n```",
            "method_doc": "This method initializes a field by finding the constructor with most parameters, resolving arguments, creating an instance, and setting the field. It calls method \"biggestConstructor\" to find the appropriate constructor and handles various exception scenarios.",
            "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
            "class_doc": " Initialize a field with type instance if a default constructor can be found.  <p> If the given field is already initialized, then <strong>the actual instance is returned</strong>. This initializer doesn't work with inner classes, local classes, interfaces or abstract types. </p>  ",
            "test_failure_causes": "Based on my analysis of the test behaviors, stack traces, and failure patterns, here's my assessment:\n\n## Common Patterns Identified:\n\n1. **Consistent Failure Point**: All tests fail at the same location - when calling `ParameterizedConstructorInstantiator.instantiate()` at line 256 in FieldInitializer.java.\n\n2. **Identical Stack Trace**: All failures show the same `UnsupportedOperationException` originating from:\n   ```\n   org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:129)\n   ```\n\n3. **Mock Interaction Issue**: The exception occurs during mock handling when the `resolveTypeInstances` method is called on the mocked `resolver`.\n\n4. **Cross-Cutting Failure**: Tests fail regardless of their expected outcome (both success and failure scenarios).\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **`ParameterizedConstructorInstantiator.instantiate()` method** (specifically around line 256 in FieldInitializer.java) where it interacts with mocked `ConstructorArgumentResolver`.\n\n**Possible Root Cause**: The production code is likely making assumptions about how the mock resolver should behave that conflict with Mockito's internal handling. Specifically, it may be:\n\n1. **Incorrect Mock Interaction**: The code might be calling methods on the mock in a way that triggers Mockito's argument capturing mechanism unexpectedly, leading to the `UnsupportedOperationException` in `InvocationMatcher.captureArgumentsFrom()`.\n\n2. **Varargs Handling Issue**: Given that multiple tests involve varargs (as indicated by `Matchers.<Class<?>[]>anyVararg()`), the production code might be processing varargs parameters in a way that conflicts with Mockito's internal argument matching system.\n\n3. **Type Resolution Logic**: The instantiation logic may be making reflective calls or type checks that interfere with Mockito's proxy-based mocking system.\n\nThe defect is likely in how `ParameterizedConstructorInstantiator` handles the interaction with the mocked resolver, particularly around argument resolution and constructor invocation sequencing, which causes Mockito's internal invocation handling to fail with an unsupported operation.\n\n**Focus Area**: The bug is probably in the production code's interaction with Mockito mocks, not in the test logic itself, as all tests follow proper Mockito mocking patterns.",
            "test_suite": "org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest",
            "score": 10,
            "reason": "#10# This method is highly suspicious because all test failures occur at line 256 (constructor.newInstance(args)) where the production code interacts with the mocked resolver. The UnsupportedOperationException from InvocationMatcher.captureArgumentsFrom indicates that Mockito's internal argument capturing mechanism is being triggered unexpectedly when the production code calls argResolver.resolveTypeInstances() and then immediately uses the returned arguments in constructor.newInstance(). The issue appears to be that the production code is making assumptions about how the mock resolver behaves that conflict with Mockito's internal handling, particularly around varargs processing and argument resolution sequencing."
        },
        {
            "method_name": "org.mockito.internal.invocation.InvocationMatcher::InvocationMatcher(Invocation,List)",
            "method_code": "```java\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }\n\n```",
            "method_doc": "Constructs an InvocationMatcher with the given invocation and matchers. If matchers list is empty, converts invocation arguments to matchers using ArgumentsProcessor.",
            "class_name": "org.mockito.internal.invocation.InvocationMatcher",
            "class_doc": "",
            "test_failure_causes": "Looking at the test failures, I can identify a clear common pattern:\n\n## Common Patterns Identified:\n\n1. **Same Exception Location**: All tests fail with `UnsupportedOperationException` at the same line:\n   `org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:129)`\n\n2. **Varargs-Related Operations**: All failing tests involve varargs methods in different scenarios:\n   - Mixed regular parameters + varargs\n   - Object varargs\n   - Empty varargs\n   - String varargs\n   - Verification with matchers on varargs\n\n3. **Critical Operations**: The failures occur during core Mockito operations:\n   - Method invocation handling (stubbing)\n   - Verification of method calls\n   - Argument capturing/matching\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the `InvocationMatcher.captureArgumentsFrom()` method at line 129, specifically in how it handles varargs parameters during argument capturing. The `UnsupportedOperationException` suggests that an operation that should be supported is not implemented or is failing when processing varargs.\n\n**Likely Root Cause**: The argument capturing logic in `InvocationMatcher` is not properly handling varargs arrays, particularly when:\n- Varargs arrays are null\n- Varargs arrays are empty  \n- Varargs contain mixed object types\n- Varargs are used with matchers like `anyObject()` or `anyVararg()`\n\nThe method is likely attempting to perform an unsupported operation on varargs arrays, such as trying to modify an immutable array, accessing out-of-bounds elements, or improperly handling null/empty varargs scenarios.\n\nThis would explain why all varargs-related tests are failing consistently at the same point in the argument processing pipeline, regardless of whether the operation is stubbing, verification, or argument matching.",
            "test_suite": "org.mockitousage.basicapi.UsingVarargsTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious as it's the constructor that initializes the matchers list, and all test failures trace back to argument capturing operations that depend on these matchers. The constructor handles the conversion of invocation arguments to matchers when no explicit matchers are provided, which is critical for varargs processing. If the ArgumentsProcessor.argumentsToMatchers() method doesn't properly handle varargs arrays (especially null, empty, or mixed-type varargs), it would cause the UnsupportedOperationException seen in all test failures during subsequent argument capturing operations."
        },
        {
            "method_name": "org.mockito.internal.util.reflection.FieldInitializer$ParameterizedConstructorInstantiator::biggestConstructor(Class)",
            "method_code": "```java\n        private Constructor<?> biggestConstructor(Class<?> clazz) {\n            final List<Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());\n            Collections.sort(constructors, byParameterNumber);\n            \n            Constructor<?> constructor = constructors.get(0);\n            checkParameterized(constructor, field);\n            return constructor;\n        }\n\n```",
            "method_doc": "This method finds the constructor with the most parameters from a class, sorts all constructors by parameter count, and calls method \"checkParameterized\" to verify the selected constructor has parameters.",
            "class_name": "org.mockito.internal.util.reflection.FieldInitializer",
            "class_doc": " Initialize a field with type instance if a default constructor can be found.  <p> If the given field is already initialized, then <strong>the actual instance is returned</strong>. This initializer doesn't work with inner classes, local classes, interfaces or abstract types. </p>  ",
            "test_failure_causes": "Based on my analysis of the test behaviors, stack traces, and failure patterns, here's my assessment:\n\n## Common Patterns Identified:\n\n1. **Consistent Failure Point**: All tests fail at the same location - when calling `ParameterizedConstructorInstantiator.instantiate()` at line 256 in FieldInitializer.java.\n\n2. **Identical Stack Trace**: All failures show the same `UnsupportedOperationException` originating from:\n   ```\n   org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:129)\n   ```\n\n3. **Mock Interaction Issue**: The exception occurs during mock handling when the `resolveTypeInstances` method is called on the mocked `resolver`.\n\n4. **Cross-Cutting Failure**: Tests fail regardless of their expected outcome (both success and failure scenarios).\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **`ParameterizedConstructorInstantiator.instantiate()` method** (specifically around line 256 in FieldInitializer.java) where it interacts with mocked `ConstructorArgumentResolver`.\n\n**Possible Root Cause**: The production code is likely making assumptions about how the mock resolver should behave that conflict with Mockito's internal handling. Specifically, it may be:\n\n1. **Incorrect Mock Interaction**: The code might be calling methods on the mock in a way that triggers Mockito's argument capturing mechanism unexpectedly, leading to the `UnsupportedOperationException` in `InvocationMatcher.captureArgumentsFrom()`.\n\n2. **Varargs Handling Issue**: Given that multiple tests involve varargs (as indicated by `Matchers.<Class<?>[]>anyVararg()`), the production code might be processing varargs parameters in a way that conflicts with Mockito's internal argument matching system.\n\n3. **Type Resolution Logic**: The instantiation logic may be making reflective calls or type checks that interfere with Mockito's proxy-based mocking system.\n\nThe defect is likely in how `ParameterizedConstructorInstantiator` handles the interaction with the mocked resolver, particularly around argument resolution and constructor invocation sequencing, which causes Mockito's internal invocation handling to fail with an unsupported operation.\n\n**Focus Area**: The bug is probably in the production code's interaction with Mockito mocks, not in the test logic itself, as all tests follow proper Mockito mocking patterns.",
            "test_suite": "org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest",
            "score": 8,
            "reason": "#8# The biggestConstructor method is highly suspicious because it sorts constructors by parameter count and selects the first one (with most parameters), but this logic doesn't properly handle varargs constructors or verify constructor compatibility with provided arguments. The test failures all occur when the instantiate method calls resolveTypeInstances with constructor parameters, and if biggestConstructor selects an incompatible constructor (like a varargs constructor that requires special handling), it would cause the Mockito mock interactions to fail with UnsupportedOperationException during argument capturing."
        },
        {
            "method_name": "org.mockito.internal.invocation.InvocationMatcher::matches(Invocation)",
            "method_code": "```java\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n```",
            "method_doc": "Checks if the actual invocation matches this matcher by comparing mocks, methods, and arguments. This method calls method \"hasSameMethod\" to verify method equality and uses ArgumentsComparator for argument matching.",
            "class_name": "org.mockito.internal.invocation.InvocationMatcher",
            "class_doc": "",
            "test_failure_causes": "Looking at the test failures, I can identify a clear common pattern:\n\n## Common Patterns Identified:\n\n1. **Same Exception Location**: All tests fail with `UnsupportedOperationException` at the same line:\n   `org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:129)`\n\n2. **Varargs-Related Operations**: All failing tests involve varargs methods in different scenarios:\n   - Mixed regular parameters + varargs\n   - Object varargs\n   - Empty varargs\n   - String varargs\n   - Verification with matchers on varargs\n\n3. **Critical Operations**: The failures occur during core Mockito operations:\n   - Method invocation handling (stubbing)\n   - Verification of method calls\n   - Argument capturing/matching\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the `InvocationMatcher.captureArgumentsFrom()` method at line 129, specifically in how it handles varargs parameters during argument capturing. The `UnsupportedOperationException` suggests that an operation that should be supported is not implemented or is failing when processing varargs.\n\n**Likely Root Cause**: The argument capturing logic in `InvocationMatcher` is not properly handling varargs arrays, particularly when:\n- Varargs arrays are null\n- Varargs arrays are empty  \n- Varargs contain mixed object types\n- Varargs are used with matchers like `anyObject()` or `anyVararg()`\n\nThe method is likely attempting to perform an unsupported operation on varargs arrays, such as trying to modify an immutable array, accessing out-of-bounds elements, or improperly handling null/empty varargs scenarios.\n\nThis would explain why all varargs-related tests are failing consistently at the same point in the argument processing pipeline, regardless of whether the operation is stubbing, verification, or argument matching.",
            "test_suite": "org.mockitousage.basicapi.UsingVarargsTest",
            "score": 3,
            "reason": "#3# While the matches() method is involved in the invocation matching process, the actual failure occurs in captureArgumentsFrom() method at line 129, which is called during argument capturing operations. The matches() method itself doesn't directly handle the varargs argument capturing that's causing the UnsupportedOperationException. The root issue appears to be in the argument capturing logic rather than the basic matching comparison."
        },
        {
            "method_name": "org.mockito.internal.matchers.AnyVararg::matches(Object)",
            "method_code": "```java\n    public boolean matches(Object arg) {\n        return true;\n    }\n\n```",
            "method_doc": "This method always returns true for any argument, implementing a vararg matcher that accepts any number of arguments. It does not call any other covered methods.",
            "class_name": "org.mockito.internal.matchers.AnyVararg",
            "class_doc": "",
            "test_failure_causes": "Looking at the failed test and the stack trace, I can identify the following key patterns and potential defect:\n\n**Analysis of Common Patterns:**\n\n1. **Varargs Matching Issue**: The test is specifically testing Mockito's varargs functionality with the `anyVararg()` matcher.\n\n2. **Stack Trace Pattern**: The failure occurs in `InvocationMatcher.captureArgumentsFrom()` at line 129, with an `UnsupportedOperationException`. This suggests the framework is trying to perform an operation that isn't supported in the current context.\n\n3. **Framework-Level Failure**: The error is happening deep within Mockito's internal handling mechanism (`MockHandlerImpl.handle()` \u2192 `InvocationMatcher.captureArgumentsFrom()`), indicating this is a framework issue rather than application logic.\n\n**Recommended Possible Defect in Production Code:**\n\nThe defect appears to be in **Mockito's argument matching and stubbing system for varargs methods**. Specifically, there's likely a bug in how `anyVararg()` matcher interacts with the argument capture mechanism when dealing with varargs parameters.\n\n**Possible Root Causes:**\n\n1. **Argument Capture Logic**: The `InvocationMatcher.captureArgumentsFrom()` method may not properly handle varargs arrays when using `anyVararg()` matcher, leading to the `UnsupportedOperationException`.\n\n2. **Matcher-Varargs Integration**: There might be an incompatibility between the generic varargs matching logic and the specific argument capture implementation, causing the framework to attempt an unsupported operation.\n\n3. **Type Safety Issues**: The varargs matching system may have type safety problems when dealing with generic array types, particularly in the argument capture phase.\n\nThe production code defect is likely in Mockito's core argument matching infrastructure, specifically in the interaction between varargs handling and the argument capture mechanism used during stubbing verification.",
            "test_suite": "org.mockitousage.bugs.varargs.VarargsNotPlayingWithAnyObjectTest",
            "score": 2,
            "reason": "#2# The matches method simply returns true and doesn't contain any complex logic that would cause the UnsupportedOperationException. The actual failure occurs in InvocationMatcher.captureArgumentsFrom, suggesting the issue is in how the varargs matching integrates with Mockito's argument capture system rather than in this specific matcher implementation."
        }
    ],
    "buggy_codes": {
        "org.mockito.internal.invocation.InvocationMatcher::captureArgumentsFrom(Invocation)": {
            "method_name": "org.mockito.internal.invocation.InvocationMatcher::captureArgumentsFrom(Invocation)",
            "method_code": "```java\n    public void captureArgumentsFrom(Invocation TransVarInvocation0) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n                }\n        if (!(!(TransVarInvocation0.getMethod().isVarArgs()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarIndexOfLastArg = TransVarInvocation0.getRawArguments().length - 1;\n            throw new UnsupportedOperationException();\n\n        } else {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n                }\n            int TransVarIndex = 0;\n            while (!(!(TransVarIndex < matchers.size()))) {\n                Matcher TransVarMatcher = matchers.get(TransVarIndex);\n                if (!(!(TransVarMatcher instanceof CapturesArguments))) {\n                    ((CapturesArguments) TransVarMatcher)\n                            .captureFrom(TransVarInvocation0.getArgumentAt(TransVarIndex, Object.class));\n                }\n                TransVarIndex++;\n            }\n        }\n\n//        for (int position = 0; position < matchers.size(); position++) {\n//            Matcher m = matchers.get(position);\n//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n//                //TODO SF - this whole lot can be moved captureFrom implementation\n//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n//                    Object array = invocation.getRawArguments()[position];\n//                    for (int i = 0; i < Array.getLength(array); i++) {\n//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n//                    }\n//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n//                    return;\n//                } else {\n//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n//                }\n//            }\n//        }\n    }\n\n```",
            "method_doc": "Captures arguments from the given invocation for matchers that implement CapturesArguments. Handles varargs invocations by throwing UnsupportedOperationException and processes regular arguments by iterating through matchers."
        },
        "org.mockito.internal.invocation.InvocationMatcher::matches(Invocation)": {
            "method_name": "org.mockito.internal.invocation.InvocationMatcher::matches(Invocation)",
            "method_code": "```java\n    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }\n\n```",
            "method_doc": "Checks if the actual invocation matches this matcher by comparing mocks, methods, and arguments. This method calls method \"hasSameMethod\" to verify method equality and uses ArgumentsComparator for argument matching."
        },
        "org.mockito.internal.invocation.InvocationMatcher::InvocationMatcher(Invocation,List)": {
            "method_name": "org.mockito.internal.invocation.InvocationMatcher::InvocationMatcher(Invocation,List)",
            "method_code": "```java\n    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());\n        } else {\n            this.matchers = matchers;\n        }\n    }\n\n```",
            "method_doc": "Constructs an InvocationMatcher with the given invocation and matchers. If matchers list is empty, converts invocation arguments to matchers using ArgumentsProcessor."
        },
        "org.mockito.internal.util.reflection.FieldInitializer$ParameterizedConstructorInstantiator::biggestConstructor(Class)": {
            "method_name": "org.mockito.internal.util.reflection.FieldInitializer$ParameterizedConstructorInstantiator::biggestConstructor(Class)",
            "method_code": "```java\n        private Constructor<?> biggestConstructor(Class<?> clazz) {\n            final List<Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());\n            Collections.sort(constructors, byParameterNumber);\n            \n            Constructor<?> constructor = constructors.get(0);\n            checkParameterized(constructor, field);\n            return constructor;\n        }\n\n```",
            "method_doc": "This method finds the constructor with the most parameters from a class, sorts all constructors by parameter count, and calls method \"checkParameterized\" to verify the selected constructor has parameters."
        },
        "org.mockito.internal.util.reflection.FieldInitializer$ParameterizedConstructorInstantiator::instantiate()": {
            "method_name": "org.mockito.internal.util.reflection.FieldInitializer$ParameterizedConstructorInstantiator::instantiate()",
            "method_code": "```java\n        public FieldInitializationReport instantiate() {\n            final AccessibilityChanger changer = new AccessibilityChanger();\n            Constructor<?> constructor = null;\n            try {\n                constructor = biggestConstructor(field.getType());\n                changer.enableAccess(constructor);\n\n                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());\n                Object newFieldInstance = constructor.newInstance(args);\n                new FieldSetter(testClass, field).set(newFieldInstance);\n\n                return new FieldInitializationReport(field.get(testClass), false, true);\n            } catch (IllegalArgumentException e) {\n                throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n            } catch (InvocationTargetException e) {\n                throw new MockitoException(\"the constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n            } catch (InstantiationException e) {\n                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n            } catch (IllegalAccessException e) {\n                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n            } finally {\n                if(constructor != null) {\n                    changer.safelyDisableAccess(constructor);\n                }\n            }\n        }\n\n```",
            "method_doc": "This method initializes a field by finding the constructor with most parameters, resolving arguments, creating an instance, and setting the field. It calls method \"biggestConstructor\" to find the appropriate constructor and handles various exception scenarios."
        },
        "org.mockito.internal.matchers.AnyVararg::matches(Object)": {
            "method_name": "org.mockito.internal.matchers.AnyVararg::matches(Object)",
            "method_code": "```java\n    public boolean matches(Object arg) {\n        return true;\n    }\n\n```",
            "method_doc": "This method always returns true for any argument, implementing a vararg matcher that accepts any number of arguments. It does not call any other covered methods."
        }
    }
}