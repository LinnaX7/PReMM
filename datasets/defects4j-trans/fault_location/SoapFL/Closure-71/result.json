{
    "buggy_classes": [
        "com.google.javascript.jscomp.CheckAccessControls"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::checkPropertyVisibility(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void checkPropertyVisibility(NodeTraversal TransVarTraversal,\n      Node TransVarTree, Node TransVarParentNode) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    ObjectType TransVarType =\n        ObjectType.cast(dereference(TransVarTree.getFirstChild().getJSType()));\n    String TransVarPropName = TransVarTree.getLastChild().getString();\n\n    if (!(!(TransVarType != null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean TransVarIsAssign = TransVarTraversal.inGlobalScope() &&\n          TransVarParentNode.getType() == Token.ASSIGN &&\n          TransVarParentNode.getFirstChild() == TransVarTree;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (!(!(TransVarIsAssign))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n      }\n        TransVarType = TransVarType.getImplicitPrototype();\n      }\n      JSDocInfo TransVarJsDocInfo = null;\n      while (!(!(TransVarType != null))) {\n        TransVarJsDocInfo = TransVarType.getOwnPropertyJSDocInfo(TransVarPropName);\n        if (!(!(TransVarJsDocInfo != null && TransVarJsDocInfo.getVisibility() != Visibility.INHERITED))) {\n          break;\n        }\n        TransVarType = TransVarType.getImplicitPrototype();\n      }\n\n      if (!(!(TransVarType == null))) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean TransVarIsSameName =\n          TransVarTraversal.getInput().getName().equals(TransVarJsDocInfo.getSourceName());\n      Visibility TransVarPropVisibility = TransVarJsDocInfo.getVisibility();\n      JSType TransVarClassType = normalizeClassType(TransVarType);\n      if (!(!(TransVarIsAssign))) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo TransVarOverrideInfo = TransVarParentNode.getJSDocInfo();\n        Visibility TransVarOverridingVisibility1 = TransVarOverrideInfo == null ?\n            Visibility.INHERITED : TransVarOverrideInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (!(!(TransVarPropVisibility == Visibility.PRIVATE && !TransVarIsSameName))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree, PRIVATE_OVERRIDE,\n                  TransVarType.toString()));\n        } else if (!(!(TransVarOverridingVisibility1 != Visibility.INHERITED\n                && TransVarOverridingVisibility1 != TransVarPropVisibility))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree, VISIBILITY_MISMATCH,\n                  TransVarPropVisibility.name(), TransVarType.toString(),\n                  TransVarOverridingVisibility1.name()));\n        }\n      } else {\n        if (!(!(TransVarIsSameName))) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (!(!(TransVarPropVisibility == Visibility.PRIVATE\n                && (currentClass == null || TransVarClassType.differsFrom(currentClass))))) {\n          if (!(!(TransVarJsDocInfo.isConstructor() && isValidPrivateConstructorAccess(TransVarParentNode)))) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  TransVarPropName,\n                  validator.getReadableJSTypeName(\n                      TransVarTree.getFirstChild(), true)));\n        } else if (!(!(TransVarPropVisibility == Visibility.PROTECTED))) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (!(!(currentClass == null || !currentClass.isSubtype(TransVarClassType)))) {\n            compiler.report(\n                TransVarTraversal.makeError(TransVarTree,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    TransVarPropName,\n                    validator.getReadableJSTypeName(\n                        TransVarTree.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Determines whether the given property is visible in the current context. @param t The current traversal. @param getprop The getprop node. ",
            "class_name": "com.google.javascript.jscomp.CheckAccessControls",
            "class_doc": " A compiler pass that checks that the programmer has obeyed all the access control restrictions indicated by JSDoc annotations, like {@code @private} and {@code @deprecated}.  Because access control restrictions are attached to type information, it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo all run before this pass. TypedScopeCreator creates and resolves types, TypeInference propagates those types across the AST, and InferJSDocInfo propagates JSDoc across the types.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve private property inheritance/override scenarios**:\n   - `testNoPrivateAccessForProperties6`: Subclass overriding a private prototype method from parent\n   - `testNoPrivateAccessForProperties8`: Subclass declaring same private instance property as parent\n\n2. **Error type confusion**: \n   - Test 6 expected `BAD_PRIVATE_PROPERTY_ACCESS` but got `PRIVATE_OVERRIDE`\n   - Test 8 expected `PRIVATE_OVERRIDE` but got no error\n\n3. **Both tests involve cross-file scenarios** with separate constructor definitions\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **access control validation logic within `CheckAccessControls` class**, specifically in how it handles private property inheritance and override detection across different compilation units.\n\n**Possible defect location**: The logic that distinguishes between:\n- **BAD_PRIVATE_PROPERTY_ACCESS**: When accessing a private property from outside its allowed scope\n- **PRIVATE_OVERRIDE**: When a subclass attempts to override a private property from parent\n\n**Specific issues likely present**:\n\n1. **Incorrect error type mapping**: The code may be incorrectly categorizing certain private property access violations as override violations, or vice versa\n\n2. **Cross-file scope resolution problem**: The defect likely involves how private property visibility and inheritance rules are enforced when parent and child classes are defined in different files\n\n3. **Override detection logic flaw**: The algorithm that detects when a subclass property constitutes an \"override\" of a parent's private property appears to have incorrect conditions or missing edge cases\n\nThe production code defect is likely in the method that analyzes property declarations and determines whether they violate access control rules, particularly in scenarios involving inheritance and cross-file definitions.",
            "test_suite": "com.google.javascript.jscomp.CheckAccessControlsTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious and likely the best location to fix because it contains the core logic for checking private property visibility and override scenarios. The method handles both BAD_PRIVATE_PROPERTY_ACCESS and PRIVATE_OVERRIDE error types, which are exactly the error types that are mismatched in the failing tests. The logic around TransVarIsAssign, TransVarIsSameName, and the conditions for reporting PRIVATE_OVERRIDE vs BAD_PRIVATE_PROPERTY_ACCESS appears flawed, particularly in cross-file inheritance scenarios where the visibility checks and override detection are not working correctly."
        },
        {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::getClassOfMethod(Node,Node)",
            "method_code": "```java\n  private JSType getClassOfMethod(Node n, Node parent) {\n    if (parent.getType() == Token.ASSIGN) {\n      Node lValue = parent.getFirstChild();\n      if (lValue.isQualifiedName()) {\n        if (lValue.getType() == Token.GETPROP) {\n          // We have an assignment of the form \"a.b = ...\".\n          JSType lValueType = lValue.getJSType();\n          if (lValueType != null && lValueType.isConstructor()) {\n            // If a.b is a constructor, then everything in this function\n            // belongs to the \"a.b\" type.\n            return ((FunctionType) lValueType).getInstanceType();\n          } else {\n            // If a.b is not a constructor, then treat this as a method\n            // of whatever type is on \"a\".\n            return normalizeClassType(lValue.getFirstChild().getJSType());\n          }\n        } else {\n          // We have an assignment of the form \"a = ...\", so pull the\n          // type off the \"a\".\n          return normalizeClassType(lValue.getJSType());\n        }\n      }\n    } else if (NodeUtil.isFunctionDeclaration(n) ||\n               parent.getType() == Token.NAME) {\n      return normalizeClassType(n.getJSType());\n    }\n\n    return null;\n  }\n\n```",
            "method_doc": " Gets the type of the class that \"owns\" a method, or null if we know that its un-owned. ",
            "class_name": "com.google.javascript.jscomp.CheckAccessControls",
            "class_doc": " A compiler pass that checks that the programmer has obeyed all the access control restrictions indicated by JSDoc annotations, like {@code @private} and {@code @deprecated}.  Because access control restrictions are attached to type information, it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo all run before this pass. TypedScopeCreator creates and resolves types, TypeInference propagates those types across the AST, and InferJSDocInfo propagates JSDoc across the types.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve private property inheritance/override scenarios**:\n   - `testNoPrivateAccessForProperties6`: Subclass overriding a private prototype method from parent\n   - `testNoPrivateAccessForProperties8`: Subclass declaring same private instance property as parent\n\n2. **Error type confusion**: \n   - Test 6 expected `BAD_PRIVATE_PROPERTY_ACCESS` but got `PRIVATE_OVERRIDE`\n   - Test 8 expected `PRIVATE_OVERRIDE` but got no error\n\n3. **Both tests involve cross-file scenarios** with separate constructor definitions\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **access control validation logic within `CheckAccessControls` class**, specifically in how it handles private property inheritance and override detection across different compilation units.\n\n**Possible defect location**: The logic that distinguishes between:\n- **BAD_PRIVATE_PROPERTY_ACCESS**: When accessing a private property from outside its allowed scope\n- **PRIVATE_OVERRIDE**: When a subclass attempts to override a private property from parent\n\n**Specific issues likely present**:\n\n1. **Incorrect error type mapping**: The code may be incorrectly categorizing certain private property access violations as override violations, or vice versa\n\n2. **Cross-file scope resolution problem**: The defect likely involves how private property visibility and inheritance rules are enforced when parent and child classes are defined in different files\n\n3. **Override detection logic flaw**: The algorithm that detects when a subclass property constitutes an \"override\" of a parent's private property appears to have incorrect conditions or missing edge cases\n\nThe production code defect is likely in the method that analyzes property declarations and determines whether they violate access control rules, particularly in scenarios involving inheritance and cross-file definitions.",
            "test_suite": "com.google.javascript.jscomp.CheckAccessControlsTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because it determines the owning class of methods and properties, which is crucial for correctly identifying private property access violations versus override scenarios. The test failures show confusion between BAD_PRIVATE_PROPERTY_ACCESS and PRIVATE_OVERRIDE errors, suggesting the method may be incorrectly identifying class ownership in inheritance hierarchies, particularly when dealing with prototype assignments and cross-file scenarios where parent and child classes are defined separately."
        },
        {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::normalizeClassType(JSType)",
            "method_code": "```java\n  private JSType normalizeClassType(JSType type) {\n    if (type == null || type.isUnknownType()) {\n      return type;\n    } else if (type.isConstructor()) {\n      return ((FunctionType) type).getInstanceType();\n    } else if (type.isFunctionPrototypeType()) {\n      FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n      if (owner.isConstructor()) {\n        return owner.getInstanceType();\n      }\n    }\n    return type;\n  }\n\n```",
            "method_doc": " Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type). ",
            "class_name": "com.google.javascript.jscomp.CheckAccessControls",
            "class_doc": " A compiler pass that checks that the programmer has obeyed all the access control restrictions indicated by JSDoc annotations, like {@code @private} and {@code @deprecated}.  Because access control restrictions are attached to type information, it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo all run before this pass. TypedScopeCreator creates and resolves types, TypeInference propagates those types across the AST, and InferJSDocInfo propagates JSDoc across the types.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve private property inheritance/override scenarios**:\n   - `testNoPrivateAccessForProperties6`: Subclass overriding a private prototype method from parent\n   - `testNoPrivateAccessForProperties8`: Subclass declaring same private instance property as parent\n\n2. **Error type confusion**: \n   - Test 6 expected `BAD_PRIVATE_PROPERTY_ACCESS` but got `PRIVATE_OVERRIDE`\n   - Test 8 expected `PRIVATE_OVERRIDE` but got no error\n\n3. **Both tests involve cross-file scenarios** with separate constructor definitions\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **access control validation logic within `CheckAccessControls` class**, specifically in how it handles private property inheritance and override detection across different compilation units.\n\n**Possible defect location**: The logic that distinguishes between:\n- **BAD_PRIVATE_PROPERTY_ACCESS**: When accessing a private property from outside its allowed scope\n- **PRIVATE_OVERRIDE**: When a subclass attempts to override a private property from parent\n\n**Specific issues likely present**:\n\n1. **Incorrect error type mapping**: The code may be incorrectly categorizing certain private property access violations as override violations, or vice versa\n\n2. **Cross-file scope resolution problem**: The defect likely involves how private property visibility and inheritance rules are enforced when parent and child classes are defined in different files\n\n3. **Override detection logic flaw**: The algorithm that detects when a subclass property constitutes an \"override\" of a parent's private property appears to have incorrect conditions or missing edge cases\n\nThe production code defect is likely in the method that analyzes property declarations and determines whether they violate access control rules, particularly in scenarios involving inheritance and cross-file definitions.",
            "test_suite": "com.google.javascript.jscomp.CheckAccessControlsTest",
            "score": 8,
            "reason": "#8# The normalizeClassType method is highly suspicious because it handles type normalization for constructors and prototypes, which directly relates to the inheritance scenarios in the failed tests. Both test failures involve subclass relationships where private properties are being overridden across different files, and this method's logic for converting constructor and prototype types to instance types could be incorrectly handling the type relationships in cross-file inheritance scenarios, leading to the wrong error type being reported or no error being detected at all."
        },
        {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        checkNameDeprecation(t, n, parent);\n        checkNameVisibility(t, n, parent);\n        break;\n      case Token.GETPROP:\n        checkPropertyDeprecation(t, n, parent);\n        checkPropertyVisibility(t, n, parent);\n        checkConstantProperty(t, n);\n        break;\n      case Token.NEW:\n        checkConstructorDeprecation(t, n, parent);\n        break;\n    }\n  }\n\n```",
            "method_doc": "Dispatches to specific check methods based on node type (NAME, GETPROP, NEW); this method calls methods \"checkNameDeprecation\", \"checkNameVisibility\", \"checkPropertyDeprecation\", \"checkPropertyVisibility\", \"checkConstantProperty\", and \"checkConstructorDeprecation\".",
            "class_name": "com.google.javascript.jscomp.CheckAccessControls",
            "class_doc": " A compiler pass that checks that the programmer has obeyed all the access control restrictions indicated by JSDoc annotations, like {@code @private} and {@code @deprecated}.  Because access control restrictions are attached to type information, it's important that TypedScopeCreator, TypeInference, and InferJSDocInfo all run before this pass. TypedScopeCreator creates and resolves types, TypeInference propagates those types across the AST, and InferJSDocInfo propagates JSDoc across the types.  ",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defects in the production code:\n\n## Common Patterns Identified:\n\n1. **Both tests involve private property inheritance/override scenarios**:\n   - `testNoPrivateAccessForProperties6`: Subclass overriding a private prototype method from parent\n   - `testNoPrivateAccessForProperties8`: Subclass declaring same private instance property as parent\n\n2. **Error type confusion**: \n   - Test 6 expected `BAD_PRIVATE_PROPERTY_ACCESS` but got `PRIVATE_OVERRIDE`\n   - Test 8 expected `PRIVATE_OVERRIDE` but got no error\n\n3. **Both tests involve cross-file scenarios** with separate constructor definitions\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **access control validation logic within `CheckAccessControls` class**, specifically in how it handles private property inheritance and override detection across different compilation units.\n\n**Possible defect location**: The logic that distinguishes between:\n- **BAD_PRIVATE_PROPERTY_ACCESS**: When accessing a private property from outside its allowed scope\n- **PRIVATE_OVERRIDE**: When a subclass attempts to override a private property from parent\n\n**Specific issues likely present**:\n\n1. **Incorrect error type mapping**: The code may be incorrectly categorizing certain private property access violations as override violations, or vice versa\n\n2. **Cross-file scope resolution problem**: The defect likely involves how private property visibility and inheritance rules are enforced when parent and child classes are defined in different files\n\n3. **Override detection logic flaw**: The algorithm that detects when a subclass property constitutes an \"override\" of a parent's private property appears to have incorrect conditions or missing edge cases\n\nThe production code defect is likely in the method that analyzes property declarations and determines whether they violate access control rules, particularly in scenarios involving inheritance and cross-file definitions.",
            "test_suite": "com.google.javascript.jscomp.CheckAccessControlsTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it serves as the main dispatch point for all access control checks, including property visibility validation. The failed tests involve private property access and override scenarios, and this visit method directly calls checkPropertyVisibility which handles the exact logic that distinguishes between BAD_PRIVATE_PROPERTY_ACCESS and PRIVATE_OVERRIDE errors. The method's role in routing different node types to appropriate validation functions makes it the central point where the error type confusion between these two specific access control violations could be resolved."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.CheckAccessControls::getClassOfMethod(Node,Node)": {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::getClassOfMethod(Node,Node)",
            "method_code": "```java\n  private JSType getClassOfMethod(Node n, Node parent) {\n    if (parent.getType() == Token.ASSIGN) {\n      Node lValue = parent.getFirstChild();\n      if (lValue.isQualifiedName()) {\n        if (lValue.getType() == Token.GETPROP) {\n          // We have an assignment of the form \"a.b = ...\".\n          JSType lValueType = lValue.getJSType();\n          if (lValueType != null && lValueType.isConstructor()) {\n            // If a.b is a constructor, then everything in this function\n            // belongs to the \"a.b\" type.\n            return ((FunctionType) lValueType).getInstanceType();\n          } else {\n            // If a.b is not a constructor, then treat this as a method\n            // of whatever type is on \"a\".\n            return normalizeClassType(lValue.getFirstChild().getJSType());\n          }\n        } else {\n          // We have an assignment of the form \"a = ...\", so pull the\n          // type off the \"a\".\n          return normalizeClassType(lValue.getJSType());\n        }\n      }\n    } else if (NodeUtil.isFunctionDeclaration(n) ||\n               parent.getType() == Token.NAME) {\n      return normalizeClassType(n.getJSType());\n    }\n\n    return null;\n  }\n\n```",
            "method_doc": " Gets the type of the class that \"owns\" a method, or null if we know that its un-owned. "
        },
        "com.google.javascript.jscomp.CheckAccessControls::checkPropertyVisibility(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::checkPropertyVisibility(NodeTraversal,Node,Node)",
            "method_code": "```java\n  private void checkPropertyVisibility(NodeTraversal TransVarTraversal,\n      Node TransVarTree, Node TransVarParentNode) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    ObjectType TransVarType =\n        ObjectType.cast(dereference(TransVarTree.getFirstChild().getJSType()));\n    String TransVarPropName = TransVarTree.getLastChild().getString();\n\n    if (!(!(TransVarType != null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean TransVarIsAssign = TransVarTraversal.inGlobalScope() &&\n          TransVarParentNode.getType() == Token.ASSIGN &&\n          TransVarParentNode.getFirstChild() == TransVarTree;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (!(!(TransVarIsAssign))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n      }\n        TransVarType = TransVarType.getImplicitPrototype();\n      }\n      JSDocInfo TransVarJsDocInfo = null;\n      while (!(!(TransVarType != null))) {\n        TransVarJsDocInfo = TransVarType.getOwnPropertyJSDocInfo(TransVarPropName);\n        if (!(!(TransVarJsDocInfo != null && TransVarJsDocInfo.getVisibility() != Visibility.INHERITED))) {\n          break;\n        }\n        TransVarType = TransVarType.getImplicitPrototype();\n      }\n\n      if (!(!(TransVarType == null))) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean TransVarIsSameName =\n          TransVarTraversal.getInput().getName().equals(TransVarJsDocInfo.getSourceName());\n      Visibility TransVarPropVisibility = TransVarJsDocInfo.getVisibility();\n      JSType TransVarClassType = normalizeClassType(TransVarType);\n      if (!(!(TransVarIsAssign))) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo TransVarOverrideInfo = TransVarParentNode.getJSDocInfo();\n        Visibility TransVarOverridingVisibility1 = TransVarOverrideInfo == null ?\n            Visibility.INHERITED : TransVarOverrideInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (!(!(TransVarPropVisibility == Visibility.PRIVATE && !TransVarIsSameName))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree, PRIVATE_OVERRIDE,\n                  TransVarType.toString()));\n        } else if (!(!(TransVarOverridingVisibility1 != Visibility.INHERITED\n                && TransVarOverridingVisibility1 != TransVarPropVisibility))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree, VISIBILITY_MISMATCH,\n                  TransVarPropVisibility.name(), TransVarType.toString(),\n                  TransVarOverridingVisibility1.name()));\n        }\n      } else {\n        if (!(!(TransVarIsSameName))) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (!(!(TransVarPropVisibility == Visibility.PRIVATE\n                && (currentClass == null || TransVarClassType.differsFrom(currentClass))))) {\n          if (!(!(TransVarJsDocInfo.isConstructor() && isValidPrivateConstructorAccess(TransVarParentNode)))) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  TransVarPropName,\n                  validator.getReadableJSTypeName(\n                      TransVarTree.getFirstChild(), true)));\n        } else if (!(!(TransVarPropVisibility == Visibility.PROTECTED))) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (!(!(currentClass == null || !currentClass.isSubtype(TransVarClassType)))) {\n            compiler.report(\n                TransVarTraversal.makeError(TransVarTree,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    TransVarPropName,\n                    validator.getReadableJSTypeName(\n                        TransVarTree.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Determines whether the given property is visible in the current context. @param t The current traversal. @param getprop The getprop node. "
        },
        "com.google.javascript.jscomp.CheckAccessControls::normalizeClassType(JSType)": {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::normalizeClassType(JSType)",
            "method_code": "```java\n  private JSType normalizeClassType(JSType type) {\n    if (type == null || type.isUnknownType()) {\n      return type;\n    } else if (type.isConstructor()) {\n      return ((FunctionType) type).getInstanceType();\n    } else if (type.isFunctionPrototypeType()) {\n      FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n      if (owner.isConstructor()) {\n        return owner.getInstanceType();\n      }\n    }\n    return type;\n  }\n\n```",
            "method_doc": " Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type). "
        },
        "com.google.javascript.jscomp.CheckAccessControls::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.CheckAccessControls::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        checkNameDeprecation(t, n, parent);\n        checkNameVisibility(t, n, parent);\n        break;\n      case Token.GETPROP:\n        checkPropertyDeprecation(t, n, parent);\n        checkPropertyVisibility(t, n, parent);\n        checkConstantProperty(t, n);\n        break;\n      case Token.NEW:\n        checkConstructorDeprecation(t, n, parent);\n        break;\n    }\n  }\n\n```",
            "method_doc": "Dispatches to specific check methods based on node type (NAME, GETPROP, NEW); this method calls methods \"checkNameDeprecation\", \"checkNameVisibility\", \"checkPropertyDeprecation\", \"checkPropertyVisibility\", \"checkConstantProperty\", and \"checkConstructorDeprecation\"."
        }
    }
}