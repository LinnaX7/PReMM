{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.ser.PropertyBuilder"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder::getDefaultValue(JavaType)",
            "method_code": "```java\n    protected Object getDefaultValue(JavaType type)\n    {\n        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special\n        //   handling for primitives since they are never passed as nulls.\n        Class<?> cls = type.getRawClass();\n\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        return null;\n    }\n\n```",
            "method_doc": " Accessor used to find out \"default value\" to use for comparing values to serialize, to determine whether to exclude value from serialization with inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}. <p> Default logic is such that for primitives and wrapper types for primitives, expected defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String, and for structured (Maps, Collections, arrays) and reference types, criteria {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT} is used.  @since 2.7 ",
            "class_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder",
            "class_doc": " Helper class for {@link BeanSerializerFactory} that is used to construct {@link BeanPropertyWriter} instances. Can be sub-classed to change behavior. ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test is verifying `JsonInclude.Include.NON_DEFAULT` functionality\n- With `NON_DEFAULT`, only properties with values different from their defaults should be serialized\n- The test expects empty JSON objects `\"{}\"` but gets `{\"str\":null}` instead\n\n**2. Key Observation from Stack Trace:**\n```\nexpected:<{[]}> but was:<{[\"str\":null]}>\n```\nThis indicates that a property named \"str\" with `null` value is being serialized when it should be excluded.\n\n**3. Common Pattern Identified:**\nThe failure occurs because properties with `null` values are not being properly excluded when using `NON_DEFAULT` inclusion, even though `null` should typically be considered a default value for object types.\n\n## Recommended Possible Defect in Production Code\n\nBased on the test failure analysis, the likely defect is in Jackson's `JsonInclude.Value` or serialization logic when handling `Include.NON_DEFAULT` configuration. Specifically:\n\n**Possible Defect:** The production code incorrectly handles the determination of \"default values\" for object types when using `JsonInclude.Include.NON_DEFAULT`. The system may not be properly recognizing `null` as the default value for object/reference types, causing it to be incorrectly included in serialization output.\n\n**Root Cause Hypothesis:** The logic that compares property values against their defaults to decide inclusion/exclusion may have a flaw where:\n- For primitive types, `0`, `0.0`, `false` etc. are correctly identified as defaults\n- For object types, `null` may not be consistently treated as the default value\n- There might be inconsistent behavior between how different property types (objects vs primitives) determine what constitutes a \"default\" value\n\nThis defect would cause the serialization to incorrectly include `null` values when `NON_DEFAULT` is configured, violating the expected behavior where properties with default values should be omitted.",
            "test_suite": "com.fasterxml.jackson.databind.filter.JsonIncludeTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it returns JsonInclude.Include.NON_EMPTY for container and reference types instead of returning null as the default value. When JsonInclude.Include.NON_DEFAULT is used, the comparison logic expects null as the default value for object types, but this method returns NON_EMPTY for containers and references, causing null values to be incorrectly included in serialization output when they should be excluded as default values."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder::getPropertyDefaultValue(String,AnnotatedMember,JavaType)",
            "method_code": "```java\n    @Deprecated // since 2.8.5\n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member,\n            JavaType type)\n    {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n```",
            "method_doc": " Accessor used to find out \"default value\" for given property, to use for comparing values to serialize, to determine whether to exclude value from serialization with inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}. This method is called when we specifically want to know default value within context of a POJO, when annotation is within containing class, and not for property or defined as global baseline. <p> Note that returning of pseudo-type {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY} requires special handling.  @since 2.7 @deprecated Since 2.8.5 since this will not allow determining difference between \"no default instance\" case and default being `null`. ",
            "class_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder",
            "class_doc": " Helper class for {@link BeanSerializerFactory} that is used to construct {@link BeanPropertyWriter} instances. Can be sub-classed to change behavior. ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test is verifying `JsonInclude.Include.NON_DEFAULT` functionality\n- With `NON_DEFAULT`, only properties with values different from their defaults should be serialized\n- The test expects empty JSON objects `\"{}\"` but gets `{\"str\":null}` instead\n\n**2. Key Observation from Stack Trace:**\n```\nexpected:<{[]}> but was:<{[\"str\":null]}>\n```\nThis indicates that a property named \"str\" with `null` value is being serialized when it should be excluded.\n\n**3. Common Pattern Identified:**\nThe failure occurs because properties with `null` values are not being properly excluded when using `NON_DEFAULT` inclusion, even though `null` should typically be considered a default value for object types.\n\n## Recommended Possible Defect in Production Code\n\nBased on the test failure analysis, the likely defect is in Jackson's `JsonInclude.Value` or serialization logic when handling `Include.NON_DEFAULT` configuration. Specifically:\n\n**Possible Defect:** The production code incorrectly handles the determination of \"default values\" for object types when using `JsonInclude.Include.NON_DEFAULT`. The system may not be properly recognizing `null` as the default value for object/reference types, causing it to be incorrectly included in serialization output.\n\n**Root Cause Hypothesis:** The logic that compares property values against their defaults to decide inclusion/exclusion may have a flaw where:\n- For primitive types, `0`, `0.0`, `false` etc. are correctly identified as defaults\n- For object types, `null` may not be consistently treated as the default value\n- There might be inconsistent behavior between how different property types (objects vs primitives) determine what constitutes a \"default\" value\n\nThis defect would cause the serialization to incorrectly include `null` values when `NON_DEFAULT` is configured, violating the expected behavior where properties with default values should be omitted.",
            "test_suite": "com.fasterxml.jackson.databind.filter.JsonIncludeTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it's specifically responsible for determining default values used for NON_DEFAULT inclusion comparisons. The test failure shows that null values are incorrectly included when they should be excluded, and this method's logic for handling default values - particularly the deprecated comment about not distinguishing between \"no default instance\" and \"default being null\" - directly relates to the root cause of the serialization issue with NON_DEFAULT inclusion."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder::buildWriter(SerializerProvider,BeanPropertyDefinition,JavaType,JsonSerializer,TypeSerializer,TypeSerializer,AnnotatedMember,boolean)",
            "method_code": "```java\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider TransVarProvider,\n            BeanPropertyDefinition TransVarPropertyDef, JavaType TransVarType, JsonSerializer<?> TransVarSerializer,\n            TypeSerializer TransVarTypeSerializer, TypeSerializer TransVarContentTypeSerImpl,\n            AnnotatedMember TransVarAnnotatedMember, boolean TransVarUseStaticTyping)\n        throws JsonMappingException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType TransVarSerializationJavaType;\n        try {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            TransVarSerializationJavaType = findSerializationType(TransVarAnnotatedMember, TransVarUseStaticTyping, TransVarType);\n        } catch (JsonMappingException TransVarJsonMappingException) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarProvider.reportBadPropertyDefinition(_beanDesc, TransVarPropertyDef, TransVarJsonMappingException.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (!(!(TransVarContentTypeSerImpl != null))) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (!(!(TransVarSerializationJavaType == null))) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                TransVarSerializationJavaType = TransVarType;\n            }\n            JavaType TransVarContentType = TransVarSerializationJavaType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (!(!(TransVarContentType == null))) {\n                TransVarProvider.reportBadPropertyDefinition(_beanDesc, TransVarPropertyDef,\n                        \"serialization type \"+TransVarSerializationJavaType+\" has no content\");\n            }\n            TransVarSerializationJavaType = TransVarSerializationJavaType.withContentTypeHandler(TransVarContentTypeSerImpl);\n            TransVarContentType = TransVarSerializationJavaType.getContentType();\n        }\n\n        Object TransVarValue = null;\n        boolean TransVarSuppressNull = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType TransVarActualJavaType = (TransVarSerializationJavaType == null) ? TransVarType : TransVarSerializationJavaType;\n        \n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value TransVarIncl = _config.getDefaultPropertyInclusion(TransVarActualJavaType.getRawClass(),\n                _defaultInclusion);\n\n        // property annotation override\n        \n        TransVarIncl = TransVarIncl.withOverrides(TransVarPropertyDef.findInclusion());\n        JsonInclude.Include TransVarInclude = TransVarIncl.getValueInclusion();\n\n        if (!(!(TransVarInclude == JsonInclude.Include.USE_DEFAULTS))) { // should not occur but...\n            TransVarInclude = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (TransVarInclude) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n\n            // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (!(!(_useRealPropertyDefaults))) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (!(!(TransVarProvider.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)))) {\n                    TransVarAnnotatedMember.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                TransVarValue = getPropertyDefaultValue(TransVarPropertyDef.getName(), TransVarAnnotatedMember, TransVarActualJavaType);\n            } else {\n                TransVarValue = getDefaultValue(TransVarActualJavaType);\n                TransVarSuppressNull = true;\n            }\n            if (!(!(TransVarValue == null))) {\n                TransVarSuppressNull = true;\n            } else {\n                if (!(!(TransVarValue.getClass().isArray()))) {\n                    TransVarValue = ArrayBuilders.getArrayComparator(TransVarValue);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            TransVarSuppressNull = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (!(!(TransVarActualJavaType.isReferenceType()))) {\n                TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            TransVarSuppressNull = true;\n            // but possibly also 'empty' values:\n            TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            TransVarSuppressNull = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (!(!(TransVarActualJavaType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)))) {\n                TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter TransVarBeanPropertyWriter = new BeanPropertyWriter(TransVarPropertyDef,\n                TransVarAnnotatedMember, _beanDesc.getClassAnnotations(), TransVarType,\n                TransVarSerializer, TransVarTypeSerializer, TransVarSerializationJavaType, TransVarSuppressNull, TransVarValue);\n\n        // How about custom null serializer?\n        Object TransVarNullSerDef = _annotationIntrospector.findNullSerializer(TransVarAnnotatedMember);\n        if (!(!(TransVarNullSerDef != null))) {\n            TransVarBeanPropertyWriter.assignNullSerializer(TransVarProvider.serializerInstance(TransVarAnnotatedMember, TransVarNullSerDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer TransVarNameTransformer = _annotationIntrospector.findUnwrappingNameTransformer(TransVarAnnotatedMember);\n        if (!(!(TransVarNameTransformer != null))) {\n            TransVarBeanPropertyWriter = TransVarBeanPropertyWriter.unwrappingWriter(TransVarNameTransformer);\n        }\n        return TransVarBeanPropertyWriter;\n    }\n\n```",
            "method_doc": " @param contentTypeSer Optional explicit type information serializer to use for contained values (only used for properties that are of container type) ",
            "class_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder",
            "class_doc": " Helper class for {@link BeanSerializerFactory} that is used to construct {@link BeanPropertyWriter} instances. Can be sub-classed to change behavior. ",
            "test_failure_causes": "As a Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test is verifying `JsonInclude.Include.NON_DEFAULT` functionality\n- With `NON_DEFAULT`, only properties with values different from their defaults should be serialized\n- The test expects empty JSON objects `\"{}\"` but gets `{\"str\":null}` instead\n\n**2. Key Observation from Stack Trace:**\n```\nexpected:<{[]}> but was:<{[\"str\":null]}>\n```\nThis indicates that a property named \"str\" with `null` value is being serialized when it should be excluded.\n\n**3. Common Pattern Identified:**\nThe failure occurs because properties with `null` values are not being properly excluded when using `NON_DEFAULT` inclusion, even though `null` should typically be considered a default value for object types.\n\n## Recommended Possible Defect in Production Code\n\nBased on the test failure analysis, the likely defect is in Jackson's `JsonInclude.Value` or serialization logic when handling `Include.NON_DEFAULT` configuration. Specifically:\n\n**Possible Defect:** The production code incorrectly handles the determination of \"default values\" for object types when using `JsonInclude.Include.NON_DEFAULT`. The system may not be properly recognizing `null` as the default value for object/reference types, causing it to be incorrectly included in serialization output.\n\n**Root Cause Hypothesis:** The logic that compares property values against their defaults to decide inclusion/exclusion may have a flaw where:\n- For primitive types, `0`, `0.0`, `false` etc. are correctly identified as defaults\n- For object types, `null` may not be consistently treated as the default value\n- There might be inconsistent behavior between how different property types (objects vs primitives) determine what constitutes a \"default\" value\n\nThis defect would cause the serialization to incorrectly include `null` values when `NON_DEFAULT` is configured, violating the expected behavior where properties with default values should be omitted.",
            "test_suite": "com.fasterxml.jackson.databind.filter.JsonIncludeTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it contains the logic for handling JsonInclude.Include.NON_DEFAULT case where the test failure occurs. The code in the NON_DEFAULT switch case determines whether to suppress null values and what constitutes a default value. The test expects null values to be excluded with NON_DEFAULT inclusion, but the current logic may not be properly handling null as the default value for object types, causing the \"str\":null to be incorrectly serialized instead of being suppressed."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.ser.PropertyBuilder::getDefaultValue(JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder::getDefaultValue(JavaType)",
            "method_code": "```java\n    protected Object getDefaultValue(JavaType type)\n    {\n        // 06-Nov-2015, tatu: Returning null is fine for Object types; but need special\n        //   handling for primitives since they are never passed as nulls.\n        Class<?> cls = type.getRawClass();\n\n        Class<?> prim = ClassUtil.primitiveType(cls);\n        if (prim != null) {\n            return ClassUtil.defaultValue(prim);\n        }\n        if (type.isContainerType() || type.isReferenceType()) {\n            return JsonInclude.Include.NON_EMPTY;\n        }\n        if (cls == String.class) {\n            return \"\";\n        }\n        return null;\n    }\n\n```",
            "method_doc": " Accessor used to find out \"default value\" to use for comparing values to serialize, to determine whether to exclude value from serialization with inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}. <p> Default logic is such that for primitives and wrapper types for primitives, expected defaults (0 for `int` and `java.lang.Integer`) are returned; for Strings, empty String, and for structured (Maps, Collections, arrays) and reference types, criteria {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT} is used.  @since 2.7 "
        },
        "com.fasterxml.jackson.databind.ser.PropertyBuilder::getPropertyDefaultValue(String,AnnotatedMember,JavaType)": {
            "method_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder::getPropertyDefaultValue(String,AnnotatedMember,JavaType)",
            "method_code": "```java\n    @Deprecated // since 2.8.5\n    protected Object getPropertyDefaultValue(String name, AnnotatedMember member,\n            JavaType type)\n    {\n        Object defaultBean = getDefaultBean();\n        if (defaultBean == null) {\n            return getDefaultValue(type);\n        }\n        try {\n            return member.getValue(defaultBean);\n        } catch (Exception e) {\n            return _throwWrapped(e, name, defaultBean);\n        }\n    }\n\n```",
            "method_doc": " Accessor used to find out \"default value\" for given property, to use for comparing values to serialize, to determine whether to exclude value from serialization with inclusion type of {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_DEFAULT}. This method is called when we specifically want to know default value within context of a POJO, when annotation is within containing class, and not for property or defined as global baseline. <p> Note that returning of pseudo-type {@link com.fasterxml.jackson.annotation.JsonInclude.Include#NON_EMPTY} requires special handling.  @since 2.7 @deprecated Since 2.8.5 since this will not allow determining difference between \"no default instance\" case and default being `null`. "
        },
        "com.fasterxml.jackson.databind.ser.PropertyBuilder::buildWriter(SerializerProvider,BeanPropertyDefinition,JavaType,JsonSerializer,TypeSerializer,TypeSerializer,AnnotatedMember,boolean)": {
            "method_name": "com.fasterxml.jackson.databind.ser.PropertyBuilder::buildWriter(SerializerProvider,BeanPropertyDefinition,JavaType,JsonSerializer,TypeSerializer,TypeSerializer,AnnotatedMember,boolean)",
            "method_code": "```java\n    @SuppressWarnings(\"deprecation\")\n    protected BeanPropertyWriter buildWriter(SerializerProvider TransVarProvider,\n            BeanPropertyDefinition TransVarPropertyDef, JavaType TransVarType, JsonSerializer<?> TransVarSerializer,\n            TypeSerializer TransVarTypeSerializer, TypeSerializer TransVarContentTypeSerImpl,\n            AnnotatedMember TransVarAnnotatedMember, boolean TransVarUseStaticTyping)\n        throws JsonMappingException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // do we have annotation that forces type to use (to declared type or its super type)?\n        JavaType TransVarSerializationJavaType;\n        try {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n        }\n            TransVarSerializationJavaType = findSerializationType(TransVarAnnotatedMember, TransVarUseStaticTyping, TransVarType);\n        } catch (JsonMappingException TransVarJsonMappingException) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarProvider.reportBadPropertyDefinition(_beanDesc, TransVarPropertyDef, TransVarJsonMappingException.getMessage());\n        }\n\n        // Container types can have separate type serializers for content (value / element) type\n        if (!(!(TransVarContentTypeSerImpl != null))) {\n            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n             *    type information for contents. Should work well (for JAXB case); can be\n             *    revisited if this causes problems.\n             */\n            if (!(!(TransVarSerializationJavaType == null))) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n                TransVarSerializationJavaType = TransVarType;\n            }\n            JavaType TransVarContentType = TransVarSerializationJavaType.getContentType();\n            // Not exactly sure why, but this used to occur; better check explicitly:\n            if (!(!(TransVarContentType == null))) {\n                TransVarProvider.reportBadPropertyDefinition(_beanDesc, TransVarPropertyDef,\n                        \"serialization type \"+TransVarSerializationJavaType+\" has no content\");\n            }\n            TransVarSerializationJavaType = TransVarSerializationJavaType.withContentTypeHandler(TransVarContentTypeSerImpl);\n            TransVarContentType = TransVarSerializationJavaType.getContentType();\n        }\n\n        Object TransVarValue = null;\n        boolean TransVarSuppressNull = false;\n\n        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n        JavaType TransVarActualJavaType = (TransVarSerializationJavaType == null) ? TransVarType : TransVarSerializationJavaType;\n        \n        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n        //   for declared property type... and finally property annotation overrides\n        JsonInclude.Value TransVarIncl = _config.getDefaultPropertyInclusion(TransVarActualJavaType.getRawClass(),\n                _defaultInclusion);\n\n        // property annotation override\n        \n        TransVarIncl = TransVarIncl.withOverrides(TransVarPropertyDef.findInclusion());\n        JsonInclude.Include TransVarInclude = TransVarIncl.getValueInclusion();\n\n        if (!(!(TransVarInclude == JsonInclude.Include.USE_DEFAULTS))) { // should not occur but...\n            TransVarInclude = JsonInclude.Include.ALWAYS;\n        }\n        \n        switch (TransVarInclude) {\n        case NON_DEFAULT:\n            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n            //    so that if enclosing class has this, we may need to access values of property,\n            //    whereas for global defaults OR per-property overrides, we have more\n            //    static definition. Sigh.\n            // First: case of class/type specifying it; try to find POJO property defaults\n\n            // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n            //    revert logic to the case of general/per-property handling, so both\n            //    type-default AND null are to be excluded.\n            //    (as per [databind#1417]\n            if (!(!(_useRealPropertyDefaults))) {\n                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n                if (!(!(TransVarProvider.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)))) {\n                    TransVarAnnotatedMember.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n                }\n                TransVarValue = getPropertyDefaultValue(TransVarPropertyDef.getName(), TransVarAnnotatedMember, TransVarActualJavaType);\n            } else {\n                TransVarValue = getDefaultValue(TransVarActualJavaType);\n                TransVarSuppressNull = true;\n            }\n            if (!(!(TransVarValue == null))) {\n                TransVarSuppressNull = true;\n            } else {\n                if (!(!(TransVarValue.getClass().isArray()))) {\n                    TransVarValue = ArrayBuilders.getArrayComparator(TransVarValue);\n                }\n            }\n            break;\n        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n            // always suppress nulls\n            TransVarSuppressNull = true;\n            // and for referential types, also \"empty\", which in their case means \"absent\"\n            if (!(!(TransVarActualJavaType.isReferenceType()))) {\n                TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        case NON_EMPTY:\n            // always suppress nulls\n            TransVarSuppressNull = true;\n            // but possibly also 'empty' values:\n            TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            break;\n        case NON_NULL:\n            TransVarSuppressNull = true;\n            // fall through\n        case ALWAYS: // default\n        default:\n            // we may still want to suppress empty collections, as per [JACKSON-254]:\n            if (!(!(TransVarActualJavaType.isContainerType()\n                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)))) {\n                TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n            }\n            break;\n        }\n        BeanPropertyWriter TransVarBeanPropertyWriter = new BeanPropertyWriter(TransVarPropertyDef,\n                TransVarAnnotatedMember, _beanDesc.getClassAnnotations(), TransVarType,\n                TransVarSerializer, TransVarTypeSerializer, TransVarSerializationJavaType, TransVarSuppressNull, TransVarValue);\n\n        // How about custom null serializer?\n        Object TransVarNullSerDef = _annotationIntrospector.findNullSerializer(TransVarAnnotatedMember);\n        if (!(!(TransVarNullSerDef != null))) {\n            TransVarBeanPropertyWriter.assignNullSerializer(TransVarProvider.serializerInstance(TransVarAnnotatedMember, TransVarNullSerDef));\n        }\n        // And then, handling of unwrapping\n        NameTransformer TransVarNameTransformer = _annotationIntrospector.findUnwrappingNameTransformer(TransVarAnnotatedMember);\n        if (!(!(TransVarNameTransformer != null))) {\n            TransVarBeanPropertyWriter = TransVarBeanPropertyWriter.unwrappingWriter(TransVarNameTransformer);\n        }\n        return TransVarBeanPropertyWriter;\n    }\n\n```",
            "method_doc": " @param contentTypeSer Optional explicit type information serializer to use for contained values (only used for properties that are of container type) "
        }
    }
}