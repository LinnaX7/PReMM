{
    "buggy_classes": [
        "com.google.javascript.jscomp.parsing.JsDocInfoParser"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::skipEOLs()",
            "method_code": "```java\n  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }\n\n```",
            "method_doc": " Skips all EOLs and all empty lines in the JSDoc. Call this method if you want the JSDoc entry to span multiple lines. ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across mutliple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All three tests fail on the same assertion pattern** - comparing expected vs actual license text\n2. **The failures involve whitespace and line break handling** in multi-line JSDoc comments\n3. **Both `@license` and `@preserve` tags are affected** - suggesting a common parsing issue\n4. **The test output comparisons show consistent spacing discrepancies**:\n   - Extra spaces are being added or removed around line breaks\n   - The pattern shows `[Bar\\n\\n]Baz` vs `[ Bar\\n\\n ]Baz` type differences\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **JSDoc comment text extraction logic**, specifically in how multi-line text after `@license` or `@preserve` tags is processed. The issue likely resides in one of these areas:\n\n1. **Line continuation and whitespace normalization** in `JsDocInfoParser` - The parser is incorrectly handling leading/trailing whitespace when processing multi-line license text.\n\n2. **Asterisk prefix stripping logic** - In `testParseLicenseAscii`, the parser may be improperly removing or preserving the asterisk characters and associated whitespace from JSDoc-formatted comments.\n\n3. **Text accumulation algorithm** - The method that accumulates text content after JSDoc tags (likely in the license/preserve tag handler) has a bug in how it handles:\n   - Line breaks and empty lines\n   - Leading spaces on continuation lines\n   - The transition between tagged line and subsequent lines\n\nThe defect is most likely in the production code method responsible for extracting and normalizing the text content following `@license` and `@preserve` tags, possibly in the token processing or text accumulation logic within `JsDocInfoParser` or its related text extraction utilities.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 9,
            "reason": "#9# The skipEOLs() method is highly suspicious because it handles EOL and STAR token processing which directly affects multi-line text parsing. The test failures show consistent whitespace and line break discrepancies in license text extraction, and this method's logic of skipping EOLs while conditionally handling STAR tokens could be incorrectly normalizing whitespace in multi-line JSDoc comments, explaining why both @license and @preserve tags are affected across all failed tests."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parse()",
            "method_code": "```java\n  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n\n```",
            "method_doc": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across mutliple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All three tests fail on the same assertion pattern** - comparing expected vs actual license text\n2. **The failures involve whitespace and line break handling** in multi-line JSDoc comments\n3. **Both `@license` and `@preserve` tags are affected** - suggesting a common parsing issue\n4. **The test output comparisons show consistent spacing discrepancies**:\n   - Extra spaces are being added or removed around line breaks\n   - The pattern shows `[Bar\\n\\n]Baz` vs `[ Bar\\n\\n ]Baz` type differences\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **JSDoc comment text extraction logic**, specifically in how multi-line text after `@license` or `@preserve` tags is processed. The issue likely resides in one of these areas:\n\n1. **Line continuation and whitespace normalization** in `JsDocInfoParser` - The parser is incorrectly handling leading/trailing whitespace when processing multi-line license text.\n\n2. **Asterisk prefix stripping logic** - In `testParseLicenseAscii`, the parser may be improperly removing or preserving the asterisk characters and associated whitespace from JSDoc-formatted comments.\n\n3. **Text accumulation algorithm** - The method that accumulates text content after JSDoc tags (likely in the license/preserve tag handler) has a bug in how it handles:\n   - Line breaks and empty lines\n   - Leading spaces on continuation lines\n   - The transition between tagged line and subsequent lines\n\nThe defect is most likely in the production code method responsible for extracting and normalizing the text content following `@license` and `@preserve` tags, possibly in the token processing or text accumulation logic within `JsDocInfoParser` or its related text extraction utilities.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it contains the specific case handling for @license and @preserve tags where the extraction logic uses extractMultilineTextualBlock with WhitespaceOption.PRESERVE, and the test failures consistently show whitespace handling issues in multi-line license text extraction. The defect appears to be in how the text accumulation and whitespace preservation is implemented for these specific annotations."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::extractMultilineTextualBlock(JsDocToken,WhitespaceOption)",
            "method_code": "```java\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken TransVarToken2,\n                                                      WhitespaceOption TransVarOption2) {\n\n    if (!(!(false))) {\n                                                            System.out.println(\"log\");\n    }\n    if (!(!(TransVarToken2 == JsDocToken.EOC || TransVarToken2 == JsDocToken.EOL || TransVarToken2 == JsDocToken.EOF))) {\n      if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    return new ExtractionInfo(\"\", TransVarToken2);\n    }\n\n    stream.update();\n    int TransVarLineNumber = stream.getLineno();\n    int TransVarStartCharno2 = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String TransVarLine2 = stream.getRemainingJSDocLine();\n    if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n    }\n    TransVarLine2 = TransVarLine2.trim();\n    }\n\n    StringBuilder TransVarBuilder2 = new StringBuilder();\n    TransVarBuilder2.append(TransVarLine2);\n\n    state = State.SEARCHING_ANNOTATION;\n    TransVarToken2 = next();\n\n    boolean TransVarIgnore = false;\n\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n\n    do {\n      switch (TransVarToken2) {\n        case STAR:\n          if (!(!(TransVarIgnore))) {\n            // Mark the position after the star as the new start of the line.\n          } else {\n            // The star is part of the comment.\n            if (!(!(TransVarBuilder2.length() > 0))) {\n              TransVarBuilder2.append(' ');\n            }\n\n            TransVarBuilder2.append('*');\n          }\n\n          TransVarToken2 = next();\n          continue;\n\n        case EOL:\n          if (!(!(TransVarOption2 != WhitespaceOption.SINGLE_LINE))) {\n            TransVarBuilder2.append(\"\\n\");\n          }\n\n          TransVarIgnore = true;\n          TransVarToken2 = next();\n          continue;\n\n        default:\n          TransVarIgnore = false;\n          state = State.SEARCHING_ANNOTATION;\n\n              // All tokens must be separated by a space.\n\n          if (!(!(TransVarToken2 == JsDocToken.EOC || TransVarToken2 == JsDocToken.EOF\n                || (TransVarToken2 == JsDocToken.ANNOTATION && TransVarOption2 != WhitespaceOption.PRESERVE)))) {\n            String TransVarText = TransVarBuilder2.toString();\n\n            if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n              TransVarText = TransVarText.trim();\n            }\n\n            int TransVarEndLine = stream.getLineno();\n            int TransVarEndCharno2 = stream.getCharno();\n\n            if (!(!(TransVarText.length() > 0))) {\n              jsdocBuilder.markText(TransVarText, TransVarLineNumber, TransVarStartCharno2,\n                  TransVarEndLine, TransVarEndCharno2);\n            }\n\n            return new ExtractionInfo(TransVarText, TransVarToken2);\n          }\n\n          if (!(!(TransVarBuilder2.length() > 0))) {\n            TransVarBuilder2.append(' ');\n          }\n          TransVarBuilder2.append(toString(TransVarToken2));\n\n          TransVarLine2 = stream.getRemainingJSDocLine();\n\n          if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n            TransVarLine2 = trimEnd(TransVarLine2);\n          }\n\n          TransVarBuilder2.append(TransVarLine2);\n          TransVarToken2 = next();\n      }\n    } while (!(!(true)));\n  }\n\n```",
            "method_doc": " Extracts the text found on the current line and all subsequent until either an annotation, end of comment or end of file is reached. Note that if this method detects an end of line as the first token, it will quit immediately (indicating that there is no text where it was expected).  Note that token = info.token; should be called after this method is used to update the token properly in the parser.  @param token The start token. @param option How to handle whitespace.  @return The extraction information. ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across mutliple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All three tests fail on the same assertion pattern** - comparing expected vs actual license text\n2. **The failures involve whitespace and line break handling** in multi-line JSDoc comments\n3. **Both `@license` and `@preserve` tags are affected** - suggesting a common parsing issue\n4. **The test output comparisons show consistent spacing discrepancies**:\n   - Extra spaces are being added or removed around line breaks\n   - The pattern shows `[Bar\\n\\n]Baz` vs `[ Bar\\n\\n ]Baz` type differences\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **JSDoc comment text extraction logic**, specifically in how multi-line text after `@license` or `@preserve` tags is processed. The issue likely resides in one of these areas:\n\n1. **Line continuation and whitespace normalization** in `JsDocInfoParser` - The parser is incorrectly handling leading/trailing whitespace when processing multi-line license text.\n\n2. **Asterisk prefix stripping logic** - In `testParseLicenseAscii`, the parser may be improperly removing or preserving the asterisk characters and associated whitespace from JSDoc-formatted comments.\n\n3. **Text accumulation algorithm** - The method that accumulates text content after JSDoc tags (likely in the license/preserve tag handler) has a bug in how it handles:\n   - Line breaks and empty lines\n   - Leading spaces on continuation lines\n   - The transition between tagged line and subsequent lines\n\nThe defect is most likely in the production code method responsible for extracting and normalizing the text content following `@license` and `@preserve` tags, possibly in the token processing or text accumulation logic within `JsDocInfoParser` or its related text extraction utilities.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles multi-line text extraction for JSDoc comments and contains logic for whitespace handling that directly matches the test failures. The method processes line breaks, asterisks, and whitespace normalization which aligns with the observed discrepancies in license text formatting across all three failed tests. The WhitespaceOption parameter and the trimming logic suggest this method is responsible for the exact whitespace issues seen in the test outputs."
        },
        {
            "method_name": "com.google.javascript.jscomp.CodePrinter::toSource(Node,Format,boolean,boolean,int,SourceMap,DetailLevel,Charset,boolean)",
            "method_code": "```java\n  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  boolean preferEndOfFileBreak,\n                                 int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\n                                 Charset outputCharset,\n                                 boolean tagAsStrict) {\n    Preconditions.checkState(sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, preferEndOfFileBreak, lineLengthThreshold,\n            createSourceMap, sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, outputCharset)\n        : new CodeGenerator(mcp, outputCharset);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }\n\n```",
            "method_doc": " Converts a tree to js code ",
            "class_name": "com.google.javascript.jscomp.CodePrinter",
            "class_doc": " CodePrinter prints out js code in either pretty format or compact format.  @see CodeGenerator ",
            "test_failure_causes": "Based on my analysis of the failed test `testIssue701`, I can identify the common pattern and recommend a possible defect in the production code:\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves the preservation of whitespace and formatting in comments with `@preserve` annotations. The test output comparison shows that the actual compiler output has lost significant whitespace formatting compared to the expected output.\n\n**Key Observations:**\n1. **Whitespace Preservation Issue**: The expected output contains carefully formatted ASCII art with specific indentation and spacing, but the actual output shows collapsed whitespace\n2. **Comment Processing**: The test specifically targets `@preserve` annotated comments that should maintain their original formatting\n3. **Multi-line Comment Handling**: The failure occurs in multi-line comment processing where line breaks and indentation are crucial\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **comment preservation logic within the JavaScript compiler**, specifically in how `@preserve` annotated comments are processed and reconstructed during compilation.\n\n**Possible Defect Locations:**\n1. **Comment Stripping/Reconstruction Logic**: The code that strips comments during parsing and reconstructs them in the output may be normalizing or collapsing whitespace\n2. **AST Comment Handling**: The Abstract Syntax Tree node handling for comments might be losing formatting information\n3. **Pretty Printer/Comment Writer**: The code responsible for writing comments back to the output may be applying formatting rules that don't respect the original whitespace\n\n**Specific Areas to Investigate:**\n- `CommentCollection` or similar comment preservation classes\n- `CodePrinter` or output generation classes that handle comment formatting\n- AST node serialization methods for comment nodes\n- Any normalization passes that might be affecting comment content\n\nThe defect likely involves over-aggressive whitespace normalization or improper handling of multi-line comment formatting when `@preserve` annotations are present, causing the compiler to lose the precise ASCII art formatting that should be maintained.",
            "test_suite": "com.google.javascript.jscomp.IntegrationTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed because it directly controls the code generation and output formatting process. The test failure shows whitespace and formatting issues in preserved comments, and this method is responsible for converting the AST to source code using either CompactCodePrinter or PrettyCodePrinter. The formatting logic in these printer implementations likely contains the bug that incorrectly handles whitespace preservation in @preserve annotated comments during the code generation phase."
        },
        {
            "method_name": "com.google.javascript.jscomp.CodePrinter$Builder::build()",
            "method_code": "```java\n    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, preferLineBreakAtEndOfFile,\n          lineLengthThreshold, sourceMap, sourceMapDetailLevel, outputCharset,\n          tagAsStrict);\n    }\n\n```",
            "method_doc": " Generates the source code and returns it. ",
            "class_name": "com.google.javascript.jscomp.CodePrinter",
            "class_doc": " CodePrinter prints out js code in either pretty format or compact format.  @see CodeGenerator ",
            "test_failure_causes": "Based on my analysis of the failed test `testIssue701`, I can identify the common pattern and recommend a possible defect in the production code:\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves the preservation of whitespace and formatting in comments with `@preserve` annotations. The test output comparison shows that the actual compiler output has lost significant whitespace formatting compared to the expected output.\n\n**Key Observations:**\n1. **Whitespace Preservation Issue**: The expected output contains carefully formatted ASCII art with specific indentation and spacing, but the actual output shows collapsed whitespace\n2. **Comment Processing**: The test specifically targets `@preserve` annotated comments that should maintain their original formatting\n3. **Multi-line Comment Handling**: The failure occurs in multi-line comment processing where line breaks and indentation are crucial\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **comment preservation logic within the JavaScript compiler**, specifically in how `@preserve` annotated comments are processed and reconstructed during compilation.\n\n**Possible Defect Locations:**\n1. **Comment Stripping/Reconstruction Logic**: The code that strips comments during parsing and reconstructs them in the output may be normalizing or collapsing whitespace\n2. **AST Comment Handling**: The Abstract Syntax Tree node handling for comments might be losing formatting information\n3. **Pretty Printer/Comment Writer**: The code responsible for writing comments back to the output may be applying formatting rules that don't respect the original whitespace\n\n**Specific Areas to Investigate:**\n- `CommentCollection` or similar comment preservation classes\n- `CodePrinter` or output generation classes that handle comment formatting\n- AST node serialization methods for comment nodes\n- Any normalization passes that might be affecting comment content\n\nThe defect likely involves over-aggressive whitespace normalization or improper handling of multi-line comment formatting when `@preserve` annotations are present, causing the compiler to lose the precise ASCII art formatting that should be maintained.",
            "test_suite": "com.google.javascript.jscomp.IntegrationTest",
            "score": 7,
            "reason": "#7# The build() method is the entry point for code generation and controls the output format selection, but the actual whitespace preservation issue likely resides deeper in the toSource() method or comment handling logic that this method calls. The method itself doesn't directly manipulate comment formatting but orchestrates the overall code printing process."
        },
        {
            "method_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter::endFile()",
            "method_code": "```java\n    @Override\n    void endFile() {\n      super.endFile();\n      if (!preferLineBreakAtEndOfFile) {\n        return;\n      }\n      if (lineLength > lineLengthThreshold / 2) {\n        // Add an extra break at end of file.\n        append(\";\");\n        startNewLine();\n      } else if (prevCutPosition > 0) {\n        // Shift the previous break to end of file by replacing it with a\n        // <space> and adding a new break at end of file. Adding the space\n        // handles cases like instanceof\\nfoo. (it would be nice to avoid this)\n        code.setCharAt(prevCutPosition, ' ');\n        lineStartPosition = prevLineStartPosition;\n        lineLength = code.length() - lineStartPosition;\n        reportLineCut(lineIndex, prevCutPosition + 1, false);\n        lineIndex--;\n        prevCutPosition = 0;\n        prevLineStartPosition = 0;\n        append(\";\");\n        startNewLine();\n      } else {\n        // A small file with no line breaks. We do nothing in this case to\n        // avoid excessive line breaks. It's not ideal if a lot of these pile\n        // up, but that is reasonably unlikely.\n      }\n    }\n\n```",
            "method_doc": "Handles end-of-file line breaking logic based on configuration, calls method \"startNewLine\" to add line breaks when needed.",
            "class_name": "com.google.javascript.jscomp.CodePrinter",
            "class_doc": " CodePrinter prints out js code in either pretty format or compact format.  @see CodeGenerator ",
            "test_failure_causes": "Based on my analysis of the failed test `testIssue701`, I can identify the common pattern and recommend a possible defect in the production code:\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves the preservation of whitespace and formatting in comments with `@preserve` annotations. The test output comparison shows that the actual compiler output has lost significant whitespace formatting compared to the expected output.\n\n**Key Observations:**\n1. **Whitespace Preservation Issue**: The expected output contains carefully formatted ASCII art with specific indentation and spacing, but the actual output shows collapsed whitespace\n2. **Comment Processing**: The test specifically targets `@preserve` annotated comments that should maintain their original formatting\n3. **Multi-line Comment Handling**: The failure occurs in multi-line comment processing where line breaks and indentation are crucial\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **comment preservation logic within the JavaScript compiler**, specifically in how `@preserve` annotated comments are processed and reconstructed during compilation.\n\n**Possible Defect Locations:**\n1. **Comment Stripping/Reconstruction Logic**: The code that strips comments during parsing and reconstructs them in the output may be normalizing or collapsing whitespace\n2. **AST Comment Handling**: The Abstract Syntax Tree node handling for comments might be losing formatting information\n3. **Pretty Printer/Comment Writer**: The code responsible for writing comments back to the output may be applying formatting rules that don't respect the original whitespace\n\n**Specific Areas to Investigate:**\n- `CommentCollection` or similar comment preservation classes\n- `CodePrinter` or output generation classes that handle comment formatting\n- AST node serialization methods for comment nodes\n- Any normalization passes that might be affecting comment content\n\nThe defect likely involves over-aggressive whitespace normalization or improper handling of multi-line comment formatting when `@preserve` annotations are present, causing the compiler to lose the precise ASCII art formatting that should be maintained.",
            "test_suite": "com.google.javascript.jscomp.IntegrationTest",
            "score": 3,
            "reason": "#3# This method handles end-of-file line breaking logic but doesn't appear to directly process comment formatting or whitespace preservation. The test failure involves @preserve annotated comments losing their ASCII art formatting, which is more likely related to comment processing logic elsewhere in the codebase rather than end-of-file line breaking."
        },
        {
            "method_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter::getCode()",
            "method_code": "```java\n    public String getCode() {\n      return code.toString();\n    }\n\n```",
            "method_doc": "Returns the generated code as a string from internal buffer.",
            "class_name": "com.google.javascript.jscomp.CodePrinter",
            "class_doc": " CodePrinter prints out js code in either pretty format or compact format.  @see CodeGenerator ",
            "test_failure_causes": "Based on my analysis of the failed test `testIssue701`, I can identify the common pattern and recommend a possible defect in the production code:\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently involves the preservation of whitespace and formatting in comments with `@preserve` annotations. The test output comparison shows that the actual compiler output has lost significant whitespace formatting compared to the expected output.\n\n**Key Observations:**\n1. **Whitespace Preservation Issue**: The expected output contains carefully formatted ASCII art with specific indentation and spacing, but the actual output shows collapsed whitespace\n2. **Comment Processing**: The test specifically targets `@preserve` annotated comments that should maintain their original formatting\n3. **Multi-line Comment Handling**: The failure occurs in multi-line comment processing where line breaks and indentation are crucial\n\n## Recommended Production Code Defect\n\nThe likely defect is in the **comment preservation logic within the JavaScript compiler**, specifically in how `@preserve` annotated comments are processed and reconstructed during compilation.\n\n**Possible Defect Locations:**\n1. **Comment Stripping/Reconstruction Logic**: The code that strips comments during parsing and reconstructs them in the output may be normalizing or collapsing whitespace\n2. **AST Comment Handling**: The Abstract Syntax Tree node handling for comments might be losing formatting information\n3. **Pretty Printer/Comment Writer**: The code responsible for writing comments back to the output may be applying formatting rules that don't respect the original whitespace\n\n**Specific Areas to Investigate:**\n- `CommentCollection` or similar comment preservation classes\n- `CodePrinter` or output generation classes that handle comment formatting\n- AST node serialization methods for comment nodes\n- Any normalization passes that might be affecting comment content\n\nThe defect likely involves over-aggressive whitespace normalization or improper handling of multi-line comment formatting when `@preserve` annotations are present, causing the compiler to lose the precise ASCII art formatting that should be maintained.",
            "test_suite": "com.google.javascript.jscomp.IntegrationTest",
            "score": 2,
            "reason": "#2# This method simply returns the generated code as a string from an internal buffer and doesn't contain any logic for comment processing, whitespace handling, or @preserve annotation logic that would explain the formatting issues in the test failure."
        },
        {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::next()",
            "method_code": "```java\n  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }\n\n```",
            "method_doc": " Gets the next token of the token stream or the buffered token if a matching was previously made. ",
            "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
            "class_doc": "spreading it across mutliple packages.",
            "test_failure_causes": "Based on my analysis of the failed tests, I've identified the common patterns and possible defect in the production code:\n\n## Common Patterns Identified:\n\n1. **All three tests fail on the same assertion pattern** - comparing expected vs actual license text\n2. **The failures involve whitespace and line break handling** in multi-line JSDoc comments\n3. **Both `@license` and `@preserve` tags are affected** - suggesting a common parsing issue\n4. **The test output comparisons show consistent spacing discrepancies**:\n   - Extra spaces are being added or removed around line breaks\n   - The pattern shows `[Bar\\n\\n]Baz` vs `[ Bar\\n\\n ]Baz` type differences\n\n## Recommended Defect in Production Code:\n\nThe defect appears to be in the **JSDoc comment text extraction logic**, specifically in how multi-line text after `@license` or `@preserve` tags is processed. The issue likely resides in one of these areas:\n\n1. **Line continuation and whitespace normalization** in `JsDocInfoParser` - The parser is incorrectly handling leading/trailing whitespace when processing multi-line license text.\n\n2. **Asterisk prefix stripping logic** - In `testParseLicenseAscii`, the parser may be improperly removing or preserving the asterisk characters and associated whitespace from JSDoc-formatted comments.\n\n3. **Text accumulation algorithm** - The method that accumulates text content after JSDoc tags (likely in the license/preserve tag handler) has a bug in how it handles:\n   - Line breaks and empty lines\n   - Leading spaces on continuation lines\n   - The transition between tagged line and subsequent lines\n\nThe defect is most likely in the production code method responsible for extracting and normalizing the text content following `@license` and `@preserve` tags, possibly in the token processing or text accumulation logic within `JsDocInfoParser` or its related text extraction utilities.",
            "test_suite": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest",
            "score": 2,
            "reason": "#2# The next() method is unlikely to be the root cause of the test failures as it's a simple token retrieval method that doesn't handle text content processing, whitespace normalization, or multi-line comment parsing - the actual issue appears to be in text accumulation logic for license/preserve tags rather than basic token fetching."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter::endFile()": {
            "method_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter::endFile()",
            "method_code": "```java\n    @Override\n    void endFile() {\n      super.endFile();\n      if (!preferLineBreakAtEndOfFile) {\n        return;\n      }\n      if (lineLength > lineLengthThreshold / 2) {\n        // Add an extra break at end of file.\n        append(\";\");\n        startNewLine();\n      } else if (prevCutPosition > 0) {\n        // Shift the previous break to end of file by replacing it with a\n        // <space> and adding a new break at end of file. Adding the space\n        // handles cases like instanceof\\nfoo. (it would be nice to avoid this)\n        code.setCharAt(prevCutPosition, ' ');\n        lineStartPosition = prevLineStartPosition;\n        lineLength = code.length() - lineStartPosition;\n        reportLineCut(lineIndex, prevCutPosition + 1, false);\n        lineIndex--;\n        prevCutPosition = 0;\n        prevLineStartPosition = 0;\n        append(\";\");\n        startNewLine();\n      } else {\n        // A small file with no line breaks. We do nothing in this case to\n        // avoid excessive line breaks. It's not ideal if a lot of these pile\n        // up, but that is reasonably unlikely.\n      }\n    }\n\n```",
            "method_doc": "Handles end-of-file line breaking logic based on configuration, calls method \"startNewLine\" to add line breaks when needed."
        },
        "com.google.javascript.jscomp.CodePrinter$Builder::build()": {
            "method_name": "com.google.javascript.jscomp.CodePrinter$Builder::build()",
            "method_code": "```java\n    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, preferLineBreakAtEndOfFile,\n          lineLengthThreshold, sourceMap, sourceMapDetailLevel, outputCharset,\n          tagAsStrict);\n    }\n\n```",
            "method_doc": " Generates the source code and returns it. "
        },
        "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter::getCode()": {
            "method_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter::getCode()",
            "method_code": "```java\n    public String getCode() {\n      return code.toString();\n    }\n\n```",
            "method_doc": "Returns the generated code as a string from internal buffer."
        },
        "com.google.javascript.jscomp.CodePrinter::toSource(Node,Format,boolean,boolean,int,SourceMap,DetailLevel,Charset,boolean)": {
            "method_name": "com.google.javascript.jscomp.CodePrinter::toSource(Node,Format,boolean,boolean,int,SourceMap,DetailLevel,Charset,boolean)",
            "method_code": "```java\n  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  boolean preferEndOfFileBreak,\n                                 int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\n                                 Charset outputCharset,\n                                 boolean tagAsStrict) {\n    Preconditions.checkState(sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, preferEndOfFileBreak, lineLengthThreshold,\n            createSourceMap, sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, outputCharset)\n        : new CodeGenerator(mcp, outputCharset);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }\n\n```",
            "method_doc": " Converts a tree to js code "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::skipEOLs()": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::skipEOLs()",
            "method_code": "```java\n  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }\n\n```",
            "method_doc": " Skips all EOLs and all empty lines in the JSDoc. Call this method if you want the JSDoc entry to span multiple lines. "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::parse()": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::parse()",
            "method_code": "```java\n  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSISTENTIDGENERATOR:\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXPOSE:\n                  if (!jsdocBuilder.recordExpose()) {\n                    parser.addParserWarning(\"msg.jsdoc.expose\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case IDGENERATOR:\n                  if (!jsdocBuilder.recordIdGenerator()) {\n                    parser.addParserWarning(\"msg.jsdoc.idgen\",\n                      stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n\n```",
            "method_doc": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::next()": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::next()",
            "method_code": "```java\n  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }\n\n```",
            "method_doc": " Gets the next token of the token stream or the buffered token if a matching was previously made. "
        },
        "com.google.javascript.jscomp.parsing.JsDocInfoParser::extractMultilineTextualBlock(JsDocToken,WhitespaceOption)": {
            "method_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser::extractMultilineTextualBlock(JsDocToken,WhitespaceOption)",
            "method_code": "```java\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken TransVarToken2,\n                                                      WhitespaceOption TransVarOption2) {\n\n    if (!(!(false))) {\n                                                            System.out.println(\"log\");\n    }\n    if (!(!(TransVarToken2 == JsDocToken.EOC || TransVarToken2 == JsDocToken.EOL || TransVarToken2 == JsDocToken.EOF))) {\n      if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    return new ExtractionInfo(\"\", TransVarToken2);\n    }\n\n    stream.update();\n    int TransVarLineNumber = stream.getLineno();\n    int TransVarStartCharno2 = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String TransVarLine2 = stream.getRemainingJSDocLine();\n    if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n    }\n    TransVarLine2 = TransVarLine2.trim();\n    }\n\n    StringBuilder TransVarBuilder2 = new StringBuilder();\n    TransVarBuilder2.append(TransVarLine2);\n\n    state = State.SEARCHING_ANNOTATION;\n    TransVarToken2 = next();\n\n    boolean TransVarIgnore = false;\n\n    // Track the start of the line to count whitespace that\n    // the tokenizer skipped. Because this case is rare, it's easier\n    // to do this here than in the tokenizer.\n\n    do {\n      switch (TransVarToken2) {\n        case STAR:\n          if (!(!(TransVarIgnore))) {\n            // Mark the position after the star as the new start of the line.\n          } else {\n            // The star is part of the comment.\n            if (!(!(TransVarBuilder2.length() > 0))) {\n              TransVarBuilder2.append(' ');\n            }\n\n            TransVarBuilder2.append('*');\n          }\n\n          TransVarToken2 = next();\n          continue;\n\n        case EOL:\n          if (!(!(TransVarOption2 != WhitespaceOption.SINGLE_LINE))) {\n            TransVarBuilder2.append(\"\\n\");\n          }\n\n          TransVarIgnore = true;\n          TransVarToken2 = next();\n          continue;\n\n        default:\n          TransVarIgnore = false;\n          state = State.SEARCHING_ANNOTATION;\n\n              // All tokens must be separated by a space.\n\n          if (!(!(TransVarToken2 == JsDocToken.EOC || TransVarToken2 == JsDocToken.EOF\n                || (TransVarToken2 == JsDocToken.ANNOTATION && TransVarOption2 != WhitespaceOption.PRESERVE)))) {\n            String TransVarText = TransVarBuilder2.toString();\n\n            if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n              TransVarText = TransVarText.trim();\n            }\n\n            int TransVarEndLine = stream.getLineno();\n            int TransVarEndCharno2 = stream.getCharno();\n\n            if (!(!(TransVarText.length() > 0))) {\n              jsdocBuilder.markText(TransVarText, TransVarLineNumber, TransVarStartCharno2,\n                  TransVarEndLine, TransVarEndCharno2);\n            }\n\n            return new ExtractionInfo(TransVarText, TransVarToken2);\n          }\n\n          if (!(!(TransVarBuilder2.length() > 0))) {\n            TransVarBuilder2.append(' ');\n          }\n          TransVarBuilder2.append(toString(TransVarToken2));\n\n          TransVarLine2 = stream.getRemainingJSDocLine();\n\n          if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n            TransVarLine2 = trimEnd(TransVarLine2);\n          }\n\n          TransVarBuilder2.append(TransVarLine2);\n          TransVarToken2 = next();\n      }\n    } while (!(!(true)));\n  }\n\n```",
            "method_doc": " Extracts the text found on the current line and all subsequent until either an annotation, end of comment or end of file is reached. Note that if this method detects an end of line as the first token, it will quit immediately (indicating that there is no text where it was expected).  Note that token = info.token; should be called after this method is used to update the token properly in the parser.  @param token The start token. @param option How to handle whitespace.  @return The extraction information. "
        }
    }
}