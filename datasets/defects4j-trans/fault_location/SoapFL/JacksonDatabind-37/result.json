{
    "buggy_classes": [
        "com.fasterxml.jackson.databind.deser.BeanDeserializerBase"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::createContextual(DeserializationContext,BeanProperty)",
            "method_code": "```java\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        ObjectIdReader oir = _objectIdReader;\n        \n        // First: may have an override for Object Id:\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        if (accessor != null && intr != null) {\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                \n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                // Property-based generator is trickier\n                JavaType idType;\n                SettableBeanProperty idProp;\n                ObjectIdGenerator<?> idGen;\n                ObjectIdResolver resolver = ctxt.objectIdResolverInstance(accessor, objectIdInfo);\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                    PropertyName propName = objectIdInfo.getPropertyName();\n                    idProp = findProperty(propName);\n                    if (idProp == null) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                                +handledType().getName()+\": can not find property with name '\"+propName+\"'\");\n                    }\n                    idType = idProp.getType();\n                    idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n                } else { // other types need to be simpler\n                    JavaType type = ctxt.constructType(implClass);\n                    idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                    idProp = null;\n                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n                }\n                JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n                \t\tidGen, deser, idProp, resolver);\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanDeserializerBase contextual = this;\n        if (oir != null && oir != _objectIdReader) {\n            contextual = contextual.withObjectIdReader(oir);\n        }\n        // And possibly add more properties to ignore\n        if (accessor != null) {\n            String[] ignorals = intr.findPropertiesToIgnore(accessor, false);\n            if (ignorals != null && ignorals.length != 0) {\n                HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals);\n                contextual = contextual.withIgnorableProperties(newIgnored);\n            }\n        }\n\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArrayDeserializer();\n        }\n        return contextual;\n    }\n\n```",
            "method_doc": " Although most of post-processing is done in resolve(), we only get access to referring property's annotations here; and this is needed to support per-property ObjectIds. We will also consider Shape transformations (read from Array) at this point, since it may come from either Class definition or property. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase",
            "class_doc": " Base class for <code>BeanDeserializer</code>. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the following patterns and potential defect:\n\n## Common Patterns Identified:\n\n1. **Single Failure Point**: All failures occur during JSON deserialization using `ObjectMapper.readValue()`\n2. **Exception Type**: Consistently `UnrecognizedPropertyException` indicating Jackson cannot map JSON properties to Java object fields\n3. **Property Issue**: The field \"name\" in the JSON is not recognized by the target class `JsonMapSchema`\n4. **Structural Context**: The failure happens within a collection (`ArrayList[0]`) of `JsonMapSchema` objects\n\n## Analysis of the Failure:\n\nThe stack trace shows that Jackson encounters the \"name\" property in the JSON but cannot find a corresponding field in the `JsonMapSchema` class. The error occurs at:\n- JSON path: `schemas[0].name`\n- Target class: `com.fasterxml.jackson.databind.objectid.JsonMapSchema`\n\n## Recommended Possible Defect in Production Code:\n\nThe most likely defect is in the **`JsonMapSchema` class definition** where the \"name\" field is either:\n\n1. **Missing entirely** from the class definition\n2. **Not properly annotated** with Jackson annotations (like `@JsonProperty`)\n3. **Has incorrect visibility** (e.g., private field without getter/setter)\n4. **Mismatched naming** between JSON property and Java field (if using different naming strategy)\n\nSpecifically, the production code defect appears to be that the `JsonMapSchema` class does not have a field that Jackson can map to the \"name\" property from the JSON input, causing the deserialization to fail when encountering this unexpected property.\n\nThis is a production code issue because the test is providing valid JSON input that should be deserializable according to the expected object structure, but the actual object model in production code doesn't match the expected schema.",
            "test_suite": "com.fasterxml.jackson.databind.objectid.Objecid1083Test",
            "score": 3,
            "reason": "#3# This method handles object ID resolution and property configuration but the actual failure is due to a missing \"name\" field in JsonMapSchema class, which is a structural issue rather than object ID processing. The UnrecognizedPropertyException occurs during standard property deserialization, not object ID handling."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::handleUnknownVanilla(JsonParser,DeserializationContext,Object,String)",
            "method_code": "```java\n    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,\n            Object bean, String propName)\n        throws IOException\n    {\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, bean, propName);\n        } else if (_anySetter != null) {\n            try {\n               // should we consider return type of any setter?\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        } else {\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);         \n        }\n    }\n\n```",
            "method_doc": " Helper method called for an unknown property, when using \"vanilla\" processing. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase",
            "class_doc": " Base class for <code>BeanDeserializer</code>. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the following patterns and potential defect:\n\n## Common Patterns Identified:\n\n1. **Single Failure Point**: All failures occur during JSON deserialization using `ObjectMapper.readValue()`\n2. **Exception Type**: Consistently `UnrecognizedPropertyException` indicating Jackson cannot map JSON properties to Java object fields\n3. **Property Issue**: The field \"name\" in the JSON is not recognized by the target class `JsonMapSchema`\n4. **Structural Context**: The failure happens within a collection (`ArrayList[0]`) of `JsonMapSchema` objects\n\n## Analysis of the Failure:\n\nThe stack trace shows that Jackson encounters the \"name\" property in the JSON but cannot find a corresponding field in the `JsonMapSchema` class. The error occurs at:\n- JSON path: `schemas[0].name`\n- Target class: `com.fasterxml.jackson.databind.objectid.JsonMapSchema`\n\n## Recommended Possible Defect in Production Code:\n\nThe most likely defect is in the **`JsonMapSchema` class definition** where the \"name\" field is either:\n\n1. **Missing entirely** from the class definition\n2. **Not properly annotated** with Jackson annotations (like `@JsonProperty`)\n3. **Has incorrect visibility** (e.g., private field without getter/setter)\n4. **Mismatched naming** between JSON property and Java field (if using different naming strategy)\n\nSpecifically, the production code defect appears to be that the `JsonMapSchema` class does not have a field that Jackson can map to the \"name\" property from the JSON input, causing the deserialization to fail when encountering this unexpected property.\n\nThis is a production code issue because the test is providing valid JSON input that should be deserializable according to the expected object structure, but the actual object model in production code doesn't match the expected schema.",
            "test_suite": "com.fasterxml.jackson.databind.objectid.Objecid1083Test",
            "score": 3,
            "reason": "#3# This method is not the best location to be fixed because the issue is not with the deserialization logic itself, but rather with the JsonMapSchema class definition missing the \"name\" field or proper annotations. The handleUnknownVanilla method is correctly reporting an unrecognized property, which is the expected behavior when the target class doesn't have a matching field for the JSON property \"name\". The fix should be made in the JsonMapSchema class by adding the missing field or annotations."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::resolve(DeserializationContext)",
            "method_code": "```java\n    @Override\n    public void resolve(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        ExternalTypeHandler.Builder extTypes = null;\n        // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n        SettableBeanProperty[] creatorProps;\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            // also: need to try to resolve 'external' type ids...\n            for (SettableBeanProperty prop : creatorProps) {\n                if (prop.hasValueTypeDeserializer()) {\n                    TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                    if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                        if (extTypes == null) {\n                            extTypes = new ExternalTypeHandler.Builder();\n                        }\n                        extTypes.addExternal(prop, typeDeser);\n                    }\n                }\n            }\n        } else {\n            creatorProps = null;\n        }\n\n        UnwrappedPropertyHandler unwrapped = null;\n\n        for (SettableBeanProperty origProp : _beanProperties) {\n            SettableBeanProperty prop = origProp;\n\n            // May already have deserializer from annotations, if so, skip:\n            if (!prop.hasValueDeserializer()) {\n                // [databind#125]: allow use of converters\n                JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);\n                if (deser == null) {\n                    deser = findDeserializer(ctxt, prop.getType(), prop);\n                }\n                prop = prop.withValueDeserializer(deser);\n            } else { // may need contextual version\n                JsonDeserializer<Object> deser = prop.getValueDeserializer();\n                /* Important! This is the only place where actually handle \"primary\"\n                 * property deserializers -- call is different from other places.\n                 */\n                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,\n                        prop.getType());\n                if (cd != deser) {\n                    prop = prop.withValueDeserializer(cd);\n                }\n            }\n\n            // Need to link managed references with matching back references\n            prop = _resolveManagedReferenceProperty(ctxt, prop);\n\n            // [databind#351[: need to wrap properties that require object id resolution.\n            if (!(prop instanceof ManagedReferenceProperty)) {\n                prop = _resolvedObjectIdProperty(ctxt, prop);\n            }\n            // Support unwrapped values (via @JsonUnwrapped)\n            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n            if (u != null) {\n                prop = u;\n                if (unwrapped == null) {\n                    unwrapped = new UnwrappedPropertyHandler();\n                }\n                unwrapped.addProperty(prop);\n                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if\n                 *    the original property is left in place. So let's remove it now.\n                 */\n                _beanProperties.remove(prop);\n                continue;\n            }\n            // non-static inner classes too:\n            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n            if (prop != origProp) {\n                _beanProperties.replace(prop);\n                // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync\n                if (creatorProps != null) {\n                    // 18-May-2015, tatu: _Should_ start with consistent set. But can we really\n                    //   fully count on this? May need to revisit in future; seems to hold for now.\n                    for (int i = 0, len = creatorProps.length; i < len; ++i) {\n                        if (creatorProps[i] == origProp) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        // ... as per above, it is possible we'd need to add this as fallback\n                        // if (but only if) identity check fails?\n                        /*\n                        if (creatorProps[i].getName().equals(prop.getName())) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        */\n                    }\n                }\n            }\n            // one more thing: if this property uses \"external property\" type inclusion,\n            // it needs different handling altogether\n            if (prop.hasValueTypeDeserializer()) {\n                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                    if (extTypes == null) {\n                        extTypes = new ExternalTypeHandler.Builder();\n                    }\n                    extTypes.addExternal(prop, typeDeser);\n                    // In fact, remove from list of known properties to simplify later handling\n                    _beanProperties.remove(prop);\n                    continue;\n                }\n            }\n        }\n\n        // \"any setter\" may also need to be resolved now\n        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n                    _anySetter.getType(), _anySetter.getProperty()));\n        }\n\n        // as well as delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getDelegateCreator());\n        }\n\n        // and array-delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n            }\n            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getArrayDelegateCreator());\n        }\n\n        // And now that we know CreatorProperty instances are also resolved can finally create the creator:\n        if (creatorProps != null) {\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n\n        if (extTypes != null) {\n            _externalTypeIdHandler = extTypes.build();\n            // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n        \n        _unwrappedPropertyHandler = unwrapped;\n        if (unwrapped != null) { // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n\n        // may need to disable vanilla processing, if unwrapped handling was enabled...\n        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n    }\n\n```",
            "method_doc": " Method called to finalize setup of this deserializer, after deserializer itself has been registered. This is needed to handle recursive and transitive dependencies. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase",
            "class_doc": " Base class for <code>BeanDeserializer</code>. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the following patterns and potential defect:\n\n## Common Patterns Identified:\n\n1. **Single Failure Point**: All failures occur during JSON deserialization using `ObjectMapper.readValue()`\n2. **Exception Type**: Consistently `UnrecognizedPropertyException` indicating Jackson cannot map JSON properties to Java object fields\n3. **Property Issue**: The field \"name\" in the JSON is not recognized by the target class `JsonMapSchema`\n4. **Structural Context**: The failure happens within a collection (`ArrayList[0]`) of `JsonMapSchema` objects\n\n## Analysis of the Failure:\n\nThe stack trace shows that Jackson encounters the \"name\" property in the JSON but cannot find a corresponding field in the `JsonMapSchema` class. The error occurs at:\n- JSON path: `schemas[0].name`\n- Target class: `com.fasterxml.jackson.databind.objectid.JsonMapSchema`\n\n## Recommended Possible Defect in Production Code:\n\nThe most likely defect is in the **`JsonMapSchema` class definition** where the \"name\" field is either:\n\n1. **Missing entirely** from the class definition\n2. **Not properly annotated** with Jackson annotations (like `@JsonProperty`)\n3. **Has incorrect visibility** (e.g., private field without getter/setter)\n4. **Mismatched naming** between JSON property and Java field (if using different naming strategy)\n\nSpecifically, the production code defect appears to be that the `JsonMapSchema` class does not have a field that Jackson can map to the \"name\" property from the JSON input, causing the deserialization to fail when encountering this unexpected property.\n\nThis is a production code issue because the test is providing valid JSON input that should be deserializable according to the expected object structure, but the actual object model in production code doesn't match the expected schema.",
            "test_suite": "com.fasterxml.jackson.databind.objectid.Objecid1083Test",
            "score": 3,
            "reason": "#3# The resolve method handles deserializer setup and property resolution, but the actual issue is that the JsonMapSchema class is missing the \"name\" field or proper annotations. The UnrecognizedPropertyException occurs because Jackson cannot find a matching field for the JSON property, which is a class definition problem rather than a deserializer resolution issue."
        },
        {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::handleUnknownProperty(JsonParser,DeserializationContext,Object,String)",
            "method_code": "```java\n    @Override\n    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,\n            Object beanOrClass, String propName)\n        throws IOException\n    {\n        if (_ignoreAllUnknown) {\n            p.skipChildren();\n            return;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, beanOrClass, propName);\n        }\n        // Otherwise use default handling (call handler(s); if not\n        // handled, throw exception or skip depending on settings)\n        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);\n    }\n\n```",
            "method_doc": " Method called when a JSON property is encountered that has not matching setter, any-setter or field, and thus can not be assigned. ",
            "class_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase",
            "class_doc": " Base class for <code>BeanDeserializer</code>. ",
            "test_failure_causes": "Based on my analysis of the failed test case, I've identified the following patterns and potential defect:\n\n## Common Patterns Identified:\n\n1. **Single Failure Point**: All failures occur during JSON deserialization using `ObjectMapper.readValue()`\n2. **Exception Type**: Consistently `UnrecognizedPropertyException` indicating Jackson cannot map JSON properties to Java object fields\n3. **Property Issue**: The field \"name\" in the JSON is not recognized by the target class `JsonMapSchema`\n4. **Structural Context**: The failure happens within a collection (`ArrayList[0]`) of `JsonMapSchema` objects\n\n## Analysis of the Failure:\n\nThe stack trace shows that Jackson encounters the \"name\" property in the JSON but cannot find a corresponding field in the `JsonMapSchema` class. The error occurs at:\n- JSON path: `schemas[0].name`\n- Target class: `com.fasterxml.jackson.databind.objectid.JsonMapSchema`\n\n## Recommended Possible Defect in Production Code:\n\nThe most likely defect is in the **`JsonMapSchema` class definition** where the \"name\" field is either:\n\n1. **Missing entirely** from the class definition\n2. **Not properly annotated** with Jackson annotations (like `@JsonProperty`)\n3. **Has incorrect visibility** (e.g., private field without getter/setter)\n4. **Mismatched naming** between JSON property and Java field (if using different naming strategy)\n\nSpecifically, the production code defect appears to be that the `JsonMapSchema` class does not have a field that Jackson can map to the \"name\" property from the JSON input, causing the deserialization to fail when encountering this unexpected property.\n\nThis is a production code issue because the test is providing valid JSON input that should be deserializable according to the expected object structure, but the actual object model in production code doesn't match the expected schema.",
            "test_suite": "com.fasterxml.jackson.databind.objectid.Objecid1083Test",
            "score": 3,
            "reason": "#3# This method is not the best location to fix because the issue is that the JsonMapSchema class is missing the \"name\" field or proper annotations, not a problem with the unknown property handling logic itself. The method is working correctly by reporting the unrecognized property as expected. The fix should be in the JsonMapSchema class definition to properly map the \"name\" property."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::createContextual(DeserializationContext,BeanProperty)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::createContextual(DeserializationContext,BeanProperty)",
            "method_code": "```java\n    @Override\n    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property) throws JsonMappingException\n    {\n        ObjectIdReader oir = _objectIdReader;\n        \n        // First: may have an override for Object Id:\n        final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        final AnnotatedMember accessor = (property == null || intr == null)\n                ? null : property.getMember();\n        if (accessor != null && intr != null) {\n            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n            if (objectIdInfo != null) { // some code duplication here as well (from BeanDeserializerFactory)\n                // 2.1: allow modifications by \"id ref\" annotations as well:\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n                \n                Class<?> implClass = objectIdInfo.getGeneratorType();\n                // Property-based generator is trickier\n                JavaType idType;\n                SettableBeanProperty idProp;\n                ObjectIdGenerator<?> idGen;\n                ObjectIdResolver resolver = ctxt.objectIdResolverInstance(accessor, objectIdInfo);\n                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                    PropertyName propName = objectIdInfo.getPropertyName();\n                    idProp = findProperty(propName);\n                    if (idProp == null) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \"\n                                +handledType().getName()+\": can not find property with name '\"+propName+\"'\");\n                    }\n                    idType = idProp.getType();\n                    idGen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());\n                } else { // other types need to be simpler\n                    JavaType type = ctxt.constructType(implClass);\n                    idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n                    idProp = null;\n                    idGen = ctxt.objectIdGeneratorInstance(accessor, objectIdInfo);\n                }\n                JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(idType);\n                oir = ObjectIdReader.construct(idType, objectIdInfo.getPropertyName(),\n                \t\tidGen, deser, idProp, resolver);\n            }\n        }\n        // either way, need to resolve serializer:\n        BeanDeserializerBase contextual = this;\n        if (oir != null && oir != _objectIdReader) {\n            contextual = contextual.withObjectIdReader(oir);\n        }\n        // And possibly add more properties to ignore\n        if (accessor != null) {\n            String[] ignorals = intr.findPropertiesToIgnore(accessor, false);\n            if (ignorals != null && ignorals.length != 0) {\n                HashSet<String> newIgnored = ArrayBuilders.setAndArray(contextual._ignorableProps, ignorals);\n                contextual = contextual.withIgnorableProperties(newIgnored);\n            }\n        }\n\n        // One more thing: are we asked to serialize POJO as array?\n        JsonFormat.Shape shape = null;\n        if (accessor != null) {\n            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n\n            if (format != null) {\n                shape = format.getShape();\n            }\n        }\n        if (shape == null) {\n            shape = _serializationShape;\n        }\n        if (shape == JsonFormat.Shape.ARRAY) {\n            contextual = contextual.asArrayDeserializer();\n        }\n        return contextual;\n    }\n\n```",
            "method_doc": " Although most of post-processing is done in resolve(), we only get access to referring property's annotations here; and this is needed to support per-property ObjectIds. We will also consider Shape transformations (read from Array) at this point, since it may come from either Class definition or property. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::handleUnknownVanilla(JsonParser,DeserializationContext,Object,String)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::handleUnknownVanilla(JsonParser,DeserializationContext,Object,String)",
            "method_code": "```java\n    protected void handleUnknownVanilla(JsonParser p, DeserializationContext ctxt,\n            Object bean, String propName)\n        throws IOException\n    {\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, bean, propName);\n        } else if (_anySetter != null) {\n            try {\n               // should we consider return type of any setter?\n                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n            } catch (Exception e) {\n                wrapAndThrow(e, bean, propName, ctxt);\n            }\n        } else {\n            // Unknown: let's call handler method\n            handleUnknownProperty(p, ctxt, bean, propName);         \n        }\n    }\n\n```",
            "method_doc": " Helper method called for an unknown property, when using \"vanilla\" processing. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::resolve(DeserializationContext)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::resolve(DeserializationContext)",
            "method_code": "```java\n    @Override\n    public void resolve(DeserializationContext ctxt)\n        throws JsonMappingException\n    {\n        ExternalTypeHandler.Builder extTypes = null;\n        // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n        SettableBeanProperty[] creatorProps;\n        if (_valueInstantiator.canCreateFromObjectWith()) {\n            creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n            // also: need to try to resolve 'external' type ids...\n            for (SettableBeanProperty prop : creatorProps) {\n                if (prop.hasValueTypeDeserializer()) {\n                    TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                    if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                        if (extTypes == null) {\n                            extTypes = new ExternalTypeHandler.Builder();\n                        }\n                        extTypes.addExternal(prop, typeDeser);\n                    }\n                }\n            }\n        } else {\n            creatorProps = null;\n        }\n\n        UnwrappedPropertyHandler unwrapped = null;\n\n        for (SettableBeanProperty origProp : _beanProperties) {\n            SettableBeanProperty prop = origProp;\n\n            // May already have deserializer from annotations, if so, skip:\n            if (!prop.hasValueDeserializer()) {\n                // [databind#125]: allow use of converters\n                JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);\n                if (deser == null) {\n                    deser = findDeserializer(ctxt, prop.getType(), prop);\n                }\n                prop = prop.withValueDeserializer(deser);\n            } else { // may need contextual version\n                JsonDeserializer<Object> deser = prop.getValueDeserializer();\n                /* Important! This is the only place where actually handle \"primary\"\n                 * property deserializers -- call is different from other places.\n                 */\n                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,\n                        prop.getType());\n                if (cd != deser) {\n                    prop = prop.withValueDeserializer(cd);\n                }\n            }\n\n            // Need to link managed references with matching back references\n            prop = _resolveManagedReferenceProperty(ctxt, prop);\n\n            // [databind#351[: need to wrap properties that require object id resolution.\n            if (!(prop instanceof ManagedReferenceProperty)) {\n                prop = _resolvedObjectIdProperty(ctxt, prop);\n            }\n            // Support unwrapped values (via @JsonUnwrapped)\n            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n            if (u != null) {\n                prop = u;\n                if (unwrapped == null) {\n                    unwrapped = new UnwrappedPropertyHandler();\n                }\n                unwrapped.addProperty(prop);\n                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if\n                 *    the original property is left in place. So let's remove it now.\n                 */\n                _beanProperties.remove(prop);\n                continue;\n            }\n            // non-static inner classes too:\n            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n            if (prop != origProp) {\n                _beanProperties.replace(prop);\n                // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync\n                if (creatorProps != null) {\n                    // 18-May-2015, tatu: _Should_ start with consistent set. But can we really\n                    //   fully count on this? May need to revisit in future; seems to hold for now.\n                    for (int i = 0, len = creatorProps.length; i < len; ++i) {\n                        if (creatorProps[i] == origProp) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        // ... as per above, it is possible we'd need to add this as fallback\n                        // if (but only if) identity check fails?\n                        /*\n                        if (creatorProps[i].getName().equals(prop.getName())) {\n                            creatorProps[i] = prop;\n                            break;\n                        }\n                        */\n                    }\n                }\n            }\n            // one more thing: if this property uses \"external property\" type inclusion,\n            // it needs different handling altogether\n            if (prop.hasValueTypeDeserializer()) {\n                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n                    if (extTypes == null) {\n                        extTypes = new ExternalTypeHandler.Builder();\n                    }\n                    extTypes.addExternal(prop, typeDeser);\n                    // In fact, remove from list of known properties to simplify later handling\n                    _beanProperties.remove(prop);\n                    continue;\n                }\n            }\n        }\n\n        // \"any setter\" may also need to be resolved now\n        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n                    _anySetter.getType(), _anySetter.getProperty()));\n        }\n\n        // as well as delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingDelegate()) {\n            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getDelegateCreator());\n        }\n\n        // and array-delegate-based constructor:\n        if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n            if (delegateType == null) {\n                throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_beanType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n            }\n            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n                    _valueInstantiator.getArrayDelegateCreator());\n        }\n\n        // And now that we know CreatorProperty instances are also resolved can finally create the creator:\n        if (creatorProps != null) {\n            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n        }\n\n        if (extTypes != null) {\n            _externalTypeIdHandler = extTypes.build();\n            // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n        \n        _unwrappedPropertyHandler = unwrapped;\n        if (unwrapped != null) { // we consider this non-standard, to offline handling\n            _nonStandardCreation = true;\n        }\n\n        // may need to disable vanilla processing, if unwrapped handling was enabled...\n        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n    }\n\n```",
            "method_doc": " Method called to finalize setup of this deserializer, after deserializer itself has been registered. This is needed to handle recursive and transitive dependencies. "
        },
        "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::handleUnknownProperty(JsonParser,DeserializationContext,Object,String)": {
            "method_name": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase::handleUnknownProperty(JsonParser,DeserializationContext,Object,String)",
            "method_code": "```java\n    @Override\n    protected void handleUnknownProperty(JsonParser p, DeserializationContext ctxt,\n            Object beanOrClass, String propName)\n        throws IOException\n    {\n        if (_ignoreAllUnknown) {\n            p.skipChildren();\n            return;\n        }\n        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n            handleIgnoredProperty(p, ctxt, beanOrClass, propName);\n        }\n        // Otherwise use default handling (call handler(s); if not\n        // handled, throw exception or skip depending on settings)\n        super.handleUnknownProperty(p, ctxt, beanOrClass, propName);\n    }\n\n```",
            "method_doc": " Method called when a JSON property is encountered that has not matching setter, any-setter or field, and thus can not be assigned. "
        }
    }
}