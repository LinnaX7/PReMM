{
    "buggy_classes": [
        "org.apache.commons.cli.HelpFormatter"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.cli.HelpFormatter::renderWrappedText(StringBuffer,int,int,String)",
            "method_code": "```java\n    protected StringBuffer renderWrappedText(StringBuffer TransVarStringBuffer, int TransVarWidthOfBar, \n                                             int TransVarTabStop, String TransVarWord)\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarPosition = findWrapPos(TransVarWord, TransVarWidthOfBar, 0);\n\n        if (!(!(TransVarPosition == -1)))\n        {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarStringBuffer.append(rtrim(TransVarWord));\n\n            return TransVarStringBuffer;\n        }\n        TransVarStringBuffer.append(rtrim(TransVarWord.substring(0, TransVarPosition))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String TransVarPaddingSize = createPadding(TransVarTabStop);\n\n        for (; !(!(true));) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarPos = TransVarPosition;\n            TransVarWord = TransVarPaddingSize + TransVarWord.substring(TransVarPosition).trim();\n            TransVarPosition = findWrapPos(TransVarWord, TransVarWidthOfBar, 0);\n            if (!(!(TransVarPosition == -1))) {\n                TransVarStringBuffer.append(TransVarWord);\n                return TransVarStringBuffer;\n            } else if (!(!(TransVarPosition == TransVarPos))) {\n                throw new RuntimeException(\n                        \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \"\n                                + TransVarWord);\n            }\n            TransVarStringBuffer.append(rtrim(TransVarWord.substring(0, TransVarPosition))).append(defaultNewLine);\n        }\n    }\n\n```",
            "method_doc": " Render the specified text and return the rendered Options in a StringBuffer.  @param sb The StringBuffer to place the rendered text into. @param width The number of characters to display per line @param nextLineTabStop The position on the next line for the first tab. @param text The text to be rendered.  @return the StringBuffer with the rendered Options contents. ",
            "class_name": "org.apache.commons.cli.HelpFormatter",
            "class_doc": " A formatter of help messages for the current command line options  @version $Revision$, $Date$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here are my findings:\n\n## Common Patterns and Similarities:\n\n1. **Same Root Cause**: Both tests fail with identical stack traces pointing to `HelpFormatter.renderWrappedText()` at line 839, throwing a `RuntimeException` with the message \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]\"\n\n2. **Same Trigger**: Both failures occur during help text formatting when calling `HelpFormatter.printHelp()` with constrained width requirements\n\n3. **Word-Wrapping Issue**: The core problem involves text that cannot be properly wrapped within the specified width constraints, leading to the infinite loop detection mechanism being triggered\n\n4. **Long Description Handling**: Both tests involve options with lengthy descriptions that need to be wrapped:\n   - Test 1: \"This is a looooong description\" with 20-character width\n   - Test 2: Multiple complex options with extensive documentation and examples\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **word-wrapping algorithm** in `HelpFormatter.renderWrappedText()` method. Specifically, the issue likely occurs when:\n\n1. **Minimum Word Length Problem**: The algorithm encounters a word or token that is longer than the available line width, but the current implementation cannot properly handle this edge case\n\n2. **Infinite Loop Detection Logic**: The current infinite loop prevention mechanism (throwing RuntimeException) is being triggered too aggressively, indicating the core wrapping logic has fundamental flaws in handling certain text patterns\n\n3. **Tokenization and Line Breaking**: The method likely fails to properly break long words or handle whitespace/punctuation in complex option descriptions when the available width is very constrained\n\nThe defect is likely in the production code's text formatting logic that should either:\n- Properly break words that exceed line width using hyphenation or character-level breaking\n- Implement more robust handling of minimum width constraints\n- Improve the algorithm for distributing text across multiple lines when dealing with very narrow widths\n\nThe fact that both tests fail with the same exception message and stack trace pattern confirms this is a systemic issue in the HelpFormatter's text rendering logic rather than isolated test-specific problems.",
            "test_suite": "org.apache.commons.cli.bug.BugCLI162Test",
            "score": 10,
            "reason": "#10# This method is definitely the best location to be fixed because both test failures directly trace back to line 839 where the infinite loop exception is thrown. The method contains flawed logic where it compares TransVarPosition with TransVarPos to detect infinite loops, but this comparison fails when dealing with words longer than the available width. The algorithm cannot properly handle cases where a single word or token exceeds the line width, causing the infinite loop detection to trigger incorrectly instead of implementing proper word-breaking strategies."
        },
        {
            "method_name": "org.apache.commons.cli.HelpFormatter::findWrapPos(String,int,int)",
            "method_code": "```java\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n```",
            "method_doc": " Finds the next text wrap position after <code>startPos</code> for the text in <code>text</code> with the column width <code>width</code>. The wrap point is the last postion before startPos+width having a  whitespace character (space, \\n, \\r).  @param text The text being searched for the wrap position @param width width of the wrapped text @param startPos position from which to start the lookup whitespace character @return postion on which the text must be wrapped or -1 if the wrap position is at the end of the text ",
            "class_name": "org.apache.commons.cli.HelpFormatter",
            "class_doc": " A formatter of help messages for the current command line options  @version $Revision$, $Date$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here are my findings:\n\n## Common Patterns and Similarities:\n\n1. **Same Root Cause**: Both tests fail with identical stack traces pointing to `HelpFormatter.renderWrappedText()` at line 839, throwing a `RuntimeException` with the message \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]\"\n\n2. **Same Trigger**: Both failures occur during help text formatting when calling `HelpFormatter.printHelp()` with constrained width requirements\n\n3. **Word-Wrapping Issue**: The core problem involves text that cannot be properly wrapped within the specified width constraints, leading to the infinite loop detection mechanism being triggered\n\n4. **Long Description Handling**: Both tests involve options with lengthy descriptions that need to be wrapped:\n   - Test 1: \"This is a looooong description\" with 20-character width\n   - Test 2: Multiple complex options with extensive documentation and examples\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **word-wrapping algorithm** in `HelpFormatter.renderWrappedText()` method. Specifically, the issue likely occurs when:\n\n1. **Minimum Word Length Problem**: The algorithm encounters a word or token that is longer than the available line width, but the current implementation cannot properly handle this edge case\n\n2. **Infinite Loop Detection Logic**: The current infinite loop prevention mechanism (throwing RuntimeException) is being triggered too aggressively, indicating the core wrapping logic has fundamental flaws in handling certain text patterns\n\n3. **Tokenization and Line Breaking**: The method likely fails to properly break long words or handle whitespace/punctuation in complex option descriptions when the available width is very constrained\n\nThe defect is likely in the production code's text formatting logic that should either:\n- Properly break words that exceed line width using hyphenation or character-level breaking\n- Implement more robust handling of minimum width constraints\n- Improve the algorithm for distributing text across multiple lines when dealing with very narrow widths\n\nThe fact that both tests fail with the same exception message and stack trace pattern confirms this is a systemic issue in the HelpFormatter's text rendering logic rather than isolated test-specific problems.",
            "test_suite": "org.apache.commons.cli.bug.BugCLI162Test",
            "score": 9,
            "reason": "#9# The findWrapPos method is highly suspicious because it contains the core logic for determining text wrap positions and has clear flaws in handling edge cases. When a word is longer than the available width, the method's backward search for whitespace fails (pos <= startPos), then the forward search continues until it finds whitespace or reaches the end. However, if no whitespace is found within a reasonable distance, this could cause the calling method to repeatedly call findWrapPos with the same start position, leading to the infinite loop detection being triggered. The method lacks proper handling for cases where individual words exceed the line width, which matches the observed test failures with long descriptions and constrained widths."
        },
        {
            "method_name": "org.apache.commons.cli.HelpFormatter::renderOptions(StringBuffer,int,Options,int,int)",
            "method_code": "```java\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n```",
            "method_doc": " Render the specified Options and return the rendered Options in a StringBuffer.  @param sb The StringBuffer to place the rendered Options into. @param width The number of characters to display per line @param options The command line Options @param leftPad the number of characters of padding to be prefixed to each line @param descPad the number of characters of padding to be prefixed to each description line  @return the StringBuffer with the rendered Options contents. ",
            "class_name": "org.apache.commons.cli.HelpFormatter",
            "class_doc": " A formatter of help messages for the current command line options  @version $Revision$, $Date$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here are my findings:\n\n## Common Patterns and Similarities:\n\n1. **Same Root Cause**: Both tests fail with identical stack traces pointing to `HelpFormatter.renderWrappedText()` at line 839, throwing a `RuntimeException` with the message \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]\"\n\n2. **Same Trigger**: Both failures occur during help text formatting when calling `HelpFormatter.printHelp()` with constrained width requirements\n\n3. **Word-Wrapping Issue**: The core problem involves text that cannot be properly wrapped within the specified width constraints, leading to the infinite loop detection mechanism being triggered\n\n4. **Long Description Handling**: Both tests involve options with lengthy descriptions that need to be wrapped:\n   - Test 1: \"This is a looooong description\" with 20-character width\n   - Test 2: Multiple complex options with extensive documentation and examples\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **word-wrapping algorithm** in `HelpFormatter.renderWrappedText()` method. Specifically, the issue likely occurs when:\n\n1. **Minimum Word Length Problem**: The algorithm encounters a word or token that is longer than the available line width, but the current implementation cannot properly handle this edge case\n\n2. **Infinite Loop Detection Logic**: The current infinite loop prevention mechanism (throwing RuntimeException) is being triggered too aggressively, indicating the core wrapping logic has fundamental flaws in handling certain text patterns\n\n3. **Tokenization and Line Breaking**: The method likely fails to properly break long words or handle whitespace/punctuation in complex option descriptions when the available width is very constrained\n\nThe defect is likely in the production code's text formatting logic that should either:\n- Properly break words that exceed line width using hyphenation or character-level breaking\n- Implement more robust handling of minimum width constraints\n- Improve the algorithm for distributing text across multiple lines when dealing with very narrow widths\n\nThe fact that both tests fail with the same exception message and stack trace pattern confirms this is a systemic issue in the HelpFormatter's text rendering logic rather than isolated test-specific problems.",
            "test_suite": "org.apache.commons.cli.bug.BugCLI162Test",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it directly calls renderWrappedText() which is throwing the \"Text too long for line\" exception. The renderOptions method is responsible for formatting option descriptions and calculates the nextLineTabStop value that gets passed to renderWrappedText. When dealing with very narrow widths (like 20 characters in testInfiniteLoop) and long option descriptions, the combination of padding values and available width creates a scenario where renderWrappedText cannot properly wrap the text, triggering the infinite loop detection. The issue lies in how this method prepares the text and calculates formatting parameters before delegating to renderWrappedText."
        },
        {
            "method_name": "org.apache.commons.cli.HelpFormatter::printOptions(PrintWriter,int,Options,int,int)",
            "method_code": "```java\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n```",
            "method_doc": " <p>Print the help for the specified Options to the specified writer,  using the specified width, left padding and description padding.</p>  @param pw The printWriter to write the help to @param width The number of characters to display per line @param options The command line Options @param leftPad the number of characters of padding to be prefixed to each line @param descPad the number of characters of padding to be prefixed to each description line ",
            "class_name": "org.apache.commons.cli.HelpFormatter",
            "class_doc": " A formatter of help messages for the current command line options  @version $Revision$, $Date$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here are my findings:\n\n## Common Patterns and Similarities:\n\n1. **Same Root Cause**: Both tests fail with identical stack traces pointing to `HelpFormatter.renderWrappedText()` at line 839, throwing a `RuntimeException` with the message \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]\"\n\n2. **Same Trigger**: Both failures occur during help text formatting when calling `HelpFormatter.printHelp()` with constrained width requirements\n\n3. **Word-Wrapping Issue**: The core problem involves text that cannot be properly wrapped within the specified width constraints, leading to the infinite loop detection mechanism being triggered\n\n4. **Long Description Handling**: Both tests involve options with lengthy descriptions that need to be wrapped:\n   - Test 1: \"This is a looooong description\" with 20-character width\n   - Test 2: Multiple complex options with extensive documentation and examples\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **word-wrapping algorithm** in `HelpFormatter.renderWrappedText()` method. Specifically, the issue likely occurs when:\n\n1. **Minimum Word Length Problem**: The algorithm encounters a word or token that is longer than the available line width, but the current implementation cannot properly handle this edge case\n\n2. **Infinite Loop Detection Logic**: The current infinite loop prevention mechanism (throwing RuntimeException) is being triggered too aggressively, indicating the core wrapping logic has fundamental flaws in handling certain text patterns\n\n3. **Tokenization and Line Breaking**: The method likely fails to properly break long words or handle whitespace/punctuation in complex option descriptions when the available width is very constrained\n\nThe defect is likely in the production code's text formatting logic that should either:\n- Properly break words that exceed line width using hyphenation or character-level breaking\n- Implement more robust handling of minimum width constraints\n- Improve the algorithm for distributing text across multiple lines when dealing with very narrow widths\n\nThe fact that both tests fail with the same exception message and stack trace pattern confirms this is a systemic issue in the HelpFormatter's text rendering logic rather than isolated test-specific problems.",
            "test_suite": "org.apache.commons.cli.bug.BugCLI162Test",
            "score": 3,
            "reason": "#3# The printOptions method itself is very simple and just delegates to renderOptions, which is where the actual text wrapping logic and infinite loop detection occurs according to the stack traces. The real bug is likely in renderOptions or renderWrappedText methods."
        },
        {
            "method_name": "org.apache.commons.cli.HelpFormatter::printWrapped(PrintWriter,int,int,String)",
            "method_code": "```java\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n```",
            "method_doc": " Print the specified text to the specified PrintWriter.  @param pw The printWriter to write the help to @param width The number of characters to display per line @param nextLineTabStop The position on the next line for the first tab. @param text The text to be written to the PrintWriter ",
            "class_name": "org.apache.commons.cli.HelpFormatter",
            "class_doc": " A formatter of help messages for the current command line options  @version $Revision$, $Date$ ",
            "test_failure_causes": "Based on my analysis of the failed tests, stack traces, and test behaviors, here are my findings:\n\n## Common Patterns and Similarities:\n\n1. **Same Root Cause**: Both tests fail with identical stack traces pointing to `HelpFormatter.renderWrappedText()` at line 839, throwing a `RuntimeException` with the message \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]\"\n\n2. **Same Trigger**: Both failures occur during help text formatting when calling `HelpFormatter.printHelp()` with constrained width requirements\n\n3. **Word-Wrapping Issue**: The core problem involves text that cannot be properly wrapped within the specified width constraints, leading to the infinite loop detection mechanism being triggered\n\n4. **Long Description Handling**: Both tests involve options with lengthy descriptions that need to be wrapped:\n   - Test 1: \"This is a looooong description\" with 20-character width\n   - Test 2: Multiple complex options with extensive documentation and examples\n\n## Recommended Possible Defect in Production Code:\n\nThe defect appears to be in the **word-wrapping algorithm** in `HelpFormatter.renderWrappedText()` method. Specifically, the issue likely occurs when:\n\n1. **Minimum Word Length Problem**: The algorithm encounters a word or token that is longer than the available line width, but the current implementation cannot properly handle this edge case\n\n2. **Infinite Loop Detection Logic**: The current infinite loop prevention mechanism (throwing RuntimeException) is being triggered too aggressively, indicating the core wrapping logic has fundamental flaws in handling certain text patterns\n\n3. **Tokenization and Line Breaking**: The method likely fails to properly break long words or handle whitespace/punctuation in complex option descriptions when the available width is very constrained\n\nThe defect is likely in the production code's text formatting logic that should either:\n- Properly break words that exceed line width using hyphenation or character-level breaking\n- Implement more robust handling of minimum width constraints\n- Improve the algorithm for distributing text across multiple lines when dealing with very narrow widths\n\nThe fact that both tests fail with the same exception message and stack trace pattern confirms this is a systemic issue in the HelpFormatter's text rendering logic rather than isolated test-specific problems.",
            "test_suite": "org.apache.commons.cli.bug.BugCLI162Test",
            "score": 3,
            "reason": "#3# The printWrapped method itself appears to be a simple wrapper that delegates to renderWrappedText, which is where the actual infinite loop detection and text wrapping logic occurs. The stack traces clearly point to renderWrappedText at line 839 as the source of the RuntimeException, not printWrapped. While printWrapped calls renderWrappedText, the core text wrapping algorithm and infinite loop prevention logic are implemented in renderWrappedText, making that method the more likely candidate for fixing the underlying word-wrapping issues."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.cli.HelpFormatter::printOptions(PrintWriter,int,Options,int,int)": {
            "method_name": "org.apache.commons.cli.HelpFormatter::printOptions(PrintWriter,int,Options,int,int)",
            "method_code": "```java\n    public void printOptions(PrintWriter pw, int width, Options options, \n                             int leftPad, int descPad)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        renderOptions(sb, width, options, leftPad, descPad);\n        pw.println(sb.toString());\n    }\n\n```",
            "method_doc": " <p>Print the help for the specified Options to the specified writer,  using the specified width, left padding and description padding.</p>  @param pw The printWriter to write the help to @param width The number of characters to display per line @param options The command line Options @param leftPad the number of characters of padding to be prefixed to each line @param descPad the number of characters of padding to be prefixed to each description line "
        },
        "org.apache.commons.cli.HelpFormatter::renderWrappedText(StringBuffer,int,int,String)": {
            "method_name": "org.apache.commons.cli.HelpFormatter::renderWrappedText(StringBuffer,int,int,String)",
            "method_code": "```java\n    protected StringBuffer renderWrappedText(StringBuffer TransVarStringBuffer, int TransVarWidthOfBar, \n                                             int TransVarTabStop, String TransVarWord)\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarPosition = findWrapPos(TransVarWord, TransVarWidthOfBar, 0);\n\n        if (!(!(TransVarPosition == -1)))\n        {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarStringBuffer.append(rtrim(TransVarWord));\n\n            return TransVarStringBuffer;\n        }\n        TransVarStringBuffer.append(rtrim(TransVarWord.substring(0, TransVarPosition))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String TransVarPaddingSize = createPadding(TransVarTabStop);\n\n        for (; !(!(true));) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarPos = TransVarPosition;\n            TransVarWord = TransVarPaddingSize + TransVarWord.substring(TransVarPosition).trim();\n            TransVarPosition = findWrapPos(TransVarWord, TransVarWidthOfBar, 0);\n            if (!(!(TransVarPosition == -1))) {\n                TransVarStringBuffer.append(TransVarWord);\n                return TransVarStringBuffer;\n            } else if (!(!(TransVarPosition == TransVarPos))) {\n                throw new RuntimeException(\n                        \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \"\n                                + TransVarWord);\n            }\n            TransVarStringBuffer.append(rtrim(TransVarWord.substring(0, TransVarPosition))).append(defaultNewLine);\n        }\n    }\n\n```",
            "method_doc": " Render the specified text and return the rendered Options in a StringBuffer.  @param sb The StringBuffer to place the rendered text into. @param width The number of characters to display per line @param nextLineTabStop The position on the next line for the first tab. @param text The text to be rendered.  @return the StringBuffer with the rendered Options contents. "
        },
        "org.apache.commons.cli.HelpFormatter::findWrapPos(String,int,int)": {
            "method_name": "org.apache.commons.cli.HelpFormatter::findWrapPos(String,int,int)",
            "method_code": "```java\n    protected int findWrapPos(String text, int width, int startPos)\n    {\n        int pos = -1;\n\n        // the line ends before the max wrap pos or a new line char found\n        if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n                || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n        {\n            return pos + 1;\n        }\n        else if (startPos + width >= text.length())\n        {\n            return -1;\n        }\n\n\n        // look for the last whitespace character before startPos+width\n        pos = startPos + width;\n\n        char c;\n\n        while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n                && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        // if we found it - just return\n        if (pos > startPos)\n        {\n            return pos;\n        }\n        \n        // must look for the first whitespace chearacter after startPos \n        // + width\n        pos = startPos + width;\n\n        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n               && (c != '\\n') && (c != '\\r'))\n        {\n            ++pos;\n        }\n\n        return (pos == text.length()) ? (-1) : pos;\n    }\n\n```",
            "method_doc": " Finds the next text wrap position after <code>startPos</code> for the text in <code>text</code> with the column width <code>width</code>. The wrap point is the last postion before startPos+width having a  whitespace character (space, \\n, \\r).  @param text The text being searched for the wrap position @param width width of the wrapped text @param startPos position from which to start the lookup whitespace character @return postion on which the text must be wrapped or -1 if the wrap position is at the end of the text "
        },
        "org.apache.commons.cli.HelpFormatter::renderOptions(StringBuffer,int,Options,int,int)": {
            "method_name": "org.apache.commons.cli.HelpFormatter::renderOptions(StringBuffer,int,Options,int,int)",
            "method_code": "```java\n    protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n    {\n        final String lpad = createPadding(leftPad);\n        final String dpad = createPadding(descPad);\n\n        // first create list containing only <lpad>-a,--aaa where \n        // -a is opt and --aaa is long opt; in parallel look for \n        // the longest opt string this list will be then used to \n        // sort options ascending\n        int max = 0;\n        StringBuffer optBuf;\n        List prefixList = new ArrayList();\n\n        List optList = options.helpOptions();\n\n        Collections.sort(optList, getOptionComparator());\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(8);\n\n            if (option.getOpt() == null)\n            {\n                optBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n            }\n            else\n            {\n                optBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\n                if (option.hasLongOpt())\n                {\n                    optBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n                }\n            }\n\n            if (option.hasArg())\n            {\n                if (option.hasArgName())\n                {\n                    optBuf.append(\" <\").append(option.getArgName()).append(\">\");\n                }\n                else\n                {\n                    optBuf.append(' ');\n                }\n            }\n\n            prefixList.add(optBuf);\n            max = (optBuf.length() > max) ? optBuf.length() : max;\n        }\n\n        int x = 0;\n\n        for (Iterator i = optList.iterator(); i.hasNext();)\n        {\n            Option option = (Option) i.next();\n            optBuf = new StringBuffer(prefixList.get(x++).toString());\n\n            if (optBuf.length() < max)\n            {\n                optBuf.append(createPadding(max - optBuf.length()));\n            }\n\n            optBuf.append(dpad);\n\n            int nextLineTabStop = max + descPad;\n\n            if (option.getDescription() != null)\n            {\n                optBuf.append(option.getDescription());\n            }\n\n            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\n            if (i.hasNext())\n            {\n                sb.append(defaultNewLine);\n            }\n        }\n\n        return sb;\n    }\n\n```",
            "method_doc": " Render the specified Options and return the rendered Options in a StringBuffer.  @param sb The StringBuffer to place the rendered Options into. @param width The number of characters to display per line @param options The command line Options @param leftPad the number of characters of padding to be prefixed to each line @param descPad the number of characters of padding to be prefixed to each description line  @return the StringBuffer with the rendered Options contents. "
        },
        "org.apache.commons.cli.HelpFormatter::printWrapped(PrintWriter,int,int,String)": {
            "method_name": "org.apache.commons.cli.HelpFormatter::printWrapped(PrintWriter,int,int,String)",
            "method_code": "```java\n    public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n    {\n        StringBuffer sb = new StringBuffer(text.length());\n\n        renderWrappedText(sb, width, nextLineTabStop, text);\n        pw.println(sb.toString());\n    }\n\n```",
            "method_doc": " Print the specified text to the specified PrintWriter.  @param pw The printWriter to write the help to @param width The number of characters to display per line @param nextLineTabStop The position on the next line for the first tab. @param text The text to be written to the PrintWriter "
        }
    }
}