{
    "buggy_classes": [
        "com.google.javascript.jscomp.ScopedAliases"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n\n```",
            "method_doc": "Main visitor method that calls methods \"isCallToScopeMethod\" and \"validateScopeCall\" to process nodes and collect alias usages",
            "class_name": "com.google.javascript.jscomp.ScopedAliases",
            "class_doc": " Process aliases in goog.scope blocks.  goog.scope(function() { var dom = goog.dom; var DIV = dom.TagName.DIV;  dom.createElement(DIV); });  should become  goog.dom.createElement(goog.dom.TagName.DIV);  ",
            "test_failure_causes": "Based on my analysis of the test failure, I'll approach this systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe `testNonAliasLocal` test is designed to verify that the `ScopedAliases` compiler pass correctly identifies and reports non-alias local variables within `goog.scope` blocks. The test expects that certain code patterns should trigger the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error.\n\nKey observations from the test behavior:\n- The test wraps input code in `goog.scope(function() { ... })`\n- It tests various patterns that should be flagged as violations\n- The test expects exactly 1 error for each case, but is getting 0 errors\n- All five test cases are failing with the same \"expected:<1> but was:<0>\" error\n\n## Step 2: Identifying the Common Pattern\n\nAll failing test cases share a common characteristic - they contain declarations within `goog.scope` that are NOT proper aliases. Proper aliases should follow the pattern `var alias = goog.something`.\n\nThe failing patterns include:\n- Simple variable declarations (`var x = 10`)\n- Variables with goog references in expressions (`var x = goog.dom + 10`)\n- Variables with bracket notation goog access (`var x = goog['dom']`)\n- Multiple variable declarations\n- Function declarations\n\n## Step 3: Root Cause Analysis\n\nThe test failure indicates that the `ScopedAliases` compiler pass is **NOT detecting** these non-alias local variables when it should be. Since all test cases are failing with 0 errors instead of the expected 1 error, this suggests:\n\n**Possible Defect in Production Code:**\n\nThe `ScopedAliases` class likely has a bug in its logic for detecting non-alias local variables within `goog.scope` blocks. Specifically, the code responsible for identifying and reporting the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error is either:\n\n1. **Missing detection logic** for certain types of non-alias declarations\n2. **Incorrectly filtering out** valid violations due to overly permissive conditions\n3. **Failing to traverse** the entire AST structure within goog.scope blocks\n4. **Having issues with the error reporting mechanism** specific to this diagnostic type\n\nThe fact that even simple cases like `var x = 10` and `function f() {}` are not being detected suggests a fundamental issue in the core detection logic rather than edge case handling.\n\n**Recommendation:** The development team should examine the `visit` methods in `ScopedAliases.java` (particularly those handling variable and function declarations within scope blocks) to identify why these obvious violations are not being flagged.",
            "test_suite": "com.google.javascript.jscomp.ScopedAliasesTest",
            "score": 9,
            "reason": "#9# This method is very likely to be the best location that needs to be fixed because it contains the core logic for detecting violations within goog.scope blocks, but it's missing specific checks for non-alias local variable declarations. The method currently handles alias detection and certain specific violations (RETURN, THIS, THROW), but doesn't include logic to detect and report GOOG_SCOPE_NON_ALIAS_LOCAL errors for simple variable declarations, function declarations, and other non-alias patterns that the failing test cases are designed to catch."
        },
        {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::findAliases(NodeTraversal)",
            "method_code": "```java\n    private void findAliases(NodeTraversal TransVarTtt) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Scope TransVarScope1 = TransVarTtt.getScope();\n      for (Var TransVarVariable : TransVarScope1.getVarIterable()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Node TransVarV2 = TransVarVariable.getNode();\n        int TransVarT = TransVarV2.getType();\n        Node TransVarParent1 = TransVarV2.getParent();\n        if (!(!(TransVarParent1.isVar()))) {\n          if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        if (!(!(TransVarV2.hasChildren() && TransVarV2.getFirstChild().isQualifiedName()))) {\n          String TransVarName1 = TransVarV2.getString();\n          Var TransVarVar = TransVarScope1.getVar(TransVarName1);\n          aliases.put(TransVarName1, TransVarVar);\n\n          String TransVarQName =\n              TransVarVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(TransVarName1, TransVarQName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(TransVarTtt, TransVarV2, GOOG_SCOPE_NON_ALIAS_LOCAL, TransVarV2.getString());\n        }\n        }\n      }\n    }\n\n```",
            "method_doc": "Identifies and records alias definitions in current scope",
            "class_name": "com.google.javascript.jscomp.ScopedAliases",
            "class_doc": " Process aliases in goog.scope blocks.  goog.scope(function() { var dom = goog.dom; var DIV = dom.TagName.DIV;  dom.createElement(DIV); });  should become  goog.dom.createElement(goog.dom.TagName.DIV);  ",
            "test_failure_causes": "Based on my analysis of the test failure, I'll approach this systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe `testNonAliasLocal` test is designed to verify that the `ScopedAliases` compiler pass correctly identifies and reports non-alias local variables within `goog.scope` blocks. The test expects that certain code patterns should trigger the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error.\n\nKey observations from the test behavior:\n- The test wraps input code in `goog.scope(function() { ... })`\n- It tests various patterns that should be flagged as violations\n- The test expects exactly 1 error for each case, but is getting 0 errors\n- All five test cases are failing with the same \"expected:<1> but was:<0>\" error\n\n## Step 2: Identifying the Common Pattern\n\nAll failing test cases share a common characteristic - they contain declarations within `goog.scope` that are NOT proper aliases. Proper aliases should follow the pattern `var alias = goog.something`.\n\nThe failing patterns include:\n- Simple variable declarations (`var x = 10`)\n- Variables with goog references in expressions (`var x = goog.dom + 10`)\n- Variables with bracket notation goog access (`var x = goog['dom']`)\n- Multiple variable declarations\n- Function declarations\n\n## Step 3: Root Cause Analysis\n\nThe test failure indicates that the `ScopedAliases` compiler pass is **NOT detecting** these non-alias local variables when it should be. Since all test cases are failing with 0 errors instead of the expected 1 error, this suggests:\n\n**Possible Defect in Production Code:**\n\nThe `ScopedAliases` class likely has a bug in its logic for detecting non-alias local variables within `goog.scope` blocks. Specifically, the code responsible for identifying and reporting the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error is either:\n\n1. **Missing detection logic** for certain types of non-alias declarations\n2. **Incorrectly filtering out** valid violations due to overly permissive conditions\n3. **Failing to traverse** the entire AST structure within goog.scope blocks\n4. **Having issues with the error reporting mechanism** specific to this diagnostic type\n\nThe fact that even simple cases like `var x = 10` and `function f() {}` are not being detected suggests a fundamental issue in the core detection logic rather than edge case handling.\n\n**Recommendation:** The development team should examine the `visit` methods in `ScopedAliases.java` (particularly those handling variable and function declarations within scope blocks) to identify why these obvious violations are not being flagged.",
            "test_suite": "com.google.javascript.jscomp.ScopedAliasesTest",
            "score": 9,
            "reason": "#9# The findAliases method is highly suspicious because it contains the logic for detecting non-alias local variables and reporting GOOG_SCOPE_NON_ALIAS_LOCAL errors. The current implementation only reports non-alias errors when a variable declaration has children and the first child is NOT a qualified name, but it fails to handle cases like simple variable assignments (var x = 10), function declarations, and expressions containing goog references. The condition \"TransVarV2.hasChildren() && TransVarV2.getFirstChild().isQualifiedName()\" is too restrictive and misses many legitimate non-alias cases that should trigger the error."
        },
        {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::enterScope(NodeTraversal)",
            "method_code": "```java\n    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n\n```",
            "method_doc": "Called when entering scope, calls methods \"isCallToScopeMethod\" and \"findAliases\" to process scope blocks",
            "class_name": "com.google.javascript.jscomp.ScopedAliases",
            "class_doc": " Process aliases in goog.scope blocks.  goog.scope(function() { var dom = goog.dom; var DIV = dom.TagName.DIV;  dom.createElement(DIV); });  should become  goog.dom.createElement(goog.dom.TagName.DIV);  ",
            "test_failure_causes": "Based on my analysis of the test failure, I'll approach this systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe `testNonAliasLocal` test is designed to verify that the `ScopedAliases` compiler pass correctly identifies and reports non-alias local variables within `goog.scope` blocks. The test expects that certain code patterns should trigger the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error.\n\nKey observations from the test behavior:\n- The test wraps input code in `goog.scope(function() { ... })`\n- It tests various patterns that should be flagged as violations\n- The test expects exactly 1 error for each case, but is getting 0 errors\n- All five test cases are failing with the same \"expected:<1> but was:<0>\" error\n\n## Step 2: Identifying the Common Pattern\n\nAll failing test cases share a common characteristic - they contain declarations within `goog.scope` that are NOT proper aliases. Proper aliases should follow the pattern `var alias = goog.something`.\n\nThe failing patterns include:\n- Simple variable declarations (`var x = 10`)\n- Variables with goog references in expressions (`var x = goog.dom + 10`)\n- Variables with bracket notation goog access (`var x = goog['dom']`)\n- Multiple variable declarations\n- Function declarations\n\n## Step 3: Root Cause Analysis\n\nThe test failure indicates that the `ScopedAliases` compiler pass is **NOT detecting** these non-alias local variables when it should be. Since all test cases are failing with 0 errors instead of the expected 1 error, this suggests:\n\n**Possible Defect in Production Code:**\n\nThe `ScopedAliases` class likely has a bug in its logic for detecting non-alias local variables within `goog.scope` blocks. Specifically, the code responsible for identifying and reporting the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error is either:\n\n1. **Missing detection logic** for certain types of non-alias declarations\n2. **Incorrectly filtering out** valid violations due to overly permissive conditions\n3. **Failing to traverse** the entire AST structure within goog.scope blocks\n4. **Having issues with the error reporting mechanism** specific to this diagnostic type\n\nThe fact that even simple cases like `var x = 10` and `function f() {}` are not being detected suggests a fundamental issue in the core detection logic rather than edge case handling.\n\n**Recommendation:** The development team should examine the `visit` methods in `ScopedAliases.java` (particularly those handling variable and function declarations within scope blocks) to identify why these obvious violations are not being flagged.",
            "test_suite": "com.google.javascript.jscomp.ScopedAliasesTest",
            "score": 8,
            "reason": "#8# The enterScope method is highly suspicious because it's responsible for initiating alias detection within goog.scope blocks. The test failures show that non-alias local variables are not being detected, and this method contains the call to findAliases() which should identify these violations. If the scope detection logic in isCallToScopeMethod() is incorrect or if findAliases() is not properly traversing all declarations, it would explain why no errors are being reported for the test cases."
        },
        {
            "method_name": "com.google.javascript.jscomp.ScopedAliases::hotSwapScript(Node,Node)",
            "method_code": "```java\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n```",
            "method_doc": "Main transformation logic that calls traversal methods \"getAliasUsages\", \"getAliasDefinitionsInOrder\", and \"getScopeCalls\" to collect alias data and applies transformations",
            "class_name": "com.google.javascript.jscomp.ScopedAliases",
            "class_doc": " Process aliases in goog.scope blocks.  goog.scope(function() { var dom = goog.dom; var DIV = dom.TagName.DIV;  dom.createElement(DIV); });  should become  goog.dom.createElement(goog.dom.TagName.DIV);  ",
            "test_failure_causes": "Based on my analysis of the test failure, I'll approach this systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe `testNonAliasLocal` test is designed to verify that the `ScopedAliases` compiler pass correctly identifies and reports non-alias local variables within `goog.scope` blocks. The test expects that certain code patterns should trigger the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error.\n\nKey observations from the test behavior:\n- The test wraps input code in `goog.scope(function() { ... })`\n- It tests various patterns that should be flagged as violations\n- The test expects exactly 1 error for each case, but is getting 0 errors\n- All five test cases are failing with the same \"expected:<1> but was:<0>\" error\n\n## Step 2: Identifying the Common Pattern\n\nAll failing test cases share a common characteristic - they contain declarations within `goog.scope` that are NOT proper aliases. Proper aliases should follow the pattern `var alias = goog.something`.\n\nThe failing patterns include:\n- Simple variable declarations (`var x = 10`)\n- Variables with goog references in expressions (`var x = goog.dom + 10`)\n- Variables with bracket notation goog access (`var x = goog['dom']`)\n- Multiple variable declarations\n- Function declarations\n\n## Step 3: Root Cause Analysis\n\nThe test failure indicates that the `ScopedAliases` compiler pass is **NOT detecting** these non-alias local variables when it should be. Since all test cases are failing with 0 errors instead of the expected 1 error, this suggests:\n\n**Possible Defect in Production Code:**\n\nThe `ScopedAliases` class likely has a bug in its logic for detecting non-alias local variables within `goog.scope` blocks. Specifically, the code responsible for identifying and reporting the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error is either:\n\n1. **Missing detection logic** for certain types of non-alias declarations\n2. **Incorrectly filtering out** valid violations due to overly permissive conditions\n3. **Failing to traverse** the entire AST structure within goog.scope blocks\n4. **Having issues with the error reporting mechanism** specific to this diagnostic type\n\nThe fact that even simple cases like `var x = 10` and `function f() {}` are not being detected suggests a fundamental issue in the core detection logic rather than edge case handling.\n\n**Recommendation:** The development team should examine the `visit` methods in `ScopedAliases.java` (particularly those handling variable and function declarations within scope blocks) to identify why these obvious violations are not being flagged.",
            "test_suite": "com.google.javascript.jscomp.ScopedAliasesTest",
            "score": 3,
            "reason": "#3# The hotSwapScript method handles the transformation phase but the test failure indicates a detection problem in the traversal phase. The issue is that non-alias local variables are not being detected and reported as errors during AST traversal, which happens before the transformation logic in hotSwapScript. The actual bug is likely in the Traversal class or visitor methods that identify violations."
        },
        {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::report(NodeTraversal,Node,DiagnosticType,String[])",
            "method_code": "```java\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n      compiler.report(t.makeError(n, error, arguments));\n      hasErrors = true;\n    }\n\n```",
            "method_doc": "Reports compilation errors and sets error flag via method \"hasErrors\"",
            "class_name": "com.google.javascript.jscomp.ScopedAliases",
            "class_doc": " Process aliases in goog.scope blocks.  goog.scope(function() { var dom = goog.dom; var DIV = dom.TagName.DIV;  dom.createElement(DIV); });  should become  goog.dom.createElement(goog.dom.TagName.DIV);  ",
            "test_failure_causes": "Based on my analysis of the test failure, I'll approach this systematically:\n\n## Step 1: Understanding the Test Behavior\n\nThe `testNonAliasLocal` test is designed to verify that the `ScopedAliases` compiler pass correctly identifies and reports non-alias local variables within `goog.scope` blocks. The test expects that certain code patterns should trigger the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error.\n\nKey observations from the test behavior:\n- The test wraps input code in `goog.scope(function() { ... })`\n- It tests various patterns that should be flagged as violations\n- The test expects exactly 1 error for each case, but is getting 0 errors\n- All five test cases are failing with the same \"expected:<1> but was:<0>\" error\n\n## Step 2: Identifying the Common Pattern\n\nAll failing test cases share a common characteristic - they contain declarations within `goog.scope` that are NOT proper aliases. Proper aliases should follow the pattern `var alias = goog.something`.\n\nThe failing patterns include:\n- Simple variable declarations (`var x = 10`)\n- Variables with goog references in expressions (`var x = goog.dom + 10`)\n- Variables with bracket notation goog access (`var x = goog['dom']`)\n- Multiple variable declarations\n- Function declarations\n\n## Step 3: Root Cause Analysis\n\nThe test failure indicates that the `ScopedAliases` compiler pass is **NOT detecting** these non-alias local variables when it should be. Since all test cases are failing with 0 errors instead of the expected 1 error, this suggests:\n\n**Possible Defect in Production Code:**\n\nThe `ScopedAliases` class likely has a bug in its logic for detecting non-alias local variables within `goog.scope` blocks. Specifically, the code responsible for identifying and reporting the `GOOG_SCOPE_NON_ALIAS_LOCAL` diagnostic error is either:\n\n1. **Missing detection logic** for certain types of non-alias declarations\n2. **Incorrectly filtering out** valid violations due to overly permissive conditions\n3. **Failing to traverse** the entire AST structure within goog.scope blocks\n4. **Having issues with the error reporting mechanism** specific to this diagnostic type\n\nThe fact that even simple cases like `var x = 10` and `function f() {}` are not being detected suggests a fundamental issue in the core detection logic rather than edge case handling.\n\n**Recommendation:** The development team should examine the `visit` methods in `ScopedAliases.java` (particularly those handling variable and function declarations within scope blocks) to identify why these obvious violations are not being flagged.",
            "test_suite": "com.google.javascript.jscomp.ScopedAliasesTest",
            "score": 2,
            "reason": "#2# The report method is just a wrapper that delegates error reporting to the compiler and sets an error flag. The real issue is likely in the detection logic that should be calling this method for non-alias local variables, but isn't. The problem appears to be in the visitor logic that identifies violations, not in the error reporting mechanism itself."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.ScopedAliases$Traversal::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n\n```",
            "method_doc": "Main visitor method that calls methods \"isCallToScopeMethod\" and \"validateScopeCall\" to process nodes and collect alias usages"
        },
        "com.google.javascript.jscomp.ScopedAliases$Traversal::report(NodeTraversal,Node,DiagnosticType,String[])": {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::report(NodeTraversal,Node,DiagnosticType,String[])",
            "method_code": "```java\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n      compiler.report(t.makeError(n, error, arguments));\n      hasErrors = true;\n    }\n\n```",
            "method_doc": "Reports compilation errors and sets error flag via method \"hasErrors\""
        },
        "com.google.javascript.jscomp.ScopedAliases$Traversal::enterScope(NodeTraversal)": {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::enterScope(NodeTraversal)",
            "method_code": "```java\n    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n\n```",
            "method_doc": "Called when entering scope, calls methods \"isCallToScopeMethod\" and \"findAliases\" to process scope blocks"
        },
        "com.google.javascript.jscomp.ScopedAliases::hotSwapScript(Node,Node)": {
            "method_name": "com.google.javascript.jscomp.ScopedAliases::hotSwapScript(Node,Node)",
            "method_code": "```java\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n```",
            "method_doc": "Main transformation logic that calls traversal methods \"getAliasUsages\", \"getAliasDefinitionsInOrder\", and \"getScopeCalls\" to collect alias data and applies transformations"
        },
        "com.google.javascript.jscomp.ScopedAliases$Traversal::findAliases(NodeTraversal)": {
            "method_name": "com.google.javascript.jscomp.ScopedAliases$Traversal::findAliases(NodeTraversal)",
            "method_code": "```java\n    private void findAliases(NodeTraversal TransVarTtt) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Scope TransVarScope1 = TransVarTtt.getScope();\n      for (Var TransVarVariable : TransVarScope1.getVarIterable()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Node TransVarV2 = TransVarVariable.getNode();\n        int TransVarT = TransVarV2.getType();\n        Node TransVarParent1 = TransVarV2.getParent();\n        if (!(!(TransVarParent1.isVar()))) {\n          if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        if (!(!(TransVarV2.hasChildren() && TransVarV2.getFirstChild().isQualifiedName()))) {\n          String TransVarName1 = TransVarV2.getString();\n          Var TransVarVar = TransVarScope1.getVar(TransVarName1);\n          aliases.put(TransVarName1, TransVarVar);\n\n          String TransVarQName =\n              TransVarVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(TransVarName1, TransVarQName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(TransVarTtt, TransVarV2, GOOG_SCOPE_NON_ALIAS_LOCAL, TransVarV2.getString());\n        }\n        }\n      }\n    }\n\n```",
            "method_doc": "Identifies and records alias definitions in current scope"
        }
    }
}