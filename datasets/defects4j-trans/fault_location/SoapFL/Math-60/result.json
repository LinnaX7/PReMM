{
    "buggy_classes": [
        "org.apache.commons.math.util.ContinuedFraction"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math.util.ContinuedFraction::evaluate(double,double,int)",
            "method_code": "```java\n    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            boolean infinite = false;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                /*\n                 * Need to scale. Try successive powers of the larger of a or b\n                 * up to 5th power. Throw ConvergenceException if one or both\n                 * of p2, q2 still overflow.\n                 */\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(\n                            LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                             x);\n                }\n                infinite = true;\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n                    } else if (b != 0) {\n                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                    }\n                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n                    if (!infinite) {\n                        break;\n                    }\n                }\n            }\n\n            if (infinite) {\n               // Scaling failed\n               throw new ConvergenceException(\n                 LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                  x);\n            }\n\n            double r = p2 / q2;\n\n            if (Double.isNaN(r)) {\n                throw new ConvergenceException(\n                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                  x);\n            }\n            relativeError = FastMath.abs(r / c - 1.0);\n\n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                x);\n        }\n\n        return c;\n    }\n\n```",
            "method_doc": " <p> Evaluates the continued fraction at the value x. </p>  <p> The implementation of this method is based on equations 14-17 of: <ul> <li> Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web Resource. <a target=\"_blank\" href=\"http://mathworld.wolfram.com/ContinuedFraction.html\"> http://mathworld.wolfram.com/ContinuedFraction.html</a> </li> </ul> The recurrence relationship defined in those equations can result in very large intermediate results which can result in numerical overflow. As a means to combat these overflow conditions, the intermediate results are scaled whenever they threaten to become numerically unstable.</p>  @param x the evaluation point. @param epsilon maximum error allowed. @param maxIterations maximum number of convergents @return the value of the continued fraction evaluated at x. @throws MathException if the algorithm fails to converge. ",
            "class_name": "org.apache.commons.math.util.ContinuedFraction",
            "class_doc": " Provides a generic means to evaluate continued fractions.  Subclasses simply provided the a and b coefficients to evaluate the continued fraction.  <p> References: <ul> <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\"> Continued Fraction</a></li> </ul> </p>  @version $Revision$ $Date$ ",
            "test_failure_causes": "As the Software Test Engineer at DebugDev, I'll analyze this test failure systematically to identify the root cause in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently occurs when processing extreme numerical values, specifically when dealing with very large positive numbers (Double.MAX_VALUE) and infinity values. The stack trace reveals a clear pattern: the continued fraction algorithm diverges to NaN when processing \u221e.\n\n**Key Observations:**\n\n1. **Failure Point:** The test fails at `distribution.cumulativeProbability(Double.MAX_VALUE)` with a ConvergenceException\n2. **Stack Trace Pattern:** The error flows through:\n   - `NormalDistributionImpl.cumulativeProbability()`\n   - `Erf.erf()`\n   - `Gamma.regularizedGammaP()`\n   - `ContinuedFraction.evaluate()`\n3. **Specific Error:** \"Continued fraction diverged to NaN for value \u221e\"\n\n## Recommended Defect in Production Code\n\nBased on my analysis, the defect is in the **error function (erf) implementation** within the `Gamma.regularizedGammaP` method, specifically in how it handles the continued fraction calculation for extreme input values.\n\n**Root Cause:** The continued fraction algorithm in `ContinuedFraction.evaluate()` does not properly handle the case when the input value approaches or equals infinity. When `Double.MAX_VALUE` or `Double.POSITIVE_INFINITY` is passed through the cumulative probability calculation chain, it eventually reaches the continued fraction implementation which cannot converge for infinite values, resulting in NaN.\n\n**Specific Defect Location:** \nThe bug is likely in `org.apache.commons.math.util.ContinuedFraction.evaluate()` at line 186, where the algorithm lacks proper boundary case handling for infinite inputs. The method should include explicit checks for Double.POSITIVE_INFINITY and Double.NEGATIVE_INFINITY before attempting the continued fraction calculation.\n\n**Expected Behavior:** For extreme values like Double.MAX_VALUE and infinity, the cumulative probability should return the mathematically correct values (1.0 for positive infinity, 0.0 for negative infinity) without attempting complex numerical approximations that cannot converge.\n\nThe production code needs to add special case handling for infinite and extreme finite values in the error function calculation pipeline before they reach the continued fraction algorithm.",
            "test_suite": "org.apache.commons.math.distribution.NormalDistributionTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious as the root cause because it directly throws the ConvergenceException when processing extreme values like infinity, and the stack trace shows the error originates here. The method lacks proper boundary case handling for infinite inputs and extreme finite values, which causes the continued fraction algorithm to diverge when it should return mathematically correct results for these special cases."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math.util.ContinuedFraction::evaluate(double,double,int)": {
            "method_name": "org.apache.commons.math.util.ContinuedFraction::evaluate(double,double,int)",
            "method_code": "```java\n    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            boolean infinite = false;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                /*\n                 * Need to scale. Try successive powers of the larger of a or b\n                 * up to 5th power. Throw ConvergenceException if one or both\n                 * of p2, q2 still overflow.\n                 */\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = FastMath.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(\n                            LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                             x);\n                }\n                infinite = true;\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n                    } else if (b != 0) {\n                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                    }\n                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n                    if (!infinite) {\n                        break;\n                    }\n                }\n            }\n\n            if (infinite) {\n               // Scaling failed\n               throw new ConvergenceException(\n                 LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                  x);\n            }\n\n            double r = p2 / q2;\n\n            if (Double.isNaN(r)) {\n                throw new ConvergenceException(\n                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                  x);\n            }\n            relativeError = FastMath.abs(r / c - 1.0);\n\n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                x);\n        }\n\n        return c;\n    }\n\n```",
            "method_doc": " <p> Evaluates the continued fraction at the value x. </p>  <p> The implementation of this method is based on equations 14-17 of: <ul> <li> Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web Resource. <a target=\"_blank\" href=\"http://mathworld.wolfram.com/ContinuedFraction.html\"> http://mathworld.wolfram.com/ContinuedFraction.html</a> </li> </ul> The recurrence relationship defined in those equations can result in very large intermediate results which can result in numerical overflow. As a means to combat these overflow conditions, the intermediate results are scaled whenever they threaten to become numerically unstable.</p>  @param x the evaluation point. @param epsilon maximum error allowed. @param maxIterations maximum number of convergents @return the value of the continued fraction evaluated at x. @throws MathException if the algorithm fails to converge. "
        }
    }
}