{
    "buggy_classes": [
        "com.fasterxml.jackson.core.filter.FilteringParserDelegate"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate::_nextToken2()",
            "method_code": "```java\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return (_currToken = t);\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n```",
            "method_doc": " Offlined handling for cases where there was no buffered token to return, and the token read next could not be returned as-is, at least not yet, but where we have not yet established that buffering is needed. ",
            "class_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
            "class_doc": " Specialized {@link JsonParserDelegate} that allows use of {@link TokenFilter} for outputting a subset of content that is visible to caller  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when `multipleMatches` is set to `false`, the filtering parser is incorrectly including multiple matches instead of stopping at the first match. The assertion failure shows:\n- Expected: `\"3\"` (only the first match)\n- Actual: `\"3 4\"` (both matches included)\n\n## Recommended Possible Defects in Production Code\n\nBased on the test behavior and failure pattern, I recommend investigating these potential defects in the `FilteringParserDelegate` class:\n\n### 1. **Multiple Matches Flag Ignored**\nThe most likely defect is that the `multipleMatches` parameter (set to `false` in this test) is not being properly honored in the filtering logic. The production code may be continuing to process and include subsequent matches even when `multipleMatches` is disabled.\n\n**Location to investigate:** `FilteringParserDelegate` constructor and filtering logic where the `multipleMatches` flag is used to control matching behavior.\n\n### 2. **State Management Issue in Filtering Logic**\nThere may be a defect in how the filtering parser manages its internal state when encountering multiple matching fields. The code might not be properly tracking whether a match has already been found and should therefore skip subsequent matches.\n\n**Location to investigate:** The token processing loop and match detection logic in `FilteringParserDelegate`.\n\n### 3. **Incorrect Filter Application**\nThe `NameMatchFilter` might be correctly identifying matches, but the `FilteringParserDelegate` may not be properly using the `multipleMatches` flag to determine whether to include or exclude subsequent matches after the first one.\n\n**Location to investigate:** Integration point between the filter logic and the parser delegate's match counting/limiting mechanism.\n\n### 4. **Early Termination Logic Missing**\nThe production code may lack proper early termination logic when `multipleMatches` is `false`. After finding the first match, the parser should ideally stop looking for additional matches or at least exclude them from the output.\n\nThe defect appears to be specifically in how the `FilteringParserDelegate` handles the `multipleMatches = false` configuration, suggesting a logic error in the filtering pipeline rather than in the test code itself.",
            "test_suite": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles the core token processing logic where the multipleMatches flag should control whether to include only the first match or all matches. The test failure shows that when multipleMatches is false, the parser incorrectly includes multiple \"value\" fields instead of stopping at the first match. The method processes all tokens without any logic to track and limit matches based on the multipleMatches configuration, particularly in the FIELD_NAME case where it continues processing subsequent matches without checking if a match has already been found."
        },
        {
            "method_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate::nextToken()",
            "method_code": "```java\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \t\t//if not scalar and ended successfully, then return null\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n        // Anything buffered?\n        TokenFilterContext TransVarExposedContext = _exposedContext;\n\n        if (!(!(TransVarExposedContext != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n                }\n            for (; !(!(true));) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                    }\n                JsonToken TransVarExposedToken = TransVarExposedContext.nextTokenToRead();\n                if (!(!(TransVarExposedToken != null))) {\n                    _currToken = TransVarExposedToken;\n                    return TransVarExposedToken;\n                    }\n                if (!(!(TransVarExposedContext == _headContext))) {\n                    _exposedContext = null;\n                    if (!(!(TransVarExposedContext.inArray()))) {\n                        TransVarExposedToken = delegate.getCurrentToken();\n                        _currToken = TransVarExposedToken;\n                        return TransVarExposedToken;\n                    }\n                    break;\n                }\n                TransVarExposedContext = _headContext.findChildOf(TransVarExposedContext);\n                _exposedContext = TransVarExposedContext;\n                if (!(!(TransVarExposedContext == null))) {\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken TransVarToken = delegate.nextToken();\n        if (!(!(TransVarToken == null))) {\n            // no strict need to close, since we have no state here\n            return (_currToken = TransVarToken);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter TransVarFilter;\n        \n        switch (TransVarToken.id()) {\n        case ID_START_ARRAY:\n            TransVarFilter = _itemFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildArrayContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            if (!(!(TransVarFilter == null))) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            TransVarFilter = _headContext.checkValue(TransVarFilter);\n            if (!(!(TransVarFilter == null))) {\n                delegate.skipChildren();\n                break;\n            }\n            if (!(!(TransVarFilter != TokenFilter.INCLUDE_ALL))) {\n                TransVarFilter = TransVarFilter.filterStartArray();\n            }\n            _itemFilter = TransVarFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildArrayContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            _headContext = _headContext.createChildArrayContext(TransVarFilter, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (!(!(_includePath))) {\n                TransVarToken = _nextTokenWithBuffering(_headContext);\n                if (!(!(TransVarToken != null))) {\n                    _currToken = TransVarToken;\n                    return TransVarToken;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            TransVarFilter = _itemFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildObjectContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            if (!(!(TransVarFilter == null))) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            TransVarFilter = _headContext.checkValue(TransVarFilter);\n            if (!(!(TransVarFilter == null))) {\n                delegate.skipChildren();\n                break;\n            }\n            if (!(!(TransVarFilter != TokenFilter.INCLUDE_ALL))) {\n                TransVarFilter = TransVarFilter.filterStartObject();\n            }\n            _itemFilter = TransVarFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildObjectContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            _headContext = _headContext.createChildObjectContext(TransVarFilter, false);\n            // Also: only need buffering if parent path to be included\n            if (!(!(_includePath))) {\n                TransVarToken = _nextTokenWithBuffering(_headContext);\n                if (!(!(TransVarToken != null))) {\n                    _currToken = TransVarToken;\n                    return TransVarToken;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean TransVarEnd = _headContext.isStartHandled();\n                TransVarFilter = _headContext.getFilter();\n                if (!(!((TransVarFilter != null) && (TransVarFilter != TokenFilter.INCLUDE_ALL)))) {\n                    TransVarFilter.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (!(!(TransVarEnd))) {\n                    return (_currToken = TransVarToken);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String TransVarName1 = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                TransVarFilter = _headContext.setFieldName(TransVarName1);\n                if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                    _itemFilter = TransVarFilter;\n                    if (!(!(!_includePath))) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (!(!(_includeImmediateParent && !_headContext.isStartHandled()))) {\n                            TransVarToken = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = TransVarToken);\n                }\n                if (!(!(TransVarFilter == null))) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                TransVarFilter = TransVarFilter.includeProperty(TransVarName1);\n                if (!(!(TransVarFilter == null))) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = TransVarFilter;\n                if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                    if (!(!(_includePath))) {\n                        return (_currToken = TransVarToken);\n                    }\n                }\n                if (!(!(_includePath))) {\n                    TransVarToken = _nextTokenWithBuffering(_headContext);\n                    if (!(!(TransVarToken != null))) {\n                        _currToken = TransVarToken;\n                        return TransVarToken;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            TransVarFilter = _itemFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                return (_currToken = TransVarToken);\n            }\n            if (!(!(TransVarFilter != null))) {\n                TransVarFilter = _headContext.checkValue(TransVarFilter);\n                if (!(!((TransVarFilter == TokenFilter.INCLUDE_ALL)\n                        || ((TransVarFilter != null) && TransVarFilter.includeValue(delegate))))) {\n                    return (_currToken = TransVarToken);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n```",
            "method_doc": "  Public API, traversal  ",
            "class_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
            "class_doc": " Specialized {@link JsonParserDelegate} that allows use of {@link TokenFilter} for outputting a subset of content that is visible to caller  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when `multipleMatches` is set to `false`, the filtering parser is incorrectly including multiple matches instead of stopping at the first match. The assertion failure shows:\n- Expected: `\"3\"` (only the first match)\n- Actual: `\"3 4\"` (both matches included)\n\n## Recommended Possible Defects in Production Code\n\nBased on the test behavior and failure pattern, I recommend investigating these potential defects in the `FilteringParserDelegate` class:\n\n### 1. **Multiple Matches Flag Ignored**\nThe most likely defect is that the `multipleMatches` parameter (set to `false` in this test) is not being properly honored in the filtering logic. The production code may be continuing to process and include subsequent matches even when `multipleMatches` is disabled.\n\n**Location to investigate:** `FilteringParserDelegate` constructor and filtering logic where the `multipleMatches` flag is used to control matching behavior.\n\n### 2. **State Management Issue in Filtering Logic**\nThere may be a defect in how the filtering parser manages its internal state when encountering multiple matching fields. The code might not be properly tracking whether a match has already been found and should therefore skip subsequent matches.\n\n**Location to investigate:** The token processing loop and match detection logic in `FilteringParserDelegate`.\n\n### 3. **Incorrect Filter Application**\nThe `NameMatchFilter` might be correctly identifying matches, but the `FilteringParserDelegate` may not be properly using the `multipleMatches` flag to determine whether to include or exclude subsequent matches after the first one.\n\n**Location to investigate:** Integration point between the filter logic and the parser delegate's match counting/limiting mechanism.\n\n### 4. **Early Termination Logic Missing**\nThe production code may lack proper early termination logic when `multipleMatches` is `false`. After finding the first match, the parser should ideally stop looking for additional matches or at least exclude them from the output.\n\nThe defect appears to be specifically in how the `FilteringParserDelegate` handles the `multipleMatches = false` configuration, suggesting a logic error in the filtering pipeline rather than in the test code itself.",
            "test_suite": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it contains the core token processing logic for the filtering parser and handles the multipleMatches flag behavior. The test failure shows that when multipleMatches is false, the parser incorrectly includes multiple \"value\" field matches instead of stopping at the first one. The nextToken() method processes all tokens and applies filtering logic, but appears to lack proper state tracking to prevent multiple matches when the flag is disabled. The method's complex switch statement for different token types and filtering logic makes it the most probable location where the multipleMatches constraint should be enforced but isn't properly implemented."
        },
        {
            "method_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate::FilteringParserDelegate(JsonParser,TokenFilter,boolean,boolean)",
            "method_code": "```java\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n```",
            "method_doc": "  Construction, initialization  ",
            "class_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate",
            "class_doc": " Specialized {@link JsonParserDelegate} that allows use of {@link TokenFilter} for outputting a subset of content that is visible to caller  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test and its behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\nThe test failure consistently shows that when `multipleMatches` is set to `false`, the filtering parser is incorrectly including multiple matches instead of stopping at the first match. The assertion failure shows:\n- Expected: `\"3\"` (only the first match)\n- Actual: `\"3 4\"` (both matches included)\n\n## Recommended Possible Defects in Production Code\n\nBased on the test behavior and failure pattern, I recommend investigating these potential defects in the `FilteringParserDelegate` class:\n\n### 1. **Multiple Matches Flag Ignored**\nThe most likely defect is that the `multipleMatches` parameter (set to `false` in this test) is not being properly honored in the filtering logic. The production code may be continuing to process and include subsequent matches even when `multipleMatches` is disabled.\n\n**Location to investigate:** `FilteringParserDelegate` constructor and filtering logic where the `multipleMatches` flag is used to control matching behavior.\n\n### 2. **State Management Issue in Filtering Logic**\nThere may be a defect in how the filtering parser manages its internal state when encountering multiple matching fields. The code might not be properly tracking whether a match has already been found and should therefore skip subsequent matches.\n\n**Location to investigate:** The token processing loop and match detection logic in `FilteringParserDelegate`.\n\n### 3. **Incorrect Filter Application**\nThe `NameMatchFilter` might be correctly identifying matches, but the `FilteringParserDelegate` may not be properly using the `multipleMatches` flag to determine whether to include or exclude subsequent matches after the first one.\n\n**Location to investigate:** Integration point between the filter logic and the parser delegate's match counting/limiting mechanism.\n\n### 4. **Early Termination Logic Missing**\nThe production code may lack proper early termination logic when `multipleMatches` is `false`. After finding the first match, the parser should ideally stop looking for additional matches or at least exclude them from the output.\n\nThe defect appears to be specifically in how the `FilteringParserDelegate` handles the `multipleMatches = false` configuration, suggesting a logic error in the filtering pipeline rather than in the test code itself.",
            "test_suite": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest",
            "score": 3,
            "reason": "#3# This method is just a constructor that initializes fields and doesn't contain any filtering logic. The actual bug is likely in the parsing logic that uses the _allowMultipleMatches field, not in this initialization method."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.core.filter.FilteringParserDelegate::_nextToken2()": {
            "method_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate::_nextToken2()",
            "method_code": "```java\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return (_currToken = t);\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        return (_currToken = t);\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n```",
            "method_doc": " Offlined handling for cases where there was no buffered token to return, and the token read next could not be returned as-is, at least not yet, but where we have not yet established that buffering is needed. "
        },
        "com.fasterxml.jackson.core.filter.FilteringParserDelegate::FilteringParserDelegate(JsonParser,TokenFilter,boolean,boolean)": {
            "method_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate::FilteringParserDelegate(JsonParser,TokenFilter,boolean,boolean)",
            "method_code": "```java\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n```",
            "method_doc": "  Construction, initialization  "
        },
        "com.fasterxml.jackson.core.filter.FilteringParserDelegate::nextToken()": {
            "method_name": "com.fasterxml.jackson.core.filter.FilteringParserDelegate::nextToken()",
            "method_code": "```java\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    \t// check for no buffered context _exposedContext - null\n    \t//If all the conditions matches then check for scalar / non-scalar property\n    \t\t//if not scalar and ended successfully, then return null\n    \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n    \t\t// then return null \n        // Anything buffered?\n        TokenFilterContext TransVarExposedContext = _exposedContext;\n\n        if (!(!(TransVarExposedContext != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n                }\n            for (; !(!(true));) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                    }\n                JsonToken TransVarExposedToken = TransVarExposedContext.nextTokenToRead();\n                if (!(!(TransVarExposedToken != null))) {\n                    _currToken = TransVarExposedToken;\n                    return TransVarExposedToken;\n                    }\n                if (!(!(TransVarExposedContext == _headContext))) {\n                    _exposedContext = null;\n                    if (!(!(TransVarExposedContext.inArray()))) {\n                        TransVarExposedToken = delegate.getCurrentToken();\n                        _currToken = TransVarExposedToken;\n                        return TransVarExposedToken;\n                    }\n                    break;\n                }\n                TransVarExposedContext = _headContext.findChildOf(TransVarExposedContext);\n                _exposedContext = TransVarExposedContext;\n                if (!(!(TransVarExposedContext == null))) {\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken TransVarToken = delegate.nextToken();\n        if (!(!(TransVarToken == null))) {\n            // no strict need to close, since we have no state here\n            return (_currToken = TransVarToken);\n        }\n\n        // otherwise... to include or not?\n        TokenFilter TransVarFilter;\n        \n        switch (TransVarToken.id()) {\n        case ID_START_ARRAY:\n            TransVarFilter = _itemFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildArrayContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            if (!(!(TransVarFilter == null))) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            TransVarFilter = _headContext.checkValue(TransVarFilter);\n            if (!(!(TransVarFilter == null))) {\n                delegate.skipChildren();\n                break;\n            }\n            if (!(!(TransVarFilter != TokenFilter.INCLUDE_ALL))) {\n                TransVarFilter = TransVarFilter.filterStartArray();\n            }\n            _itemFilter = TransVarFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildArrayContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            _headContext = _headContext.createChildArrayContext(TransVarFilter, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (!(!(_includePath))) {\n                TransVarToken = _nextTokenWithBuffering(_headContext);\n                if (!(!(TransVarToken != null))) {\n                    _currToken = TransVarToken;\n                    return TransVarToken;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            TransVarFilter = _itemFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildObjectContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            if (!(!(TransVarFilter == null))) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            TransVarFilter = _headContext.checkValue(TransVarFilter);\n            if (!(!(TransVarFilter == null))) {\n                delegate.skipChildren();\n                break;\n            }\n            if (!(!(TransVarFilter != TokenFilter.INCLUDE_ALL))) {\n                TransVarFilter = TransVarFilter.filterStartObject();\n            }\n            _itemFilter = TransVarFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                _headContext = _headContext.createChildObjectContext(TransVarFilter, true);\n                return (_currToken = TransVarToken);\n            }\n            _headContext = _headContext.createChildObjectContext(TransVarFilter, false);\n            // Also: only need buffering if parent path to be included\n            if (!(!(_includePath))) {\n                TransVarToken = _nextTokenWithBuffering(_headContext);\n                if (!(!(TransVarToken != null))) {\n                    _currToken = TransVarToken;\n                    return TransVarToken;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean TransVarEnd = _headContext.isStartHandled();\n                TransVarFilter = _headContext.getFilter();\n                if (!(!((TransVarFilter != null) && (TransVarFilter != TokenFilter.INCLUDE_ALL)))) {\n                    TransVarFilter.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (!(!(TransVarEnd))) {\n                    return (_currToken = TransVarToken);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String TransVarName1 = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                TransVarFilter = _headContext.setFieldName(TransVarName1);\n                if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                    _itemFilter = TransVarFilter;\n                    if (!(!(!_includePath))) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (!(!(_includeImmediateParent && !_headContext.isStartHandled()))) {\n                            TransVarToken = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = TransVarToken);\n                }\n                if (!(!(TransVarFilter == null))) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                TransVarFilter = TransVarFilter.includeProperty(TransVarName1);\n                if (!(!(TransVarFilter == null))) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = TransVarFilter;\n                if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                    if (!(!(_includePath))) {\n                        return (_currToken = TransVarToken);\n                    }\n                }\n                if (!(!(_includePath))) {\n                    TransVarToken = _nextTokenWithBuffering(_headContext);\n                    if (!(!(TransVarToken != null))) {\n                        _currToken = TransVarToken;\n                        return TransVarToken;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            TransVarFilter = _itemFilter;\n            if (!(!(TransVarFilter == TokenFilter.INCLUDE_ALL))) {\n                return (_currToken = TransVarToken);\n            }\n            if (!(!(TransVarFilter != null))) {\n                TransVarFilter = _headContext.checkValue(TransVarFilter);\n                if (!(!((TransVarFilter == TokenFilter.INCLUDE_ALL)\n                        || ((TransVarFilter != null) && TransVarFilter.includeValue(delegate))))) {\n                    return (_currToken = TransVarToken);\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n```",
            "method_doc": "  Public API, traversal  "
        }
    }
}