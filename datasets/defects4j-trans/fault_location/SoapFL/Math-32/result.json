{
    "buggy_classes": [
        "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet"
    ],
    "buggy_methods": [
        {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet::computeGeometricalProperties()",
            "method_code": "```java\n    @Override\n    protected void computeGeometricalProperties() {\n\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final Vector2D[][] TransVarVertices = getVertices();\n\n        if (!(!(TransVarVertices.length == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            final BSPTree<Euclidean2D> TransVarTree2 = getTree(false);\n            if (!(!((Boolean) TransVarTree2.getAttribute()))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (!(!(TransVarVertices[0][0] == null))) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double TransVarSum1  = 0;\n            double TransVarSum2 = 0;\n            double TransVarSumY1 = 0;\n\n            for (Vector2D[] TransVarLoopVertices : TransVarVertices) {\n                double TransVarX2 = TransVarLoopVertices[TransVarLoopVertices.length - 1].getX();\n                double TransVarY2 = TransVarLoopVertices[TransVarLoopVertices.length - 1].getY();\n                for (final Vector2D TransVarPoint1 : TransVarLoopVertices) {\n                    final double TransVarX1 = TransVarX2;\n                    final double TransVarY = TransVarY2;\n                    TransVarX2 = TransVarPoint1.getX();\n                    TransVarY2 = TransVarPoint1.getY();\n                    final double TransVarYFactor = TransVarX1 * TransVarY2 - TransVarY * TransVarX2;\n                    TransVarSum1  += TransVarYFactor;\n                    TransVarSum2 += TransVarYFactor * (TransVarX1 + TransVarX2);\n                    TransVarSumY1 += TransVarYFactor * (TransVarY + TransVarY2);\n                }\n            }\n\n            if (!(!(TransVarSum1 < 0))) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(TransVarSum1 / 2);\n                setBarycenter(new Vector2D(TransVarSum2 / (3 * TransVarSum1), TransVarSumY1 / (3 * TransVarSum1)));\n            }\n\n        }\n\n    }\n\n```",
            "method_doc": "{@inheritDoc} */",
            "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
            "class_doc": "This class represents a 2D region: a set of polygons. @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, I've identified the key issue:\n\n## Analysis Summary\n\n**Common Pattern:** The test failure occurs during geometric property computation (specifically `getSize()`) when constructing a polyhedron from triangular faces. The stack trace reveals a critical `ClassCastException` in the underlying 2D polygon processing.\n\n**Key Evidence from Stack Trace:**\n```\njava.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\nat org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:142)\n```\n\n## Recommended Production Code Defect\n\nThe defect appears to be in the **`PolygonsSet.computeGeometricalProperties` method** (line 142 in the euclidean.twod package). The code is incorrectly attempting to cast a `BoundaryAttribute` object to a `Boolean`, which indicates:\n\n1. **Type Safety Issue**: The BSP tree traversal logic in the geometric property computation is expecting boolean values but receiving `BoundaryAttribute` objects instead.\n\n2. **BSP Tree Processing Defect**: When the polyhedron faces are processed and projected to 2D polygons, the boundary attribute handling in the partitioning structure is incorrect. The algorithm is likely misinterpreting node attributes during the recursive tree traversal.\n\n3. **Inheritance/Polymorphism Problem**: The issue suggests that the code assumes all node attributes in the BSP tree are simple booleans (representing inside/outside status), but in complex polyhedron cases, the nodes contain `BoundaryAttribute` objects that encapsulate boundary information.\n\nThis defect would affect any polyhedron construction that relies on the 2D polygon processing for face calculations, explaining why this specific test case fails when computing the polyhedron's volume and surface area properties.\n\nThe fix should focus on properly handling `BoundaryAttribute` objects in the `PolygonsSet.computeGeometricalProperties` method and ensuring correct type checking during the BSP tree traversal.",
            "test_suite": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest",
            "score": 10,
            "reason": "#10# This method is definitely the best location to be fixed because the stack trace clearly shows a ClassCastException occurring at line 142 of this exact method where it attempts to cast a BoundaryAttribute object to Boolean. The problematic line is \"(Boolean) TransVarTree2.getAttribute()\" which assumes the attribute is always a Boolean, but in complex polyhedron cases it can be a BoundaryAttribute object instead."
        },
        {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder::visitInternalNode(BSPTree)",
            "method_code": "```java\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n```",
            "method_doc": "{@inheritDoc} */",
            "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
            "class_doc": "This class represents a 2D region: a set of polygons. @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, I've identified the key issue:\n\n## Analysis Summary\n\n**Common Pattern:** The test failure occurs during geometric property computation (specifically `getSize()`) when constructing a polyhedron from triangular faces. The stack trace reveals a critical `ClassCastException` in the underlying 2D polygon processing.\n\n**Key Evidence from Stack Trace:**\n```\njava.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\nat org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:142)\n```\n\n## Recommended Production Code Defect\n\nThe defect appears to be in the **`PolygonsSet.computeGeometricalProperties` method** (line 142 in the euclidean.twod package). The code is incorrectly attempting to cast a `BoundaryAttribute` object to a `Boolean`, which indicates:\n\n1. **Type Safety Issue**: The BSP tree traversal logic in the geometric property computation is expecting boolean values but receiving `BoundaryAttribute` objects instead.\n\n2. **BSP Tree Processing Defect**: When the polyhedron faces are processed and projected to 2D polygons, the boundary attribute handling in the partitioning structure is incorrect. The algorithm is likely misinterpreting node attributes during the recursive tree traversal.\n\n3. **Inheritance/Polymorphism Problem**: The issue suggests that the code assumes all node attributes in the BSP tree are simple booleans (representing inside/outside status), but in complex polyhedron cases, the nodes contain `BoundaryAttribute` objects that encapsulate boundary information.\n\nThis defect would affect any polyhedron construction that relies on the 2D polygon processing for face calculations, explaining why this specific test case fails when computing the polyhedron's volume and surface area properties.\n\nThe fix should focus on properly handling `BoundaryAttribute` objects in the `PolygonsSet.computeGeometricalProperties` method and ensuring correct type checking during the BSP tree traversal.",
            "test_suite": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because the stack trace shows a ClassCastException involving BoundaryAttribute being cast to Boolean, and this method directly handles BoundaryAttribute objects from BSP tree nodes. The method processes boundary attributes during BSP tree traversal, which aligns with the error occurring in computeGeometricalProperties. The incorrect handling of boundary attributes in this visitor pattern could propagate the wrong type information up the call chain, causing the casting issue in the geometrical properties computation."
        },
        {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet::followLoop(Node,AVLTree)",
            "method_code": "```java\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n```",
            "method_doc": "Follow a boundary loop. @param node node containing the segment starting the loop @param sorted set of segments belonging to the boundary, sorted by start points (contains {@code node}) @return a list of connected sub-hyperplanes starting at {@code node} ",
            "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
            "class_doc": "This class represents a 2D region: a set of polygons. @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, I've identified the key issue:\n\n## Analysis Summary\n\n**Common Pattern:** The test failure occurs during geometric property computation (specifically `getSize()`) when constructing a polyhedron from triangular faces. The stack trace reveals a critical `ClassCastException` in the underlying 2D polygon processing.\n\n**Key Evidence from Stack Trace:**\n```\njava.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\nat org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:142)\n```\n\n## Recommended Production Code Defect\n\nThe defect appears to be in the **`PolygonsSet.computeGeometricalProperties` method** (line 142 in the euclidean.twod package). The code is incorrectly attempting to cast a `BoundaryAttribute` object to a `Boolean`, which indicates:\n\n1. **Type Safety Issue**: The BSP tree traversal logic in the geometric property computation is expecting boolean values but receiving `BoundaryAttribute` objects instead.\n\n2. **BSP Tree Processing Defect**: When the polyhedron faces are processed and projected to 2D polygons, the boundary attribute handling in the partitioning structure is incorrect. The algorithm is likely misinterpreting node attributes during the recursive tree traversal.\n\n3. **Inheritance/Polymorphism Problem**: The issue suggests that the code assumes all node attributes in the BSP tree are simple booleans (representing inside/outside status), but in complex polyhedron cases, the nodes contain `BoundaryAttribute` objects that encapsulate boundary information.\n\nThis defect would affect any polyhedron construction that relies on the 2D polygon processing for face calculations, explaining why this specific test case fails when computing the polyhedron's volume and surface area properties.\n\nThe fix should focus on properly handling `BoundaryAttribute` objects in the `PolygonsSet.computeGeometricalProperties` method and ensuring correct type checking during the BSP tree traversal.",
            "test_suite": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest",
            "score": 8,
            "reason": "#8# The followLoop method is highly suspicious because it handles boundary loop construction for polygons, and the ClassCastException in computeGeometricalProperties suggests incorrect boundary attribute handling in the BSP tree structure. This method processes boundary segments and could be creating malformed boundary loops that later cause the type casting issue when the BSP tree is traversed for geometric property computation. The method's role in building polygon boundaries directly relates to the boundary attribute problems observed in the stack trace."
        },
        {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder::addContribution(SubHyperplane,boolean)",
            "method_code": "```java\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n```",
            "method_doc": "Add he contribution of a boundary facet. @param sub boundary facet @param reversed if true, the facet has the inside on its plus side ",
            "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
            "class_doc": "This class represents a 2D region: a set of polygons. @version $Id$ @since 3.0 ",
            "test_failure_causes": "Based on my analysis of the failed test and the stack trace, I've identified the key issue:\n\n## Analysis Summary\n\n**Common Pattern:** The test failure occurs during geometric property computation (specifically `getSize()`) when constructing a polyhedron from triangular faces. The stack trace reveals a critical `ClassCastException` in the underlying 2D polygon processing.\n\n**Key Evidence from Stack Trace:**\n```\njava.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\nat org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:142)\n```\n\n## Recommended Production Code Defect\n\nThe defect appears to be in the **`PolygonsSet.computeGeometricalProperties` method** (line 142 in the euclidean.twod package). The code is incorrectly attempting to cast a `BoundaryAttribute` object to a `Boolean`, which indicates:\n\n1. **Type Safety Issue**: The BSP tree traversal logic in the geometric property computation is expecting boolean values but receiving `BoundaryAttribute` objects instead.\n\n2. **BSP Tree Processing Defect**: When the polyhedron faces are processed and projected to 2D polygons, the boundary attribute handling in the partitioning structure is incorrect. The algorithm is likely misinterpreting node attributes during the recursive tree traversal.\n\n3. **Inheritance/Polymorphism Problem**: The issue suggests that the code assumes all node attributes in the BSP tree are simple booleans (representing inside/outside status), but in complex polyhedron cases, the nodes contain `BoundaryAttribute` objects that encapsulate boundary information.\n\nThis defect would affect any polyhedron construction that relies on the 2D polygon processing for face calculations, explaining why this specific test case fails when computing the polyhedron's volume and surface area properties.\n\nThe fix should focus on properly handling `BoundaryAttribute` objects in the `PolygonsSet.computeGeometricalProperties` method and ensuring correct type checking during the BSP tree traversal.",
            "test_suite": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest",
            "score": 3,
            "reason": "#3# While the method has some complexity with type casting and boundary handling, the actual ClassCastException occurs in PolygonsSet.computeGeometricalProperties at line 142, not in this SegmentsBuilder.addContribution method. The stack trace clearly shows the error happens during geometric property computation in the PolygonsSet class, not during segment building. This method appears to be correctly handling boundary segments and doesn't contain the problematic cast from BoundaryAttribute to Boolean that's causing the test failure."
        }
    ],
    "buggy_codes": {
        "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder::addContribution(SubHyperplane,boolean)": {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder::addContribution(SubHyperplane,boolean)",
            "method_code": "```java\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n```",
            "method_doc": "Add he contribution of a boundary facet. @param sub boundary facet @param reversed if true, the facet has the inside on its plus side "
        },
        "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder::visitInternalNode(BSPTree)": {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder::visitInternalNode(BSPTree)",
            "method_code": "```java\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n```",
            "method_doc": "{@inheritDoc} */"
        },
        "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet::computeGeometricalProperties()": {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet::computeGeometricalProperties()",
            "method_code": "```java\n    @Override\n    protected void computeGeometricalProperties() {\n\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final Vector2D[][] TransVarVertices = getVertices();\n\n        if (!(!(TransVarVertices.length == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            final BSPTree<Euclidean2D> TransVarTree2 = getTree(false);\n            if (!(!((Boolean) TransVarTree2.getAttribute()))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (!(!(TransVarVertices[0][0] == null))) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double TransVarSum1  = 0;\n            double TransVarSum2 = 0;\n            double TransVarSumY1 = 0;\n\n            for (Vector2D[] TransVarLoopVertices : TransVarVertices) {\n                double TransVarX2 = TransVarLoopVertices[TransVarLoopVertices.length - 1].getX();\n                double TransVarY2 = TransVarLoopVertices[TransVarLoopVertices.length - 1].getY();\n                for (final Vector2D TransVarPoint1 : TransVarLoopVertices) {\n                    final double TransVarX1 = TransVarX2;\n                    final double TransVarY = TransVarY2;\n                    TransVarX2 = TransVarPoint1.getX();\n                    TransVarY2 = TransVarPoint1.getY();\n                    final double TransVarYFactor = TransVarX1 * TransVarY2 - TransVarY * TransVarX2;\n                    TransVarSum1  += TransVarYFactor;\n                    TransVarSum2 += TransVarYFactor * (TransVarX1 + TransVarX2);\n                    TransVarSumY1 += TransVarYFactor * (TransVarY + TransVarY2);\n                }\n            }\n\n            if (!(!(TransVarSum1 < 0))) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(TransVarSum1 / 2);\n                setBarycenter(new Vector2D(TransVarSum2 / (3 * TransVarSum1), TransVarSumY1 / (3 * TransVarSum1)));\n            }\n\n        }\n\n    }\n\n```",
            "method_doc": "{@inheritDoc} */"
        },
        "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet::followLoop(Node,AVLTree)": {
            "method_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet::followLoop(Node,AVLTree)",
            "method_code": "```java\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n```",
            "method_doc": "Follow a boundary loop. @param node node containing the segment starting the loop @param sorted set of segments belonging to the boundary, sorted by start points (contains {@code node}) @return a list of connected sub-hyperplanes starting at {@code node} "
        }
    }
}