{
    "buggy_classes": [
        "com.google.javascript.jscomp.CheckGlobalThis"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::shouldTraverse(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public boolean shouldTraverse(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarParentNode) {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarNode.getType() == Token.FUNCTION))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo TransVarJsdoc = getFunctionJsDocInfo(TransVarNode);\n      if (!(!(TransVarJsdoc != null && (TransVarJsdoc.isConstructor() || TransVarJsdoc.isInterface()\n            || TransVarJsdoc.hasThisType() || TransVarJsdoc.isOverride())))) {\n        if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int TransVarType = TransVarParentNode.getType();\n      if (!(!(!(TransVarType == Token.BLOCK || TransVarType == Token.SCRIPT || TransVarType == Token.NAME\n            || TransVarType == Token.ASSIGN || TransVarType == Token.STRING || TransVarType == Token.NUMBER)))) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n        }\n\n    if (!(!(TransVarParentNode != null && TransVarParentNode.getType() == Token.ASSIGN))) {\n      Node TransVarLeft = TransVarParentNode.getFirstChild();\n      Node TransVarRNode = TransVarLeft.getNext();\n\n      if (!(!(TransVarNode == TransVarLeft))) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (!(!(assignLhsChild == null))) {\n          assignLhsChild = TransVarLeft;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (!(!(NodeUtil.isGet(TransVarLeft)))) {\n          if (!(!(TransVarLeft.getType() == Token.GETPROP && TransVarLeft.getLastChild().getString().equals(\"prototype\")))) {\n            return false;\n          }\n          Node TransVarCurrentLhs = TransVarLeft.getFirstChild();\n          if (!(!(TransVarCurrentLhs.getType() == Token.GETPROP\n                && TransVarCurrentLhs.getLastChild().getString().equals(\"prototype\")))) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n```",
            "method_doc": " Since this pass reports errors only when a global {@code this} keyword is encountered, there is no reason to traverse non global contexts. ",
            "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
            "class_doc": " Checks for certain uses of the {@code this} keyword that are considered unsafe because they are likely to reference the global {@code this} object unintentionally.  <p>A use of {@code this} is considered unsafe if it's on the left side of an assignment or a property access, and not inside one of the following: <ol> <li>a prototype method <li>a function annotated with {@code @constructor} <li>a function annotated with {@code @this}. <li>a function where there's no logical place to put a {@code this} annotation. </ol>  <p>Note that this check does not track assignments of {@code this} to variables or objects. The code <pre> function evil() { var a = this; a.useful = undefined; } </pre> will not get flagged, even though it is semantically equivalent to <pre> function evil() { this.useful = undefined; } </pre> which would get flagged.  ",
            "test_failure_causes": "Based on my analysis of the failed test case and the test behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- The test failure consistently involves the `@lends` annotation in combination with constructor functions\n- The `CheckGlobalThis` pass is incorrectly flagging valid `this` usage within methods that should be properly scoped due to the `@lends` annotation\n- The error `JSC_USED_GLOBAL_THIS` is being reported when it shouldn't be, indicating a scope resolution issue\n\n## Recommended Possible Defects in Production Code\n\nBased on the test failure analysis, I recommend investigating these potential defects in the `CheckGlobalThis` production code:\n\n### 1. **Lends Annotation Scope Resolution Defect**\n**Location:** `CheckGlobalThis.java` - likely in the scope analysis logic\n**Problem:** The compiler is failing to properly recognize that methods declared with `@lends {F.prototype}` annotation should have their `this` context bound to the prototype object, not the global scope.\n\n### 2. **Type Information Propagation Defect**\n**Location:** Type inference system related to `CheckGlobalThis`\n**Problem:** The `@lends` annotation information may not be properly propagated to the `CheckGlobalThis` pass, causing it to treat the method as if it were in global scope rather than prototype scope.\n\n### 3. **Dojo Declare Pattern Recognition Defect**\n**Location:** Pattern matching logic in `CheckGlobalThis`\n**Problem:** The compiler may not be properly handling the `dojo.declare(F, /** @lends {F.prototype} */ (...))` pattern, where the second parameter with `@lends` should establish the proper `this` context for the contained methods.\n\n### 4. **Annotation Processing Order Defect**\n**Location:** Compiler pass execution order\n**Problem:** The `@lends` annotation processing might be happening after `CheckGlobalThis` runs, or the annotation information might not be available when `CheckGlobalThis` performs its analysis.\n\n### 5. **This Context Binding Defect**\n**Location:** `CheckGlobalThis` context analysis logic\n**Problem:** The pass is incorrectly determining that `this.foo` inside a method declared with `@lends {F.prototype}` represents dangerous global `this` usage, when it should recognize this as safe prototype method access.\n\nThe core issue appears to be that the production code is not properly accounting for the scope-establishing behavior of the `@lends` annotation when analyzing `this` usage within object literals passed to declaration patterns like `dojo.declare`.",
            "test_suite": "com.google.javascript.jscomp.CheckGlobalThisTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because it contains the logic for determining whether to traverse function contexts and specifically handles prototype assignments. The test failure involves a @lends annotation that should establish proper this context for prototype methods, but the current code only checks for direct prototype assignments and doesn't account for @lends annotations that semantically bind methods to prototypes. The method's logic for skipping traversal of functions assigned to prototypes is incomplete and doesn't recognize the @lends annotation pattern used in dojo.declare."
        },
        {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }\n\n```",
            "method_doc": "Visits nodes during traversal and reports global 'this' usage errors when detected. This method calls method \"shouldReportThis\" to determine if a 'this' node should be reported.",
            "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
            "class_doc": " Checks for certain uses of the {@code this} keyword that are considered unsafe because they are likely to reference the global {@code this} object unintentionally.  <p>A use of {@code this} is considered unsafe if it's on the left side of an assignment or a property access, and not inside one of the following: <ol> <li>a prototype method <li>a function annotated with {@code @constructor} <li>a function annotated with {@code @this}. <li>a function where there's no logical place to put a {@code this} annotation. </ol>  <p>Note that this check does not track assignments of {@code this} to variables or objects. The code <pre> function evil() { var a = this; a.useful = undefined; } </pre> will not get flagged, even though it is semantically equivalent to <pre> function evil() { this.useful = undefined; } </pre> which would get flagged.  ",
            "test_failure_causes": "Based on my analysis of the failed test case and the test behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- The test failure consistently involves the `@lends` annotation in combination with constructor functions\n- The `CheckGlobalThis` pass is incorrectly flagging valid `this` usage within methods that should be properly scoped due to the `@lends` annotation\n- The error `JSC_USED_GLOBAL_THIS` is being reported when it shouldn't be, indicating a scope resolution issue\n\n## Recommended Possible Defects in Production Code\n\nBased on the test failure analysis, I recommend investigating these potential defects in the `CheckGlobalThis` production code:\n\n### 1. **Lends Annotation Scope Resolution Defect**\n**Location:** `CheckGlobalThis.java` - likely in the scope analysis logic\n**Problem:** The compiler is failing to properly recognize that methods declared with `@lends {F.prototype}` annotation should have their `this` context bound to the prototype object, not the global scope.\n\n### 2. **Type Information Propagation Defect**\n**Location:** Type inference system related to `CheckGlobalThis`\n**Problem:** The `@lends` annotation information may not be properly propagated to the `CheckGlobalThis` pass, causing it to treat the method as if it were in global scope rather than prototype scope.\n\n### 3. **Dojo Declare Pattern Recognition Defect**\n**Location:** Pattern matching logic in `CheckGlobalThis`\n**Problem:** The compiler may not be properly handling the `dojo.declare(F, /** @lends {F.prototype} */ (...))` pattern, where the second parameter with `@lends` should establish the proper `this` context for the contained methods.\n\n### 4. **Annotation Processing Order Defect**\n**Location:** Compiler pass execution order\n**Problem:** The `@lends` annotation processing might be happening after `CheckGlobalThis` runs, or the annotation information might not be available when `CheckGlobalThis` performs its analysis.\n\n### 5. **This Context Binding Defect**\n**Location:** `CheckGlobalThis` context analysis logic\n**Problem:** The pass is incorrectly determining that `this.foo` inside a method declared with `@lends {F.prototype}` represents dangerous global `this` usage, when it should recognize this as safe prototype method access.\n\nThe core issue appears to be that the production code is not properly accounting for the scope-establishing behavior of the `@lends` annotation when analyzing `this` usage within object literals passed to declaration patterns like `dojo.declare`.",
            "test_suite": "com.google.javascript.jscomp.CheckGlobalThisTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it directly handles the detection and reporting of global 'this' usage errors. The test failure shows that the compiler is incorrectly flagging valid 'this' usage within methods that should be properly scoped due to the @lends annotation. Since this method calls shouldReportThis to determine whether to report a 'this' node as a global this error, and the test failure involves JSC_USED_GLOBAL_THIS being incorrectly reported, the logic in this method or its dependencies is likely not properly handling the scope established by @lends annotations in dojo.declare patterns."
        },
        {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::getFunctionJsDocInfo(Node)",
            "method_code": "```java\n  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.getType() == Token.VAR) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }\n\n```",
            "method_doc": " Gets a function's JSDoc information, if it has any. Checks for a few patterns (ellipses show where JSDoc would be): <pre> ... function() {} ... x = function() {}; var ... x = function() {}; ... var x = function() {}; </pre> ",
            "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
            "class_doc": " Checks for certain uses of the {@code this} keyword that are considered unsafe because they are likely to reference the global {@code this} object unintentionally.  <p>A use of {@code this} is considered unsafe if it's on the left side of an assignment or a property access, and not inside one of the following: <ol> <li>a prototype method <li>a function annotated with {@code @constructor} <li>a function annotated with {@code @this}. <li>a function where there's no logical place to put a {@code this} annotation. </ol>  <p>Note that this check does not track assignments of {@code this} to variables or objects. The code <pre> function evil() { var a = this; a.useful = undefined; } </pre> will not get flagged, even though it is semantically equivalent to <pre> function evil() { this.useful = undefined; } </pre> which would get flagged.  ",
            "test_failure_causes": "Based on my analysis of the failed test case and the test behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- The test failure consistently involves the `@lends` annotation in combination with constructor functions\n- The `CheckGlobalThis` pass is incorrectly flagging valid `this` usage within methods that should be properly scoped due to the `@lends` annotation\n- The error `JSC_USED_GLOBAL_THIS` is being reported when it shouldn't be, indicating a scope resolution issue\n\n## Recommended Possible Defects in Production Code\n\nBased on the test failure analysis, I recommend investigating these potential defects in the `CheckGlobalThis` production code:\n\n### 1. **Lends Annotation Scope Resolution Defect**\n**Location:** `CheckGlobalThis.java` - likely in the scope analysis logic\n**Problem:** The compiler is failing to properly recognize that methods declared with `@lends {F.prototype}` annotation should have their `this` context bound to the prototype object, not the global scope.\n\n### 2. **Type Information Propagation Defect**\n**Location:** Type inference system related to `CheckGlobalThis`\n**Problem:** The `@lends` annotation information may not be properly propagated to the `CheckGlobalThis` pass, causing it to treat the method as if it were in global scope rather than prototype scope.\n\n### 3. **Dojo Declare Pattern Recognition Defect**\n**Location:** Pattern matching logic in `CheckGlobalThis`\n**Problem:** The compiler may not be properly handling the `dojo.declare(F, /** @lends {F.prototype} */ (...))` pattern, where the second parameter with `@lends` should establish the proper `this` context for the contained methods.\n\n### 4. **Annotation Processing Order Defect**\n**Location:** Compiler pass execution order\n**Problem:** The `@lends` annotation processing might be happening after `CheckGlobalThis` runs, or the annotation information might not be available when `CheckGlobalThis` performs its analysis.\n\n### 5. **This Context Binding Defect**\n**Location:** `CheckGlobalThis` context analysis logic\n**Problem:** The pass is incorrectly determining that `this.foo` inside a method declared with `@lends {F.prototype}` represents dangerous global `this` usage, when it should recognize this as safe prototype method access.\n\nThe core issue appears to be that the production code is not properly accounting for the scope-establishing behavior of the `@lends` annotation when analyzing `this` usage within object literals passed to declaration patterns like `dojo.declare`.",
            "test_suite": "com.google.javascript.jscomp.CheckGlobalThisTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because it's responsible for retrieving JSDoc information from function nodes, and the test failure involves @lends annotation processing. The method currently only checks immediate parent and grandparent nodes for JSDoc, but in the dojo.declare pattern with @lends annotation, the annotation may be attached to a different ancestor node that this method doesn't traverse, causing it to miss the @lends annotation that should establish the proper this context."
        },
        {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::shouldReportThis(Node,Node)",
            "method_code": "```java\n  private boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n      // Always report a THIS on the left side of an assign.\n      return true;\n    }\n\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent);\n  }\n\n```",
            "method_doc": "Checks if a 'this' node should be reported as a global this error based on assignment context or property access.",
            "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
            "class_doc": " Checks for certain uses of the {@code this} keyword that are considered unsafe because they are likely to reference the global {@code this} object unintentionally.  <p>A use of {@code this} is considered unsafe if it's on the left side of an assignment or a property access, and not inside one of the following: <ol> <li>a prototype method <li>a function annotated with {@code @constructor} <li>a function annotated with {@code @this}. <li>a function where there's no logical place to put a {@code this} annotation. </ol>  <p>Note that this check does not track assignments of {@code this} to variables or objects. The code <pre> function evil() { var a = this; a.useful = undefined; } </pre> will not get flagged, even though it is semantically equivalent to <pre> function evil() { this.useful = undefined; } </pre> which would get flagged.  ",
            "test_failure_causes": "Based on my analysis of the failed test case and the test behavior, I'll identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Test Failure Patterns\n\n**Common Pattern Identified:**\n- The test failure consistently involves the `@lends` annotation in combination with constructor functions\n- The `CheckGlobalThis` pass is incorrectly flagging valid `this` usage within methods that should be properly scoped due to the `@lends` annotation\n- The error `JSC_USED_GLOBAL_THIS` is being reported when it shouldn't be, indicating a scope resolution issue\n\n## Recommended Possible Defects in Production Code\n\nBased on the test failure analysis, I recommend investigating these potential defects in the `CheckGlobalThis` production code:\n\n### 1. **Lends Annotation Scope Resolution Defect**\n**Location:** `CheckGlobalThis.java` - likely in the scope analysis logic\n**Problem:** The compiler is failing to properly recognize that methods declared with `@lends {F.prototype}` annotation should have their `this` context bound to the prototype object, not the global scope.\n\n### 2. **Type Information Propagation Defect**\n**Location:** Type inference system related to `CheckGlobalThis`\n**Problem:** The `@lends` annotation information may not be properly propagated to the `CheckGlobalThis` pass, causing it to treat the method as if it were in global scope rather than prototype scope.\n\n### 3. **Dojo Declare Pattern Recognition Defect**\n**Location:** Pattern matching logic in `CheckGlobalThis`\n**Problem:** The compiler may not be properly handling the `dojo.declare(F, /** @lends {F.prototype} */ (...))` pattern, where the second parameter with `@lends` should establish the proper `this` context for the contained methods.\n\n### 4. **Annotation Processing Order Defect**\n**Location:** Compiler pass execution order\n**Problem:** The `@lends` annotation processing might be happening after `CheckGlobalThis` runs, or the annotation information might not be available when `CheckGlobalThis` performs its analysis.\n\n### 5. **This Context Binding Defect**\n**Location:** `CheckGlobalThis` context analysis logic\n**Problem:** The pass is incorrectly determining that `this.foo` inside a method declared with `@lends {F.prototype}` represents dangerous global `this` usage, when it should recognize this as safe prototype method access.\n\nThe core issue appears to be that the production code is not properly accounting for the scope-establishing behavior of the `@lends` annotation when analyzing `this` usage within object literals passed to declaration patterns like `dojo.declare`.",
            "test_suite": "com.google.javascript.jscomp.CheckGlobalThisTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it directly determines whether 'this' usage should be reported as a global this error, and the test failure shows that valid 'this' usage within @lends annotated methods is being incorrectly flagged. The method currently only checks if 'this' is on the left side of assignment or in a property access, but doesn't account for the scope context established by @lends annotations, which is exactly what's causing the false positive in the test case."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.CheckGlobalThis::shouldTraverse(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::shouldTraverse(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public boolean shouldTraverse(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarParentNode) {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarNode.getType() == Token.FUNCTION))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo TransVarJsdoc = getFunctionJsDocInfo(TransVarNode);\n      if (!(!(TransVarJsdoc != null && (TransVarJsdoc.isConstructor() || TransVarJsdoc.isInterface()\n            || TransVarJsdoc.hasThisType() || TransVarJsdoc.isOverride())))) {\n        if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int TransVarType = TransVarParentNode.getType();\n      if (!(!(!(TransVarType == Token.BLOCK || TransVarType == Token.SCRIPT || TransVarType == Token.NAME\n            || TransVarType == Token.ASSIGN || TransVarType == Token.STRING || TransVarType == Token.NUMBER)))) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n        }\n\n    if (!(!(TransVarParentNode != null && TransVarParentNode.getType() == Token.ASSIGN))) {\n      Node TransVarLeft = TransVarParentNode.getFirstChild();\n      Node TransVarRNode = TransVarLeft.getNext();\n\n      if (!(!(TransVarNode == TransVarLeft))) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (!(!(assignLhsChild == null))) {\n          assignLhsChild = TransVarLeft;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (!(!(NodeUtil.isGet(TransVarLeft)))) {\n          if (!(!(TransVarLeft.getType() == Token.GETPROP && TransVarLeft.getLastChild().getString().equals(\"prototype\")))) {\n            return false;\n          }\n          Node TransVarCurrentLhs = TransVarLeft.getFirstChild();\n          if (!(!(TransVarCurrentLhs.getType() == Token.GETPROP\n                && TransVarCurrentLhs.getLastChild().getString().equals(\"prototype\")))) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n```",
            "method_doc": " Since this pass reports errors only when a global {@code this} keyword is encountered, there is no reason to traverse non global contexts. "
        },
        "com.google.javascript.jscomp.CheckGlobalThis::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }\n\n```",
            "method_doc": "Visits nodes during traversal and reports global 'this' usage errors when detected. This method calls method \"shouldReportThis\" to determine if a 'this' node should be reported."
        },
        "com.google.javascript.jscomp.CheckGlobalThis::getFunctionJsDocInfo(Node)": {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::getFunctionJsDocInfo(Node)",
            "method_code": "```java\n  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.getType() == Token.VAR) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }\n\n```",
            "method_doc": " Gets a function's JSDoc information, if it has any. Checks for a few patterns (ellipses show where JSDoc would be): <pre> ... function() {} ... x = function() {}; var ... x = function() {}; ... var x = function() {}; </pre> "
        },
        "com.google.javascript.jscomp.CheckGlobalThis::shouldReportThis(Node,Node)": {
            "method_name": "com.google.javascript.jscomp.CheckGlobalThis::shouldReportThis(Node,Node)",
            "method_code": "```java\n  private boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n      // Always report a THIS on the left side of an assign.\n      return true;\n    }\n\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent);\n  }\n\n```",
            "method_doc": "Checks if a 'this' node should be reported as a global this error based on assignment context or property access."
        }
    }
}