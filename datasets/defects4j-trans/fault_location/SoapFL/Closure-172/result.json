{
    "buggy_classes": [
        "com.google.javascript.rhino.jstype.JSTypeRegistry",
        "com.google.javascript.rhino.jstype.ObjectType",
        "com.google.javascript.jscomp.TypedScopeCreator",
        "com.google.javascript.jscomp.TypeInference"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::isQualifiedNameInferred(String,Node,JSDocInfo,Node,JSType)",
            "method_code": "```java\n    private boolean isQualifiedNameInferred(\n        String TransVarName, Node TransVarNode, JSDocInfo TransVarDocInfo,\n        Node TransVarRhsNode, JSType TransVarType) {\n      if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(TransVarType == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (!(!(TransVarName != null && TransVarName.endsWith(\".prototype\")))) {\n          if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n          return false;\n        }\n\n      boolean TransVarInfer = true;\n      if (!(!(TransVarDocInfo != null))) {\n        TransVarInfer = !(TransVarDocInfo.hasType()\n            || TransVarDocInfo.hasEnumParameterType()\n            || (isConstantSymbol(TransVarDocInfo, TransVarNode) && TransVarType != null\n                && !TransVarType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(TransVarDocInfo));\n      }\n\n      if (!(!(TransVarInfer && TransVarRhsNode != null && TransVarRhsNode.isFunction()))) {\n        if (!(!(TransVarDocInfo != null))) {\n          return false;\n        } else if (!(!(!scope.isDeclared(TransVarName, false) && TransVarNode.isUnscopedQualifiedName()))) {\n\n          Node TransVarCurrentNode = TransVarNode.getParent();\n        while (!(!(!(TransVarCurrentNode.isScript() || TransVarCurrentNode.isFunction())))) {\n            if (!(!(NodeUtil.isControlStructure(TransVarCurrentNode)))) {\n              return true;\n            }\n            TransVarCurrentNode = TransVarCurrentNode.getParent();\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents TransVarFunctionContent =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (!(!(TransVarFunctionContent == null\n                || !TransVarFunctionContent.getEscapedQualifiedNames().contains(TransVarName)))) {\n            return false;\n          }\n        }\n      }\n      return TransVarInfer;\n    }\n\n```",
            "method_doc": " Determines whether a qualified name is inferred. NOTE(nicksantos): Determining whether a property is declared or not is really really obnoxious.  The problem is that there are two (equally valid) coding styles:  (function() { The authoritative definition of goog.bar. / goog.bar = function() {}; })();  function f() { goog.bar(); Reset goog.bar to a no-op. / goog.bar = function() {}; }  In a dynamic language with first-class functions, it's very difficult to know which one the user intended without looking at lots of contextual information (the second example demonstrates a small case of this, but there are some really pathological cases as well).  The current algorithm checks if either the declaration has JsDoc type information, or @const with a known type, or a function literal with a name we haven't seen before. ",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it handles type inference for qualified names including prototype properties, and the test failure specifically involves incorrect type inference for Object.prototype assignments. The method's logic for determining whether a qualified name is inferred appears to be incorrectly handling prototype property type tracking, which matches the observed behavior where type information from one function context incorrectly propagates to another function context. The method's special handling of \".prototype\" names and its complex inference logic aligns with the test failure pattern where prototype property types are not properly isolated between different Object instances."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::register(JSType,String)",
            "method_code": "```java\n  private void register(JSType type, String name) {\n    Preconditions.checkArgument(\n        !name.contains(\"<\"), \"Type names cannot contain template annotations.\");\n\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }\n\n```",
            "method_doc": "Registers a JSType with a specific name, storing it in the namesToTypes map and updating namespaces.",
            "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
            "class_doc": " The type registry is used to resolve named types.  <p>This class is not thread-safe.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles type registration in the global type registry, and the test failure indicates a problem with incorrect type propagation where string type assigned to a.prototype in one function context incorrectly affects the type inference of b.prototype in another function context. The register method maintains a shared namesToTypes map that could be causing global type contamination instead of maintaining proper scope isolation between different object instances."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::resetForTypeCheck()",
            "method_code": "```java\n  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }\n\n```",
            "method_doc": " Reset to run the TypeCheck pass. ",
            "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
            "class_doc": " The type registry is used to resolve named types.  <p>This class is not thread-safe.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The resetForTypeCheck() method clears type registries including typesIndexedByProperty, which likely contains cached type information for properties like 'prototype'. When this method is called at the wrong time or doesn't properly isolate type information between different function contexts, it could cause the observed issue where type assignments to a.prototype incorrectly affect the type inference of b.prototype in a different function. The method's responsibility for resetting type state makes it a prime suspect for type propagation bugs."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::registerPropertyOnType(String,JSType)",
            "method_code": "```java\n  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }\n\n```",
            "method_doc": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
            "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
            "class_doc": " The type registry is used to resolve named types.  <p>This class is not thread-safe.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The registerPropertyOnType method is highly suspicious because it globally tracks property types across all instances, which explains why assigning a string to a.prototype in one function incorrectly affects the type inference of b.prototype in another function. The method maintains a shared registry (typesIndexedByProperty) that doesn't distinguish between different object instances, causing the type contamination observed in the test failure."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::initializeBuiltInTypes()",
            "method_code": "```java\n  private void initializeBuiltInTypes() {\n    objectIndexTemplateKey = new TemplateType(this, OBJECT_INDEX_TEMPLATE);\n    objectElementTemplateKey = new TemplateType(this, OBJECT_ELEMENT_TEMPLATE);\n\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    UnknownType checkedUnknownType = new UnknownType(this, true);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, checkedUnknownType);\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true, null);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null,\n            createTemplateTypeMap(ImmutableList.of(\n                objectIndexTemplateKey, objectElementTemplateKey), null),\n            true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null,\n          createTemplateTypeMap(ImmutableList.of(\n              objectElementTemplateKey), null),\n          true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (null,void)\n    JSType NULL_VOID =\n        createUnionType(NULL_TYPE, VOID_TYPE);\n    registerNativeType(JSTypeNative.NULL_VOID, NULL_VOID);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the Unknown type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            UNKNOWN_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }\n\n```",
            "method_doc": "Initializes all built-in JavaScript types (e.g., Boolean, Number, Object, Array) and registers them; this method calls method \"registerNativeType\" for each type and method \"registerPropertyOnType\" for the \"prototype\" property.",
            "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
            "class_doc": " The type registry is used to resolve named types.  <p>This class is not thread-safe.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it initializes the built-in Object type and registers the \"prototype\" property globally. The test failure shows incorrect type propagation where assigning a string to one object's prototype affects type inference for other objects' prototype properties. Since this method sets up the fundamental type system infrastructure and handles prototype property registration for all Object instances, any defect in how prototype properties are initialized or tracked would cause the observed cross-contamination of type information between different object instances."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::addReferenceTypeIndexedByProperty(String,JSType)",
            "method_code": "```java\n  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }\n\n```",
            "method_doc": "Adds reference types (ObjectType or NamedType) to the property index, handling unions recursively.",
            "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
            "class_doc": " The type registry is used to resolve named types.  <p>This class is not thread-safe.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it maintains a global registry of reference types indexed by property names, which explains why type information for the 'prototype' property is being incorrectly shared across different Object instances. The method stores ObjectType instances in a shared map (eachRefTypeIndexedByProperty) using property names as keys, causing type assignments to 'prototype' in one context to affect type checking in unrelated contexts, leading to the observed type mismatch errors."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::defineDeclaredProperty(String,JSType,Node)",
            "method_code": "```java\n  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false, propertyNode);\n    // All property definitions go through this method\n    // or defineInferredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n    return result;\n  }\n\n```",
            "method_doc": " Defines a property whose type is explicitly declared by the programmer. @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
            "class_name": "com.google.javascript.rhino.jstype.ObjectType",
            "class_doc": " Object type.  In JavaScript, all object types have properties, and each of those properties has a type. Property types may be DECLARED, INFERRED, or UNKNOWN.  DECLARED properties have an explicit type annotation, as in: <code> xx @type {number} x/ Foo.prototype.bar = 1; </code> This property may only hold number values, and an assignment to any other type of value is an error.  INFERRED properties do not have an explicit type annotation. Rather, we try to find all the possible types that this property can hold. <code> Foo.prototype.bar = 1; </code> If the programmer assigns other types of values to this property, the property will take on the union of all these types.  UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN type has all properties, but we do not know whether they are declared or inferred.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The defineDeclaredProperty method is highly suspicious because it handles property type declarations and registration. The test failure shows incorrect type propagation for the 'prototype' property across different object instances, which aligns with this method's responsibility for defining declared properties and registering them in the type registry. The registry.registerPropertyOnType call suggests this method could be causing global type pollution where prototype property type definitions are incorrectly shared across all ObjectType instances rather than being instance-specific."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::getPropertyType(String)",
            "method_code": "```java\n  public JSType getPropertyType(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    if (slot == null) {\n      if (isNoResolvedType() || isCheckedUnknownType()) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n      } else if (isEmptyType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }\n\n```",
            "method_doc": " Gets the property type of the property whose name is given. If the underlying object does not have this property, the Unknown type is returned to indicate that no information is available on this property.  This gets overridden by FunctionType for lazily-resolved call() and bind() functions.  @return the property's type or {@link UnknownType}. This method never returns {@code null}. ",
            "class_name": "com.google.javascript.rhino.jstype.ObjectType",
            "class_doc": " Object type.  In JavaScript, all object types have properties, and each of those properties has a type. Property types may be DECLARED, INFERRED, or UNKNOWN.  DECLARED properties have an explicit type annotation, as in: <code> xx @type {number} x/ Foo.prototype.bar = 1; </code> This property may only hold number values, and an assignment to any other type of value is an error.  INFERRED properties do not have an explicit type annotation. Rather, we try to find all the possible types that this property can hold. <code> Foo.prototype.bar = 1; </code> If the programmer assigns other types of values to this property, the property will take on the union of all these types.  UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN type has all properties, but we do not know whether they are declared or inferred.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The getPropertyType method is highly suspicious because it directly handles property type resolution for ObjectType instances. The test failure shows incorrect type inference where assigning a string to a.prototype affects the return type of b.prototype in a different context. This method's logic for returning property types (including UNKNOWN_TYPE, CHECKED_UNKNOWN_TYPE, or the slot's type) likely fails to properly isolate type information between different object instances, causing the cross-contamination of prototype property types observed in the test failure."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::resolveTypes()",
            "method_code": "```java\n    @Override\n    public void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }\n\n```",
            "method_doc": "Resolves deferred types and scope variables, and informs the type registry to resolve types in the scope.",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because the resolveTypes() method handles type resolution for scope variables and deferred types, and the test failure involves incorrect type propagation where assigning a string to a.prototype in one function incorrectly affects the type inference of b.prototype in another function. The method's responsibility for resolving types in the scope and informing the type registry aligns with the pattern of the defect where type information is not properly isolated between different function contexts."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,JSType,boolean)",
            "method_code": "```java\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualified names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.isName()) {\n        Preconditions.checkArgument(\n            parent.isFunction() ||\n            parent.isVar() ||\n            parent.isParamList() ||\n            parent.isCatch());\n      } else {\n        Preconditions.checkArgument(\n            n.isGetProp() &&\n            (parent.isAssign() ||\n             parent.isExprResult()));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }\n\n```",
            "method_doc": " Defines a typed variable. The defining node will be annotated with the variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is inferred.  Slots may be any variable or any qualified name in the global scope.  @param n the defining NAME or GETPROP node. @param parent the {@code n}'s parent. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. ",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because it handles type slot definitions for variables and properties including prototype assignments. The test failure shows incorrect type propagation for Object.prototype property across different function contexts, and this method is responsible for defining type slots and propagating type information. The issue appears to be that when defining slots for prototype property assignments, the method may not properly isolate type information between different object instances, causing the string type from one assignment to incorrectly affect the return type checking in another function."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,JSType)",
            "method_code": "```java\n    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }\n\n```",
            "method_doc": " Defines a typed variable. The defining node will be annotated with the variable's type or {@code null} if its type is inferred. @param name the defining node. It must be a {@link Token#NAME}. @param parent the {@code name}'s parent. @param type the variable's type. It may be {@code null}, in which case the variable's type will be inferred. ",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The defineSlot method is highly suspicious because it handles variable type definitions and type inference, which directly relates to the test failure where the type system incorrectly infers that b.prototype has type string instead of Object. The method's role in defining typed variables and handling type inference makes it a prime candidate for the bug where type information is incorrectly propagated across different function scopes."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,String,JSType,boolean)",
            "method_code": "```java\n    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.isName() && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.isVar() ||\n           parent.isFunction());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.isGetProp() && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // The input may be null if we are working with a AST snippet. So read\n      // the extern info from the node.\n      Var newVar = null;\n\n      // declared in closest scope?\n      CompilerInput input = compiler.getInput(inputId);\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        newVar = validator.expectUndeclaredVariable(\n            sourceName, input, n, parent, oldVar, variableName, type);\n      } else {\n        if (type != null) {\n          setDeferredType(n, type);\n        }\n\n        newVar =\n          scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.isObjectLit() ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n      }\n\n      // We need to do some additional work for constructors and interfaces.\n      FunctionType fnType = JSType.toMaybeFunctionType(type);\n      if (fnType != null &&\n          // We don't want to look at empty function types.\n          !type.isEmptyType()) {\n\n        // We want to make sure that when we declare a new instance type\n        // (with @constructor) that there's actually a ctor for it.\n        // This doesn't apply to structural constructors (like\n        // function(new:Array). Checking the constructed type against\n        // the variable name is a sufficient check for this.\n        if ((fnType.isConstructor() || fnType.isInterface()) &&\n            variableName.equals(fnType.getReferenceName())) {\n          finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn,\n                                      input, newVar);\n        }\n      }\n\n      if (shouldDeclareOnGlobalThis) {\n        ObjectType globalThis =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS);\n        if (inferred) {\n          globalThis.defineInferredProperty(variableName,\n              type == null ?\n              getNativeType(JSTypeNative.NO_TYPE) :\n              type,\n              n);\n        } else {\n          globalThis.defineDeclaredProperty(variableName, type, n);\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type != null\n          && type.isFunctionType()\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n      }\n    }\n\n```",
            "method_doc": " Defines a symbol in the current scope.  @param n the defining NAME or GETPROP or object literal key node. @param parent the {@code n}'s parent. @param variableName The name that this should be known by. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. @param inferred Whether the type is inferred or declared. ",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles type declaration and scope management for variables and properties, including the 'prototype' property. The test failure shows incorrect type propagation where assigning a string to 'a.prototype' in one function incorrectly affects the type inference of 'b.prototype' in another function. The defineSlot method contains logic for declaring properties in different scopes and handling global scope declarations, which could be causing the improper type sharing between different Object instances' prototype properties. The method's responsibility for defining symbol types and scope management directly relates to the type inference issue observed in the test failure."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
            "method_code": "```java\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has JsDoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n\n          qVar.getScope().undeclare(qVar);\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = isQualifiedNameInferred(\n          qName, n, info, rhsValue, valueType);\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        FunctionType ownerFnType = JSType.toMaybeFunctionType(ownerType);\n        if (ownerFnType != null) {\n          JSType ownerTypeOfThis = ownerFnType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n\n```",
            "method_doc": " Declare the symbol for a qualified name in the global scope.  @param info The doc info for this property. @param n A top-level GETPROP node (it should not be contained inside another GETPROP). @param parent The parent of {@code n}. @param rhsValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles the special case for \"prototype\" property assignments and contains logic that resets implicit prototypes. The test failure shows incorrect type propagation for prototype properties across different function contexts, and this method's handling of prototype assignments (particularly the resetImplicitPrototype call and the logic around undeclaring variables) could be causing the type system to incorrectly infer string types for prototype properties when they should maintain Object type consistency."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeInference::traverseGetProp(Node,FlowScope)",
            "method_code": "```java\n  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }\n\n```",
            "method_doc": "Traverses property access nodes, determining property types and dereferencing pointers. This method calls methods \"traverseChildren\", \"getPropertyType\", and \"dereferencePointer\" for child traversal, type resolution, and pointer dereferencing.",
            "class_name": "com.google.javascript.jscomp.TypeInference",
            "class_doc": " Type inference within a script node or a function body, using the data-flow analysis framework.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles property access type inference and directly calls getPropertyType which determines the type of prototype properties. The test failure shows incorrect type propagation for Object.prototype across different function contexts, and this method is responsible for inferring property types during property access operations like b.prototype. The method's logic for determining property types appears to be incorrectly sharing type information between different object instances instead of maintaining proper scope isolation."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeInference::getPropertyType(JSType,String,Node,FlowScope)",
            "method_code": "```java\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // We often have a couple of different types to choose from for the\n    // property. Ordered by accuracy, we have\n    // 1) A locally inferred qualified name (which is in the FlowScope)\n    // 2) A globally declared qualified name (which is in the FlowScope)\n    // 3) A property on the owner type (which is on objType)\n    // 4) A name in the type registry (as a last resort)\n    JSType propertyType = null;\n    boolean isLocallyInferred = false;\n\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        boolean isDeclared = !var.isTypeInferred();\n        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n        if (isDeclared || isLocallyInferred) {\n          propertyType = varType;\n        }\n      }\n    }\n\n    if (propertyType == null && objType != null) {\n      JSType foundType = objType.findPropertyType(propName);\n      if (foundType != null) {\n        propertyType = foundType;\n      }\n    }\n\n    if (propertyType != null && objType != null) {\n      JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n      if (restrictedObjType.isTemplatizedType()\n          && propertyType.hasAnyTemplateTypes()) {\n        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n            registry, typeMap);\n        propertyType = propertyType.visit(replacer);\n      }\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType())\n        && qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    if (propertyType == null) {\n      return unknownType;\n    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n      // If the type has been checked in this scope,\n      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n      return getNativeType(CHECKED_UNKNOWN_TYPE);\n    } else {\n      return propertyType;\n    }\n  }\n\n```",
            "method_doc": "Resolves property types from scope, object type, or registry with template type handling.",
            "class_name": "com.google.javascript.jscomp.TypeInference",
            "class_doc": " Type inference within a script node or a function body, using the data-flow analysis framework.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles property type resolution and appears to have issues with scope isolation. The test failure shows incorrect type propagation where assigning a string to a.prototype in one function affects the type inference of b.prototype in another function. The method's logic for resolving property types from scope, object type, or registry could be incorrectly sharing type information across different object instances, particularly for built-in properties like \"prototype\". The code path that checks the scope for qualified names might be returning type information from a different context, causing the observed type mismatch error."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeInference::updateScopeForTypeChange(FlowScope,Node,JSType,JSType)",
            "method_code": "```java\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n\n```",
            "method_doc": " Updates the scope according to the result of a type change, like an assignment or a type cast. ",
            "class_name": "com.google.javascript.jscomp.TypeInference",
            "class_doc": " Type inference within a script node or a function body, using the data-flow analysis framework.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles type updates for property assignments including GETPROP operations like \"prototype\" property access. The test failure shows incorrect type propagation where assigning a string to a.prototype affects the type inference for b.prototype in a different context. The method's scope.inferQualifiedSlot call for GETPROP case may be incorrectly sharing type information across different object instances instead of maintaining instance-specific type tracking for prototype properties."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeInference::ensurePropertyDeclaredHelper(Node,ObjectType)",
            "method_code": "```java\n  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }\n\n```",
            "method_doc": " Declares a property on its owner, if necessary. @return True if a property was declared. ",
            "class_name": "com.google.javascript.jscomp.TypeInference",
            "class_doc": " Type inference within a script node or a function body, using the data-flow analysis framework.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it specifically handles prototype property declarations and contains logic that could cause incorrect type propagation. The method checks for \"prototype\" property names and defines declared properties on object types, which could explain why assigning a string to a.prototype in one function context incorrectly affects the type inference of b.prototype in another function context. The logic around objectType.defineDeclaredProperty() may be updating type information globally rather than maintaining proper scope isolation between different object instances."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeInference::traverse(Node,FlowScope)",
            "method_code": "```java\n  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n\n      case Token.CAST:\n        scope = traverseChildren(n, scope);\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.hasType()) {\n          n.setJSType(info.getType().evaluate(syntacticScope, registry));\n        }\n        break;\n    }\n\n    return scope;\n  }\n\n```",
            "method_doc": "Dispatches to specific traversal methods based on node type, handling various JavaScript expressions and statements. This method calls multiple traversal methods including \"traverseAssign\", \"traverseName\", \"traverseGetProp\", \"traverseAnd\", \"traverseOr\", \"traverseHook\", \"traverseObjectLiteral\", \"traverseCall\", \"traverseNew\", \"traverseAdd\", \"traverseArrayLiteral\", \"traverseReturn\", \"traverseChildren\", and \"traverseCatch\".",
            "class_name": "com.google.javascript.jscomp.TypeInference",
            "class_doc": " Type inference within a script node or a function body, using the data-flow analysis framework.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# The traverse method is highly suspicious because it handles GETPROP token type which processes property accesses like b.prototype. The issue appears to be in how type information for the prototype property is propagated across different object instances. When traverseGetProp processes b.prototype, it may be incorrectly using global type information rather than instance-specific type data, causing the type mismatch error where string type from a.prototype assignment incorrectly affects the return type inference for b.prototype in function g."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeInference::ensurePropertyDefined(Node,JSType)",
            "method_code": "```java\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      // Don't add the property to @struct objects outside a constructor\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        if (!(obj.isThis() &&\n              getJSType(syntacticScope.getRootNode()).isConstructor())) {\n          return;\n        }\n      }\n\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(propName, rightType, getprop);\n          }\n        } else if (obj.isThis() &&\n                   getJSType(syntacticScope.getRootNode()).isConstructor()) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        } else {\n          registry.registerPropertyOnType(propName, objectType);\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Defines a property if the property has not been defined yet. ",
            "class_name": "com.google.javascript.jscomp.TypeInference",
            "class_doc": " Type inference within a script node or a function body, using the data-flow analysis framework.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that need to be fixed, because it contains special handling for the \"prototype\" property where it calls defineDeclaredProperty instead of defineInferredProperty, which could be causing incorrect type propagation across different object instances. The test failure shows that assigning a string to a.prototype is incorrectly affecting the type inference for b.prototype in a different function, suggesting this special prototype handling is not properly scoped to individual object instances."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::getSlot(String)",
            "method_code": "```java\n  @Override\n  public Property getSlot(String name) {\n    return getPropertyMap().getSlot(name);\n  }\n\n```",
            "method_doc": " Default getSlot implementation. This gets overridden by FunctionType for lazily-resolved prototypes. ",
            "class_name": "com.google.javascript.rhino.jstype.ObjectType",
            "class_doc": " Object type.  In JavaScript, all object types have properties, and each of those properties has a type. Property types may be DECLARED, INFERRED, or UNKNOWN.  DECLARED properties have an explicit type annotation, as in: <code> xx @type {number} x/ Foo.prototype.bar = 1; </code> This property may only hold number values, and an assignment to any other type of value is an error.  INFERRED properties do not have an explicit type annotation. Rather, we try to find all the possible types that this property can hold. <code> Foo.prototype.bar = 1; </code> If the programmer assigns other types of values to this property, the property will take on the union of all these types.  UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN type has all properties, but we do not know whether they are declared or inferred.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 7,
            "reason": "#7# The getSlot method is suspicious because it retrieves property information from the property map, and the test failure suggests incorrect type propagation for the 'prototype' property across different object instances. Since this method is responsible for accessing property slots and the failure involves prototype property type inference issues, it could be contributing to the shared type registry problem where prototype property types are not properly isolated between different object instances."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::isPropertyTypeDeclared(String)",
            "method_code": "```java\n  public boolean isPropertyTypeDeclared(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : !slot.isTypeInferred();\n  }\n\n```",
            "method_doc": " Checks whether the property's type is declared. ",
            "class_name": "com.google.javascript.rhino.jstype.ObjectType",
            "class_doc": " Object type.  In JavaScript, all object types have properties, and each of those properties has a type. Property types may be DECLARED, INFERRED, or UNKNOWN.  DECLARED properties have an explicit type annotation, as in: <code> xx @type {number} x/ Foo.prototype.bar = 1; </code> This property may only hold number values, and an assignment to any other type of value is an error.  INFERRED properties do not have an explicit type annotation. Rather, we try to find all the possible types that this property can hold. <code> Foo.prototype.bar = 1; </code> If the programmer assigns other types of values to this property, the property will take on the union of all these types.  UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN type has all properties, but we do not know whether they are declared or inferred.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 7,
            "reason": "#7# The method isPropertyTypeDeclared is suspicious because it determines whether a property type is declared or inferred, which directly relates to how the type system handles prototype property assignments. In the test failure, the type checker incorrectly infers that b.prototype has type string instead of Object, suggesting issues with how property types are classified as declared vs inferred. The method's logic using getSlot and isTypeInferred could be misclassifying the prototype property's type status, leading to improper type propagation across different object instances."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::isPropertyTypeInferred(String)",
            "method_code": "```java\n  public boolean isPropertyTypeInferred(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : slot.isTypeInferred();\n  }\n\n```",
            "method_doc": " Checks whether the property's type is inferred. ",
            "class_name": "com.google.javascript.rhino.jstype.ObjectType",
            "class_doc": " Object type.  In JavaScript, all object types have properties, and each of those properties has a type. Property types may be DECLARED, INFERRED, or UNKNOWN.  DECLARED properties have an explicit type annotation, as in: <code> xx @type {number} x/ Foo.prototype.bar = 1; </code> This property may only hold number values, and an assignment to any other type of value is an error.  INFERRED properties do not have an explicit type annotation. Rather, we try to find all the possible types that this property can hold. <code> Foo.prototype.bar = 1; </code> If the programmer assigns other types of values to this property, the property will take on the union of all these types.  UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN type has all properties, but we do not know whether they are declared or inferred.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 7,
            "reason": "#7# The isPropertyTypeInferred method is suspicious because it determines whether a property's type is inferred, which directly relates to the test failure where the type system incorrectly infers the prototype property type. The test shows that string assignments to a.prototype are incorrectly affecting type inference for b.prototype in a different context, suggesting issues with how inferred types are tracked and propagated across different object instances. The method's role in identifying inferred properties makes it a key component in the type inference system that could be causing the incorrect type propagation."
        },
        {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::hasProperty(String)",
            "method_code": "```java\n  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isEmptyType() || isUnknownType() || getSlot(propertyName) != null;\n  }\n\n```",
            "method_doc": "Checks if a property exists on this object or its prototype chain. This method calls method \"getSlot\" to verify property existence.",
            "class_name": "com.google.javascript.rhino.jstype.ObjectType",
            "class_doc": " Object type.  In JavaScript, all object types have properties, and each of those properties has a type. Property types may be DECLARED, INFERRED, or UNKNOWN.  DECLARED properties have an explicit type annotation, as in: <code> xx @type {number} x/ Foo.prototype.bar = 1; </code> This property may only hold number values, and an assignment to any other type of value is an error.  INFERRED properties do not have an explicit type annotation. Rather, we try to find all the possible types that this property can hold. <code> Foo.prototype.bar = 1; </code> If the programmer assigns other types of values to this property, the property will take on the union of all these types.  UNKNOWN properties are properties on the UNKNOWN type. The UNKNOWN type has all properties, but we do not know whether they are declared or inferred.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 3,
            "reason": "#3# The hasProperty method is unlikely to be the root cause of the test failure. The test failure involves incorrect type inference and propagation for the prototype property across different function contexts, specifically when assigning string values to a.prototype and then expecting Object return types. The hasProperty method only checks property existence and doesn't handle type assignment or type inference logic. The actual bug likely resides in type assignment tracking or type propagation mechanisms elsewhere in the type system."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::attachLiteralTypes(Node)",
            "method_code": "```java\n    private void attachLiteralTypes(Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          n.setJSType(getNativeType(STRING_TYPE));\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null &&\n              info.getLendsName() != null) {\n            if (lentObjectLiterals == null) {\n              lentObjectLiterals = Lists.newArrayList();\n            }\n            lentObjectLiterals.add(n);\n          } else {\n            defineObjectLiteral(n);\n          }\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }\n\n```",
            "method_doc": "Attaches literal types to nodes (e.g., string, number) and handles object literals with @lends by calling defineObjectLiteral.",
            "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
            "class_doc": " Creates the symbol table of variables available in the current scope and their types.  Scopes created by this class are very different from scopes created by the syntactic scope creator. These scopes have type information, and include some qualified names in addition to variables (like Class.staticMethod).  When building scope information, also declares relevant information about types in the type registry.  ",
            "test_failure_causes": "As Software Test Engineer, let me analyze the test failure step by step:\n\n## Analysis of Test Failure\n\n**1. Understanding the Test Behavior:**\n- The test `testIssue1024` contains two test cases for type checking prototype property assignments\n- First test case expects no warnings when assigning string to `a.prototype`\n- Second test case expects a specific warning about type mismatch when assigning object to `a.prototype`\n\n**2. Key Failure Evidence:**\n- **Test Output**: Shows `JSC_TYPE_MISMATCH` error for inconsistent return type\n- **Error Location**: Line 9, where function `g` returns `b.prototype` with `!Object` return type annotation\n- **Specific Error**: Found `string` but required `Object`\n\n**3. Pattern Analysis:**\nThe failure occurs in the first test case where:\n- Function `f` assigns string `'__proto'` to `a.prototype`\n- Function `g` returns `b.prototype` with `!Object` return type annotation\n- The type checker is incorrectly inferring that `b.prototype` has type `string` instead of `Object`\n\n## Recommended Production Code Defect\n\n**Possible Defect in Type Inference System:**\n\nThe type checker is incorrectly propagating the type assignment from `a.prototype = '__proto'` to affect the type inference of `b.prototype` in a different function context. The production code likely has a bug where:\n\n1. **Incorrect Type Propagation**: When `a.prototype` is assigned a string value, the type system is incorrectly updating the type of the `prototype` property for all Object instances globally, rather than treating it as a specific instance assignment.\n\n2. **Missing Context Isolation**: The type inference system fails to maintain proper scope separation between different function contexts, causing type information from one function (`f`) to incorrectly influence type checking in another function (`g`).\n\n3. **Prototype Property Type Tracking**: The code that tracks types for the built-in `prototype` property may be using a shared type registry instead of instance-specific type information.\n\n**Expected Behavior**: Each Object parameter should maintain independent type information for its `prototype` property based on assignments within its own scope, not influenced by assignments to other Object instances.\n\nThis defect would explain why the test fails with a type mismatch warning when it shouldn't produce any warnings for the first test case.",
            "test_suite": "com.google.javascript.jscomp.TypeCheckTest",
            "score": 3,
            "reason": "#3# The attachLiteralTypes method handles basic literal type assignments but doesn't appear to be directly responsible for the prototype property type propagation issue. The failure involves incorrect type inference across function scopes for prototype properties, which is more likely handled in type propagation or scope management logic rather than basic literal type attachment."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.rhino.jstype.JSTypeRegistry::register(JSType,String)": {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::register(JSType,String)",
            "method_code": "```java\n  private void register(JSType type, String name) {\n    Preconditions.checkArgument(\n        !name.contains(\"<\"), \"Type names cannot contain template annotations.\");\n\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }\n\n```",
            "method_doc": "Registers a JSType with a specific name, storing it in the namesToTypes map and updating namespaces."
        },
        "com.google.javascript.rhino.jstype.JSTypeRegistry::resetForTypeCheck()": {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::resetForTypeCheck()",
            "method_code": "```java\n  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }\n\n```",
            "method_doc": " Reset to run the TypeCheck pass. "
        },
        "com.google.javascript.rhino.jstype.JSTypeRegistry::registerPropertyOnType(String,JSType)": {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::registerPropertyOnType(String,JSType)",
            "method_code": "```java\n  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }\n\n```",
            "method_doc": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). "
        },
        "com.google.javascript.rhino.jstype.JSTypeRegistry::initializeBuiltInTypes()": {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::initializeBuiltInTypes()",
            "method_code": "```java\n  private void initializeBuiltInTypes() {\n    objectIndexTemplateKey = new TemplateType(this, OBJECT_INDEX_TEMPLATE);\n    objectElementTemplateKey = new TemplateType(this, OBJECT_ELEMENT_TEMPLATE);\n\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    UnknownType checkedUnknownType = new UnknownType(this, true);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, checkedUnknownType);\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true, null);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null,\n            createTemplateTypeMap(ImmutableList.of(\n                objectIndexTemplateKey, objectElementTemplateKey), null),\n            true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null,\n          createTemplateTypeMap(ImmutableList.of(\n              objectElementTemplateKey), null),\n          true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (null,void)\n    JSType NULL_VOID =\n        createUnionType(NULL_TYPE, VOID_TYPE);\n    registerNativeType(JSTypeNative.NULL_VOID, NULL_VOID);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the Unknown type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            UNKNOWN_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(NO_TYPE, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n        createNativeFunctionTypeWithVarArgs(ALL_TYPE, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }\n\n```",
            "method_doc": "Initializes all built-in JavaScript types (e.g., Boolean, Number, Object, Array) and registers them; this method calls method \"registerNativeType\" for each type and method \"registerPropertyOnType\" for the \"prototype\" property."
        },
        "com.google.javascript.rhino.jstype.JSTypeRegistry::addReferenceTypeIndexedByProperty(String,JSType)": {
            "method_name": "com.google.javascript.rhino.jstype.JSTypeRegistry::addReferenceTypeIndexedByProperty(String,JSType)",
            "method_code": "```java\n  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }\n\n```",
            "method_doc": "Adds reference types (ObjectType or NamedType) to the property index, handling unions recursively."
        },
        "com.google.javascript.rhino.jstype.ObjectType::getSlot(String)": {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::getSlot(String)",
            "method_code": "```java\n  @Override\n  public Property getSlot(String name) {\n    return getPropertyMap().getSlot(name);\n  }\n\n```",
            "method_doc": " Default getSlot implementation. This gets overridden by FunctionType for lazily-resolved prototypes. "
        },
        "com.google.javascript.rhino.jstype.ObjectType::defineDeclaredProperty(String,JSType,Node)": {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::defineDeclaredProperty(String,JSType,Node)",
            "method_code": "```java\n  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false, propertyNode);\n    // All property definitions go through this method\n    // or defineInferredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n    return result;\n  }\n\n```",
            "method_doc": " Defines a property whose type is explicitly declared by the programmer. @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. "
        },
        "com.google.javascript.rhino.jstype.ObjectType::hasProperty(String)": {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::hasProperty(String)",
            "method_code": "```java\n  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isEmptyType() || isUnknownType() || getSlot(propertyName) != null;\n  }\n\n```",
            "method_doc": "Checks if a property exists on this object or its prototype chain. This method calls method \"getSlot\" to verify property existence."
        },
        "com.google.javascript.rhino.jstype.ObjectType::isPropertyTypeDeclared(String)": {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::isPropertyTypeDeclared(String)",
            "method_code": "```java\n  public boolean isPropertyTypeDeclared(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : !slot.isTypeInferred();\n  }\n\n```",
            "method_doc": " Checks whether the property's type is declared. "
        },
        "com.google.javascript.rhino.jstype.ObjectType::isPropertyTypeInferred(String)": {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::isPropertyTypeInferred(String)",
            "method_code": "```java\n  public boolean isPropertyTypeInferred(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    return slot == null ? false : slot.isTypeInferred();\n  }\n\n```",
            "method_doc": " Checks whether the property's type is inferred. "
        },
        "com.google.javascript.rhino.jstype.ObjectType::getPropertyType(String)": {
            "method_name": "com.google.javascript.rhino.jstype.ObjectType::getPropertyType(String)",
            "method_code": "```java\n  public JSType getPropertyType(String propertyName) {\n    StaticSlot<JSType> slot = getSlot(propertyName);\n    if (slot == null) {\n      if (isNoResolvedType() || isCheckedUnknownType()) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n      } else if (isEmptyType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }\n\n```",
            "method_doc": " Gets the property type of the property whose name is given. If the underlying object does not have this property, the Unknown type is returned to indicate that no information is available on this property.  This gets overridden by FunctionType for lazily-resolved call() and bind() functions.  @return the property's type or {@link UnknownType}. This method never returns {@code null}. "
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::isQualifiedNameInferred(String,Node,JSDocInfo,Node,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::isQualifiedNameInferred(String,Node,JSDocInfo,Node,JSType)",
            "method_code": "```java\n    private boolean isQualifiedNameInferred(\n        String TransVarName, Node TransVarNode, JSDocInfo TransVarDocInfo,\n        Node TransVarRhsNode, JSType TransVarType) {\n      if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(TransVarType == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n      }\n\n      // Prototypes of constructors and interfaces are always declared.\n      if (!(!(TransVarName != null && TransVarName.endsWith(\".prototype\")))) {\n          if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n          return false;\n        }\n\n      boolean TransVarInfer = true;\n      if (!(!(TransVarDocInfo != null))) {\n        TransVarInfer = !(TransVarDocInfo.hasType()\n            || TransVarDocInfo.hasEnumParameterType()\n            || (isConstantSymbol(TransVarDocInfo, TransVarNode) && TransVarType != null\n                && !TransVarType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(TransVarDocInfo));\n      }\n\n      if (!(!(TransVarInfer && TransVarRhsNode != null && TransVarRhsNode.isFunction()))) {\n        if (!(!(TransVarDocInfo != null))) {\n          return false;\n        } else if (!(!(!scope.isDeclared(TransVarName, false) && TransVarNode.isUnscopedQualifiedName()))) {\n\n          Node TransVarCurrentNode = TransVarNode.getParent();\n        while (!(!(!(TransVarCurrentNode.isScript() || TransVarCurrentNode.isFunction())))) {\n            if (!(!(NodeUtil.isControlStructure(TransVarCurrentNode)))) {\n              return true;\n            }\n            TransVarCurrentNode = TransVarCurrentNode.getParent();\n          }\n\n          // Check if this is assigned in an inner scope.\n          // Functions assigned in inner scopes are inferred.\n          AstFunctionContents TransVarFunctionContent =\n              getFunctionAnalysisResults(scope.getRootNode());\n          if (!(!(TransVarFunctionContent == null\n                || !TransVarFunctionContent.getEscapedQualifiedNames().contains(TransVarName)))) {\n            return false;\n          }\n        }\n      }\n      return TransVarInfer;\n    }\n\n```",
            "method_doc": " Determines whether a qualified name is inferred. NOTE(nicksantos): Determining whether a property is declared or not is really really obnoxious.  The problem is that there are two (equally valid) coding styles:  (function() { The authoritative definition of goog.bar. / goog.bar = function() {}; })();  function f() { goog.bar(); Reset goog.bar to a no-op. / goog.bar = function() {}; }  In a dynamic language with first-class functions, it's very difficult to know which one the user intended without looking at lots of contextual information (the second example demonstrates a small case of this, but there are some really pathological cases as well).  The current algorithm checks if either the declaration has JsDoc type information, or @const with a known type, or a function literal with a name we haven't seen before. "
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::resolveTypes()": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::resolveTypes()",
            "method_code": "```java\n    @Override\n    public void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }\n\n```",
            "method_doc": "Resolves deferred types and scope variables, and informs the type registry to resolve types in the scope."
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,JSType,boolean)": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,JSType,boolean)",
            "method_code": "```java\n    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualified names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.isName()) {\n        Preconditions.checkArgument(\n            parent.isFunction() ||\n            parent.isVar() ||\n            parent.isParamList() ||\n            parent.isCatch());\n      } else {\n        Preconditions.checkArgument(\n            n.isGetProp() &&\n            (parent.isAssign() ||\n             parent.isExprResult()));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }\n\n```",
            "method_doc": " Defines a typed variable. The defining node will be annotated with the variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is inferred.  Slots may be any variable or any qualified name in the global scope.  @param n the defining NAME or GETPROP node. @param parent the {@code n}'s parent. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. "
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,JSType)",
            "method_code": "```java\n    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }\n\n```",
            "method_doc": " Defines a typed variable. The defining node will be annotated with the variable's type or {@code null} if its type is inferred. @param name the defining node. It must be a {@link Token#NAME}. @param parent the {@code name}'s parent. @param type the variable's type. It may be {@code null}, in which case the variable's type will be inferred. "
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,String,JSType,boolean)": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::defineSlot(Node,Node,String,JSType,boolean)",
            "method_code": "```java\n    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.isName() && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.isVar() ||\n           parent.isFunction());\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.isGetProp() && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // The input may be null if we are working with a AST snippet. So read\n      // the extern info from the node.\n      Var newVar = null;\n\n      // declared in closest scope?\n      CompilerInput input = compiler.getInput(inputId);\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        newVar = validator.expectUndeclaredVariable(\n            sourceName, input, n, parent, oldVar, variableName, type);\n      } else {\n        if (type != null) {\n          setDeferredType(n, type);\n        }\n\n        newVar =\n          scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.isObjectLit() ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n      }\n\n      // We need to do some additional work for constructors and interfaces.\n      FunctionType fnType = JSType.toMaybeFunctionType(type);\n      if (fnType != null &&\n          // We don't want to look at empty function types.\n          !type.isEmptyType()) {\n\n        // We want to make sure that when we declare a new instance type\n        // (with @constructor) that there's actually a ctor for it.\n        // This doesn't apply to structural constructors (like\n        // function(new:Array). Checking the constructed type against\n        // the variable name is a sufficient check for this.\n        if ((fnType.isConstructor() || fnType.isInterface()) &&\n            variableName.equals(fnType.getReferenceName())) {\n          finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn,\n                                      input, newVar);\n        }\n      }\n\n      if (shouldDeclareOnGlobalThis) {\n        ObjectType globalThis =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS);\n        if (inferred) {\n          globalThis.defineInferredProperty(variableName,\n              type == null ?\n              getNativeType(JSTypeNative.NO_TYPE) :\n              type,\n              n);\n        } else {\n          globalThis.defineDeclaredProperty(variableName, type, n);\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type != null\n          && type.isFunctionType()\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType());\n      }\n    }\n\n```",
            "method_doc": " Defines a symbol in the current scope.  @param n the defining NAME or GETPROP or object literal key node. @param parent the {@code n}'s parent. @param variableName The name that this should be known by. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. @param inferred Whether the type is inferred or declared. "
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
            "method_code": "```java\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has JsDoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n\n          qVar.getScope().undeclare(qVar);\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = isQualifiedNameInferred(\n          qName, n, info, rhsValue, valueType);\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        FunctionType ownerFnType = JSType.toMaybeFunctionType(ownerType);\n        if (ownerFnType != null) {\n          JSType ownerTypeOfThis = ownerFnType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n\n```",
            "method_doc": " Declare the symbol for a qualified name in the global scope.  @param info The doc info for this property. @param n A top-level GETPROP node (it should not be contained inside another GETPROP). @param parent The parent of {@code n}. @param rhsValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. "
        },
        "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::attachLiteralTypes(Node)": {
            "method_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder::attachLiteralTypes(Node)",
            "method_code": "```java\n    private void attachLiteralTypes(Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          n.setJSType(getNativeType(STRING_TYPE));\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          JSDocInfo info = n.getJSDocInfo();\n          if (info != null &&\n              info.getLendsName() != null) {\n            if (lentObjectLiterals == null) {\n              lentObjectLiterals = Lists.newArrayList();\n            }\n            lentObjectLiterals.add(n);\n          } else {\n            defineObjectLiteral(n);\n          }\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }\n\n```",
            "method_doc": "Attaches literal types to nodes (e.g., string, number) and handles object literals with @lends by calling defineObjectLiteral."
        },
        "com.google.javascript.jscomp.TypeInference::traverseGetProp(Node,FlowScope)": {
            "method_name": "com.google.javascript.jscomp.TypeInference::traverseGetProp(Node,FlowScope)",
            "method_code": "```java\n  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }\n\n```",
            "method_doc": "Traverses property access nodes, determining property types and dereferencing pointers. This method calls methods \"traverseChildren\", \"getPropertyType\", and \"dereferencePointer\" for child traversal, type resolution, and pointer dereferencing."
        },
        "com.google.javascript.jscomp.TypeInference::getPropertyType(JSType,String,Node,FlowScope)": {
            "method_name": "com.google.javascript.jscomp.TypeInference::getPropertyType(JSType,String,Node,FlowScope)",
            "method_code": "```java\n  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // We often have a couple of different types to choose from for the\n    // property. Ordered by accuracy, we have\n    // 1) A locally inferred qualified name (which is in the FlowScope)\n    // 2) A globally declared qualified name (which is in the FlowScope)\n    // 3) A property on the owner type (which is on objType)\n    // 4) A name in the type registry (as a last resort)\n    JSType propertyType = null;\n    boolean isLocallyInferred = false;\n\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        boolean isDeclared = !var.isTypeInferred();\n        isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));\n        if (isDeclared || isLocallyInferred) {\n          propertyType = varType;\n        }\n      }\n    }\n\n    if (propertyType == null && objType != null) {\n      JSType foundType = objType.findPropertyType(propName);\n      if (foundType != null) {\n        propertyType = foundType;\n      }\n    }\n\n    if (propertyType != null && objType != null) {\n      JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n      if (restrictedObjType.isTemplatizedType()\n          && propertyType.hasAnyTemplateTypes()) {\n        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n            registry, typeMap);\n        propertyType = propertyType.visit(replacer);\n      }\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType())\n        && qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    if (propertyType == null) {\n      return unknownType;\n    } else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {\n      // If the type has been checked in this scope,\n      // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n      return getNativeType(CHECKED_UNKNOWN_TYPE);\n    } else {\n      return propertyType;\n    }\n  }\n\n```",
            "method_doc": "Resolves property types from scope, object type, or registry with template type handling."
        },
        "com.google.javascript.jscomp.TypeInference::updateScopeForTypeChange(FlowScope,Node,JSType,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypeInference::updateScopeForTypeChange(FlowScope,Node,JSType,JSType)",
            "method_code": "```java\n  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n\n```",
            "method_doc": " Updates the scope according to the result of a type change, like an assignment or a type cast. "
        },
        "com.google.javascript.jscomp.TypeInference::ensurePropertyDeclaredHelper(Node,ObjectType)": {
            "method_name": "com.google.javascript.jscomp.TypeInference::ensurePropertyDeclaredHelper(Node,ObjectType)",
            "method_code": "```java\n  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }\n\n```",
            "method_doc": " Declares a property on its owner, if necessary. @return True if a property was declared. "
        },
        "com.google.javascript.jscomp.TypeInference::traverse(Node,FlowScope)": {
            "method_name": "com.google.javascript.jscomp.TypeInference::traverse(Node,FlowScope)",
            "method_code": "```java\n  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.PARAM_LIST:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().isGetProp()) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.RETURN:\n        scope = traverseReturn(n, scope);\n        break;\n\n      case Token.VAR:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n\n      case Token.CAST:\n        scope = traverseChildren(n, scope);\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.hasType()) {\n          n.setJSType(info.getType().evaluate(syntacticScope, registry));\n        }\n        break;\n    }\n\n    return scope;\n  }\n\n```",
            "method_doc": "Dispatches to specific traversal methods based on node type, handling various JavaScript expressions and statements. This method calls multiple traversal methods including \"traverseAssign\", \"traverseName\", \"traverseGetProp\", \"traverseAnd\", \"traverseOr\", \"traverseHook\", \"traverseObjectLiteral\", \"traverseCall\", \"traverseNew\", \"traverseAdd\", \"traverseArrayLiteral\", \"traverseReturn\", \"traverseChildren\", and \"traverseCatch\"."
        },
        "com.google.javascript.jscomp.TypeInference::ensurePropertyDefined(Node,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypeInference::ensurePropertyDefined(Node,JSType)",
            "method_code": "```java\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      // Don't add the property to @struct objects outside a constructor\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        if (!(obj.isThis() &&\n              getJSType(syntacticScope.getRootNode()).isConstructor())) {\n          return;\n        }\n      }\n\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the property.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) || !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(propName, rightType, getprop);\n          }\n        } else if (obj.isThis() &&\n                   getJSType(syntacticScope.getRootNode()).isConstructor()) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        } else {\n          registry.registerPropertyOnType(propName, objectType);\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Defines a property if the property has not been defined yet. "
        }
    }
}