{
    "buggy_classes": [
        "com.google.javascript.jscomp.TypeCheck"
    ],
    "buggy_methods": [
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitName(NodeTraversal,Node,Node)",
            "method_code": "```java\n  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.LP ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }\n\n```",
            "method_doc": " Visits a NAME node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. @return whether the node is typeable or not ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze these test failures systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Common Patterns\n\n### 1. Test Failure Similarities\n\nBoth tests are failing in the type checking system:\n- **testDuplicateLocalVarDecl**: Expected 2 warnings but only received 1\n- **testFunctionArguments13**: Expected a warning but received none\n\n### 2. Common Type Checking Context\n\nBoth tests involve:\n- **Variable type validation**: Checking type compatibility between assignments\n- **Parameter handling**: Dealing with function parameters and their types\n- **Type inference and validation**: The compiler's ability to detect type mismatches\n\n### 3. Stack Trace Analysis\n\nBoth failures occur in the type checking infrastructure:\n- `testDuplicateLocalVarDecl` fails in `testClosureTypesMultipleWarnings` at assertion for expected warning count\n- `testFunctionArguments13` fails in `testTypes` when expecting a warning that wasn't generated\n\n## Recommended Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the type checking system:\n\n### 1. **Type Checker Warning Suppression Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The type checker may be incorrectly suppressing valid warnings in specific scenarios involving:\n- Variable redeclaration with different types\n- Parameter reassignment with incompatible types\n\n### 2. **Variable Scope Resolution Issue**\n**Location**: Scope management in type checking (possibly in `SemanticReverseAbstractInterpreter` or scope resolution logic)\n**Defect**: The system may not be properly distinguishing between parameter scope and local variable scope, causing it to miss type conflicts when the same identifier appears in different scopes.\n\n### 3. **Null Assignment Handling Defect**\n**Location**: Type compatibility checking logic for nullable types\n**Defect**: The type checker may have incorrect logic for handling assignments to non-nullable parameters when the target type is nullable (`?boolean`), potentially allowing null assignments to non-nullable parameters.\n\n### 4. **Warning Generation Filter**\n**Location**: Warning reporting mechanism in the type checking pipeline\n**Defect**: There may be an over-aggressive filter that incorrectly suppresses warnings about type mismatches in parameter reassignment scenarios.\n\nThe common thread is that the type checker is failing to generate expected warnings about type safety violations, suggesting a defect in the warning generation or type validation logic rather than the core type inference itself.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 9,
            "reason": "#8# The visitName method is highly suspicious because it handles variable name resolution and type assignment, which directly relates to both test failures. The method's logic for determining when to type-check names and how it resolves variable types from scope could be incorrectly suppressing warnings for duplicate variable declarations and parameter reassignments, explaining why expected type warnings are not being generated in both failed test cases."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitVar(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n        if (info != null && info.hasEnumParameterType()) {\n          // var.getType() can never be null, this would indicate a bug in the\n          // scope creation logic.\n          checkEnumInitializer(\n              t, value,\n              info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n        } else if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Visits a VAR node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze these test failures systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Common Patterns\n\n### 1. Test Failure Similarities\n\nBoth tests are failing in the type checking system:\n- **testDuplicateLocalVarDecl**: Expected 2 warnings but only received 1\n- **testFunctionArguments13**: Expected a warning but received none\n\n### 2. Common Type Checking Context\n\nBoth tests involve:\n- **Variable type validation**: Checking type compatibility between assignments\n- **Parameter handling**: Dealing with function parameters and their types\n- **Type inference and validation**: The compiler's ability to detect type mismatches\n\n### 3. Stack Trace Analysis\n\nBoth failures occur in the type checking infrastructure:\n- `testDuplicateLocalVarDecl` fails in `testClosureTypesMultipleWarnings` at assertion for expected warning count\n- `testFunctionArguments13` fails in `testTypes` when expecting a warning that wasn't generated\n\n## Recommended Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the type checking system:\n\n### 1. **Type Checker Warning Suppression Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The type checker may be incorrectly suppressing valid warnings in specific scenarios involving:\n- Variable redeclaration with different types\n- Parameter reassignment with incompatible types\n\n### 2. **Variable Scope Resolution Issue**\n**Location**: Scope management in type checking (possibly in `SemanticReverseAbstractInterpreter` or scope resolution logic)\n**Defect**: The system may not be properly distinguishing between parameter scope and local variable scope, causing it to miss type conflicts when the same identifier appears in different scopes.\n\n### 3. **Null Assignment Handling Defect**\n**Location**: Type compatibility checking logic for nullable types\n**Defect**: The type checker may have incorrect logic for handling assignments to non-nullable parameters when the target type is nullable (`?boolean`), potentially allowing null assignments to non-nullable parameters.\n\n### 4. **Warning Generation Filter**\n**Location**: Warning reporting mechanism in the type checking pipeline\n**Defect**: There may be an over-aggressive filter that incorrectly suppresses warnings about type mismatches in parameter reassignment scenarios.\n\nThe common thread is that the type checker is failing to generate expected warnings about type safety violations, suggesting a defect in the warning generation or type validation logic rather than the core type inference itself.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 9,
            "reason": "#8# This method is highly suspicious because it handles variable declaration and initialization type checking, which directly relates to both test failures. The testDuplicateLocalVarDecl involves variable redeclaration with conflicting types, and testFunctionArguments13 involves parameter assignment type validation - both scenarios are processed through visitVar's type assignment logic. The method's current implementation may be incorrectly handling type validation for parameters vs local variables, or failing to generate expected warnings when type mismatches occur during variable initialization."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitAssign(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    if (lvalue.getType() == Token.GETPROP) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      String property = lvalue.getLastChild().getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.getType() == Token.GETPROP) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n        }\n      }\n\n      // /** @type ... */object.name = ...;\n      if (info != null && info.hasType()) {\n        visitAnnotatedAssignGetprop(t, assign,\n            info.getType().evaluate(t.getScope(), typeRegistry), object,\n            property, rvalue);\n        return;\n      }\n\n      // /** @enum ... */object.name = ...;\n      if (info != null && info.hasEnumParameterType()) {\n        checkEnumInitializer(\n            t, rvalue, info.getEnumParameterType().evaluate(\n                t.getScope(), typeRegistry));\n        return;\n      }\n\n      // object.prototype = ...;\n      if (property.equals(\"prototype\")) {\n        if (objectJsType instanceof FunctionType) {\n          FunctionType functionType = (FunctionType) objectJsType;\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n          }\n        } else {\n          // TODO(user): might want to flag that\n        }\n        return;\n      }\n\n      // object.prototype.property = ...;\n      if (object.getType() == Token.GETPROP) {\n        Node object2 = object.getFirstChild();\n        String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n        if (\"prototype\".equals(property2)) {\n          JSType jsType = object2.getJSType();\n          if (jsType instanceof FunctionType) {\n            FunctionType functionType = (FunctionType) jsType;\n            if (functionType.isConstructor() || functionType.isInterface()) {\n              checkDeclaredPropertyInheritance(\n                  t, assign, functionType, property, info, getJSType(rvalue));\n            }\n          } else {\n            // TODO(user): might want to flag that\n          }\n          return;\n        }\n      }\n\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(property) &&\n            !type.isPropertyTypeInferred(property) &&\n            !propertyIsImplicitCast(type, property)) {\n          validator.expectCanAssignToPropertyOf(\n              t, assign, getJSType(rvalue),\n              type.getPropertyType(property), object, property);\n        }\n        return;\n      }\n    } else if (lvalue.getType() == Token.NAME) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getString());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n      }\n    }\n\n    // fall through case\n    JSType leftType = getJSType(lvalue);\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n\n```",
            "method_doc": " Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to. @param t the traversal @param assign the assign node (<code>assign.getType() == Token.ASSIGN</code> is an implicit invariant) ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze these test failures systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Common Patterns\n\n### 1. Test Failure Similarities\n\nBoth tests are failing in the type checking system:\n- **testDuplicateLocalVarDecl**: Expected 2 warnings but only received 1\n- **testFunctionArguments13**: Expected a warning but received none\n\n### 2. Common Type Checking Context\n\nBoth tests involve:\n- **Variable type validation**: Checking type compatibility between assignments\n- **Parameter handling**: Dealing with function parameters and their types\n- **Type inference and validation**: The compiler's ability to detect type mismatches\n\n### 3. Stack Trace Analysis\n\nBoth failures occur in the type checking infrastructure:\n- `testDuplicateLocalVarDecl` fails in `testClosureTypesMultipleWarnings` at assertion for expected warning count\n- `testFunctionArguments13` fails in `testTypes` when expecting a warning that wasn't generated\n\n## Recommended Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the type checking system:\n\n### 1. **Type Checker Warning Suppression Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The type checker may be incorrectly suppressing valid warnings in specific scenarios involving:\n- Variable redeclaration with different types\n- Parameter reassignment with incompatible types\n\n### 2. **Variable Scope Resolution Issue**\n**Location**: Scope management in type checking (possibly in `SemanticReverseAbstractInterpreter` or scope resolution logic)\n**Defect**: The system may not be properly distinguishing between parameter scope and local variable scope, causing it to miss type conflicts when the same identifier appears in different scopes.\n\n### 3. **Null Assignment Handling Defect**\n**Location**: Type compatibility checking logic for nullable types\n**Defect**: The type checker may have incorrect logic for handling assignments to non-nullable parameters when the target type is nullable (`?boolean`), potentially allowing null assignments to non-nullable parameters.\n\n### 4. **Warning Generation Filter**\n**Location**: Warning reporting mechanism in the type checking pipeline\n**Defect**: There may be an over-aggressive filter that incorrectly suppresses warnings about type mismatches in parameter reassignment scenarios.\n\nThe common thread is that the type checker is failing to generate expected warnings about type safety violations, suggesting a defect in the warning generation or type validation logic rather than the core type inference itself.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 9,
            "reason": "#8# This method is highly suspicious because it handles assignment operations and type checking, which directly relates to both test failures. The testDuplicateLocalVarDecl involves variable redeclaration with type conflicts, and testFunctionArguments13 involves parameter assignment with incompatible types. The method contains logic for handling NAME assignments and type validation, but appears to have early returns that might prevent proper type checking in certain scenarios, particularly when dealing with inferred types or scope resolution issues that could explain why expected warnings are not being generated."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)",
            "method_code": "```java\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n```",
            "method_doc": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze these test failures systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Common Patterns\n\n### 1. Test Failure Similarities\n\nBoth tests are failing in the type checking system:\n- **testDuplicateLocalVarDecl**: Expected 2 warnings but only received 1\n- **testFunctionArguments13**: Expected a warning but received none\n\n### 2. Common Type Checking Context\n\nBoth tests involve:\n- **Variable type validation**: Checking type compatibility between assignments\n- **Parameter handling**: Dealing with function parameters and their types\n- **Type inference and validation**: The compiler's ability to detect type mismatches\n\n### 3. Stack Trace Analysis\n\nBoth failures occur in the type checking infrastructure:\n- `testDuplicateLocalVarDecl` fails in `testClosureTypesMultipleWarnings` at assertion for expected warning count\n- `testFunctionArguments13` fails in `testTypes` when expecting a warning that wasn't generated\n\n## Recommended Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the type checking system:\n\n### 1. **Type Checker Warning Suppression Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The type checker may be incorrectly suppressing valid warnings in specific scenarios involving:\n- Variable redeclaration with different types\n- Parameter reassignment with incompatible types\n\n### 2. **Variable Scope Resolution Issue**\n**Location**: Scope management in type checking (possibly in `SemanticReverseAbstractInterpreter` or scope resolution logic)\n**Defect**: The system may not be properly distinguishing between parameter scope and local variable scope, causing it to miss type conflicts when the same identifier appears in different scopes.\n\n### 3. **Null Assignment Handling Defect**\n**Location**: Type compatibility checking logic for nullable types\n**Defect**: The type checker may have incorrect logic for handling assignments to non-nullable parameters when the target type is nullable (`?boolean`), potentially allowing null assignments to non-nullable parameters.\n\n### 4. **Warning Generation Filter**\n**Location**: Warning reporting mechanism in the type checking pipeline\n**Defect**: There may be an over-aggressive filter that incorrectly suppresses warnings about type mismatches in parameter reassignment scenarios.\n\nThe common thread is that the type checker is failing to generate expected warnings about type safety violations, suggesting a defect in the warning generation or type validation logic rather than the core type inference itself.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 8,
            "reason": "#8# This method is highly suspicious because it handles type assignment and validation logic, and both test failures involve missing type warnings - testDuplicateLocalVarDecl expects 2 warnings but gets 1, and testFunctionArguments13 expects a warning but gets none. The ensureTyped method contains type casting validation and error reporting logic that could be incorrectly suppressing warnings, particularly in the validator.expectCanCast call and the conditional type assignment logic that may not properly handle variable redeclaration type conflicts or parameter reassignment type mismatches."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze these test failures systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Common Patterns\n\n### 1. Test Failure Similarities\n\nBoth tests are failing in the type checking system:\n- **testDuplicateLocalVarDecl**: Expected 2 warnings but only received 1\n- **testFunctionArguments13**: Expected a warning but received none\n\n### 2. Common Type Checking Context\n\nBoth tests involve:\n- **Variable type validation**: Checking type compatibility between assignments\n- **Parameter handling**: Dealing with function parameters and their types\n- **Type inference and validation**: The compiler's ability to detect type mismatches\n\n### 3. Stack Trace Analysis\n\nBoth failures occur in the type checking infrastructure:\n- `testDuplicateLocalVarDecl` fails in `testClosureTypesMultipleWarnings` at assertion for expected warning count\n- `testFunctionArguments13` fails in `testTypes` when expecting a warning that wasn't generated\n\n## Recommended Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the type checking system:\n\n### 1. **Type Checker Warning Suppression Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The type checker may be incorrectly suppressing valid warnings in specific scenarios involving:\n- Variable redeclaration with different types\n- Parameter reassignment with incompatible types\n\n### 2. **Variable Scope Resolution Issue**\n**Location**: Scope management in type checking (possibly in `SemanticReverseAbstractInterpreter` or scope resolution logic)\n**Defect**: The system may not be properly distinguishing between parameter scope and local variable scope, causing it to miss type conflicts when the same identifier appears in different scopes.\n\n### 3. **Null Assignment Handling Defect**\n**Location**: Type compatibility checking logic for nullable types\n**Defect**: The type checker may have incorrect logic for handling assignments to non-nullable parameters when the target type is nullable (`?boolean`), potentially allowing null assignments to non-nullable parameters.\n\n### 4. **Warning Generation Filter**\n**Location**: Warning reporting mechanism in the type checking pipeline\n**Defect**: There may be an over-aggressive filter that incorrectly suppresses warnings about type mismatches in parameter reassignment scenarios.\n\nThe common thread is that the type checker is failing to generate expected warnings about type safety violations, suggesting a defect in the warning generation or type validation logic rather than the core type inference itself.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 8,
            "reason": "#8# The visit method is highly suspicious as it's the core type checking logic that handles all AST nodes. Both test failures involve type checking scenarios (variable redeclaration and parameter assignment) that are processed through this method's switch statement. The VAR token case calls visitVar which likely handles variable declarations, and the ASSIGN token case calls visitAssign which handles assignments - both directly relevant to the test failures where type warnings are missing."
        },
        {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitReturn(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitReturn(NodeTraversal t, Node n) {\n    Node function = t.getEnclosingFunction();\n\n    // This is a misplaced return, but the real JS will fail to compile,\n    // so let it go.\n    if (function == null) {\n      return;\n    }\n    JSType jsType = getJSType(function);\n\n    if (jsType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) jsType;\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n          \"inconsistent return type\");\n    }\n  }\n\n```",
            "method_doc": " Visits a RETURN node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
            "class_name": "com.google.javascript.jscomp.TypeCheck",
            "class_doc": " <p>Checks the types of JS expressions against any declared type information.</p>  ",
            "test_failure_causes": "As a Software Test Engineer at DebugDev, I'll analyze these test failures systematically to identify the common patterns and recommend possible defects in the production code.\n\n## Analysis of Common Patterns\n\n### 1. Test Failure Similarities\n\nBoth tests are failing in the type checking system:\n- **testDuplicateLocalVarDecl**: Expected 2 warnings but only received 1\n- **testFunctionArguments13**: Expected a warning but received none\n\n### 2. Common Type Checking Context\n\nBoth tests involve:\n- **Variable type validation**: Checking type compatibility between assignments\n- **Parameter handling**: Dealing with function parameters and their types\n- **Type inference and validation**: The compiler's ability to detect type mismatches\n\n### 3. Stack Trace Analysis\n\nBoth failures occur in the type checking infrastructure:\n- `testDuplicateLocalVarDecl` fails in `testClosureTypesMultipleWarnings` at assertion for expected warning count\n- `testFunctionArguments13` fails in `testTypes` when expecting a warning that wasn't generated\n\n## Recommended Possible Defects in Production Code\n\nBased on the analysis, I recommend investigating these potential defects in the type checking system:\n\n### 1. **Type Checker Warning Suppression Logic**\n**Location**: Likely in `TypeCheck` class or related type validation components\n**Defect**: The type checker may be incorrectly suppressing valid warnings in specific scenarios involving:\n- Variable redeclaration with different types\n- Parameter reassignment with incompatible types\n\n### 2. **Variable Scope Resolution Issue**\n**Location**: Scope management in type checking (possibly in `SemanticReverseAbstractInterpreter` or scope resolution logic)\n**Defect**: The system may not be properly distinguishing between parameter scope and local variable scope, causing it to miss type conflicts when the same identifier appears in different scopes.\n\n### 3. **Null Assignment Handling Defect**\n**Location**: Type compatibility checking logic for nullable types\n**Defect**: The type checker may have incorrect logic for handling assignments to non-nullable parameters when the target type is nullable (`?boolean`), potentially allowing null assignments to non-nullable parameters.\n\n### 4. **Warning Generation Filter**\n**Location**: Warning reporting mechanism in the type checking pipeline\n**Defect**: There may be an over-aggressive filter that incorrectly suppresses warnings about type mismatches in parameter reassignment scenarios.\n\nThe common thread is that the type checker is failing to generate expected warnings about type safety violations, suggesting a defect in the warning generation or type validation logic rather than the core type inference itself.",
            "test_suite": "com.google.javascript.jscomp.LooseTypeCheckTest",
            "score": 3,
            "reason": "#3# The visitReturn method handles return type validation, but the test failures involve variable redeclaration warnings and parameter assignment type checking, which are unrelated to return statement processing. The method focuses on verifying return type consistency, while the failing tests deal with duplicate variable declarations and parameter reassignment type warnings."
        }
    ],
    "buggy_codes": {
        "com.google.javascript.jscomp.TypeCheck::visitName(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitName(NodeTraversal,Node,Node)",
            "method_code": "```java\n  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.LP ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }\n\n```",
            "method_doc": " Visits a NAME node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. @return whether the node is typeable or not "
        },
        "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::ensureTyped(NodeTraversal,Node,JSType)",
            "method_code": "```java\n  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }\n\n```",
            "method_doc": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. "
        },
        "com.google.javascript.jscomp.TypeCheck::visitVar(NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitVar(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n        if (info != null && info.hasEnumParameterType()) {\n          // var.getType() can never be null, this would indicate a bug in the\n          // scope creation logic.\n          checkEnumInitializer(\n              t, value,\n              info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n        } else if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }\n\n```",
            "method_doc": " Visits a VAR node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. "
        },
        "com.google.javascript.jscomp.TypeCheck::visitAssign(NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitAssign(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    if (lvalue.getType() == Token.GETPROP) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      String property = lvalue.getLastChild().getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.getType() == Token.GETPROP) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n        }\n      }\n\n      // /** @type ... */object.name = ...;\n      if (info != null && info.hasType()) {\n        visitAnnotatedAssignGetprop(t, assign,\n            info.getType().evaluate(t.getScope(), typeRegistry), object,\n            property, rvalue);\n        return;\n      }\n\n      // /** @enum ... */object.name = ...;\n      if (info != null && info.hasEnumParameterType()) {\n        checkEnumInitializer(\n            t, rvalue, info.getEnumParameterType().evaluate(\n                t.getScope(), typeRegistry));\n        return;\n      }\n\n      // object.prototype = ...;\n      if (property.equals(\"prototype\")) {\n        if (objectJsType instanceof FunctionType) {\n          FunctionType functionType = (FunctionType) objectJsType;\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n          }\n        } else {\n          // TODO(user): might want to flag that\n        }\n        return;\n      }\n\n      // object.prototype.property = ...;\n      if (object.getType() == Token.GETPROP) {\n        Node object2 = object.getFirstChild();\n        String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n        if (\"prototype\".equals(property2)) {\n          JSType jsType = object2.getJSType();\n          if (jsType instanceof FunctionType) {\n            FunctionType functionType = (FunctionType) jsType;\n            if (functionType.isConstructor() || functionType.isInterface()) {\n              checkDeclaredPropertyInheritance(\n                  t, assign, functionType, property, info, getJSType(rvalue));\n            }\n          } else {\n            // TODO(user): might want to flag that\n          }\n          return;\n        }\n      }\n\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(property) &&\n            !type.isPropertyTypeInferred(property) &&\n            !propertyIsImplicitCast(type, property)) {\n          validator.expectCanAssignToPropertyOf(\n              t, assign, getJSType(rvalue),\n              type.getPropertyType(property), object, property);\n        }\n        return;\n      }\n    } else if (lvalue.getType() == Token.NAME) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getString());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n      }\n    }\n\n    // fall through case\n    JSType leftType = getJSType(lvalue);\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }\n\n```",
            "method_doc": " Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to. @param t the traversal @param assign the assign node (<code>assign.getType() == Token.ASSIGN</code> is an implicit invariant) "
        },
        "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visit(NodeTraversal,Node,Node)",
            "method_code": "```java\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          report(t, n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }\n\n```",
            "method_doc": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. "
        },
        "com.google.javascript.jscomp.TypeCheck::visitReturn(NodeTraversal,Node)": {
            "method_name": "com.google.javascript.jscomp.TypeCheck::visitReturn(NodeTraversal,Node)",
            "method_code": "```java\n  private void visitReturn(NodeTraversal t, Node n) {\n    Node function = t.getEnclosingFunction();\n\n    // This is a misplaced return, but the real JS will fail to compile,\n    // so let it go.\n    if (function == null) {\n      return;\n    }\n    JSType jsType = getJSType(function);\n\n    if (jsType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) jsType;\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType,\n          \"inconsistent return type\");\n    }\n  }\n\n```",
            "method_doc": " Visits a RETURN node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. "
        }
    }
}