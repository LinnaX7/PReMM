{
    "buggy_classes": [
        "org.jsoup.parser.TokenQueue"
    ],
    "buggy_methods": [
        {
            "method_name": "org.jsoup.parser.TokenQueue::consumeAttributeKey()",
            "method_code": "```java\n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n```",
            "method_doc": " Consume an attribute key off the queue (letter, digit, -, _, :\") @return attribute key ",
            "class_name": "org.jsoup.parser.TokenQueue",
            "class_doc": " A character queue with parsing helpers.  ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I need to analyze this systematically.\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows:\n- **Exception**: `StringIndexOutOfBoundsException: String index out of range: 14`\n- **Location**: `String.charAt(String.java:658)`\n- **Call chain**: `TokenQueue.consume()` \u2192 `Parser.parseAttribute()` \u2192 `Parser.parseStartTag()`\n\nThe error occurs when trying to access character at index 14 in a string, but the string doesn't have that many characters.\n\n## Step 2: Examine the Test Input and Expected Behavior\n\nThe test input that causes the failure is: `\"<p =a>One<a =a\"`\n\nLooking at the test behavior description:\n- The parser encounters malformed attributes starting with `=` directly after tag names\n- The expected behavior is to ignore malformed attributes and continue parsing\n- The parser should handle incomplete tags and malformed syntax gracefully\n\n## Step 3: Identify the Common Pattern\n\nThe common issue across all test scenarios is **malformed attribute syntax**:\n- `\"<p =a>\"` - attribute starts with `=` without attribute name\n- `\"<a =a\"` - similar malformed attribute, incomplete tag\n- `\"<p .....\"` - invalid attribute characters\n- `\"<p .....<p!!\"` - mixed malformed content\n\n## Step 4: Locate the Root Cause in Production Code\n\nBased on the stack trace, the failure occurs in:\n1. `TokenQueue.consume()` at line 162\n2. Called by `Parser.parseAttribute()` at line 214\n3. During `Parser.parseStartTag()` at line 139\n\nThe issue appears to be in the **attribute parsing logic** where the code doesn't properly handle malformed attributes that start with `=` or contain invalid characters. The parser is trying to consume more characters than available when encountering these edge cases.\n\n## Recommended Possible Defect in Production Code:\n\n**The attribute parsing logic in `Parser.parseAttribute()` (line 214) and the character consumption in `TokenQueue.consume()` (line 162) lacks proper bounds checking when processing malformed attribute syntax that starts with `=` or contains sequences of special characters.**\n\nSpecifically, the defect likely involves:\n- Insufficient validation of attribute name boundaries when encountering `=` as the first character after tag name\n- Failure to handle cases where attribute names are missing but the `=` character is present\n- Inadequate error recovery when parsing attribute names that don't conform to HTML syntax rules\n\nThe parser should detect these malformed attributes early and skip them without attempting to parse them as valid attributes, thus avoiding the string index out of bounds exception.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 8,
            "reason": "#8# The consumeAttributeKey() method is highly suspicious because it doesn't properly handle malformed attributes that start with '=' or contain invalid characters. The method consumes characters without bounds checking when encountering sequences like \"=a\" or \".....\" after tag names, which can lead to StringIndexOutOfBoundsException when the queue is exhausted. The method should validate that it's actually consuming valid attribute key characters and stop when encountering invalid syntax."
        },
        {
            "method_name": "org.jsoup.parser.TokenQueue::consume()",
            "method_code": "```java\n    public Character consume() {\n        Character c = queue.charAt(pos);\n        pos++;\n        return c;\n    }\n\n```",
            "method_doc": " Consume one character off queue. @return first character on queue. ",
            "class_name": "org.jsoup.parser.TokenQueue",
            "class_doc": " A character queue with parsing helpers.  ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I need to analyze this systematically.\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows:\n- **Exception**: `StringIndexOutOfBoundsException: String index out of range: 14`\n- **Location**: `String.charAt(String.java:658)`\n- **Call chain**: `TokenQueue.consume()` \u2192 `Parser.parseAttribute()` \u2192 `Parser.parseStartTag()`\n\nThe error occurs when trying to access character at index 14 in a string, but the string doesn't have that many characters.\n\n## Step 2: Examine the Test Input and Expected Behavior\n\nThe test input that causes the failure is: `\"<p =a>One<a =a\"`\n\nLooking at the test behavior description:\n- The parser encounters malformed attributes starting with `=` directly after tag names\n- The expected behavior is to ignore malformed attributes and continue parsing\n- The parser should handle incomplete tags and malformed syntax gracefully\n\n## Step 3: Identify the Common Pattern\n\nThe common issue across all test scenarios is **malformed attribute syntax**:\n- `\"<p =a>\"` - attribute starts with `=` without attribute name\n- `\"<a =a\"` - similar malformed attribute, incomplete tag\n- `\"<p .....\"` - invalid attribute characters\n- `\"<p .....<p!!\"` - mixed malformed content\n\n## Step 4: Locate the Root Cause in Production Code\n\nBased on the stack trace, the failure occurs in:\n1. `TokenQueue.consume()` at line 162\n2. Called by `Parser.parseAttribute()` at line 214\n3. During `Parser.parseStartTag()` at line 139\n\nThe issue appears to be in the **attribute parsing logic** where the code doesn't properly handle malformed attributes that start with `=` or contain invalid characters. The parser is trying to consume more characters than available when encountering these edge cases.\n\n## Recommended Possible Defect in Production Code:\n\n**The attribute parsing logic in `Parser.parseAttribute()` (line 214) and the character consumption in `TokenQueue.consume()` (line 162) lacks proper bounds checking when processing malformed attribute syntax that starts with `=` or contains sequences of special characters.**\n\nSpecifically, the defect likely involves:\n- Insufficient validation of attribute name boundaries when encountering `=` as the first character after tag name\n- Failure to handle cases where attribute names are missing but the `=` character is present\n- Inadequate error recovery when parsing attribute names that don't conform to HTML syntax rules\n\nThe parser should detect these malformed attributes early and skip them without attempting to parse them as valid attributes, thus avoiding the string index out of bounds exception.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 3,
            "reason": "#3# The consume() method itself is simple and correct - it just returns the character at current position and increments. The real issue is in the calling code (Parser.parseAttribute) that doesn't properly validate bounds before calling consume() when processing malformed attributes starting with \"=\"."
        },
        {
            "method_name": "org.jsoup.parser.TokenQueue::consumeTagName()",
            "method_code": "```java\n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n```",
            "method_doc": " Consume an tag name off the queue (word or :, _, -)  @return tag name ",
            "class_name": "org.jsoup.parser.TokenQueue",
            "class_doc": " A character queue with parsing helpers.  ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I need to analyze this systematically.\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows:\n- **Exception**: `StringIndexOutOfBoundsException: String index out of range: 14`\n- **Location**: `String.charAt(String.java:658)`\n- **Call chain**: `TokenQueue.consume()` \u2192 `Parser.parseAttribute()` \u2192 `Parser.parseStartTag()`\n\nThe error occurs when trying to access character at index 14 in a string, but the string doesn't have that many characters.\n\n## Step 2: Examine the Test Input and Expected Behavior\n\nThe test input that causes the failure is: `\"<p =a>One<a =a\"`\n\nLooking at the test behavior description:\n- The parser encounters malformed attributes starting with `=` directly after tag names\n- The expected behavior is to ignore malformed attributes and continue parsing\n- The parser should handle incomplete tags and malformed syntax gracefully\n\n## Step 3: Identify the Common Pattern\n\nThe common issue across all test scenarios is **malformed attribute syntax**:\n- `\"<p =a>\"` - attribute starts with `=` without attribute name\n- `\"<a =a\"` - similar malformed attribute, incomplete tag\n- `\"<p .....\"` - invalid attribute characters\n- `\"<p .....<p!!\"` - mixed malformed content\n\n## Step 4: Locate the Root Cause in Production Code\n\nBased on the stack trace, the failure occurs in:\n1. `TokenQueue.consume()` at line 162\n2. Called by `Parser.parseAttribute()` at line 214\n3. During `Parser.parseStartTag()` at line 139\n\nThe issue appears to be in the **attribute parsing logic** where the code doesn't properly handle malformed attributes that start with `=` or contain invalid characters. The parser is trying to consume more characters than available when encountering these edge cases.\n\n## Recommended Possible Defect in Production Code:\n\n**The attribute parsing logic in `Parser.parseAttribute()` (line 214) and the character consumption in `TokenQueue.consume()` (line 162) lacks proper bounds checking when processing malformed attribute syntax that starts with `=` or contains sequences of special characters.**\n\nSpecifically, the defect likely involves:\n- Insufficient validation of attribute name boundaries when encountering `=` as the first character after tag name\n- Failure to handle cases where attribute names are missing but the `=` character is present\n- Inadequate error recovery when parsing attribute names that don't conform to HTML syntax rules\n\nThe parser should detect these malformed attributes early and skip them without attempting to parse them as valid attributes, thus avoiding the string index out of bounds exception.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 3,
            "reason": "#3# While the consumeTagName() method handles tag name parsing, the actual failure occurs during attribute parsing in Parser.parseAttribute() when trying to consume characters beyond the string bounds. The consumeTagName() method itself has proper bounds checking with isEmpty() and only consumes valid tag name characters, making it unlikely to be the direct cause of the StringIndexOutOfBoundsException."
        },
        {
            "method_name": "org.jsoup.parser.TokenQueue::remainingLength()",
            "method_code": "```java\n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n```",
            "method_doc": "Calculates the number of remaining characters in the queue by comparing queue length and current position.",
            "class_name": "org.jsoup.parser.TokenQueue",
            "class_doc": " A character queue with parsing helpers.  ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I need to analyze this systematically.\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows:\n- **Exception**: `StringIndexOutOfBoundsException: String index out of range: 14`\n- **Location**: `String.charAt(String.java:658)`\n- **Call chain**: `TokenQueue.consume()` \u2192 `Parser.parseAttribute()` \u2192 `Parser.parseStartTag()`\n\nThe error occurs when trying to access character at index 14 in a string, but the string doesn't have that many characters.\n\n## Step 2: Examine the Test Input and Expected Behavior\n\nThe test input that causes the failure is: `\"<p =a>One<a =a\"`\n\nLooking at the test behavior description:\n- The parser encounters malformed attributes starting with `=` directly after tag names\n- The expected behavior is to ignore malformed attributes and continue parsing\n- The parser should handle incomplete tags and malformed syntax gracefully\n\n## Step 3: Identify the Common Pattern\n\nThe common issue across all test scenarios is **malformed attribute syntax**:\n- `\"<p =a>\"` - attribute starts with `=` without attribute name\n- `\"<a =a\"` - similar malformed attribute, incomplete tag\n- `\"<p .....\"` - invalid attribute characters\n- `\"<p .....<p!!\"` - mixed malformed content\n\n## Step 4: Locate the Root Cause in Production Code\n\nBased on the stack trace, the failure occurs in:\n1. `TokenQueue.consume()` at line 162\n2. Called by `Parser.parseAttribute()` at line 214\n3. During `Parser.parseStartTag()` at line 139\n\nThe issue appears to be in the **attribute parsing logic** where the code doesn't properly handle malformed attributes that start with `=` or contain invalid characters. The parser is trying to consume more characters than available when encountering these edge cases.\n\n## Recommended Possible Defect in Production Code:\n\n**The attribute parsing logic in `Parser.parseAttribute()` (line 214) and the character consumption in `TokenQueue.consume()` (line 162) lacks proper bounds checking when processing malformed attribute syntax that starts with `=` or contains sequences of special characters.**\n\nSpecifically, the defect likely involves:\n- Insufficient validation of attribute name boundaries when encountering `=` as the first character after tag name\n- Failure to handle cases where attribute names are missing but the `=` character is present\n- Inadequate error recovery when parsing attribute names that don't conform to HTML syntax rules\n\nThe parser should detect these malformed attributes early and skip them without attempting to parse them as valid attributes, thus avoiding the string index out of bounds exception.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 2,
            "reason": "#2# The remainingLength() method is not the best location to fix because it's a simple calculation that correctly returns the difference between queue length and current position. The actual issue is in the parsing logic that consumes characters without properly checking bounds before accessing them, particularly in the consume() method at line 162 where the StringIndexOutOfBoundsException occurs."
        },
        {
            "method_name": "org.jsoup.parser.TokenQueue::isEmpty()",
            "method_code": "```java\n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n\n```",
            "method_doc": " Is the queue empty? @return true if no data left in queue. ",
            "class_name": "org.jsoup.parser.TokenQueue",
            "class_doc": " A character queue with parsing helpers.  ",
            "test_failure_causes": "Looking at the failed test and the stack trace, I need to analyze this systematically.\n\n## Step 1: Analyze the Stack Trace Pattern\n\nThe stack trace shows:\n- **Exception**: `StringIndexOutOfBoundsException: String index out of range: 14`\n- **Location**: `String.charAt(String.java:658)`\n- **Call chain**: `TokenQueue.consume()` \u2192 `Parser.parseAttribute()` \u2192 `Parser.parseStartTag()`\n\nThe error occurs when trying to access character at index 14 in a string, but the string doesn't have that many characters.\n\n## Step 2: Examine the Test Input and Expected Behavior\n\nThe test input that causes the failure is: `\"<p =a>One<a =a\"`\n\nLooking at the test behavior description:\n- The parser encounters malformed attributes starting with `=` directly after tag names\n- The expected behavior is to ignore malformed attributes and continue parsing\n- The parser should handle incomplete tags and malformed syntax gracefully\n\n## Step 3: Identify the Common Pattern\n\nThe common issue across all test scenarios is **malformed attribute syntax**:\n- `\"<p =a>\"` - attribute starts with `=` without attribute name\n- `\"<a =a\"` - similar malformed attribute, incomplete tag\n- `\"<p .....\"` - invalid attribute characters\n- `\"<p .....<p!!\"` - mixed malformed content\n\n## Step 4: Locate the Root Cause in Production Code\n\nBased on the stack trace, the failure occurs in:\n1. `TokenQueue.consume()` at line 162\n2. Called by `Parser.parseAttribute()` at line 214\n3. During `Parser.parseStartTag()` at line 139\n\nThe issue appears to be in the **attribute parsing logic** where the code doesn't properly handle malformed attributes that start with `=` or contain invalid characters. The parser is trying to consume more characters than available when encountering these edge cases.\n\n## Recommended Possible Defect in Production Code:\n\n**The attribute parsing logic in `Parser.parseAttribute()` (line 214) and the character consumption in `TokenQueue.consume()` (line 162) lacks proper bounds checking when processing malformed attribute syntax that starts with `=` or contains sequences of special characters.**\n\nSpecifically, the defect likely involves:\n- Insufficient validation of attribute name boundaries when encountering `=` as the first character after tag name\n- Failure to handle cases where attribute names are missing but the `=` character is present\n- Inadequate error recovery when parsing attribute names that don't conform to HTML syntax rules\n\nThe parser should detect these malformed attributes early and skip them without attempting to parse them as valid attributes, thus avoiding the string index out of bounds exception.",
            "test_suite": "org.jsoup.parser.ParserTest",
            "score": 2,
            "reason": "#2# The isEmpty() method simply checks if remaining characters equal zero and is unlikely to cause StringIndexOutOfBoundsException; the real issue is in consume() method where bounds checking is insufficient when parsing malformed attributes"
        }
    ],
    "buggy_codes": {
        "org.jsoup.parser.TokenQueue::consume()": {
            "method_name": "org.jsoup.parser.TokenQueue::consume()",
            "method_code": "```java\n    public Character consume() {\n        Character c = queue.charAt(pos);\n        pos++;\n        return c;\n    }\n\n```",
            "method_doc": " Consume one character off queue. @return first character on queue. "
        },
        "org.jsoup.parser.TokenQueue::remainingLength()": {
            "method_name": "org.jsoup.parser.TokenQueue::remainingLength()",
            "method_code": "```java\n    private int remainingLength() {\n        return queue.length() - pos;\n    }\n\n```",
            "method_doc": "Calculates the number of remaining characters in the queue by comparing queue length and current position."
        },
        "org.jsoup.parser.TokenQueue::consumeAttributeKey()": {
            "method_name": "org.jsoup.parser.TokenQueue::consumeAttributeKey()",
            "method_code": "```java\n    public String consumeAttributeKey() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n```",
            "method_doc": " Consume an attribute key off the queue (letter, digit, -, _, :\") @return attribute key "
        },
        "org.jsoup.parser.TokenQueue::isEmpty()": {
            "method_name": "org.jsoup.parser.TokenQueue::isEmpty()",
            "method_code": "```java\n    public boolean isEmpty() {\n        return remainingLength() == 0;\n    }\n\n```",
            "method_doc": " Is the queue empty? @return true if no data left in queue. "
        },
        "org.jsoup.parser.TokenQueue::consumeTagName()": {
            "method_name": "org.jsoup.parser.TokenQueue::consumeTagName()",
            "method_code": "```java\n    public String consumeTagName() {\n        int start = pos;\n        while (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\n            pos++;\n        \n        return queue.substring(start, pos);\n    }\n\n```",
            "method_doc": " Consume an tag name off the queue (word or :, _, -)  @return tag name "
        }
    }
}