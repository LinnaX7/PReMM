{
    "buggy_classes": [
        "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer"
    ],
    "buggy_methods": [
        {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::addName(String,int[],int)",
            "method_code": "```java\n    public String addName(String name, int[] q, int qlen)\n    {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        // plus add the actual String\n        _names[offset >> 2] = name;\n\n        // and finally; see if we really should rehash.\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n```",
            "method_doc": "Method that adds a new symbol name to the table, calling methods \"_verifySharing()\", \"_findOffsetForAdd(int)\", and \"_verifyNeedForRehash()\" for table management and rehash verification.",
            "class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
            "class_doc": " Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized memory access due to flattening of name quad data. Performance improvement modest for simple JSON document data binding (maybe 3%), but should help more for larger symbol tables, or for binary formats like Smile.  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe test `testSymbolTableExpansionBytes` fails with an `ArrayIndexOutOfBoundsException: 512` at:\n- `ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:824)`\n- During symbol table expansion when parsing byte-based JSON input\n\n## Step 2: Identify Key Characteristics\n\n1. **Failure Context**: The test executes 200 iterations, each creating unique field names to force symbol table expansion\n2. **Specific Trigger**: The failure occurs in `ByteQuadsCanonicalizer.addName()` method\n3. **Array Bound**: The index 512 suggests a fixed-size array boundary being exceeded\n4. **Input Type**: The failure specifically occurs with byte-based parsing (`useBytes = true`)\n\n## Step 3: Root Cause Analysis\n\nThe `ArrayIndexOutOfBoundsException` at index 512 in `ByteQuadsCanonicalizer.addName()` indicates:\n\n1. **Symbol Table Capacity Issue**: The `ByteQuadsCanonicalizer` likely uses a hash table with a fixed initial capacity that doesn't properly handle expansion\n2. **Hash Table Implementation**: The number 512 suggests the internal hash table has a capacity of 512 entries (power of 2), and the expansion logic is failing\n3. **Byte-Specific Bug**: Since this only fails with byte-based parsing, there may be a difference in how the symbol table handles byte vs char input during expansion\n\n## Step 4: Recommended Possible Defect\n\n**Possible Defect in `ByteQuadsCanonicalizer.addName()` method:**\n\nThe method likely contains incorrect logic for handling hash table expansion when the symbol table reaches its capacity limit. Specifically:\n\n- The method may be calculating hash bucket indices incorrectly during expansion\n- There may be a race condition or incorrect state management when the table needs to resize\n- The expansion logic might not properly handle the transition from the current capacity to the new larger capacity\n- There could be an off-by-one error in the array bounds checking during the expansion process\n\n**Location**: `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName()` at or around line 824\n\nThe defect appears to be in the symbol table expansion algorithm that fails to properly handle the transition when the hash table needs to grow beyond its initial capacity, particularly when processing byte-based input streams.",
            "test_suite": "com.fasterxml.jackson.core.sym.SymbolsViaParserTest",
            "score": 9,
            "reason": "#9# The method is highly suspicious because the ArrayIndexOutOfBoundsException at index 512 occurs directly in addName at line 824, which matches the hash table capacity boundary. The method handles symbol table expansion and contains array access operations on _hashArea and _names arrays that could exceed bounds during rehashing or when the table reaches capacity. The failure specifically happens during symbol table expansion with byte-based parsing, and this method is responsible for adding new names to the table while managing hash table growth."
        },
        {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_findOffsetForAdd(int)",
            "method_code": "```java\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }\n\n```",
            "method_doc": " Method called to find the location within hash table to add a new symbol in. ",
            "class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
            "class_doc": " Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized memory access due to flattening of name quad data. Performance improvement modest for simple JSON document data binding (maybe 3%), but should help more for larger symbol tables, or for binary formats like Smile.  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe test `testSymbolTableExpansionBytes` fails with an `ArrayIndexOutOfBoundsException: 512` at:\n- `ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:824)`\n- During symbol table expansion when parsing byte-based JSON input\n\n## Step 2: Identify Key Characteristics\n\n1. **Failure Context**: The test executes 200 iterations, each creating unique field names to force symbol table expansion\n2. **Specific Trigger**: The failure occurs in `ByteQuadsCanonicalizer.addName()` method\n3. **Array Bound**: The index 512 suggests a fixed-size array boundary being exceeded\n4. **Input Type**: The failure specifically occurs with byte-based parsing (`useBytes = true`)\n\n## Step 3: Root Cause Analysis\n\nThe `ArrayIndexOutOfBoundsException` at index 512 in `ByteQuadsCanonicalizer.addName()` indicates:\n\n1. **Symbol Table Capacity Issue**: The `ByteQuadsCanonicalizer` likely uses a hash table with a fixed initial capacity that doesn't properly handle expansion\n2. **Hash Table Implementation**: The number 512 suggests the internal hash table has a capacity of 512 entries (power of 2), and the expansion logic is failing\n3. **Byte-Specific Bug**: Since this only fails with byte-based parsing, there may be a difference in how the symbol table handles byte vs char input during expansion\n\n## Step 4: Recommended Possible Defect\n\n**Possible Defect in `ByteQuadsCanonicalizer.addName()` method:**\n\nThe method likely contains incorrect logic for handling hash table expansion when the symbol table reaches its capacity limit. Specifically:\n\n- The method may be calculating hash bucket indices incorrectly during expansion\n- There may be a race condition or incorrect state management when the table needs to resize\n- The expansion logic might not properly handle the transition from the current capacity to the new larger capacity\n- There could be an off-by-one error in the array bounds checking during the expansion process\n\n**Location**: `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName()` at or around line 824\n\nThe defect appears to be in the symbol table expansion algorithm that fails to properly handle the transition when the hash table needs to grow beyond its initial capacity, particularly when processing byte-based input streams.",
            "test_suite": "com.fasterxml.jackson.core.sym.SymbolsViaParserTest",
            "score": 9,
            "reason": "#9# This method is highly suspicious because it calculates hash table offsets and manages the spillover area, and the ArrayIndexOutOfBoundsException at index 512 suggests a boundary calculation error during symbol table expansion. The method's logic for handling hash collisions and spillover growth could lead to exceeding array bounds when the table needs to expand, particularly evident in the test that forces repeated expansions with unique field names."
        },
        {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_verifyNeedForRehash()",
            "method_code": "```java\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n```",
            "method_doc": "Private method that checks if rehashing is needed based on count and spillover thresholds.",
            "class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
            "class_doc": " Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized memory access due to flattening of name quad data. Performance improvement modest for simple JSON document data binding (maybe 3%), but should help more for larger symbol tables, or for binary formats like Smile.  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe test `testSymbolTableExpansionBytes` fails with an `ArrayIndexOutOfBoundsException: 512` at:\n- `ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:824)`\n- During symbol table expansion when parsing byte-based JSON input\n\n## Step 2: Identify Key Characteristics\n\n1. **Failure Context**: The test executes 200 iterations, each creating unique field names to force symbol table expansion\n2. **Specific Trigger**: The failure occurs in `ByteQuadsCanonicalizer.addName()` method\n3. **Array Bound**: The index 512 suggests a fixed-size array boundary being exceeded\n4. **Input Type**: The failure specifically occurs with byte-based parsing (`useBytes = true`)\n\n## Step 3: Root Cause Analysis\n\nThe `ArrayIndexOutOfBoundsException` at index 512 in `ByteQuadsCanonicalizer.addName()` indicates:\n\n1. **Symbol Table Capacity Issue**: The `ByteQuadsCanonicalizer` likely uses a hash table with a fixed initial capacity that doesn't properly handle expansion\n2. **Hash Table Implementation**: The number 512 suggests the internal hash table has a capacity of 512 entries (power of 2), and the expansion logic is failing\n3. **Byte-Specific Bug**: Since this only fails with byte-based parsing, there may be a difference in how the symbol table handles byte vs char input during expansion\n\n## Step 4: Recommended Possible Defect\n\n**Possible Defect in `ByteQuadsCanonicalizer.addName()` method:**\n\nThe method likely contains incorrect logic for handling hash table expansion when the symbol table reaches its capacity limit. Specifically:\n\n- The method may be calculating hash bucket indices incorrectly during expansion\n- There may be a race condition or incorrect state management when the table needs to resize\n- The expansion logic might not properly handle the transition from the current capacity to the new larger capacity\n- There could be an off-by-one error in the array bounds checking during the expansion process\n\n**Location**: `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName()` at or around line 824\n\nThe defect appears to be in the symbol table expansion algorithm that fails to properly handle the transition when the hash table needs to grow beyond its initial capacity, particularly when processing byte-based input streams.",
            "test_suite": "com.fasterxml.jackson.core.sym.SymbolsViaParserTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it contains critical logic for determining when the symbol table needs to rehash/expand. The ArrayIndexOutOfBoundsException at index 512 suggests the hash table capacity is being exceeded, and this method's calculations for determining rehash thresholds appear flawed. Specifically, the bit shift operations and percentage calculations may be incorrectly determining when to trigger rehashing, causing the table to overflow its bounds during symbol table expansion."
        },
        {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_verifySharing()",
            "method_code": "```java\n    private void _verifySharing()\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_hashShared))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n        }\n        if (!(!(_needRehash))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            rehash();\n        }\n    }\n\n```",
            "method_doc": "Private method that verifies and handles hash sharing, potentially copying arrays and calling method \"rehash()\" if needed.",
            "class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
            "class_doc": " Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized memory access due to flattening of name quad data. Performance improvement modest for simple JSON document data binding (maybe 3%), but should help more for larger symbol tables, or for binary formats like Smile.  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe test `testSymbolTableExpansionBytes` fails with an `ArrayIndexOutOfBoundsException: 512` at:\n- `ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:824)`\n- During symbol table expansion when parsing byte-based JSON input\n\n## Step 2: Identify Key Characteristics\n\n1. **Failure Context**: The test executes 200 iterations, each creating unique field names to force symbol table expansion\n2. **Specific Trigger**: The failure occurs in `ByteQuadsCanonicalizer.addName()` method\n3. **Array Bound**: The index 512 suggests a fixed-size array boundary being exceeded\n4. **Input Type**: The failure specifically occurs with byte-based parsing (`useBytes = true`)\n\n## Step 3: Root Cause Analysis\n\nThe `ArrayIndexOutOfBoundsException` at index 512 in `ByteQuadsCanonicalizer.addName()` indicates:\n\n1. **Symbol Table Capacity Issue**: The `ByteQuadsCanonicalizer` likely uses a hash table with a fixed initial capacity that doesn't properly handle expansion\n2. **Hash Table Implementation**: The number 512 suggests the internal hash table has a capacity of 512 entries (power of 2), and the expansion logic is failing\n3. **Byte-Specific Bug**: Since this only fails with byte-based parsing, there may be a difference in how the symbol table handles byte vs char input during expansion\n\n## Step 4: Recommended Possible Defect\n\n**Possible Defect in `ByteQuadsCanonicalizer.addName()` method:**\n\nThe method likely contains incorrect logic for handling hash table expansion when the symbol table reaches its capacity limit. Specifically:\n\n- The method may be calculating hash bucket indices incorrectly during expansion\n- There may be a race condition or incorrect state management when the table needs to resize\n- The expansion logic might not properly handle the transition from the current capacity to the new larger capacity\n- There could be an off-by-one error in the array bounds checking during the expansion process\n\n**Location**: `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName()` at or around line 824\n\nThe defect appears to be in the symbol table expansion algorithm that fails to properly handle the transition when the hash table needs to grow beyond its initial capacity, particularly when processing byte-based input streams.",
            "test_suite": "com.fasterxml.jackson.core.sym.SymbolsViaParserTest",
            "score": 8,
            "reason": "#8# This method is very likely to be the best location that needs to be fixed because it handles hash table sharing and rehashing operations, which are critical during symbol table expansion. The ArrayIndexOutOfBoundsException at index 512 suggests a capacity boundary issue during hash table resizing, and this method contains the rehash() call that could be improperly handling the transition when the table grows beyond its initial capacity. The method's responsibility for copying arrays and triggering rehashing aligns with the expansion failure pattern observed in the test."
        },
        {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_calcOffset(int)",
            "method_code": "```java\n    private final int _calcOffset(int hash)\n    {\n        // NOTE: simple for initial impl, but we may want to interleave it a bit\n        // in near future\n        // So: first, hash into primary hash index\n        int ix = hash & (_hashSize-1);\n        // keeping in mind we have 4 ints per entry\n        return (ix << 2);\n    }\n\n```",
            "method_doc": "Private method that calculates hash table offset from hash value using bit masking and shifting.",
            "class_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer",
            "class_doc": " Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized memory access due to flattening of name quad data. Performance improvement modest for simple JSON document data binding (maybe 3%), but should help more for larger symbol tables, or for binary formats like Smile.  @since 2.6 ",
            "test_failure_causes": "Based on my analysis of the failed test case, stack trace, and test behavior, here's my step-by-step reasoning:\n\n## Step 1: Analyze the Common Failure Pattern\n\nThe test `testSymbolTableExpansionBytes` fails with an `ArrayIndexOutOfBoundsException: 512` at:\n- `ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:824)`\n- During symbol table expansion when parsing byte-based JSON input\n\n## Step 2: Identify Key Characteristics\n\n1. **Failure Context**: The test executes 200 iterations, each creating unique field names to force symbol table expansion\n2. **Specific Trigger**: The failure occurs in `ByteQuadsCanonicalizer.addName()` method\n3. **Array Bound**: The index 512 suggests a fixed-size array boundary being exceeded\n4. **Input Type**: The failure specifically occurs with byte-based parsing (`useBytes = true`)\n\n## Step 3: Root Cause Analysis\n\nThe `ArrayIndexOutOfBoundsException` at index 512 in `ByteQuadsCanonicalizer.addName()` indicates:\n\n1. **Symbol Table Capacity Issue**: The `ByteQuadsCanonicalizer` likely uses a hash table with a fixed initial capacity that doesn't properly handle expansion\n2. **Hash Table Implementation**: The number 512 suggests the internal hash table has a capacity of 512 entries (power of 2), and the expansion logic is failing\n3. **Byte-Specific Bug**: Since this only fails with byte-based parsing, there may be a difference in how the symbol table handles byte vs char input during expansion\n\n## Step 4: Recommended Possible Defect\n\n**Possible Defect in `ByteQuadsCanonicalizer.addName()` method:**\n\nThe method likely contains incorrect logic for handling hash table expansion when the symbol table reaches its capacity limit. Specifically:\n\n- The method may be calculating hash bucket indices incorrectly during expansion\n- There may be a race condition or incorrect state management when the table needs to resize\n- The expansion logic might not properly handle the transition from the current capacity to the new larger capacity\n- There could be an off-by-one error in the array bounds checking during the expansion process\n\n**Location**: `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName()` at or around line 824\n\nThe defect appears to be in the symbol table expansion algorithm that fails to properly handle the transition when the hash table needs to grow beyond its initial capacity, particularly when processing byte-based input streams.",
            "test_suite": "com.fasterxml.jackson.core.sym.SymbolsViaParserTest",
            "score": 8,
            "reason": "#8# The _calcOffset method is highly suspicious because it calculates array indices for a hash table with fixed size _hashSize. The ArrayIndexOutOfBoundsException at index 512 suggests the calculated offset exceeds array bounds during symbol table expansion. Since this method directly computes array positions using hash & (_hashSize-1) and multiplies by 4, any miscalculation in hash distribution or size handling could cause the out-of-bounds access observed in addName at line 824."
        }
    ],
    "buggy_codes": {
        "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_verifyNeedForRehash()": {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_verifyNeedForRehash()",
            "method_code": "```java\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n```",
            "method_doc": "Private method that checks if rehashing is needed based on count and spillover thresholds."
        },
        "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_verifySharing()": {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_verifySharing()",
            "method_code": "```java\n    private void _verifySharing()\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_hashShared))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n        }\n        if (!(!(_needRehash))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            rehash();\n        }\n    }\n\n```",
            "method_doc": "Private method that verifies and handles hash sharing, potentially copying arrays and calling method \"rehash()\" if needed."
        },
        "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::addName(String,int[],int)": {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::addName(String,int[],int)",
            "method_code": "```java\n    public String addName(String name, int[] q, int qlen)\n    {\n        _verifySharing();\n        if (_intern) {\n            name = InternCache.instance.intern(name);\n        }\n        int offset;\n        \n        switch (qlen) {\n        case 1:\n        {\n                offset = _findOffsetForAdd(calcHash(q[0]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+3] = 1;\n            }\n            break;\n        case 2:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+3] = 2;\n            }\n            break;\n        case 3:\n            {\n                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n                _hashArea[offset] = q[0];\n                _hashArea[offset+1] = q[1];\n                _hashArea[offset+2] = q[2];\n                _hashArea[offset+3] = 3;\n            }\n            break;\n        default:\n            final int hash = calcHash(q, qlen);\n            offset = _findOffsetForAdd(hash);\n\n            _hashArea[offset] = hash;\n            int longStart = _appendLongName(q, qlen);\n            _hashArea[offset+1] = longStart;\n            _hashArea[offset+3] = qlen;\n        }\n        // plus add the actual String\n        _names[offset >> 2] = name;\n\n        // and finally; see if we really should rehash.\n        ++_count;\n        _verifyNeedForRehash();\n        return name;\n    }\n\n```",
            "method_doc": "Method that adds a new symbol name to the table, calling methods \"_verifySharing()\", \"_findOffsetForAdd(int)\", and \"_verifyNeedForRehash()\" for table management and rehash verification."
        },
        "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_calcOffset(int)": {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_calcOffset(int)",
            "method_code": "```java\n    private final int _calcOffset(int hash)\n    {\n        // NOTE: simple for initial impl, but we may want to interleave it a bit\n        // in near future\n        // So: first, hash into primary hash index\n        int ix = hash & (_hashSize-1);\n        // keeping in mind we have 4 ints per entry\n        return (ix << 2);\n    }\n\n```",
            "method_doc": "Private method that calculates hash table offset from hash value using bit masking and shifting."
        },
        "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_findOffsetForAdd(int)": {
            "method_name": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer::_findOffsetForAdd(int)",
            "method_code": "```java\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n            return offset2;\n        }\n        // if not, tertiary?\n\n        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n        final int bucketSize = (1 << _tertiaryShift);\n        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n            if (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                return offset2;\n            }\n        }\n\n        // and if even tertiary full, append at the end of spill area\n        offset = _spilloverEnd;\n        _spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n        \n        // one caveat: in the unlikely event if spill-over filling up,\n        // check if that could be considered a DoS attack; handle appropriately\n        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n         */\n        final int end = (_hashSize << 3);\n        if (_spilloverEnd >= end) {\n            if (_failOnDoS) {\n                _reportTooManyCollisions();\n            }\n            // and if we didn't fail, we'll simply force rehash for next add\n            // (which, in turn, may double up or nuke contents, depending on size etc)\n            _needRehash = true;\n        }\n        return offset;\n    }\n\n```",
            "method_doc": " Method called to find the location within hash table to add a new symbol in. "
        }
    }
}