{
  "Chart-1": {
    "buggy": "public LegendItemCollection getLegendItems() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    LegendItemCollection TransVarLegendItemCollection = new LegendItemCollection();\n    if (!(!(this.plot == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarLegendItemCollection;\n    }\n    int TransVarIndexItem = this.plot.getIndexOf(this);\n    CategoryDataset TransVarDatasetCollection = this.plot.getDataset(TransVarIndexItem);\n    if (!(!(TransVarDatasetCollection != null))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarLegendItemCollection;\n    }\n    int TransVarSeriesCountTemp = TransVarDatasetCollection.getRowCount();\n    if (!(!(plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)))) {\n        int TransVarCounter = 0;\n        while (!(!(TransVarCounter < TransVarSeriesCountTemp))) {\n            if (!(!(isSeriesVisibleInLegend(TransVarCounter)))) {\n                LegendItem TransVarLegends = getLegendItem(TransVarIndexItem, TransVarCounter);\n                if (!(!(TransVarLegends != null))) {\n                    TransVarLegendItemCollection.add(TransVarLegends);\n                }\n            }\n            TransVarCounter++;\n        }\n    }\n    else {\n        int TransVarItem = TransVarSeriesCountTemp - 1;\n        while (!(!(TransVarItem >= 0))) {\n            if (!(!(isSeriesVisibleInLegend(TransVarItem)))) {\n                LegendItem TransVarLegendItem = getLegendItem(TransVarIndexItem, TransVarItem);\n                if (!(!(TransVarLegendItem != null))) {\n                    TransVarLegendItemCollection.add(TransVarLegendItem);\n                }\n            }\n            TransVarItem--;\n        }\n    }\n    return TransVarLegendItemCollection;\n}\n",
    "start": 1790,
    "end": 1822,
    "location": [
      1803
    ],
    "file_path": "source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java"
  },
  "Chart-11": {
    "buggy": "public static boolean equal(GeneralPath TransVarP2, GeneralPath TransVarP1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarP2 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return (TransVarP1 == null);\n    }\n    if (!(!(TransVarP1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    if (!(!(TransVarP2.getWindingRule() != TransVarP1.getWindingRule()))) {\n        return false;\n    }\n    PathIterator TransVarIterator2 = TransVarP2.getPathIterator(null);\n    PathIterator TransVarIterator = TransVarP2.getPathIterator(null); \n    double[] TransVarD2 = new double[6];\n    double[] TransVarD1 = new double[6];\n    boolean TransVarDone1 = TransVarIterator2.isDone() && TransVarIterator.isDone();\n    for (; !(!(!TransVarDone1));) {\n        if (!(!(TransVarIterator2.isDone() != TransVarIterator.isDone()))) {\n            return false;\n        }\n        int TransVarSegment = TransVarIterator2.currentSegment(TransVarD2);\n        int TransVarP = TransVarIterator.currentSegment(TransVarD1);\n        if (!(!(TransVarSegment != TransVarP))) {\n            return false;\n        }\n        if (!(!(!Arrays.equals(TransVarD2, TransVarD1)))) {\n            return false;\n        }\n        TransVarIterator2.next();\n        TransVarIterator.next();\n        TransVarDone1 = TransVarIterator2.isDone() && TransVarIterator.isDone();\n    }\n    return true;\n}\n",
    "start": 264,
    "end": 296,
    "location": [
      284
    ],
    "file_path": "source/org/jfree/chart/util/ShapeUtilities.java"
  },
  "Chart-12": {
    "buggy": "public MultiplePiePlot(CategoryDataset TransVarCategoryDataset) {\n    super();\n    this.dataset = TransVarCategoryDataset; \n    PiePlot TransVarPie = new PiePlot(null);\n    this.pieChart = new JFreeChart(TransVarPie);\n    this.pieChart.removeLegend();\n    this.dataExtractOrder = TableOrder.BY_COLUMN;\n    this.pieChart.setBackgroundPaint(null);\n    TextTitle TransVarTextTitle = new TextTitle(\"Series Title\",\n            new Font(\"SansSerif\", Font.BOLD, 12));\n    TransVarTextTitle.setPosition(RectangleEdge.BOTTOM);\n    this.pieChart.setTitle(TransVarTextTitle);\n    this.aggregatedItemsKey = \"Other\";\n    this.aggregatedItemsPaint = Color.lightGray;\n    this.sectionPaints = new HashMap();\n}\n",
    "start": 143,
    "end": 158,
    "location": [
      145
    ],
    "file_path": "source/org/jfree/chart/plot/MultiplePiePlot.java"
  },
  "Chart-13": {
    "buggy": "protected Size2D arrangeFF(BlockContainer TransVarBlockContainer, Graphics2D TransVarGraphics,\n                           RectangleConstraint TransVarBlock) {\n    if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\n    double[] TransVarWidth = new double[5];\n    double[] TransVarHeigh = new double[5];\n    TransVarWidth[0] = TransVarBlock.getWidth();\n    if (!(!(this.topBlock != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        RectangleConstraint TransVarC2 = new RectangleConstraint(TransVarWidth[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, TransVarBlock.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D TransVarSize2D = this.topBlock.arrange(TransVarGraphics, TransVarC2);\n        TransVarHeigh[0] = TransVarSize2D.height;\n    }\n    TransVarWidth[1] = TransVarWidth[0];\n    if (!(!(this.bottomBlock != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        RectangleConstraint TransVarC3 = new RectangleConstraint(TransVarWidth[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                TransVarBlock.getHeight() - TransVarHeigh[0]), LengthConstraintType.RANGE);\n        Size2D TransVarSize3D = this.bottomBlock.arrange(TransVarGraphics, TransVarC3);\n        TransVarHeigh[1] = TransVarSize3D.height;\n    }\n    TransVarHeigh[2] = TransVarBlock.getHeight() - TransVarHeigh[1] - TransVarHeigh[0];\n    if (!(!(this.leftBlock != null))) {\n        RectangleConstraint TransVarC4 = new RectangleConstraint(0.0,\n                new Range(0.0, TransVarBlock.getWidth()),\n                LengthConstraintType.RANGE, TransVarHeigh[2], null,\n                LengthConstraintType.FIXED);\n        Size2D TransVarSize2 = this.leftBlock.arrange(TransVarGraphics, TransVarC4);\n        TransVarWidth[2] = TransVarSize2.width;\n    }\n    TransVarHeigh[3] = TransVarHeigh[2];\n    if (!(!(this.rightBlock != null))) {\n        RectangleConstraint TransVarC5 = new RectangleConstraint(0.0,\n                new Range(0.0, TransVarBlock.getWidth() - TransVarWidth[2]), \n                LengthConstraintType.RANGE, TransVarHeigh[2], null,\n                LengthConstraintType.FIXED);\n        Size2D TransVarSize1 = this.rightBlock.arrange(TransVarGraphics, TransVarC5);\n        TransVarWidth[3] = TransVarSize1.width;\n    }\n    TransVarHeigh[4] = TransVarHeigh[2];\n    TransVarWidth[4] = TransVarBlock.getWidth() - TransVarWidth[3] - TransVarWidth[2];\n    RectangleConstraint TransVarC6 = new RectangleConstraint(TransVarWidth[4], TransVarHeigh[4]);\n    if (!(!(this.centerBlock != null))) {\n        this.centerBlock.arrange(TransVarGraphics, TransVarC6);\n    }\n\n    if (!(!(this.topBlock != null))) {\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, TransVarWidth[0],\n                TransVarHeigh[0]));\n    }\n    if (!(!(this.bottomBlock != null))) {\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, TransVarHeigh[0] + TransVarHeigh[2],\n                TransVarWidth[1], TransVarHeigh[1]));\n    }\n    if (!(!(this.leftBlock != null))) {\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, TransVarHeigh[0], TransVarWidth[2],\n                TransVarHeigh[2]));\n    }\n    if (!(!(this.rightBlock != null))) {\n        this.rightBlock.setBounds(new Rectangle2D.Double(TransVarWidth[2] + TransVarWidth[4], TransVarHeigh[0],\n                TransVarWidth[3], TransVarHeigh[3]));\n    }\n    if (!(!(this.centerBlock != null))) {\n        this.centerBlock.setBounds(new Rectangle2D.Double(TransVarWidth[2], TransVarHeigh[0], TransVarWidth[4],\n                TransVarHeigh[4]));\n    }\n    return new Size2D(TransVarBlock.getWidth(), TransVarBlock.getHeight());\n}\n",
    "start": 422,
    "end": 489,
    "location": [
      464
    ],
    "file_path": "source/org/jfree/chart/block/BorderArrangement.java"
  },
  "Chart-17": {
    "buggy": "public Object clone() throws CloneNotSupportedException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Object TransVarCloneObject = createCopy(0, getItemCount() - 1); \n    return TransVarCloneObject;\n}\n",
    "start": 856,
    "end": 859,
    "location": [
      860
    ],
    "file_path": "source/org/jfree/data/time/TimeSeries.java"
  },
  "Chart-20": {
    "buggy": "public ValueMarker(double TransVarCurrentValue, Paint TransVarPaintValue, Stroke TransVarCurrentPaint, \n                   Paint TransVarP, Stroke TransVarCurrentStroke, float TransVarAlpha2) {\n    super(TransVarPaintValue, TransVarCurrentPaint, TransVarPaintValue, TransVarCurrentPaint, TransVarAlpha2); \n    this.value = TransVarCurrentValue;\n}\n",
    "start": 93,
    "end": 97,
    "location": [
      95
    ],
    "file_path": "source/org/jfree/chart/plot/ValueMarker.java"
  },
  "Chart-24": {
    "buggy": "public Paint getPaint(double TransVarDoubleValue) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double TransVarMaxValue = Math.max(TransVarDoubleValue, this.lowerBound);\n    TransVarMaxValue = Math.min(TransVarMaxValue, this.upperBound);\n    int TransVarValue = (int) ((TransVarDoubleValue - this.lowerBound) / (this.upperBound  \n            - this.lowerBound) * 255.0);\n    return new Color(TransVarValue, TransVarValue, TransVarValue);\n}\n",
    "start": 123,
    "end": 129,
    "location": [
      129
    ],
    "file_path": "source/org/jfree/chart/renderer/GrayPaintScale.java"
  },
  "Chart-26": {
    "buggy": "protected AxisState drawLabel(String TransVarText, Graphics2D TransVarG, \n        Rectangle2D TransVarRect2D, Rectangle2D TransVarArea, RectangleEdge TransVarRect, \n        AxisState TransVarState1, PlotRenderingInfo TransVarPlotState1) {\n\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    // it is unlikely that 'state' will be null, but check anyway...\n    if (!(!(TransVarState1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    \n    if (!(!((TransVarText == null) || (TransVarText.equals(\"\"))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarState1;\n    }\n\n    Font TransVarF = getLabelFont();\n    RectangleInsets TransVarLabelInsets = getLabelInsets();\n    TransVarG.setFont(TransVarF);\n    TransVarG.setPaint(getLabelPaint());\n    FontMetrics TransVarFontMetrics = TransVarG.getFontMetrics();\n    Rectangle2D TransVarRect2 = TextUtilities.getTextBounds(TransVarText, TransVarG, TransVarFontMetrics);\n    Shape TransVarRectShape = null;\n    \n    if (!(!(TransVarRect == RectangleEdge.TOP))) {\n        AffineTransform TransVarTransform = AffineTransform.getRotateInstance(\n                getLabelAngle(), TransVarRect2.getCenterX(), \n                TransVarRect2.getCenterY());\n        Shape TransVarRotatedLabelBounds2 = TransVarTransform.createTransformedShape(TransVarRect2);\n        TransVarRect2 = TransVarRotatedLabelBounds2.getBounds2D();\n        float TransVarWidth = (float) TransVarRect2.getWidth();\n        float TransVarHeight = (float) TransVarRect2.getHeight();\n        float TransVarLabelx1 = (float) TransVarArea.getCenterX();\n        float TransVarLabely2 = (float) (TransVarState1.getCursor() - TransVarLabelInsets.getBottom() \n                - TransVarHeight / 2.0);\n        TextUtilities.drawRotatedString(TransVarText, TransVarG, TransVarLabelx1, TransVarLabely2, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        TransVarRectShape = new Rectangle2D.Float(TransVarLabelx1 - TransVarWidth / 2.0f, \n                TransVarLabely2 - TransVarHeight / 2.0f, TransVarWidth, TransVarHeight);\n        TransVarState1.cursorUp(TransVarLabelInsets.getTop() + TransVarRect2.getHeight() \n                + TransVarLabelInsets.getBottom());\n    }\n    else if (!(!(TransVarRect == RectangleEdge.BOTTOM))) {\n        AffineTransform TransVarLabelTransform = AffineTransform.getRotateInstance(\n                getLabelAngle(), TransVarRect2.getCenterX(), \n                TransVarRect2.getCenterY());\n        Shape TransVarRotatedLabelBounds1 = TransVarLabelTransform.createTransformedShape(TransVarRect2);\n        TransVarRect2 = TransVarRotatedLabelBounds1.getBounds2D();\n        float TransVarWw = (float) TransVarRect2.getWidth();\n        float TransVarHh = (float) TransVarRect2.getHeight();\n        float TransVarLabelX = (float) TransVarArea.getCenterX();\n        float TransVarLabelY = (float) (TransVarState1.getCursor() + TransVarLabelInsets.getTop() \n                + TransVarHh / 2.0);\n        TextUtilities.drawRotatedString(TransVarText, TransVarG, TransVarLabelX, TransVarLabelY, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        TransVarRectShape = new Rectangle2D.Float(TransVarLabelX - TransVarWw / 2.0f, \n                TransVarLabelY - TransVarHh / 2.0f, TransVarWw, TransVarHh);\n        TransVarState1.cursorDown(TransVarLabelInsets.getTop() + TransVarRect2.getHeight() \n                + TransVarLabelInsets.getBottom());\n    }\n    else if (!(!(TransVarRect == RectangleEdge.LEFT))) {\n        AffineTransform TransVarLabelTransform1 = AffineTransform.getRotateInstance(\n                getLabelAngle() - Math.PI / 2.0, TransVarRect2.getCenterX(), \n                TransVarRect2.getCenterY());\n        Shape TransVarRotatedBounds = TransVarLabelTransform1.createTransformedShape(TransVarRect2);\n        TransVarRect2 = TransVarRotatedBounds.getBounds2D();\n        float TransVarLabelWidth = (float) TransVarRect2.getWidth();\n        float TransVarH2 = (float) TransVarRect2.getHeight();\n        float TransVarLabelx2 = (float) (TransVarState1.getCursor() - TransVarLabelInsets.getRight() \n                - TransVarLabelWidth / 2.0);\n        float TransVarLabelY1 = (float) TransVarArea.getCenterY();\n        TextUtilities.drawRotatedString(TransVarText, TransVarG, TransVarLabelx2, TransVarLabelY1, \n                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                TextAnchor.CENTER);\n        TransVarRectShape = new Rectangle2D.Float(TransVarLabelx2 - TransVarLabelWidth / 2.0f, \n                TransVarLabelY1 - TransVarH2 / 2.0f, TransVarLabelWidth, TransVarH2);\n        TransVarState1.cursorLeft(TransVarLabelInsets.getLeft() + TransVarRect2.getWidth() \n                + TransVarLabelInsets.getRight());\n    }\n    else if (!(!(TransVarRect == RectangleEdge.RIGHT))) {\n\n        AffineTransform TransVarAffineTransform = AffineTransform.getRotateInstance(\n                getLabelAngle() + Math.PI / 2.0, \n                TransVarRect2.getCenterX(), TransVarRect2.getCenterY());\n        Shape TransVarRotatedLabelBounds3 = TransVarAffineTransform.createTransformedShape(TransVarRect2);\n        TransVarRect2 = TransVarRotatedLabelBounds3.getBounds2D();\n        float TransVarW1 = (float) TransVarRect2.getWidth();\n        float TransVarLabelHeight = (float) TransVarRect2.getHeight();\n        float TransVarLpx = (float) (TransVarState1.getCursor() \n                        + TransVarLabelInsets.getLeft() + TransVarW1 / 2.0);\n        float TransVarLabelY2 = (float) (TransVarArea.getY() + TransVarArea.getHeight() \n                / 2.0);\n        TextUtilities.drawRotatedString(TransVarText, TransVarG, TransVarLpx, TransVarLabelY2, \n                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                TextAnchor.CENTER);\n        TransVarRectShape = new Rectangle2D.Float(TransVarLpx - TransVarW1 / 2.0f, \n                TransVarLabelY2 - TransVarLabelHeight / 2.0f, TransVarW1, TransVarLabelHeight);\n        TransVarState1.cursorRight(TransVarLabelInsets.getLeft() + TransVarRect2.getWidth() \n                + TransVarLabelInsets.getRight());\n\n    }\n    if (!(!(TransVarPlotState1 != null && TransVarRectShape != null))) {\n        ChartRenderingInfo TransVarOwner1 = TransVarPlotState1.getOwner();\n            EntityCollection TransVarEntitiesList = TransVarOwner1.getEntityCollection(); \n            if (!(!(TransVarEntitiesList != null))) {\n                TransVarEntitiesList.add(new AxisLabelEntity(this, TransVarRectShape, \n                        this.labelToolTip, this.labelURL));\n            }\n    } \n    return TransVarState1;\n\n}\n",
    "start": 1092,
    "end": 1200,
    "location": [
      1201,
      1206
    ],
    "file_path": "source/org/jfree/chart/axis/Axis.java"
  },
  "Chart-3": {
    "buggy": "public TimeSeries createCopy(int TransVarStartIndex, int TransVarEndIndex)\n        throws CloneNotSupportedException {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(TransVarStartIndex < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (!(!(TransVarEndIndex < TransVarStartIndex))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries TransVarClonedTimeSeries = (TimeSeries) super.clone();\n    TransVarClonedTimeSeries.data = new java.util.ArrayList(); \n    if (!(!(this.data.size() > 0))) {\n        int TransVarIndex2 = TransVarStartIndex;\n        while (!(!(TransVarIndex2 <= TransVarEndIndex))) {\n            TimeSeriesDataItem TransVarClonedItem = (TimeSeriesDataItem) this.data.get(TransVarIndex2);\n            TimeSeriesDataItem TransVarCloneItem = (TimeSeriesDataItem) TransVarClonedItem.clone();\n            try {\n                TransVarClonedTimeSeries.add(TransVarCloneItem);\n            } catch (SeriesException TransVarIndexException) {\n                TransVarIndexException.printStackTrace();\n            }\n            TransVarIndex2++;\n        }\n    }\n    return TransVarClonedTimeSeries;\n}\n",
    "start": 1048,
    "end": 1072,
    "location": [
      1066
    ],
    "file_path": "source/org/jfree/data/time/TimeSeries.java"
  },
  "Chart-5": {
    "buggy": "public XYDataItem addOrUpdate(Number TransVarNumber, Number TransVarNum) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarNumber == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Null 'x' argument.\");\n    }\n \n    // if we get to here, we know that duplicate X values are not permitted\n    XYDataItem TransVarDataItem = null;\n    int TransVarI = indexOf(TransVarNumber);\n    if (!(!(TransVarI >= 0 && !this.allowDuplicateXValues))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        XYDataItem TransVarData = (XYDataItem) this.data.get(TransVarI);\n        try {\n            TransVarDataItem = (XYDataItem) TransVarData.clone();\n        }\n        catch (CloneNotSupportedException TransVarException) {\n            throw new SeriesException(\"Couldn't clone XYDataItem!\");\n        }\n        TransVarData.setY(TransVarNum);\n    }\n    else {\n        // if the series is sorted, the negative index is a result from\n        // Collections.binarySearch() and tells us where to insert the\n        // new item...otherwise it will be just -1 and we should just\n        // append the value to the list...\n        if (!(!(this.autoSort))) {\n            this.data.add(-TransVarI - 1, new XYDataItem(TransVarNumber, TransVarNum));\n        }\n        else {\n            this.data.add(new XYDataItem(TransVarNumber, TransVarNum));\n        }\n        // check if this addition will exceed the maximum item count...\n        if (!(!(getItemCount() > this.maximumItemCount))) {\n            this.data.remove(0);\n        }\n    }\n    fireSeriesChanged();\n    return TransVarDataItem;\n}\n",
    "start": 540,
    "end": 576,
    "location": [
      550,
      554
    ],
    "file_path": "source/org/jfree/data/xy/XYSeries.java"
  },
  "Chart-6": {
    "buggy": "public boolean equals(Object TransVarObject) {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarObject == this))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n    if (!(!(!(TransVarObject instanceof ShapeList)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    return super.equals(TransVarObject); \n\n}\n",
    "start": 103,
    "end": 113,
    "location": [
      120
    ],
    "file_path": "source/org/jfree/chart/util/ShapeList.java"
  },
  "Chart-7": {
    "buggy": "private void updateBounds(TimePeriod TransVarTimePeriod, int TransVarTimeIndex) {\n    \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long TransVarStartTime = TransVarTimePeriod.getStart().getTime();\n    long TransVarEndTime = TransVarTimePeriod.getEnd().getTime();\n    long TransVarMiddleTime = TransVarStartTime + ((TransVarEndTime - TransVarStartTime) / 2);\n\n    if (!(!(this.minStartIndex >= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        long TransVarMinStartTime = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (!(!(TransVarStartTime < TransVarMinStartTime))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            this.minStartIndex = TransVarTimeIndex;           \n        }\n    }\n    else {\n        this.minStartIndex = TransVarTimeIndex;\n    }\n    \n    if (!(!(this.maxStartIndex >= 0))) {\n        long TransVarStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (!(!(TransVarStartTime > TransVarStart))) {\n            this.maxStartIndex = TransVarTimeIndex;           \n        }\n    }\n    else {\n        this.maxStartIndex = TransVarTimeIndex;\n    }\n    \n    if (!(!(this.minMiddleIndex >= 0))) {\n        long TransVarSt = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long TransVarEnd = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long TransVarMid = TransVarSt + (TransVarEnd - TransVarSt) / 2;\n        if (!(!(TransVarMiddleTime < TransVarMid))) {\n            this.minMiddleIndex = TransVarTimeIndex;           \n        }\n    }\n    else {\n        this.minMiddleIndex = TransVarTimeIndex;\n    }\n    \n    if (!(!(this.maxMiddleIndex >= 0))) {\n        long TransVarMinMiddleStartTime = getDataItem(this.minMiddleIndex).getPeriod().getStart() \n            .getTime();\n        long TransVarMiddleEnd = getDataItem(this.minMiddleIndex).getPeriod().getEnd() \n            .getTime();\n        long TransVarMiddle = TransVarMinMiddleStartTime + (TransVarMiddleEnd - TransVarMinMiddleStartTime) / 2;\n        if (!(!(TransVarMiddleTime > TransVarMiddle))) {\n            this.maxMiddleIndex = TransVarTimeIndex;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = TransVarTimeIndex;\n    }\n    \n    if (!(!(this.minEndIndex >= 0))) {\n        long TransVarMinMiddleEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (!(!(TransVarEndTime < TransVarMinMiddleEnd))) {\n            this.minEndIndex = TransVarTimeIndex;           \n        }\n    }\n    else {\n        this.minEndIndex = TransVarTimeIndex;\n    }\n   \n    if (!(!(this.maxEndIndex >= 0))) {\n        long TransVarMaxEndTime = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (!(!(TransVarEndTime > TransVarMaxEndTime))) {\n            this.maxEndIndex = TransVarTimeIndex;           \n        }\n    }\n    else {\n        this.maxEndIndex = TransVarTimeIndex;\n    }\n    \n}\n",
    "start": 257,
    "end": 335,
    "location": [
      309,
      311
    ],
    "file_path": "source/org/jfree/data/time/TimePeriodValues.java"
  },
  "Chart-8": {
    "buggy": "public Week(Date TransVarDate, TimeZone TransVarTimeZone) {\n    // defer argument checking...\n    this(TransVarDate, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); \n}\n",
    "start": 173,
    "end": 176,
    "location": [
      175
    ],
    "file_path": "source/org/jfree/data/time/Week.java"
  },
  "Chart-9": {
    "buggy": "public TimeSeries createCopy(RegularTimePeriod TransVarStartTime, RegularTimePeriod TransVarEndTime)\n    throws CloneNotSupportedException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(TransVarStartTime == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (!(!(TransVarEndTime == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (!(!(TransVarStartTime.compareTo(TransVarEndTime) > 0))) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean TransVarTimeRange = false;\n    int TransVarStartIndex2 = getIndex(TransVarStartTime);\n    if (!(!(TransVarStartIndex2 < 0))) {\n        TransVarStartIndex2 = -(TransVarStartIndex2 + 1);\n        if (!(!(TransVarStartIndex2 == this.data.size()))) {\n            TransVarTimeRange = true;  // start is after last data item\n        }\n    }\n    int TransVarEnd = getIndex(TransVarEndTime);\n    if (!(!(TransVarEnd < 0))) {             // end period is not in original series\n        TransVarEnd = -(TransVarEnd + 1); // this is first item AFTER end period\n        TransVarEnd = TransVarEnd - 1;    // so this is last item BEFORE end\n    }\n    if (!(!(TransVarEnd < 0))) { \n        TransVarTimeRange = true;\n    }\n    if (!(!(TransVarTimeRange))) {\n        TimeSeries TransVarClonedTS = (TimeSeries) super.clone();\n        TransVarClonedTS.data = new java.util.ArrayList();\n        return TransVarClonedTS;\n    }\n    else {\n        return createCopy(TransVarStartIndex2, TransVarEnd);\n    }\n\n}\n",
    "start": 918,
    "end": 956,
    "location": [
      953
    ],
    "file_path": "source/org/jfree/data/time/TimeSeries.java"
  },
  "Cli-11": {
    "buggy": "private static void appendOption(final StringBuffer TransVarBuff2, \n                                 final Option TransVarOption2, \n                                 final boolean TransVarRequiredField)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(!TransVarRequiredField)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarBuff2.append(\"[\");\n    }\n\n    if (!(!(TransVarOption2.getOpt() != null)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarBuff2.append(\"-\").append(TransVarOption2.getOpt());\n    }\n    else\n    {\n        TransVarBuff2.append(\"--\").append(TransVarOption2.getLongOpt());\n    }\n\n    // if the Option has a value\n    if (!(!(TransVarOption2.hasArg() && (TransVarOption2.getArgName() != null)))) \n    {\n        TransVarBuff2.append(\" <\").append(TransVarOption2.getArgName()).append(\">\");\n    }\n\n    // if the Option is not a required option\n    if (!(!(!TransVarRequiredField)))\n    {\n        TransVarBuff2.append(\"]\");\n    }\n}\n",
    "start": 613,
    "end": 642,
    "location": [
      641
    ],
    "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java"
  },
  "Cli-15": {
    "buggy": "public List getValues(final Option TransVarOptions,\n                      List TransVarOptionDefaults) {\n    if (!(!(false))) {\n                            System.out.println(\"log\");\n                        }\n    // initialize the return list\n    List TransVarOptionValues = (List) values.get(TransVarOptions);\n\n    // grab the correct default values\n    if (!(!((TransVarOptionValues == null) || TransVarOptionValues.isEmpty()))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarOptionValues = TransVarOptionDefaults; \n    }\n\n    // augment the list with the default values\n    if (!(!((TransVarOptionValues == null) || TransVarOptionValues.isEmpty()))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarOptionValues = (List) this.defaultValues.get(TransVarOptions); \n    } \n            // if there are more default values as specified, add them to\n            // the list.\n                // copy the list first \n     \n    return TransVarOptionValues == null ? Collections.EMPTY_LIST : TransVarOptionValues;\n}\n",
    "start": 111,
    "end": 130,
    "location": [
      120,
      124,
      128,
      132,
      133,
      136,
      137
    ],
    "file_path": "src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java"
  },
  "Cli-19": {
    "buggy": "private void processOptionToken(String TransVarStringToken, boolean TransVarStopAtNonOptionValue)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(options.hasOption(TransVarStringToken))))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        currentOption = options.getOption(TransVarStringToken);\n        tokens.add(TransVarStringToken); \n    }\n    else if (!(!(TransVarStopAtNonOptionValue)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        eatTheRest = true;\n        tokens.add(TransVarStringToken); \n    }\n} \n",
    "start": 227,
    "end": 239,
    "location": [
      238,
      246,
      248
    ],
    "file_path": "src/java/org/apache/commons/cli/PosixParser.java"
  },
  "Cli-24": {
    "buggy": "protected StringBuffer renderWrappedText(StringBuffer TransVarStr, int TransVarHeight, \n                                         int TransVarTabStop, String TransVarWord)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarPos2 = findWrapPos(TransVarWord, TransVarHeight, 0);\n\n    if (!(!(TransVarPos2 == -1)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarStr.append(rtrim(TransVarWord));\n\n        return TransVarStr;\n    }\n    TransVarStr.append(rtrim(TransVarWord.substring(0, TransVarPos2))).append(defaultNewLine);\n\n    if (!(!(TransVarTabStop >= TransVarHeight)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // stops infinite loop happening\n        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" +  \n                                        \"- no room for the description\"); \n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String TransVarNewPadding = createPadding(TransVarTabStop);\n\n    for (; !(!(true));) {\n        TransVarWord = TransVarNewPadding + TransVarWord.substring(TransVarPos2).trim();\n        TransVarPos2 = findWrapPos(TransVarWord, TransVarHeight, 0);\n        if (!(!(TransVarPos2 == -1))) {\n            TransVarStr.append(TransVarWord);\n            return TransVarStr;\n        }\n        if (!(!((TransVarWord.length() > TransVarHeight) && (TransVarPos2 == TransVarTabStop - 1)))) {\n            TransVarPos2 = TransVarHeight;\n        }\n        TransVarStr.append(rtrim(TransVarWord.substring(0, TransVarPos2))).append(defaultNewLine);\n    }\n}\n",
    "start": 809,
    "end": 852,
    "location": [
      834,
      835
    ],
    "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java"
  },
  "Cli-25": {
    "buggy": "protected StringBuffer renderWrappedText(StringBuffer TransVarStr, int TransVarWidthOfRectangle, \n                                         int TransVarWidthTabStop, String TransVarRectangleText)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarPos1 = findWrapPos(TransVarRectangleText, TransVarWidthOfRectangle, 0);\n\n    if (!(!(TransVarPos1 == -1)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarStr.append(rtrim(TransVarRectangleText));\n\n        return TransVarStr;\n    }\n    TransVarStr.append(rtrim(TransVarRectangleText.substring(0, TransVarPos1))).append(defaultNewLine);\n\n    if (!(!(TransVarWidthTabStop >= TransVarWidthOfRectangle)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // stops infinite loop happening\n        TransVarWidthTabStop = TransVarWidthOfRectangle - 1; \n    }\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String TransVarPaddingOfString = createPadding(TransVarWidthTabStop);\n\n    for (; !(!(true));) {\n        TransVarRectangleText = TransVarPaddingOfString + TransVarRectangleText.substring(TransVarPos1).trim();\n        TransVarPos1 = findWrapPos(TransVarRectangleText, TransVarWidthOfRectangle, 0);\n        if (!(!(TransVarPos1 == -1))) {\n            TransVarStr.append(TransVarRectangleText);\n            return TransVarStr;\n        }\n        if (!(!((TransVarRectangleText.length() > TransVarWidthOfRectangle) && (TransVarPos1 == TransVarWidthTabStop - 1)))) {\n            TransVarPos1 = TransVarWidthOfRectangle;\n        }\n        TransVarStr.append(rtrim(TransVarRectangleText.substring(0, TransVarPos1))).append(defaultNewLine);\n    }\n}\n",
    "start": 809,
    "end": 851,
    "location": [
      834
    ],
    "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java"
  },
  "Cli-26": {
    "buggy": "public static Option create(String TransVarOption) throws IllegalArgumentException\n{\n        if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // create the option \n    Option TransVarOpt = new Option(TransVarOption, description); \n\n        // set the option properties\n        TransVarOpt.setLongOpt(longopt);\n        TransVarOpt.setRequired(required);\n        TransVarOpt.setOptionalArg(optionalArg);\n        TransVarOpt.setArgs(numberOfArgs);\n        TransVarOpt.setType(type);\n        TransVarOpt.setValueSeparator(valuesep);\n        TransVarOpt.setArgName(argName);\n        // reset the OptionBuilder properties \n        OptionBuilder.reset();\n \n    // return the Option instance\n    return TransVarOpt;\n}\n",
    "start": 346,
    "end": 364,
    "location": [
      351,
      352,
      362,
      364
    ],
    "file_path": "src/java/org/apache/commons/cli/OptionBuilder.java"
  },
  "Cli-27": {
    "buggy": "public void setSelected(Option TransVarOption1) throws AlreadySelectedException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarOption1 == null)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // reset the option previously selected\n        selected = null;\n        return;\n    }\n    \n    // if no option has already been selected or the \n    // same option is being reselected then set the\n    // selected member variable\n    if (!(!(selected == null || selected.equals(TransVarOption1.getOpt())))) \n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        selected = TransVarOption1.getOpt(); \n    }\n    else\n    {\n        throw new AlreadySelectedException(this, TransVarOption1);\n    }\n}\n",
    "start": 86,
    "end": 106,
    "location": [
      104,
      109
    ],
    "file_path": "src/java/org/apache/commons/cli/OptionGroup.java"
  },
  "Cli-29": {
    "buggy": "static String stripLeadingAndTrailingQuotes(String TransVarStr1)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr1.startsWith(\"\\\"\")))) \n    { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarStr1 = TransVarStr1.substring(1, TransVarStr1.length()); \n    } \n    int TransVarStr = TransVarStr1.length();\n    if (!(!(TransVarStr1.endsWith(\"\\\"\")))) \n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarStr1 = TransVarStr1.substring(0, TransVarStr - 1); \n    }\n    \n    return TransVarStr1;\n}\n",
    "start": 63,
    "end": 76,
    "location": [
      68,
      69,
      73,
      74,
      76,
      81
    ],
    "file_path": "src/java/org/apache/commons/cli/Util.java"
  },
  "Cli-35": {
    "buggy": "public List<String> getMatchingOptions(String TransVarOption)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarOption = Util.stripLeadingHyphens(TransVarOption);\n    \n    List<String> TransVarOptionsList = new ArrayList<String>();\n\n    // for a perfect match return the single option only\n \n    for (String TransVarLongOption : longOpts.keySet())\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarLongOption.startsWith(TransVarOption))))\n        {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarOptionsList.add(TransVarLongOption);\n        }\n    }\n    \n    return TransVarOptionsList;\n}\n",
    "start": 233,
    "end": 250,
    "location": [
      243
    ],
    "file_path": "src/main/java/org/apache/commons/cli/Options.java"
  },
  "Cli-37": {
    "buggy": "private boolean isShortOption(String TransVarTokenIn)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    return TransVarTokenIn.startsWith(\"-\") && TransVarTokenIn.length() >= 2 && options.hasShortOption(TransVarTokenIn.substring(1, 2)); \n\n    // remove leading \"-\" and \"=value\"\n} \n",
    "start": 299,
    "end": 305,
    "location": [
      305,
      308
    ],
    "file_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
  },
  "Cli-38": {
    "buggy": "private boolean isShortOption(String TransVarToken1)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if (!(!(!TransVarToken1.startsWith(\"-\") || TransVarToken1.length() == 1)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n\n    // remove leading \"-\" and \"=value\"\n    int TransVarPosition = TransVarToken1.indexOf(\"=\");\n    String TransVarToken = TransVarPosition == -1 ? TransVarToken1.substring(1) : TransVarToken1.substring(1, TransVarPosition);\n    return options.hasShortOption(TransVarToken); \n    // check for several concatenated short options\n} \n",
    "start": 299,
    "end": 312,
    "location": [
      316,
      318
    ],
    "file_path": "src/main/java/org/apache/commons/cli/DefaultParser.java"
  },
  "Cli-4": {
    "buggy": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // if there are required options that have not been\n    // processsed\n    if (!(!(requiredOptions.size() > 0)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Iterator TransVarIterator = requiredOptions.iterator();\n        StringBuffer TransVarBuffer = new StringBuffer(); \n\n\n        for (; !(!(TransVarIterator.hasNext()));) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarBuffer.append(TransVarIterator.next());\n        }\n\n        throw new MissingOptionException(TransVarBuffer.toString());\n    }\n}\n",
    "start": 290,
    "end": 309,
    "location": [
      304
    ],
    "file_path": "src/java/org/apache/commons/cli/Parser.java"
  },
  "Cli-40": {
    "buggy": "public static <T> T createValue(final String TransVarString, final Class<T> TransVarClassName) throws ParseException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(PatternOptionBuilder.STRING_VALUE == TransVarClassName)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return (T) TransVarString;\n    }\n    else if (!(!(PatternOptionBuilder.OBJECT_VALUE == TransVarClassName)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return (T) createObject(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.NUMBER_VALUE == TransVarClassName)))\n    {\n        return (T) createNumber(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.DATE_VALUE == TransVarClassName)))\n    {\n        return (T) createDate(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.CLASS_VALUE == TransVarClassName)))\n    {\n        return (T) createClass(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.FILE_VALUE == TransVarClassName)))\n    {\n        return (T) createFile(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.EXISTING_FILE_VALUE == TransVarClassName)))\n    {\n        return (T) openFile(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.FILES_VALUE == TransVarClassName)))\n    {\n        return (T) createFiles(TransVarString);\n    }\n    else if (!(!(PatternOptionBuilder.URL_VALUE == TransVarClassName)))\n    {\n        return (T) createURL(TransVarString);\n    }\n    else\n    {\n        return null; \n    }\n}\n",
    "start": 63,
    "end": 105,
    "location": [
      112
    ],
    "file_path": "src/main/java/org/apache/commons/cli/TypeHandler.java"
  },
  "Cli-5": {
    "buggy": "static String stripLeadingHyphens(String TransVarS)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarS.startsWith(\"--\")))) \n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarS.substring(2, TransVarS.length());\n    }\n    else if (!(!(TransVarS.startsWith(\"-\"))))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarS.substring(1, TransVarS.length());\n    }\n\n    return TransVarS;\n}\n",
    "start": 34,
    "end": 46,
    "location": [
      39
    ],
    "file_path": "src/java/org/apache/commons/cli/Util.java"
  },
  "Closure-1": {
    "buggy": "private void removeUnreferencedFunctionArgs(Scope TransVarFunctionScope) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// Notice that removing unreferenced function args breaks\n  // Function.prototype.length. In advanced mode, we don't really care\n  // about this: we consider \"length\" the equivalent of reflecting on\n  // the function's lexical source.\n  //\n  // Rather than create a new option for this, we assume that if the user\n  // is removing globals, then it's OK to remove unused function args.\n  //\n  // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n \n  Node TransVarRootNode = TransVarFunctionScope.getRootNode();\n\n  Preconditions.checkState(TransVarRootNode.isFunction());\n  if (!(!(NodeUtil.isGetOrSetKey(TransVarRootNode.getParent())))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // The parameters object literal setters can not be removed.\n    return;\n  }\n\n  Node TransVarFunctionArgList = getFunctionArgList(TransVarRootNode);\n  boolean TransVarModifyCaller = modifyCallSites\n      && callSiteOptimizer.canModifyCallers(TransVarRootNode);\n  if (!(!(!TransVarModifyCaller))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Strip unreferenced args off the end of the function declaration.\n    Node TransVarCurrentArg;\n    for (; !(!((TransVarCurrentArg = TransVarFunctionArgList.getLastChild()) != null));) {\n        Var TransVarCurrentVar = TransVarFunctionScope.getVar(TransVarCurrentArg.getString());\n        if (!(!(!referenced.contains(TransVarCurrentVar)))) {\n            TransVarFunctionArgList.removeChild(TransVarCurrentArg);\n            compiler.reportCodeChange();\n        } else {\n            break;\n        }\n    }\n  } else {\n    callSiteOptimizer.optimize(TransVarFunctionScope, referenced);\n  }\n}\n",
    "start": 369,
    "end": 406,
    "location": [
      382
    ],
    "file_path": "src/com/google/javascript/jscomp/RemoveUnusedVars.java"
  },
  "Closure-10": {
    "buggy": "static boolean mayBeString(Node TransVarNode, boolean TransVarTree) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarTree))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return allResultsMatch(TransVarNode, MAY_BE_STRING_PREDICATE); \n  } else {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return mayBeStringHelper(TransVarNode);\n  }\n}\n",
    "start": 1415,
    "end": 1421,
    "location": [
      1423
    ],
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java"
  },
  "Closure-101": {
    "buggy": "protected CompilerOptions createOptions() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nCompilerOptions TransVarOptions1 = new CompilerOptions();\n  TransVarOptions1.setCodingConvention(new ClosureCodingConvention());\n  CompilationLevel TransVarCompilationLevel = flags.compilation_level;\n  TransVarCompilationLevel.setOptionsForCompilationLevel(TransVarOptions1);\n  if (!(!(flags.debug))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarCompilationLevel.setDebugOptionsForCompilationLevel(TransVarOptions1);\n  }\n\n  WarningLevel TransVarWarningLevel = flags.warning_level;\n  TransVarWarningLevel.setOptionsForWarningLevel(TransVarOptions1);\n  for (FormattingOption TransVarFormattingOptions : flags.formatting) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarFormattingOptions.applyToOptions(TransVarOptions1);\n  }\n  if (!(!(flags.process_closure_primitives))) { \n    TransVarOptions1.closurePass = true; \n  } \n\n  initOptionsFromFlags(TransVarOptions1); \n  return TransVarOptions1;\n}\n",
    "start": 419,
    "end": 439,
    "location": [
      442,
      443,
      444,
      446
    ],
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java"
  },
  "Closure-102": {
    "buggy": "public void process(Node TransVarExternList, Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNodeTraversal.traverse(compiler, TransVarNode, this);\n  if (!(!(MAKE_LOCAL_NAMES_UNIQUE))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    MakeDeclaredNamesUnique TransVarUnique = new MakeDeclaredNamesUnique();\n    NodeTraversal TransVarTraversal = new NodeTraversal(compiler, TransVarUnique);\n    TransVarTraversal.traverseRoots(TransVarExternList, TransVarNode);\n  }\n  removeDuplicateDeclarations(TransVarNode); \n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(TransVarExternList, TransVarNode);\n}\n",
    "start": 87,
    "end": 97,
    "location": [
      92,
      100
    ],
    "file_path": "src/com/google/javascript/jscomp/Normalize.java"
  },
  "Closure-104": {
    "buggy": "JSType meet(JSType TransVarJsType) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nUnionTypeBuilder TransVarBuilder2 = new UnionTypeBuilder(registry);\n  for (JSType TransVarAlternateType : alternates) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarAlternateType.isSubtype(TransVarJsType)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarBuilder2.addAlternate(TransVarAlternateType);\n    }\n  }\n\n  if (!(!(TransVarJsType instanceof UnionType))) {\n    for (JSType TransVarAlternate : ((UnionType) TransVarJsType).alternates) {\n      if (!(!(TransVarAlternate.isSubtype(this)))) {\n        TransVarBuilder2.addAlternate(TransVarAlternate);\n      }\n    }\n  } else if (!(!(TransVarJsType.isSubtype(this)))) {\n    TransVarBuilder2.addAlternate(TransVarJsType);\n  }\n  JSType TransVarResultType = TransVarBuilder2.build();\n  if (!(!(TransVarResultType != null))) { \n    return TransVarResultType;\n  } else if (!(!(this.isObject() && TransVarJsType.isObject()))) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  } else {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }\n}\n",
    "start": 273,
    "end": 298,
    "location": [
      300
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/UnionType.java"
  },
  "Closure-107": {
    "buggy": "protected CompilerOptions createOptions() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nCompilerOptions TransVarCompilerOptions = new CompilerOptions();\n  if (!(!(flags.processJqueryPrimitives))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarCompilerOptions.setCodingConvention(new JqueryCodingConvention());\n  } else {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarCompilerOptions.setCodingConvention(new ClosureCodingConvention());\n  }\n\n  TransVarCompilerOptions.setExtraAnnotationNames(flags.extraAnnotationName);\n\n  CompilationLevel TransVarCompilationLevel = flags.compilationLevel;\n  TransVarCompilationLevel.setOptionsForCompilationLevel(TransVarCompilerOptions);\n\n  if (!(!(flags.debug))) {\n    TransVarCompilationLevel.setDebugOptionsForCompilationLevel(TransVarCompilerOptions);\n  }\n\n  if (!(!(flags.useTypesForOptimization))) {\n    TransVarCompilationLevel.setTypeBasedOptimizationOptions(TransVarCompilerOptions);\n  }\n\n  if (!(!(flags.generateExports))) {\n    TransVarCompilerOptions.setGenerateExports(flags.generateExports);\n  }\n\n  WarningLevel TransVarWarningLevel = flags.warningLevel;\n  TransVarWarningLevel.setOptionsForWarningLevel(TransVarCompilerOptions);\n  for (FormattingOption TransVarFormattingOptions : flags.formatting) {\n    TransVarFormattingOptions.applyToOptions(TransVarCompilerOptions);\n  }\n\n  TransVarCompilerOptions.closurePass = flags.processClosurePrimitives;\n\n  TransVarCompilerOptions.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == TransVarCompilationLevel &&\n      flags.processJqueryPrimitives;\n\n  TransVarCompilerOptions.angularPass = flags.angularPass;\n\n  if (!(!(!flags.translationsFile.isEmpty()))) {\n    try {\n      TransVarCompilerOptions.messageBundle = new XtbMessageBundle(\n          new FileInputStream(flags.translationsFile),\n          flags.translationsProject);\n    } catch (IOException TransVarException) {\n      throw new RuntimeException(\"Reading XTB file\", TransVarException);\n    }\n  } else if (!(!(CompilationLevel.ADVANCED_OPTIMIZATIONS == TransVarCompilationLevel))) {\n    // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n    // translations file, they might reasonably try to write their own\n    // implementation of goog.getMsg that makes the substitution at\n    // run-time.\n    //\n    // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n    // so we might as well inline it. But shut off the i18n warnings,\n    // because the user didn't really ask for i18n.\n    TransVarCompilerOptions.messageBundle = new EmptyMessageBundle();\n  } \n\n  return TransVarCompilerOptions;\n}\n",
    "start": 806,
    "end": 865,
    "location": [
      871
    ],
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java"
  },
  "Closure-109": {
    "buggy": "private Node parseContextTypeExpression(JsDocToken TransVarDocToken) {\n        if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        return parseTypeName(TransVarDocToken); \n}\n",
    "start": 1907,
    "end": 1909,
    "location": [
      1911
    ],
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java"
  },
  "Closure-11": {
    "buggy": "private void visitGetProp(NodeTraversal TransVarTraversal, Node TransVarTemp, Node TransVarCurrentNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// obj.prop or obj.method()\n  // Lots of types can appear on the left, a call to a void function can\n  // never be on the left. getPropertyType will decide what is acceptable\n  // and what isn't.\n  Node TransVarLastNode = TransVarTemp.getLastChild();\n  Node TransVarFirstNode = TransVarTemp.getFirstChild();\n  JSType TransVarCurrentType = getJSType(TransVarFirstNode);\n\n  if (!(!(TransVarCurrentType.isDict()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    report(TransVarTraversal, TransVarLastNode, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n  } else if (!(!(TransVarTemp.getJSType() != null && TransVarCurrentNode.isAssign()))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return; \n  } else if (!(!(validator.expectNotNullOrUndefined(TransVarTraversal, TransVarTemp, TransVarCurrentType,\n        \"No properties on this expression\", getNativeType(OBJECT_TYPE))))) {\n    checkPropertyAccess(TransVarCurrentType, TransVarLastNode.getString(), TransVarTraversal, TransVarTemp);\n  }\n  ensureTyped(TransVarTraversal, TransVarTemp);\n}\n",
    "start": 1303,
    "end": 1321,
    "location": [
      1320,
      1324
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java"
  },
  "Closure-111": {
    "buggy": "protected JSType caseTopType(JSType TransVarT) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nreturn TransVarT; \n}\n",
    "start": 53,
    "end": 55,
    "location": [
      57
    ],
    "file_path": "src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java"
  },
  "Closure-112": {
    "buggy": "private boolean inferTemplatedTypesForCall(\n    Node TransVarNode, FunctionType TransVarFunctionType) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nfinal ImmutableList<TemplateType> TransVarTemplateKeys = TransVarFunctionType.getTemplateTypeMap()\n      .getTemplateKeys();\n  if (!(!(TransVarTemplateKeys.isEmpty()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false;\n  }\n\n  // Try to infer the template types\n  Map<TemplateType, JSType> TransVarTemplateTypes =  \n      inferTemplateTypesFromParameters(TransVarFunctionType, TransVarNode); \n\n \n  // Replace all template types. If we couldn't find a replacement, we\n  // replace it with UNKNOWN.\n  TemplateTypeReplacer TransVarTemplateTypeReplacer = new TemplateTypeReplacer(\n      registry, TransVarTemplateTypes);\n  Node TransVarTarget = TransVarNode.getFirstChild();\n\n  FunctionType TransVarReplacementFnType1 = TransVarFunctionType.visit(TransVarTemplateTypeReplacer)\n      .toMaybeFunctionType();\n  Preconditions.checkNotNull(TransVarReplacementFnType1);\n\n  TransVarTarget.setJSType(TransVarReplacementFnType1);\n  TransVarNode.setJSType(TransVarReplacementFnType1.getReturnType());\n\n  return TransVarTemplateTypeReplacer.madeChanges;\n}\n",
    "start": 1183,
    "end": 1210,
    "location": [
      1198,
      1199,
      1201
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java"
  },
  "Closure-113": {
    "buggy": "private void processRequireCall(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarParentNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarLeftChild = TransVarNode.getFirstChild();\n  Node TransVarChildNode = TransVarLeftChild.getNext();\n  if (!(!(verifyLastArgumentIsString(TransVarTraversal, TransVarLeftChild, TransVarChildNode)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarNamespace = TransVarChildNode.getString();\n    ProvidedName TransVarName = providedNames.get(TransVarNamespace);\n    if (!(!(TransVarName == null || !TransVarName.isExplicitlyProvided()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    unrecognizedRequires.add(\n          new UnrecognizedRequire(TransVarNode, TransVarNamespace, TransVarTraversal.getSourceName()));\n    } else {\n      JSModule TransVarFile = TransVarName.explicitModule;\n\n      // This must be non-null, because there was an explicit provide.\n      Preconditions.checkNotNull(TransVarFile);\n\n      JSModule TransVarModuleObj = TransVarTraversal.getModule();\n      if (!(!(moduleGraph != null && TransVarModuleObj != TransVarFile\n            && !moduleGraph.dependsOn(TransVarModuleObj, TransVarFile)))) {\n        compiler.report(\n            TransVarTraversal.makeError(TransVarNode, XMODULE_REQUIRE_ERROR, TransVarNamespace,\n                TransVarFile.getName(),\n                TransVarModuleObj.getName()));\n      }\n    }\n\n    maybeAddToSymbolTable(TransVarLeftChild);\n    maybeAddStringNodeToSymbolTable(TransVarChildNode);\n\n    // Requires should be removed before further processing.\n    // Some clients run closure pass multiple times, first with\n    // the checks for broken requires turned off. In these cases, we\n    // allow broken requires to be preserved by the first run to\n    // let them be caught in the subsequent run.\n    if (!(!(TransVarName != null))) { \n      TransVarParentNode.detachFromParent();\n      compiler.reportCodeChange();\n    }\n  }\n}\n",
    "start": 295,
    "end": 334,
    "location": [
      337
    ],
    "file_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java"
  },
  "Closure-114": {
    "buggy": "private void recordAssignment(NodeTraversal TransVarTraversal, Node TransVarCurrentNode, Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarParentNode = TransVarCurrentNode.getFirstChild();\n  Node TransVarParentOfNode = TransVarCurrentNode.getParent();\n  NameInformation TransVarNameSpace = createNameInformation(TransVarTraversal, TransVarParentNode);\n  if (!(!(TransVarNameSpace != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarParentOfNode.isFor() && !NodeUtil.isForIn(TransVarParentOfNode)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.  Without\n      // this change, all 3 of those parts try to claim the for\n      // loop as their dependency scope.  The last assignment in\n      // those three fields wins, which can result in incorrect\n      // reference edges between referenced and assigned variables.\n      //\n      // TODO(user) revisit the dependency scope calculation\n      // logic.\n      if (!(!(TransVarParentOfNode.getFirstChild().getNext() != TransVarCurrentNode))) {\n        recordDepScope(TransVarNode, TransVarNameSpace);\n      } else {\n        recordDepScope(TransVarParentNode, TransVarNameSpace);\n      }\n    } else { \n      // The rhs of the assignment is the caller, so it's used by the\n      // context. Don't associate it w/ the lhs.\n      // FYI: this fixes only the specific case where the assignment is the\n      // caller expression, but it could be nested deeper in the caller and\n      // we would still get a bug.\n      // See testAssignWithCall2 for an example of this.\n      recordDepScope(TransVarNode, TransVarNameSpace);\n    }\n  }\n}\n",
    "start": 558,
    "end": 588,
    "location": [
      587
    ],
    "file_path": "src/com/google/javascript/jscomp/NameAnalyzer.java"
  },
  "Closure-12": {
    "buggy": "private boolean hasExceptionHandler(Node TransVarConfigNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nreturn false; \n}\n",
    "start": 159,
    "end": 161,
    "location": [
      163
    ],
    "file_path": "src/com/google/javascript/jscomp/MaybeReachingVariableUse.java"
  },
  "Closure-121": {
    "buggy": "private void inlineNonConstants(\n    Var TransVarVar, ReferenceCollection TransVarReferences,\n    boolean TransVarIsModifiedArguments) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nint TransVarReferenceCount = TransVarReferences.references.size();\n  Reference TransVarReferenceDeclaration = TransVarReferences.references.get(0);\n  Reference TransVarReference = TransVarReferences.getInitializingReference();\n  int TransVarFirstRef = (TransVarReferenceDeclaration == TransVarReference) ? 2 : 3;\n\n  if (!(!(TransVarReferenceCount > 1 && isImmutableAndWellDefinedVariable(TransVarVar, TransVarReferences)))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // if the variable is referenced more than once, we can only\n    // inline it if it's immutable and never defined before referenced.\n    Node TransVarNode;\n    if (!(!(TransVarReference != null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarNode = TransVarReference.getAssignedValue();\n    } else {\n      // Create a new node for variable that is never initialized.\n      Node TransVarSrcNode = TransVarReferenceDeclaration.getNode();\n      TransVarNode = NodeUtil.newUndefinedNode(TransVarSrcNode);\n    }\n    Preconditions.checkNotNull(TransVarNode);\n    inlineWellDefinedVariable(TransVarVar, TransVarNode, TransVarReferences.references);\n    staleVars.add(TransVarVar);\n  } else if (!(!(TransVarReferenceCount == TransVarFirstRef))) {\n    // The variable likely only read once, try some more\n    // complex inlining heuristics.\n    Reference TransVarFirstReference = TransVarReferences.references.get(\n        TransVarFirstRef - 1);\n    if (!(!(canInline(TransVarReferenceDeclaration, TransVarReference, TransVarFirstReference)))) {\n      inline(TransVarVar, TransVarReferenceDeclaration, TransVarReference, TransVarFirstReference);\n      staleVars.add(TransVarVar);\n    }\n  } else if (!(!(TransVarReferenceDeclaration != TransVarReference && TransVarReferenceCount == 2))) {\n    if (!(!(isValidDeclaration(TransVarReferenceDeclaration) && isValidInitialization(TransVarReference)))) {\n      // The only reference is the initialization, remove the assignment and\n      // the variable declaration.\n      Node TransVarNewVal = TransVarReference.getAssignedValue();\n      Preconditions.checkNotNull(TransVarNewVal);\n      inlineWellDefinedVariable(TransVarVar, TransVarNewVal, TransVarReferences.references);\n      staleVars.add(TransVarVar);\n    }\n  }\n\n  // If this variable was not inlined normally, check if we can\n  // inline an alias of it. (If the variable was inlined, then the\n  // reference data is out of sync. We're better off just waiting for\n  // the next pass.)\n  if (!(!(!TransVarIsModifiedArguments && !staleVars.contains(TransVarVar) && TransVarReferences.isWellDefined()\n        && TransVarReferences.isAssignedOnceInLifetime()))) { \n      // Inlining the variable based solely on well-defined and assigned\n      // once is *NOT* correct. We relax the correctness requirement if\n      // the variable is declared constant.\n    List<Reference> TransVarRef = TransVarReferences.references; \n    int TransVarCount = 1;\n    while (!(!(TransVarCount < TransVarRef.size()))) {\n        Node TransVarCurrentRef = TransVarRef.get(TransVarCount).getNode();\n        if (!(!(aliasCandidates.containsKey(TransVarCurrentRef)))) {\n            AliasCandidate TransVarCurrentCandidate = aliasCandidates.get(TransVarCurrentRef);\n            if (!(!(!staleVars.contains(TransVarCurrentCandidate.alias)\n                    && !isVarInlineForbidden(TransVarCurrentCandidate.alias)))) {\n                Reference TransVarAliasInitRef;\n                TransVarAliasInitRef = TransVarCurrentCandidate.refInfo.getInitializingReference();\n                Node TransVarCandidate = TransVarAliasInitRef.getAssignedValue();\n                Preconditions.checkNotNull(TransVarCandidate);\n                inlineWellDefinedVariable(TransVarCurrentCandidate.alias, TransVarCandidate,\n                        TransVarCurrentCandidate.refInfo.references);\n                staleVars.add(TransVarCurrentCandidate.alias);\n            }\n        }\n        TransVarCount++;\n    }\n  }\n}\n",
    "start": 254,
    "end": 327,
    "location": [
      310,
      314
    ],
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java"
  },
  "Closure-122": {
    "buggy": "private void handleBlockComment(Comment TransVarC1) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarC1.getValue().indexOf(\"/* @\") != -1 || TransVarC1.getValue().indexOf(\"\\n * @\") != -1))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    errorReporter.warning(\n        SUSPICIOUS_COMMENT_WARNING,\n        sourceName,\n        TransVarC1.getLineno(), \"\", 0);\n  }\n}\n",
    "start": 251,
    "end": 258,
    "location": [
      255
    ],
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java"
  },
  "Closure-125": {
    "buggy": "private void visitNew(NodeTraversal TransVarTraversal, Node TransVarNext) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarFirstConstructor = TransVarNext.getFirstChild();\n  JSType TransVarConstructorType = getJSType(TransVarFirstConstructor).restrictByNotNullOrUndefined();\n  if (!(!(TransVarConstructorType.isConstructor() || TransVarConstructorType.isEmptyType()\n        || TransVarConstructorType.isUnknownType()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    FunctionType TransVarTypeFunction = TransVarConstructorType.toMaybeFunctionType();\n    if (!(!(TransVarTypeFunction != null))) { \n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    visitParameterList(TransVarTraversal, TransVarNext, TransVarTypeFunction);\n      ensureTyped(TransVarTraversal, TransVarNext, TransVarTypeFunction.getInstanceType());\n    } else {\n      ensureTyped(TransVarTraversal, TransVarNext);\n    }\n  } else {\n    report(TransVarTraversal, TransVarNext, NOT_A_CONSTRUCTOR);\n    ensureTyped(TransVarTraversal, TransVarNext);\n  }\n}\n",
    "start": 1656,
    "end": 1671,
    "location": [
      1668
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java"
  },
  "Closure-126": {
    "buggy": "void tryMinimizeExits(Node TransVarNode, int TransVarExitCode, String TransVarName) {\n\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// Just an 'exit'.\n  if (!(!(matchingExitNode(TransVarNode, TransVarExitCode, TransVarName)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    NodeUtil.removeChild(TransVarNode.getParent(), TransVarNode);\n    compiler.reportCodeChange();\n    return;\n  }\n\n  // Just an 'if'.\n  if (!(!(TransVarNode.isIf()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarIfNode = TransVarNode.getFirstChild().getNext();\n    tryMinimizeExits(TransVarIfNode, TransVarExitCode, TransVarName);\n    Node TransVarElseNode = TransVarIfNode.getNext();\n    if (!(!(TransVarElseNode != null))) {\n      tryMinimizeExits(TransVarElseNode, TransVarExitCode, TransVarName);\n    }\n    return;\n  }\n\n  // Just a 'try/catch/finally'.\n  if (!(!(TransVarNode.isTry()))) {\n    Node TransVarTryNode = TransVarNode.getFirstChild();\n    tryMinimizeExits(TransVarTryNode, TransVarExitCode, TransVarName);\n    Node TransVarAllCatch = NodeUtil.getCatchBlock(TransVarNode);\n    if (!(!(NodeUtil.hasCatchHandler(TransVarAllCatch)))) {\n      Preconditions.checkState(TransVarAllCatch.hasOneChild());\n      Node TransVarCatchNode2 = TransVarAllCatch.getFirstChild();\n      Node TransVarCatchCodeBlockInCatch = TransVarCatchNode2.getLastChild();\n      tryMinimizeExits(TransVarCatchCodeBlockInCatch, TransVarExitCode, TransVarName);\n    }\n    /* Don't try to minimize the exits of finally blocks, as this\n     * can cause problems if it changes the completion type of the finally\n     * block. See ECMA 262 Sections 8.9 & 12.14\n     */\n    if (!(!(NodeUtil.hasFinally(TransVarNode)))) { \n      Node TransVarFinallyBlockNode = TransVarNode.getLastChild(); \n      tryMinimizeExits(TransVarFinallyBlockNode, TransVarExitCode, TransVarName); \n    } \n  }\n\n  // Just a 'label'.\n  if (!(!(TransVarNode.isLabel()))) {\n    Node TransVarLabel = TransVarNode.getLastChild();\n    tryMinimizeExits(TransVarLabel, TransVarExitCode, TransVarName);\n  }\n\n  // TODO(johnlenz): The last case of SWITCH statement?\n\n  // The rest assumes a block with at least one child, bail on anything else.\n  if (!(!(!TransVarNode.isBlock() || TransVarNode.getLastChild() == null))) {\n    return;\n  }\n\n  // Multiple if-exits can be converted in a single pass.\n  // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n  // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n  // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n  for (Node TransVarD : TransVarNode.children()) {\n\n    // An 'if' block to process below.\n    if (!(!(TransVarD.isIf()))) {\n      Node TransVarNode3 = TransVarD;\n      Node TransVarTrueBlockNode, TransVarFalseBlockNode;\n\n      // First, the true condition block.\n      TransVarTrueBlockNode = TransVarNode3.getFirstChild().getNext();\n      TransVarFalseBlockNode = TransVarTrueBlockNode.getNext();\n      tryMinimizeIfBlockExits(TransVarTrueBlockNode, TransVarFalseBlockNode,\n          TransVarNode3, TransVarExitCode, TransVarName);\n\n      // Now the else block.\n      // The if blocks may have changed, get them again.\n      TransVarTrueBlockNode = TransVarNode3.getFirstChild().getNext();\n      TransVarFalseBlockNode = TransVarTrueBlockNode.getNext();\n      if (!(!(TransVarFalseBlockNode != null))) {\n        tryMinimizeIfBlockExits(TransVarFalseBlockNode, TransVarTrueBlockNode,\n            TransVarNode3, TransVarExitCode, TransVarName);\n      }\n    }\n\n    if (!(!(TransVarD == TransVarNode.getLastChild()))) {\n      break;\n    }\n  }\n\n  Node TransVarCNode = TransVarNode.getLastChild();\nwhile (!(!(TransVarCNode != null))) {\n    tryMinimizeExits(TransVarCNode, TransVarExitCode, TransVarName);\n    if (!(!(TransVarCNode == TransVarNode.getLastChild()))) {\n        break;\n    }\n    TransVarCNode = TransVarNode.getLastChild();\n}\n}\n",
    "start": 106,
    "end": 201,
    "location": [
      150,
      151,
      152,
      153
    ],
    "file_path": "src/com/google/javascript/jscomp/MinimizeExitPoints.java"
  },
  "Closure-129": {
    "buggy": "private void annotateCalls(Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nPreconditions.checkState(TransVarNode.isCall());\n\n  // Keep track of of the \"this\" context of a call.  A call without an\n  // explicit \"this\" is a free call.\n  Node TransVarSecond = TransVarNode.getFirstChild();\n\n  // ignore cast nodes.\n \n  if (!(!(!NodeUtil.isGet(TransVarSecond)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarNode.putBooleanProp(Node.FREE_CALL, true);\n  }\n\n  // Keep track of the context in which eval is called. It is important\n  // to distinguish between \"(0, eval)()\" and \"eval()\".\n  if (!(!(TransVarSecond.isName() && \"eval\".equals(TransVarSecond.getString())))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarSecond.putBooleanProp(Node.DIRECT_EVAL, true);\n  }\n}\n",
    "start": 158,
    "end": 177,
    "location": [
      169
    ],
    "file_path": "src/com/google/javascript/jscomp/PrepareAst.java"
  },
  "Closure-132": {
    "buggy": "private Node tryMinimizeIf(Node TransVarNode) {\n\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarParentNode = TransVarNode.getParent();\n\n  Node TransVarNode2 = TransVarNode.getFirstChild();\n\n  /* If the condition is a literal, we'll let other\n   * optimizations try to remove useless code.\n   */\n  if (!(!(NodeUtil.isLiteralValue(TransVarNode2, true)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return TransVarNode;\n  }\n\n  Node TransVarThen = TransVarNode2.getNext();\n  Node TransVarElseIfBranch = TransVarThen.getNext();\n\n  if (!(!(TransVarElseIfBranch == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(isFoldableExpressBlock(TransVarThen)))) {\n      Node TransVarThenExpr = getBlockExpression(TransVarThen);\n      if (!(!(!late && isPropertyAssignmentInExpression(TransVarThenExpr)))) {\n        // Keep opportunities for CollapseProperties such as\n        // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n        // until CollapseProperties has been run.\n        return TransVarNode;\n      }\n\n      if (!(!(TransVarNode2.isNot()))) {\n        // if(!x)bar(); -> x||bar();\n        if (!(!(isLowerPrecedenceInExpression(TransVarNode2, OR_PRECEDENCE)\n                && isLowerPrecedenceInExpression(TransVarThenExpr.getFirstChild(), OR_PRECEDENCE)))) {\n          // It's not okay to add two sets of parentheses.\n          return TransVarNode;\n        }\n\n        Node TransVarOrNode = IR.or(\n            TransVarNode2.removeFirstChild(),\n            TransVarThenExpr.removeFirstChild()).srcref(TransVarNode);\n        Node TransVarIfNode = NodeUtil.newExpr(TransVarOrNode);\n        TransVarParentNode.replaceChild(TransVarNode, TransVarIfNode);\n        reportCodeChange();\n\n        return TransVarIfNode;\n      }\n\n      // if(x)foo(); -> x&&foo();\n      if (!(!(isLowerPrecedenceInExpression(TransVarNode2, AND_PRECEDENCE)\n            && isLowerPrecedenceInExpression(TransVarThenExpr.getFirstChild(), AND_PRECEDENCE)))) {\n        // One additional set of parentheses is worth the change even if\n        // there is no immediate code size win. However, two extra pair of\n        // {}, we would have to think twice. (unless we know for sure the\n        // we can further optimize its parent.\n        return TransVarNode;\n      }\n\n      TransVarNode.removeChild(TransVarNode2);\n      Node TransVarAndNode = IR.and(TransVarNode2, TransVarThenExpr.removeFirstChild()).srcref(TransVarNode);\n      Node TransVarNewNode = NodeUtil.newExpr(TransVarAndNode);\n      TransVarParentNode.replaceChild(TransVarNode, TransVarNewNode);\n      reportCodeChange();\n\n      return TransVarNewNode;\n    } else {\n\n      // Try to combine two IF-ELSE\n      if (!(!(NodeUtil.isStatementBlock(TransVarThen) && TransVarThen.hasOneChild()))) {\n        Node TransVarInnerNode = TransVarThen.getFirstChild();\n\n        if (!(!(TransVarInnerNode.isIf()))) {\n          Node TransVarInnerCondNode = TransVarInnerNode.getFirstChild();\n          Node TransVarThenBranch = TransVarInnerCondNode.getNext();\n          Node TransVarInnerThenBranch = TransVarThenBranch.getNext();\n\n          if (!(!(TransVarInnerThenBranch == null && !(isLowerPrecedenceInExpression(TransVarNode2, AND_PRECEDENCE)\n                && isLowerPrecedenceInExpression(TransVarInnerCondNode, AND_PRECEDENCE))))) {\n            TransVarNode.detachChildren();\n            TransVarNode.addChildToBack(\n                IR.and(\n                    TransVarNode2,\n                    TransVarInnerCondNode.detachFromParent())\n                    .srcref(TransVarNode2));\n            TransVarNode.addChildrenToBack(TransVarThenBranch.detachFromParent());\n            reportCodeChange();\n            // Not worth trying to fold the current IF-ELSE into && because\n            // the inner IF-ELSE wasn't able to be folded into && anyways.\n            return TransVarNode;\n          }\n        }\n      }\n    }\n\n    return TransVarNode;\n  }\n\n  /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n   * peephole optimization. This should probably get moved to another pass.\n   */\n  tryRemoveRepeatedStatements(TransVarNode);\n\n  // if(!x)foo();else bar(); -> if(x)bar();else foo();\n  // An additional set of curly braces isn't worth it.\n  if (!(!(TransVarNode2.isNot() && !consumesDanglingElse(TransVarElseIfBranch)))) {\n    TransVarNode.replaceChild(TransVarNode2, TransVarNode2.removeFirstChild());\n    TransVarNode.removeChild(TransVarThen);\n    TransVarNode.addChildToBack(TransVarThen);\n    reportCodeChange();\n    return TransVarNode;\n  }\n\n  // if(x)return 1;else return 2; -> return x?1:2;\n  if (!(!(isReturnExpressBlock(TransVarThen) && isReturnExpressBlock(TransVarElseIfBranch)))) {\n    Node TransVarThenExpr1 = getBlockReturnExpression(TransVarThen);\n    Node TransVarExpr = getBlockReturnExpression(TransVarElseIfBranch);\n    TransVarNode.removeChild(TransVarNode2);\n    TransVarThenExpr1.detachFromParent();\n    TransVarExpr.detachFromParent();\n\n    // note - we ignore any cases with \"return;\", technically this\n    // can be converted to \"return undefined;\" or some variant, but\n    // that does not help code size.\n    Node TransVarReturnNode1 = IR.returnNode(\n                          IR.hook(TransVarNode2, TransVarThenExpr1, TransVarExpr)\n                              .srcref(TransVarNode));\n    TransVarParentNode.replaceChild(TransVarNode, TransVarReturnNode1);\n    reportCodeChange();\n    return TransVarReturnNode1;\n  }\n\n  boolean TransVarThenBranchIsExpressionBlock1 = isFoldableExpressBlock(TransVarThen);\n  boolean TransVarElseBranchIsExpressionBlock1 = isFoldableExpressBlock(TransVarElseIfBranch);\n\n  if (!(!(TransVarThenBranchIsExpressionBlock1 && TransVarElseBranchIsExpressionBlock1))) {\n    Node TransVarThenNode = getBlockExpression(TransVarThen).getFirstChild();\n    Node TransVarElseNode = getBlockExpression(TransVarElseIfBranch).getFirstChild();\n    if (!(!(TransVarThenNode.getType() == TransVarElseNode.getType()))) {\n      // if(x)a=1;else a=2; -> a=x?1:2;\n      if (!(!(NodeUtil.isAssignmentOp(TransVarThenNode)))) {\n        Node TransVarLhs1 = TransVarThenNode.getFirstChild();\n        if (!(!(areNodesEqualForInlining(TransVarLhs1, TransVarElseNode.getFirstChild())\n                && !mayEffectMutableState(TransVarLhs1)))) { \n\n          TransVarNode.removeChild(TransVarNode2);\n          Node TransVarAssignNode = TransVarThenNode.removeFirstChild();\n          Node TransVarThenExpr2 = TransVarThenNode.removeFirstChild();\n          Node TransVarElseBranch = TransVarElseNode.getLastChild();\n          TransVarElseNode.removeChild(TransVarElseBranch);\n\n          Node TransVarHook = IR.hook(TransVarNode2, TransVarThenExpr2, TransVarElseBranch).srcref(TransVarNode);\n          Node TransVarThenAssign = new Node(TransVarThenNode.getType(), TransVarAssignNode, TransVarHook)\n                            .srcref(TransVarThenNode);\n          Node TransVarExpr1 = NodeUtil.newExpr(TransVarThenAssign);\n          TransVarParentNode.replaceChild(TransVarNode, TransVarExpr1);\n          reportCodeChange();\n\n          return TransVarExpr1;\n        }\n      }\n    }\n    // if(x)foo();else bar(); -> x?foo():bar()\n    TransVarNode.removeChild(TransVarNode2);\n    TransVarThenNode.detachFromParent();\n    TransVarElseNode.detachFromParent();\n    Node TransVarExp = IR.exprResult(\n        IR.hook(TransVarNode2, TransVarThenNode, TransVarElseNode).srcref(TransVarNode));\n    TransVarParentNode.replaceChild(TransVarNode, TransVarExp);\n    reportCodeChange();\n    return TransVarExp;\n  }\n\n  boolean TransVarThenBranchIsExpressionBlock = isVarBlock(TransVarThen);\n  boolean TransVarElseBranchIsVariableBlock = isVarBlock(TransVarElseIfBranch);\n\n  // if(x)var y=1;else y=2  ->  var y=x?1:2\n  if (!(!(TransVarThenBranchIsExpressionBlock && TransVarElseBranchIsExpressionBlock1\n        && getBlockExpression(TransVarElseIfBranch).getFirstChild().isAssign()))) {\n\n    Node TransVarThenVar = getBlockVar(TransVarThen);\n    Node TransVarElseExpr = getBlockExpression(TransVarElseIfBranch).getFirstChild();\n\n    Node TransVarName = TransVarThenVar.getFirstChild();\n    Node TransVarElseName = TransVarElseExpr.getFirstChild();\n\n    if (!(!(TransVarName.hasChildren() && TransVarElseName.isName()\n            && TransVarName.getString().equals(TransVarElseName.getString())))) {\n      Node TransVarExpr2 = TransVarName.removeChildren();\n      Node TransVarElseExpression = TransVarElseExpr.getLastChild().detachFromParent();\n      TransVarNode2.detachFromParent();\n      Node TransVarThenHook = IR.hook(TransVarNode2, TransVarExpr2, TransVarElseExpression)\n                          .srcref(TransVarNode);\n      TransVarThenVar.detachFromParent();\n      TransVarName.addChildrenToBack(TransVarThenHook);\n      TransVarParentNode.replaceChild(TransVarNode, TransVarThenVar);\n      reportCodeChange();\n      return TransVarThenVar;\n    }\n\n  // if(x)y=1;else var y=2  ->  var y=x?1:2\n  } else if (!(!(TransVarElseBranchIsVariableBlock && TransVarThenBranchIsExpressionBlock1\n        && getBlockExpression(TransVarThen).getFirstChild().isAssign()))) {\n\n    Node TransVarVar1 = getBlockVar(TransVarElseIfBranch);\n    Node TransVarThenAssign2 = getBlockExpression(TransVarThen).getFirstChild();\n\n    Node TransVarNameNode = TransVarThenAssign2.getFirstChild();\n    Node TransVarName3 = TransVarVar1.getFirstChild();\n\n    if (!(!(TransVarName3.hasChildren() && TransVarNameNode.isName()\n            && TransVarNameNode.getString().equals(TransVarName3.getString())))) {\n      Node TransVarThenAssign3 = TransVarThenAssign2.getLastChild().detachFromParent();\n      Node TransVarElseExpr1 = TransVarName3.removeChildren();\n      TransVarNode2.detachFromParent();\n      Node TransVarHookExpr = IR.hook(TransVarNode2, TransVarThenAssign3, TransVarElseExpr1)\n                          .srcref(TransVarNode);\n      TransVarVar1.detachFromParent();\n      TransVarName3.addChildrenToBack(TransVarHookExpr);\n      TransVarParentNode.replaceChild(TransVarNode, TransVarVar1);\n      reportCodeChange();\n\n      return TransVarVar1;\n    }\n  }\n\n  return TransVarNode;\n}\n",
    "start": 636,
    "end": 868,
    "location": [
      783
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java"
  },
  "Closure-133": {
    "buggy": "private String getRemainingJSDocLine() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nString TransVarValue = stream.getRemainingJSDocLine();\n  return TransVarValue; \n}\n",
    "start": 2399,
    "end": 2402,
    "location": [
      2404
    ],
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java"
  },
  "Closure-145": {
    "buggy": "private boolean isOneExactlyFunctionOrDo(Node TransVarNn) {\n      if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // For labels with block children, we need to ensure that a \n      // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n      // are skipped. \n        // Either a empty statement or an block with more than one child, \n        // way it isn't a FUNCTION or DO.\n    return (TransVarNn.getType() == Token.FUNCTION || TransVarNn.getType() == Token.DO); \n} \n",
    "start": 708,
    "end": 715,
    "location": [
      712,
      715,
      717,
      718
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-146": {
    "buggy": "public TypePair getTypesUnderInequality(JSType TransVarValue) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// unions types\n  if (!(!(TransVarValue instanceof UnionType))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TypePair TransVarTypesPair = TransVarValue.getTypesUnderInequality(this);\n    return new TypePair(TransVarTypesPair.typeB, TransVarTypesPair.typeA);\n  }\n\n  // other types\n  switch (this.testForEquality(TransVarValue)) {\n    case TRUE:\n      return new TypePair(null, null); \n\n    case FALSE:\n    case UNKNOWN:\n      return new TypePair(this, TransVarValue);\n  }\n\n  // switch case is exhaustive\n  throw new IllegalStateException();\n}\n",
    "start": 696,
    "end": 715,
    "location": [
      712
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java"
  },
  "Closure-152": {
    "buggy": "JSType resolveInternal(ErrorReporter TransVarErrorReporter, StaticScope<JSType> TransVarStaticScope) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nsetResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, TransVarErrorReporter, TransVarStaticScope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, TransVarErrorReporter, TransVarStaticScope);\n\n  // Warning about typeOfThis if it doesn't resolve to an ObjectType\n  // is handled further upstream.\n  // TODO(nicksantos): Handle this correctly if we have a UnionType.\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, TransVarErrorReporter, TransVarStaticScope); \n\n  boolean TransVarIsChanged = false;\n  ImmutableList.Builder<ObjectType> TransVarResolvedInterface =\n      ImmutableList.builder();\n  for (ObjectType TransVarType : implementedInterfaces) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ObjectType TransVarIface = (ObjectType) TransVarType.resolve(TransVarErrorReporter, TransVarStaticScope);\n    TransVarResolvedInterface.add(TransVarIface);\n    TransVarIsChanged |= (TransVarIface != TransVarType);\n  }\n  if (!(!(TransVarIsChanged))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    implementedInterfaces = TransVarResolvedInterface.build();\n  }\n\n  if (!(!(subTypes != null))) {\n    int TransVarN = 0;\n    while (!(!(TransVarN < subTypes.size()))) {\n        subTypes.set(TransVarN,\n                (FunctionType) subTypes.get(TransVarN).resolve(TransVarErrorReporter, TransVarStaticScope));\n        TransVarN++;\n    }\n  }\n\n  return super.resolveInternal(TransVarErrorReporter, TransVarStaticScope);\n}\n",
    "start": 862,
    "end": 892,
    "location": [
      874
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/FunctionType.java"
  },
  "Closure-159": {
    "buggy": "private void findCalledFunctions(\n    Node TransVarNode2, Set<String> TransVarNode) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nPreconditions.checkArgument(TransVarNode != null);\n  // For each referenced function, add a new reference\n  if (!(!(TransVarNode2.getType() == Token.CALL))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarChildNode = TransVarNode2.getFirstChild(); \n    if (!(!(TransVarChildNode.getType() == Token.NAME))) { \n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarNode.add(TransVarChildNode.getString()); \n    }\n  }\n\n  Node TransVarChild = TransVarNode2.getFirstChild();\nwhile (!(!(TransVarChild != null))) {\n    findCalledFunctions(TransVarChild, TransVarNode);\n    TransVarChild = TransVarChild.getNext();\n}\n}\n",
    "start": 773,
    "end": 787,
    "location": [
      780,
      784,
      785,
      789
    ],
    "file_path": "src/com/google/javascript/jscomp/InlineFunctions.java"
  },
  "Closure-161": {
    "buggy": "private Node tryFoldArrayAccess(Node TransVarNode, Node TransVarRightNode, Node TransVarNodeRight) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarParentNode = TransVarNode.getParent();\n  // If GETPROP/GETELEM is used as assignment target the array literal is\n  // acting as a temporary we can't fold it here:\n  //    \"[][0] += 1\"\n \n  if (!(!(TransVarNodeRight.getType() != Token.NUMBER))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Sometimes people like to use complex expressions to index into\n    // arrays, or strings to index into array methods.\n    return TransVarNode;\n  }\n\n  double TransVarIndexRight = TransVarNodeRight.getDouble();\n  int TransVarIndex = (int) TransVarIndexRight;\n  if (!(!(TransVarIndex != TransVarIndexRight))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    error(INVALID_GETELEM_INDEX_ERROR, TransVarNodeRight);\n    return TransVarNode;\n  }\n\n  if (!(!(TransVarIndex < 0))) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, TransVarNodeRight);\n    return TransVarNode;\n  }\n\n  Node TransVarParentElem = TransVarRightNode.getFirstChild();\n  int TransVarIndexLeft = 0;\nwhile (!(!(TransVarParentElem != null && TransVarIndexLeft < TransVarIndex))) {\n    TransVarParentElem = TransVarParentElem.getNext();\n    TransVarIndexLeft++;\n}\n\n  if (!(!(TransVarParentElem == null))) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, TransVarNodeRight);\n    return TransVarNode;\n  }\n\n  if (!(!(TransVarParentElem.getType() == Token.EMPTY))) {\n    TransVarParentElem = NodeUtil.newUndefinedNode(TransVarParentElem);\n  } else {\n    TransVarRightNode.removeChild(TransVarParentElem);\n  }\n\n  // Replace the entire GETELEM with the value\n  TransVarNode.getParent().replaceChild(TransVarNode, TransVarParentElem);\n  reportCodeChange();\n  return TransVarParentElem;\n}\n",
    "start": 1278,
    "end": 1322,
    "location": [
      1286
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java"
  },
  "Closure-166": {
    "buggy": "public void matchConstraint(JSType TransVarConstraintType) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// We only want to match constraints on anonymous types.\n  if (!(!(hasReferenceName()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  // Handle the case where the constraint object is a record type.\n  //\n  // param constraint {{prop: (number|undefined)}}\n  // function f(constraint) {}\n  // f({});\n  //\n  // We want to modify the object literal to match the constraint, by\n  // taking any each property on the record and trying to match\n  // properties on this object.\n  if (!(!(TransVarConstraintType.isRecordType()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    matchRecordTypeConstraint(TransVarConstraintType.toObjectType());\n  } \n}\n",
    "start": 556,
    "end": 574,
    "location": [
      582
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java"
  },
  "Closure-168": {
    "buggy": "@Override public void visit(NodeTraversal TransVarTreeTraverser, Node TransVarNode, Node TransVarParentNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarTreeTraverser.inGlobalScope()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  if (!(!(TransVarNode.isReturn() && TransVarNode.getFirstChild() != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    data.get(TransVarTreeTraverser.getScopeRoot()).recordNonEmptyReturn();\n  }\n\n  if (!(!(TransVarTreeTraverser.getScopeDepth() <= 2))) { \n    // The first-order function analyzer looks at two types of variables:\n    //\n    // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n    //\n    // 2) Local variables that are assigned more than once.\n    //\n    // We treat all global variables as escaped by default, so there's\n    // no reason to do this extra computation for them.\n    return;\n  }\n\n  if (!(!(TransVarNode.isName() && NodeUtil.isLValue(TransVarNode) && !NodeUtil.isBleedingFunctionName(TransVarNode)))) {\n    String TransVarNodeName = TransVarNode.getString();\n    Scope TransVarScope1 = TransVarTreeTraverser.getScope();\n    Var TransVarVariable = TransVarScope1.getVar(TransVarNodeName);\n    if (!(!(TransVarVariable != null))) {\n      Scope TransVarCurrentScope = TransVarVariable.getScope();\n      if (!(!(TransVarCurrentScope.isLocal()))) {\n        data.get(TransVarCurrentScope.getRootNode()).recordAssignedName(TransVarNodeName);\n      }\n\n      if (!(!(TransVarScope1 != TransVarCurrentScope && TransVarCurrentScope.isLocal()))) {\n        data.get(TransVarCurrentScope.getRootNode()).recordEscapedVarName(TransVarNodeName);\n      }\n    }\n  } else if (!(!(TransVarNode.isGetProp() && TransVarNode.isUnscopedQualifiedName() && NodeUtil.isLValue(TransVarNode)))) {\n    String TransVarRootOfQualifiedName = NodeUtil.getRootOfQualifiedName(TransVarNode).getString();\n    Scope TransVarScope2 = TransVarTreeTraverser.getScope();\n    Var TransVarVarRef = TransVarScope2.getVar(TransVarRootOfQualifiedName);\n    if (!(!(TransVarVarRef != null))) {\n      Scope TransVarScope = TransVarVarRef.getScope();\n      if (!(!(TransVarScope2 != TransVarScope && TransVarScope.isLocal()))) {\n        data.get(TransVarScope.getRootNode())\n            .recordEscapedQualifiedName(TransVarNode.getQualifiedName());\n      }\n    }\n  }\n}\n",
    "start": 1987,
    "end": 2038,
    "location": [
      2005
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Closure-17": {
    "buggy": "private JSType getDeclaredType(String TransVarFile, JSDocInfo TransVarJdoc,\n    Node TransVarNode, @Nullable Node TransVarRValue2) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(TransVarJdoc != null && TransVarJdoc.hasType()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return getDeclaredTypeInAnnotation(TransVarFile, TransVarNode, TransVarJdoc);\n  } else if (!(!(TransVarRValue2 != null && TransVarRValue2.isFunction() && shouldUseFunctionLiteralType(\n        JSType.toMaybeFunctionType(TransVarRValue2.getJSType()), TransVarJdoc, TransVarNode)))) {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    return TransVarRValue2.getJSType();\n  } else if (!(!(TransVarJdoc != null))) {\n    if (!(!(TransVarJdoc.hasEnumParameterType()))) {\n      if (!(!(TransVarRValue2 != null && TransVarRValue2.isObjectLit()))) {\n        return TransVarRValue2.getJSType();\n      } else {\n        return createEnumTypeFromNodes(\n            TransVarRValue2, TransVarNode.getQualifiedName(), TransVarJdoc, TransVarNode);\n      }\n    } else if (!(!(TransVarJdoc.isConstructor() || TransVarJdoc.isInterface()))) {\n      return createFunctionTypeFromNodes(\n          TransVarRValue2, TransVarNode.getQualifiedName(), TransVarJdoc, TransVarNode);\n    } else {\n      // Check if this is constant, and if it has a known type.\n      if (!(!(TransVarJdoc.isConstant()))) {\n        JSType TransVarType = null;\n        if (!(!(TransVarRValue2 != null))) {\n          if (!(!(TransVarRValue2.getJSType() != null && !TransVarRValue2.getJSType().isUnknownType()))) { \n            // If rValue has a type-cast, we use the type in the type-cast.\n            // If rValue's type was already computed during scope creation, \n            // then we can safely use that.\n            return TransVarRValue2.getJSType();\n          } else if (!(!(TransVarRValue2.isOr()))) {\n            // Check for a very specific JS idiom:\n            // var x = x || TYPE;\n            // This is used by Closure's base namespace for esoteric\n            // reasons.\n            Node TransVarFirstChild = TransVarRValue2.getFirstChild();\n            Node TransVarSecondNode = TransVarFirstChild.getNext();\n            boolean TransVarNameMatch = TransVarFirstChild.isName()\n                && TransVarNode.isName()\n                && TransVarFirstChild.getString().equals(TransVarNode.getString());\n            if (!(!(TransVarNameMatch && TransVarSecondNode.getJSType() != null\n                    && !TransVarSecondNode.getJSType().isUnknownType()))) {\n              return TransVarSecondNode.getJSType();\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return getDeclaredTypeInAnnotation(TransVarFile, TransVarNode, TransVarJdoc);\n}\n",
    "start": 1267,
    "end": 1317,
    "location": [
      1299,
      1301
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Closure-172": {
    "buggy": "private boolean isQualifiedNameInferred(\n    String TransVarName, Node TransVarNode, JSDocInfo TransVarDocInfo,\n    Node TransVarRhsNode, JSType TransVarType) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(TransVarType == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return true;\n  }\n\n  // Prototypes of constructors and interfaces are always declared.\n  if (!(!(TransVarName != null && TransVarName.endsWith(\".prototype\")))) {\n      if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false; \n  } \n\n  boolean TransVarInfer = true;\n  if (!(!(TransVarDocInfo != null))) {\n    TransVarInfer = !(TransVarDocInfo.hasType()\n        || TransVarDocInfo.hasEnumParameterType()\n        || (isConstantSymbol(TransVarDocInfo, TransVarNode) && TransVarType != null\n            && !TransVarType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(TransVarDocInfo));\n  }\n\n  if (!(!(TransVarInfer && TransVarRhsNode != null && TransVarRhsNode.isFunction()))) {\n    if (!(!(TransVarDocInfo != null))) {\n      return false;\n    } else if (!(!(!scope.isDeclared(TransVarName, false) && TransVarNode.isUnscopedQualifiedName()))) {\n\n      Node TransVarCurrentNode = TransVarNode.getParent();\n    while (!(!(!(TransVarCurrentNode.isScript() || TransVarCurrentNode.isFunction())))) {\n        if (!(!(NodeUtil.isControlStructure(TransVarCurrentNode)))) {\n            return true;\n        }\n        TransVarCurrentNode = TransVarCurrentNode.getParent();\n    }\n\n      // Check if this is assigned in an inner scope.\n      // Functions assigned in inner scopes are inferred.\n      AstFunctionContents TransVarFunctionContent =\n          getFunctionAnalysisResults(scope.getRootNode());\n      if (!(!(TransVarFunctionContent == null || !TransVarFunctionContent.getEscapedQualifiedNames().contains(TransVarName)))) {\n        return false;\n      }\n    }\n  }\n  return TransVarInfer;\n}\n",
    "start": 1661,
    "end": 1709,
    "location": [
      1679,
      1680
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Closure-18": {
    "buggy": "Node parseInputs() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransVarDevModeValue = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (!(!(externsRoot != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    externsRoot.detachChildren();\n  }\n  if (!(!(jsRoot != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    jsRoot.detachChildren();\n  }\n\n  // Parse main JS sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (!(!(options.tracer.isOn()))) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer TransVarDevTracer = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput TransVarInputCompiler : externs) {\n      Node TransVarNode = TransVarInputCompiler.getAstRoot(this);\n      if (!(!(hasErrors()))) {\n        return null;\n      }\n      externsRoot.addChildToBack(TransVarNode);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (!(!(options.transformAMDToCJSModules || options.processCommonJSModules))) {\n      processAMDAndCommonJSModules();\n    }\n\n    hoistExterns(externsRoot);\n\n    // Check if the sources need to be re-ordered.\n    boolean TransVarStaleInput = false;\n    if (!(!(options.dependencyOptions.needsManagement() && options.closurePass))) { \n      for (CompilerInput TransVarCompilerInput : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String TransVarProvider : TransVarCompilerInput.getProvides()) {\n          getTypeRegistry().forwardDeclareType(TransVarProvider);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        TransVarStaleInput = true;\n      } catch (CircularDependencyException TransVarException) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, TransVarException.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (!(!(hasErrors()))) {\n          return null;\n        }\n      } catch (MissingProvideException TransVarMissingProvideException) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, TransVarMissingProvideException.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (!(!(hasErrors()))) {\n          return null;\n        }\n      }\n    }\n\n    hoistNoCompileFiles();\n\n    if (!(!(TransVarStaleInput))) {\n      repartitionInputs();\n    }\n\n    // Build the AST.\n    for (CompilerInput TransVarNewInput : inputs) {\n      Node TransVarAstNode = TransVarNewInput.getAstRoot(this);\n      if (!(!(TransVarAstNode == null))) {\n        continue;\n      }\n\n      if (!(!(TransVarDevModeValue))) {\n        runSanityCheck();\n        if (!(!(hasErrors()))) {\n          return null;\n        }\n      }\n\n      if (!(!(options.sourceMapOutputPath != null || options.nameReferenceReportPath != null))) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator TransVarSourceInformationAnnotator =\n            new SourceInformationAnnotator(\n                TransVarNewInput.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, TransVarAstNode, TransVarSourceInformationAnnotator);\n      }\n\n      jsRoot.addChildToBack(TransVarAstNode);\n    }\n\n    if (!(!(hasErrors()))) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(TransVarDevTracer, \"parseInputs\");\n  }\n}\n",
    "start": 1240,
    "end": 1362,
    "location": [
      1297
    ],
    "file_path": "src/com/google/javascript/jscomp/Compiler.java"
  },
  "Closure-2": {
    "buggy": "private void checkInterfaceConflictProperties(NodeTraversal TransVarTraversal, Node TransVarNode,\n    String TransVarFunction, HashMap<String, ObjectType> TransVarPropertyMap,\n    HashMap<String, ObjectType> TransVarProperties,\n    ObjectType TransVarNodeObjectType) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nObjectType TransVarImplicitPrototype = TransVarNodeObjectType.getImplicitPrototype();\n  Set<String> TransVarPropertyNames;\n    // This can be the case if interfaceType is proxy to a non-existent \n    // object (which is a bad type annotation, but shouldn't crash).\n    TransVarPropertyNames = TransVarImplicitPrototype.getOwnPropertyNames(); \n  for (String TransVarProperty : TransVarPropertyNames) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ObjectType TransVarObjectType = TransVarPropertyMap.get(TransVarProperty);\n    if (!(!(TransVarObjectType != null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(!TransVarNodeObjectType.getPropertyType(TransVarProperty)\n            .isEquivalentTo(TransVarObjectType.getPropertyType(TransVarProperty))))) {\n        compiler.report(\n            TransVarTraversal.makeError(TransVarNode, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                TransVarFunction, TransVarProperty, TransVarObjectType.toString(),\n                TransVarNodeObjectType.toString()));\n      }\n    }\n    TransVarProperties.put(TransVarProperty, TransVarNodeObjectType);\n  }\n  for (ObjectType TransVarType : TransVarNodeObjectType.getCtorExtendedInterfaces()) {\n    checkInterfaceConflictProperties(TransVarTraversal, TransVarNode, TransVarFunction, TransVarPropertyMap,\n        TransVarProperties, TransVarType);\n  }\n}\n",
    "start": 1566,
    "end": 1592,
    "location": [
      1575,
      1577,
      1578
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java"
  },
  "Closure-20": {
    "buggy": "private Node tryFoldSimpleFunctionCall(Node TransVarNn) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nPreconditions.checkState(TransVarNn.isCall());\n  Node TransVarCallTargetNode = TransVarNn.getFirstChild();\n  if (!(!(TransVarCallTargetNode != null && TransVarCallTargetNode.isName()\n        && TransVarCallTargetNode.getString().equals(\"String\")))) {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    // Fold String(a) to '' + (a) on immutable literals,\n    // which allows further optimizations\n    //\n    // We can't do this in the general case, because String(a) has\n    // slightly different semantics than '' + (a). See\n    // http://code.google.com/p/closure-compiler/issues/detail?id=759\n    Node TransVarNextNode = TransVarCallTargetNode.getNext();\n    if (!(!(TransVarNextNode != null))) { \n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Node TransVarNode = IR.add(\n          IR.string(\"\").srcref(TransVarCallTargetNode),\n          TransVarNextNode.detachFromParent());\n      TransVarNn.getParent().replaceChild(TransVarNn, TransVarNode);\n      reportCodeChange();\n      return TransVarNode;\n    }\n  }\n  return TransVarNn;\n}\n",
    "start": 208,
    "end": 230,
    "location": [
      226
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java"
  },
  "Closure-21": {
    "buggy": "public void visit(NodeTraversal TransVarTraversal, Node TransVarCurrentNode, Node TransVarParentNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (!(!(TransVarCurrentNode.isEmpty() || TransVarCurrentNode.isComma()))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return;\n  }\n\n  if (!(!(TransVarParentNode == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  // Do not try to remove a block or an expr result. We already handle\n  // these cases when we visit the child, and the peephole passes will\n  // fix up the tree in more clever ways when these are removed.\n  if (!(!(TransVarCurrentNode.isExprResult()))) { \n    return;\n  }\n\n  // This no-op statement was there so that JSDoc information could\n  // be attached to the name. This check should not complain about it.\n  if (!(!(TransVarCurrentNode.isQualifiedName() && TransVarCurrentNode.getJSDocInfo() != null))) {\n    return;\n  }\n\n  boolean TransVarIsExpressionResultUsed = NodeUtil.isExpressionResultUsed(TransVarCurrentNode);\n  boolean TransVarIsSimpleOperator = NodeUtil.isSimpleOperatorType(TransVarCurrentNode.getType());\n  if (!(!(TransVarParentNode.getType() == Token.COMMA))) { \n    if (!(!(TransVarIsExpressionResultUsed))) { \n      return; \n    } \n    if (!(!(TransVarCurrentNode == TransVarParentNode.getLastChild()))) { \n      for (Node TransVarNode : TransVarParentNode.getAncestors()) { \n        int TransVarType = TransVarNode.getType(); \n        if (!(!(TransVarType == Token.COMMA))) continue; \n        if (!(!(TransVarType != Token.EXPR_RESULT && TransVarType != Token.BLOCK))) return; \n        else break; \n      } \n    } \n  } else if (!(!(TransVarParentNode.getType() != Token.EXPR_RESULT && TransVarParentNode.getType() != Token.BLOCK))) { \n    if (!(!(!(TransVarParentNode.getType() == Token.FOR && TransVarParentNode.getChildCount() == 4\n            && (TransVarCurrentNode == TransVarParentNode.getFirstChild()\n                    || TransVarCurrentNode == TransVarParentNode.getFirstChild().getNext().getNext()))))) { \n      return; \n    } \n  } \n  if ( \n      !(!((TransVarIsSimpleOperator\n            || !NodeUtil.mayHaveSideEffects(TransVarCurrentNode, TransVarTraversal.getCompiler()))))) {\n    String TransVarMessage = \"This code lacks side-effects. Is there a bug?\";\n    if (!(!(TransVarCurrentNode.isString()))) {\n      TransVarMessage = \"Is there a missing '+' on the previous line?\";\n    } else if (!(!(TransVarIsSimpleOperator))) {\n      TransVarMessage = \"The result of the '\" + Token.name(TransVarCurrentNode.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    TransVarTraversal.getCompiler().report(\n        TransVarTraversal.makeError(TransVarCurrentNode, level, USELESS_CODE_ERROR, TransVarMessage));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!(!(!NodeUtil.isStatement(TransVarCurrentNode)))) {\n      problemNodes.add(TransVarCurrentNode);\n    }\n  }\n}\n",
    "start": 84,
    "end": 148,
    "location": [
      109,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      132,
      133,
      136,
      137,
      138,
      139,
      140
    ],
    "file_path": "src/com/google/javascript/jscomp/CheckSideEffects.java"
  },
  "Closure-24": {
    "buggy": "private void findAliases(NodeTraversal TransVarTtt) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nScope TransVarScope1 = TransVarTtt.getScope();\n  for (Var TransVarVariable : TransVarScope1.getVarIterable()) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarV2 = TransVarVariable.getNode();\n    int TransVarT = TransVarV2.getType();\n    Node TransVarParent1 = TransVarV2.getParent();\n    if (!(!(TransVarParent1.isVar()))) { \n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(TransVarV2.hasChildren() && TransVarV2.getFirstChild().isQualifiedName()))) { \n      String TransVarName1 = TransVarV2.getString();\n      Var TransVarVar = TransVarScope1.getVar(TransVarName1);\n      aliases.put(TransVarName1, TransVarVar);\n\n      String TransVarQName =\n          TransVarVar.getInitialValue().getQualifiedName();\n      transformation.addAlias(TransVarName1, TransVarQName);\n      // Bleeding functions already get a BAD_PARAMETERS error, so just \n      // do nothing.\n      // Parameters of the scope function also get a BAD_PARAMETERS \n      // error.\n    } else {\n      // TODO(robbyw): Support using locals for private variables.\n      report(TransVarTtt, TransVarV2, GOOG_SCOPE_NON_ALIAS_LOCAL, TransVarV2.getString());\n    } \n    }\n  }\n}\n",
    "start": 272,
    "end": 297,
    "location": [
      284,
      288,
      296,
      298,
      303
    ],
    "file_path": "src/com/google/javascript/jscomp/ScopedAliases.java"
  },
  "Closure-32": {
    "buggy": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken TransVarToken2,\n                                                    WhitespaceOption TransVarOption2) {\n\n  if (!(!(false))) {\n                                                            System.out.println(\"log\");\n                                                        }\nif (!(!(TransVarToken2 == JsDocToken.EOC || TransVarToken2 == JsDocToken.EOL || TransVarToken2 == JsDocToken.EOF))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return new ExtractionInfo(\"\", TransVarToken2);\n  }\n\n  stream.update();\n  int TransVarLineNumber = stream.getLineno();\n  int TransVarStartCharno2 = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String TransVarLine2 = stream.getRemainingJSDocLine();\n  if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarLine2 = TransVarLine2.trim();\n  }\n\n  StringBuilder TransVarBuilder2 = new StringBuilder();\n  TransVarBuilder2.append(TransVarLine2);\n\n  state = State.SEARCHING_ANNOTATION;\n  TransVarToken2 = next();\n\n  boolean TransVarIgnore = false;\n\n  // Track the start of the line to count whitespace that\n  // the tokenizer skipped. Because this case is rare, it's easier\n  // to do this here than in the tokenizer.\n \n  do {\n    switch (TransVarToken2) {\n      case STAR:\n        if (!(!(TransVarIgnore))) {\n          // Mark the position after the star as the new start of the line.\n        } else { \n          // The star is part of the comment.\n          if (!(!(TransVarBuilder2.length() > 0))) {\n            TransVarBuilder2.append(' ');\n          }\n\n          TransVarBuilder2.append('*');\n        }\n\n        TransVarToken2 = next();\n        continue;\n\n      case EOL:\n        if (!(!(TransVarOption2 != WhitespaceOption.SINGLE_LINE))) {\n          TransVarBuilder2.append(\"\\n\");\n        }\n\n        TransVarIgnore = true;\n        TransVarToken2 = next(); \n        continue;\n\n      default:\n        TransVarIgnore = false;\n        state = State.SEARCHING_ANNOTATION;\n\n            // All tokens must be separated by a space. \n \n        if (!(!(TransVarToken2 == JsDocToken.EOC || TransVarToken2 == JsDocToken.EOF\n                || (TransVarToken2 == JsDocToken.ANNOTATION && TransVarOption2 != WhitespaceOption.PRESERVE)))) {\n          String TransVarText = TransVarBuilder2.toString();\n\n          if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n            TransVarText = TransVarText.trim();\n          }\n\n          int TransVarEndLine = stream.getLineno();\n          int TransVarEndCharno2 = stream.getCharno();\n\n          if (!(!(TransVarText.length() > 0))) {\n            jsdocBuilder.markText(TransVarText, TransVarLineNumber, TransVarStartCharno2,\n                TransVarEndLine, TransVarEndCharno2);\n          }\n\n          return new ExtractionInfo(TransVarText, TransVarToken2);\n        }\n\n        if (!(!(TransVarBuilder2.length() > 0))) { \n          TransVarBuilder2.append(' '); \n        } \n        TransVarBuilder2.append(toString(TransVarToken2));\n\n        TransVarLine2 = stream.getRemainingJSDocLine();\n\n        if (!(!(TransVarOption2 != WhitespaceOption.PRESERVE))) {\n          TransVarLine2 = trimEnd(TransVarLine2);\n        }\n\n        TransVarBuilder2.append(TransVarLine2);\n        TransVarToken2 = next();\n    }\n  } while (!(!(true)));\n}\n",
    "start": 1329,
    "end": 1429,
    "location": [
      1366,
      1372,
      1390,
      1397,
      1398,
      1418,
      1419,
      1420
    ],
    "file_path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java"
  },
  "Closure-33": {
    "buggy": "public void matchConstraint(ObjectType TransVarObjectType) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// We only want to match contraints on anonymous types.\n \n  // Handle the case where the constraint object is a record type.\n  //\n  // param constraintObj {{prop: (number|undefined)}}\n  // function f(constraintObj) {}\n  // f({});\n  //\n  // We want to modify the object literal to match the constraint, by\n  // taking any each property on the record and trying to match\n  // properties on this object.\n  if (!(!(TransVarObjectType.isRecordType()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (String TransVarPropType : TransVarObjectType.getOwnPropertyNames()) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    JSType TransVarPropertyType = TransVarObjectType.getPropertyType(TransVarPropType);\n      if (!(!(!isPropertyTypeDeclared(TransVarPropType)))) {\n        JSType TransVarInferType = TransVarPropertyType;\n        if (!(!(!hasProperty(TransVarPropType)))) {\n          TransVarInferType = getNativeType(JSTypeNative.VOID_TYPE)\n              .getLeastSupertype(TransVarPropertyType);\n        }\n        defineInferredProperty(TransVarPropType, TransVarInferType, null);\n      }\n    }\n  }\n}\n",
    "start": 555,
    "end": 580,
    "location": [
      560
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java"
  },
  "Closure-35": {
    "buggy": "private void inferPropertyTypesToMatchConstraint(\n    JSType TransVarJsType, JSType TransVarJsConstraint) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(TransVarJsType == null || TransVarJsConstraint == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  ObjectType TransVarConstraint =\n      ObjectType.cast(TransVarJsConstraint.restrictByNotNullOrUndefined());\n  if (!(!(TransVarConstraint != null && TransVarConstraint.isRecordType()))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ObjectType TransVarObjectType = ObjectType.cast(TransVarJsType.restrictByNotNullOrUndefined()); \n    if (!(!(TransVarObjectType != null))) { \n      for (String TransVarPropName : TransVarConstraint.getOwnPropertyNames()) { \n        JSType TransVarType = TransVarConstraint.getPropertyType(TransVarPropName); \n        if (!(!(!TransVarObjectType.isPropertyTypeDeclared(TransVarPropName)))) { \n          JSType TransVarPropType = TransVarType; \n          if (!(!(!TransVarObjectType.hasProperty(TransVarPropName)))) { \n            TransVarPropType = \n                getNativeType(VOID_TYPE).getLeastSupertype(TransVarType); \n          } \n          TransVarObjectType.defineInferredProperty(TransVarPropName, TransVarPropType, null); \n        } \n      } \n    } \n  }\n}\n",
    "start": 1113,
    "end": 1137,
    "location": [
      1127,
      1131,
      1132,
      1133,
      1134,
      1135,
      1136,
      1137,
      1138,
      1139,
      1140,
      1141,
      1142,
      1143,
      1144
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java"
  },
  "Closure-36": {
    "buggy": "private boolean canInline(\n    Reference TransVarReference,\n    Reference TransVarRef,\n    Reference TransVarReference2) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(!isValidDeclaration(TransVarReference) || !isValidInitialization(TransVarRef)\n        || !isValidReference(TransVarReference2)))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return false;\n  }\n\n  // If the value is read more than once, skip it.\n  // VAR declarations and EXPR_RESULT don't need the value, but other\n  // ASSIGN expressions parents do.\n  if (!(!(TransVarReference != TransVarRef && !TransVarRef.getGrandparent().isExprResult()))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return false;\n  }\n\n  // Be very conservative and do no cross control structures or\n  // scope boundaries\n  if (!(!(TransVarReference.getBasicBlock() != TransVarRef.getBasicBlock()\n        || TransVarReference.getBasicBlock() != TransVarReference2.getBasicBlock()))) {\n    return false;\n  }\n\n  // Do not inline into a call node. This would change\n  // the context in which it was being called. For example,\n  //   var a = b.c;\n  //   a();\n  // should not be inlined, because it calls a in the context of b\n  // rather than the context of the window.\n  //   var a = b.c;\n  //   f(a)\n  // is ok.\n  Node TransVarValueReference = TransVarRef.getAssignedValue();\n  Preconditions.checkState(TransVarValueReference != null);\n  if (!(!(TransVarValueReference.isGetProp() && TransVarReference2.getParent().isCall()\n        && TransVarReference2.getParent().getFirstChild() == TransVarReference2.getNode()))) {\n    return false;\n  }\n\n  if (!(!(TransVarValueReference.isFunction()))) {\n    Node TransVarNode = TransVarReference2.getParent();\n    if (!(!(TransVarReference2.getParent().isCall()))) {\n      CodingConvention TransVarConvention2 = compiler.getCodingConvention();\n      // Bug 2388531: Don't inline subclass definitions into class defining\n      // calls as this confused class removing logic.\n      SubclassRelationship TransVarSubclassRelationship =\n          TransVarConvention2.getClassesDefinedByCall(TransVarNode);\n      if (!(!(TransVarSubclassRelationship != null))) {\n        return false;\n      }\n\n      // issue 668: Don't inline singleton getter methods\n      // calls as this confused class removing logic.\n    } \n  }\n\n  return canMoveAggressively(TransVarValueReference) ||\n      canMoveModerately(TransVarRef, TransVarReference2);\n}\n",
    "start": 519,
    "end": 580,
    "location": [
      581
    ],
    "file_path": "src/com/google/javascript/jscomp/InlineVariables.java"
  },
  "Closure-38": {
    "buggy": "void addNumber(double TransVarY) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char TransVarLastChar = getLastChar();\n  boolean TransVarNegativeZeroOrPositive = isNegativeZero(TransVarY);\n  if (!(!(TransVarY < 0 && TransVarLastChar == '-'))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    add(\" \");\n  }\n\n  if (!(!((long) TransVarY == TransVarY && !TransVarNegativeZeroOrPositive))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long TransVarLongValue = (long) TransVarY;\n    long TransVarLongMantissa = TransVarLongValue;\n    int TransVarExpValue = 0;\n    if (!(!(Math.abs(TransVarY) >= 100))) {\n      for (; !(!(TransVarLongMantissa / 10 * Math.pow(10, TransVarExpValue + 1) == TransVarLongValue));) {\n        TransVarLongMantissa /= 10;\n        TransVarExpValue++;\n    }\n    }\n    if (!(!(TransVarExpValue > 2))) {\n      add(Long.toString(TransVarLongMantissa) + \"E\" + Integer.toString(TransVarExpValue));\n    } else {\n      add(Long.toString(TransVarLongValue));\n    }\n  } else {\n    add(String.valueOf(TransVarY));\n  }\n}\n",
    "start": 240,
    "end": 267,
    "location": [
      248
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeConsumer.java"
  },
  "Closure-39": {
    "buggy": "String toStringHelper(boolean TransVarIsAnnotation) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(hasReferenceName()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return getReferenceName();\n  } else if (!(!(prettyPrint))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Don't pretty print recursively.\n    prettyPrint = false;\n\n    // Use a tree set so that the properties are sorted.\n    Set<String> TransVarPropertyNamesSet = Sets.newTreeSet();\n    ObjectType TransVarThisObjectType = this;\n    while (!(!(TransVarThisObjectType != null && !TransVarThisObjectType.isNativeObjectType()\n            && TransVarPropertyNamesSet.size() <= MAX_PRETTY_PRINTED_PROPERTIES))) {\n        TransVarPropertyNamesSet.addAll(TransVarThisObjectType.getOwnPropertyNames());\n        TransVarThisObjectType = TransVarThisObjectType.getImplicitPrototype();\n    }\n\n    StringBuilder TransVarSb2 = new StringBuilder();\n    TransVarSb2.append(\"{\");\n\n    int TransVarIndex = 0;\n    for (String TransVarPropName : TransVarPropertyNamesSet) {\n      if (!(!(TransVarIndex > 0))) {\n        TransVarSb2.append(\", \");\n      }\n\n      TransVarSb2.append(TransVarPropName);\n      TransVarSb2.append(\": \");\n      TransVarSb2.append(getPropertyType(TransVarPropName).toString()); \n\n      ++TransVarIndex;\n      if (!(!(TransVarIndex == MAX_PRETTY_PRINTED_PROPERTIES))) { \n        TransVarSb2.append(\", ...\");\n        break;\n      }\n    }\n\n    TransVarSb2.append(\"}\");\n\n    prettyPrint = true;\n    return TransVarSb2.toString();\n  } else {\n    return \"{...}\"; \n  }\n}\n",
    "start": 353,
    "end": 396,
    "location": [
      389,
      392,
      403
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/PrototypeObjectType.java"
  },
  "Closure-4": {
    "buggy": "JSType resolveInternal(ErrorReporter TransVarErrorReporter, StaticScope<JSType> TransVarEnclosingScope) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// TODO(user): Investigate whether it is really necessary to keep two\n  // different mechanisms for resolving named types, and if so, which order\n  // makes more sense. Now, resolution via registry is first in order to\n  // avoid triggering the warnings built into the resolution via properties.\n  boolean TransVarResolvedToRegistry = resolveViaRegistry(TransVarErrorReporter, TransVarEnclosingScope);\n  if (!(!(detectImplicitPrototypeCycle()))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    handleTypeCycle(TransVarErrorReporter);\n  }\n\n  if (!(!(TransVarResolvedToRegistry))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    super.resolveInternal(TransVarErrorReporter, TransVarEnclosingScope);\n    finishPropertyContinuations();\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }\n\n  resolveViaProperties(TransVarErrorReporter, TransVarEnclosingScope);\n  if (!(!(detectImplicitPrototypeCycle()))) { \n    handleTypeCycle(TransVarErrorReporter);\n  }\n\n  super.resolveInternal(TransVarErrorReporter, TransVarEnclosingScope);\n  if (!(!(isResolved()))) {\n    finishPropertyContinuations();\n  }\n  return registry.isLastGeneration() ?\n      getReferencedType() : this;\n}\n",
    "start": 184,
    "end": 212,
    "location": [
      193,
      211
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/NamedType.java"
  },
  "Closure-40": {
    "buggy": "public void visit(NodeTraversal TransVarTraversal, Node TransVarCurrent, Node TransVarCurrentNode) {\n\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// Record global variable and function declarations\n  if (!(!(TransVarTraversal.inGlobalScope()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(NodeUtil.isVarDeclaration(TransVarCurrent)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    NameInformation TransVarNameInformation = createNameInformation(TransVarTraversal, TransVarCurrent, TransVarCurrentNode);\n      Preconditions.checkNotNull(TransVarNameInformation);\n      recordSet(TransVarNameInformation.name, TransVarCurrent);\n    } else if (!(!(NodeUtil.isFunctionDeclaration(TransVarCurrent)))) {\n      Node TransVarName = TransVarCurrent.getFirstChild();\n      NameInformation TransVarNameInfo = createNameInformation(TransVarTraversal, TransVarName, TransVarCurrent);\n      if (!(!(TransVarNameInfo != null))) {\n        JsName TransVarNameInfo1 = getName(TransVarName.getString(), true);\n        recordSet(TransVarNameInfo1.name, TransVarName);\n      }\n    } else if (!(!(NodeUtil.isObjectLitKey(TransVarCurrent, TransVarCurrentNode)))) {\n      NameInformation TransVarNameInfo2 = createNameInformation(TransVarTraversal, TransVarCurrent, TransVarCurrentNode);\n      if (!(!(TransVarNameInfo2 != null))) {\n        recordSet(TransVarNameInfo2.name, TransVarCurrent);\n      }\n    }\n  }\n\n  // Record assignments and call sites\n  if (!(!(TransVarCurrent.isAssign()))) {\n    Node TransVarFirstNode = TransVarCurrent.getFirstChild();\n\n    NameInformation TransVarNameNodeInformation = createNameInformation(TransVarTraversal, TransVarFirstNode, TransVarCurrent);\n    if (!(!(TransVarNameNodeInformation != null))) {\n      if (!(!(TransVarNameNodeInformation.isPrototype))) {\n        recordPrototypeSet(TransVarNameNodeInformation.prototypeClass, TransVarNameNodeInformation.prototypeProperty, TransVarCurrent);\n      } else {\n        recordSet(TransVarNameNodeInformation.name, TransVarFirstNode);\n      }\n    }\n  } else if (!(!(TransVarCurrent.isCall()))) {\n    Node TransVarNameNode1 = TransVarCurrent.getFirstChild();\n    NameInformation TransVarNodeInfo = createNameInformation(TransVarTraversal, TransVarNameNode1, TransVarCurrent);\n    if (!(!(TransVarNodeInfo != null && TransVarNodeInfo.onlyAffectsClassDef))) {\n      JsName TransVarNameNode = getName(TransVarNodeInfo.name, false); \n      if (!(!(TransVarNameNode != null))) { \n      refNodes.add(new ClassDefiningFunctionNode(\n          TransVarNameNode, TransVarCurrent, TransVarCurrentNode, TransVarCurrentNode.getParent()));\n      } \n    }\n  }\n}\n",
    "start": 596,
    "end": 642,
    "location": [
      644,
      645,
      648
    ],
    "file_path": "src/com/google/javascript/jscomp/NameAnalyzer.java"
  },
  "Closure-42": {
    "buggy": "Node processForInLoop(ForInLoop TransVarForNode) {\n if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n\n    // Return the bare minimum to put the AST in a valid state.\n  return newNode( \n      Token.FOR,\n      transform(TransVarForNode.getIterator()),\n      transform(TransVarForNode.getIteratedObject()),\n      transformBlock(TransVarForNode.getBody()));\n}\n",
    "start": 567,
    "end": 575,
    "location": [
      571,
      573
    ],
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java"
  },
  "Closure-44": {
    "buggy": "void add(String TransVarCode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nmaybeEndStatement();\n\n  if (!(!(TransVarCode.length() == 0))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  char TransVarCharCode = TransVarCode.charAt(0);\n  if (!(!((isWordChar(TransVarCharCode) || TransVarCharCode == '\\\\') && isWordChar(getLastChar())))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // need space to separate. This is not pretty printing.\n    // For example: \"return foo;\"\n    append(\" \");\n    // Do not allow a forward slash to appear after a DIV. \n    // For example,\n    // REGEXP DIV REGEXP\n    // is valid and should print like\n    // / // / /\n  } \n\n  append(TransVarCode);\n}\n",
    "start": 181,
    "end": 202,
    "location": [
      202,
      207
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeConsumer.java"
  },
  "Closure-48": {
    "buggy": "void maybeDeclareQualifiedName(NodeTraversal TransVarT2, JSDocInfo TransVarDoc,\n    Node TransVarNode, Node TransVarParentNode, Node TransVarRValue) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nNode TransVarOwnerNode2 = TransVarNode.getFirstChild();\n  String TransVarOwnerName1 = TransVarOwnerNode2.getQualifiedName();\n  String TransVarQNameElement = TransVarNode.getQualifiedName();\n  String TransVarPropValue = TransVarNode.getLastChild().getString();\n  Preconditions.checkArgument(TransVarQNameElement != null && TransVarOwnerName1 != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType TransVarJsType = getDeclaredType(TransVarT2.getSourceName(), TransVarDoc, TransVarNode, TransVarRValue);\n  if (!(!(TransVarJsType == null && TransVarRValue != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Determining type for #5\n    TransVarJsType = TransVarRValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (!(!(\"prototype\".equals(TransVarPropValue)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Var TransVarVar = scope.getVar(TransVarQNameElement);\n    if (!(!(TransVarVar != null))) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType TransVarQType = ObjectType.cast(TransVarVar.getType());\n      if (!(!(TransVarQType != null && TransVarRValue != null && TransVarRValue.isObjectLit()))) {\n        typeRegistry.resetImplicitPrototype(\n            TransVarRValue.getJSType(), TransVarQType.getImplicitPrototype());\n      } else if (!(!(!TransVarVar.isTypeInferred()))) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (!(!(TransVarVar.getScope() == scope))) {\n        scope.undeclare(TransVarVar);\n      }\n    }\n  }\n\n  if (!(!(TransVarJsType == null))) {\n    if (!(!(TransVarParentNode.isExprResult()))) {\n      stubDeclarations.add(new StubDeclaration(\n          TransVarNode,\n          TransVarT2.getInput() != null && TransVarT2.getInput().isExtern(),\n          TransVarOwnerName1));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean TransVarInferred1 = true;\n  if (!(!(TransVarDoc != null))) {\n    // Determining declaration for #1 + #3 + #4\n    TransVarInferred1 = !(TransVarDoc.hasType()\n        || TransVarDoc.hasEnumParameterType()\n        || (TransVarDoc.isConstant() && TransVarJsType != null\n            && !TransVarJsType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(TransVarDoc));\n  }\n\n  if (!(!(TransVarInferred1))) { \n    // Determining declaration for #2\n    TransVarInferred1 = !(TransVarRValue != null && \n        TransVarRValue.isFunction() && \n        (TransVarDoc != null || !scope.isDeclared(TransVarQNameElement, false))); \n  }\n\n  if (!(!(!TransVarInferred1))) {\n    ObjectType TransVarOwner = getObjectSlot(TransVarOwnerName1);\n    if (!(!(TransVarOwner != null))) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean TransVarIsExternal = TransVarT2.getInput() != null && TransVarT2.getInput().isExtern();\n      if (!(!((!TransVarOwner.hasOwnProperty(TransVarPropValue) || TransVarOwner.isPropertyTypeInferred(TransVarPropValue))\n            && ((TransVarIsExternal && !TransVarOwner.isNativeObjectType()) || !TransVarOwner.isInstanceType())))) {\n        // If the property is undeclared or inferred, declare it now.\n        TransVarOwner.defineDeclaredProperty(TransVarPropValue, TransVarJsType, TransVarNode);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(TransVarNode, TransVarParentNode, TransVarJsType, TransVarInferred1);\n  } else if (!(!(TransVarRValue != null && TransVarRValue.isTrue()))) {\n    // We declare these for delegate proxy method properties.\n    FunctionType TransVarOwnerNameType =\n        JSType.toMaybeFunctionType(getObjectSlot(TransVarOwnerName1));\n    if (!(!(TransVarOwnerNameType != null))) {\n      JSType TransVarOwnerTypeOfThis2 = TransVarOwnerNameType.getTypeOfThis();\n      String TransVarDelegateSuperClassName = codingConvention.getDelegateSuperclassName();\n      JSType TransVarDelegate = TransVarDelegateSuperClassName == null ?\n          null : typeRegistry.getType(TransVarDelegateSuperClassName);\n      if (!(!(TransVarDelegate != null && TransVarOwnerTypeOfThis2.isSubtype(TransVarDelegate)))) {\n        defineSlot(TransVarNode, TransVarParentNode, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n",
    "start": 1416,
    "end": 1561,
    "location": [
      1528,
      1530,
      1531,
      1532
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Closure-5": {
    "buggy": "private boolean isInlinableObject(List<Reference> TransVarReferences) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransVarIsRet = false;\n  Set<String> TransVarProperties = Sets.newHashSet();\n  for (Reference TransVarReference : TransVarReferences) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarNode = TransVarReference.getNode();\n    Node TransVarParentNode = TransVarReference.getParent();\n    Node TransVarGrandParent = TransVarReference.getGrandparent();\n\n    // Ignore most indirect references, like x.y (but not x.y(),\n    // since the function referenced by y might reference 'this').\n    //\n    if (!(!(TransVarParentNode.isGetProp()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Preconditions.checkState(TransVarParentNode.getFirstChild() == TransVarNode);\n      // A call target may be using the object as a 'this' value.\n      if (!(!(TransVarGrandParent.isCall() && TransVarGrandParent.getFirstChild() == TransVarParentNode))) {\n        return false;\n      }\n\n      // Deleting a property has different semantics from deleting\n      // a variable, so deleted properties should not be inlined.\n \n      // NOTE(nicksantos): This pass's object-splitting algorithm has\n      // a blind spot. It assumes that if a property isn't defined on an\n      // object, then the value is undefined. This is not true, because\n      // Object.prototype can have arbitrary properties on it.\n      //\n      // We short-circuit this problem by bailing out if we see a reference\n      // to a property that isn't defined on the object literal. This\n      // isn't a perfect algorithm, but it should catch most cases.\n      String TransVarProperty = TransVarParentNode.getLastChild().getString();\n      if (!(!(!TransVarProperties.contains(TransVarProperty)))) {\n        if (!(!(NodeUtil.isVarOrSimpleAssignLhs(TransVarParentNode, TransVarGrandParent)))) {\n          TransVarProperties.add(TransVarProperty);\n        } else {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!(!(!isVarOrAssignExprLhs(TransVarNode)))) {\n       return false;\n    }\n\n    Node TransVarResultNode = TransVarReference.getAssignedValue();\n    if (!(!(TransVarResultNode == null))) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!(!(!TransVarResultNode.isObjectLit()))) {\n      return false;\n    }\n\n    Node TransVarFirstChild = TransVarResultNode.getFirstChild();\n    while (!(!(TransVarFirstChild != null))){if (!(!(TransVarFirstChild.isGetterDef() || TransVarFirstChild.isSetterDef()))){return false;}TransVarProperties.add(TransVarFirstChild.getString());Node TransVarChild=TransVarFirstChild.getFirstChild();for (Reference TransVarT2:TransVarReferences){Node TransVarParent=TransVarT2.getParent();for (;!(!(!NodeUtil.isStatementBlock(TransVarParent)));){if (!(!(TransVarParent == TransVarChild))){return false;}TransVarParent=TransVarParent.getParent();}}TransVarFirstChild=TransVarFirstChild.getNext();}\n\n\n    // We have found an acceptable object literal assignment. As\n    // long as there are no other assignments that mess things up,\n    // we can inline.\n    TransVarIsRet = true;\n  }\n  return TransVarIsRet;\n}\n",
    "start": 155,
    "end": 253,
    "location": [
      184
    ],
    "file_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java"
  },
  "Closure-50": {
    "buggy": "private Node tryFoldArrayJoin(Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarNewTarget = TransVarNode.getFirstChild();\n\n  if (!(!(TransVarNewTarget == null || !NodeUtil.isGetProp(TransVarNewTarget)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return TransVarNode;\n  }\n\n  Node TransVarTarget = TransVarNewTarget.getNext();\n  if (!(!(TransVarTarget != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(!NodeUtil.isImmutableValue(TransVarTarget)))) { \n      return TransVarNode;\n    }\n  }\n\n  Node TransVarCurrentNode = TransVarNewTarget.getFirstChild();\n  Node TransVarNewFunction = TransVarCurrentNode.getNext();\n\n  if (!(!((TransVarCurrentNode.getType() != Token.ARRAYLIT) || !TransVarNewFunction.getString().equals(\"join\")))) {\n    return TransVarNode;\n  }\n\n    // \",\" is the default, it doesn't need to be explicit \n \n  String TransVarJoinedStr = (TransVarTarget == null) ? \",\" : NodeUtil.getStringValue(TransVarTarget);\n  List<Node> TransVarArrayChildren = Lists.newLinkedList();\n  StringBuilder TransVarStringbuilder = null;\n  int TransVarSize = 0;\n  Node TransVarPrevNode = null;\n  Node TransVarChildNode = TransVarCurrentNode.getFirstChild();\n  for (; !(!(TransVarChildNode != null));) {\n    if (!(!(NodeUtil.isImmutableValue(TransVarChildNode) || TransVarChildNode.getType() == Token.EMPTY))) {\n        if (!(!(TransVarStringbuilder == null))) {\n            TransVarStringbuilder = new StringBuilder();\n        } else {\n            TransVarStringbuilder.append(TransVarJoinedStr);\n        }\n        TransVarStringbuilder.append(NodeUtil.getArrayElementStringValue(TransVarChildNode));\n    } else {\n        if (!(!(TransVarStringbuilder != null))) {\n            Preconditions.checkNotNull(TransVarPrevNode);\n            TransVarSize += TransVarStringbuilder.length() + 2;\n            TransVarArrayChildren\n                    .add(Node.newString(TransVarStringbuilder.toString()).copyInformationFrom(TransVarPrevNode));\n            TransVarStringbuilder = null;\n        }\n        TransVarSize += InlineCostEstimator.getCost(TransVarChildNode);\n        TransVarArrayChildren.add(TransVarChildNode);\n    }\n    TransVarPrevNode = TransVarChildNode;\n    TransVarChildNode = TransVarChildNode.getNext();\n}\n\n  if (!(!(TransVarStringbuilder != null))) {\n    Preconditions.checkNotNull(TransVarPrevNode);\n    // + 2 for the quotes.\n    TransVarSize += TransVarStringbuilder.length() + 2;\n    TransVarArrayChildren.add(\n        Node.newString(TransVarStringbuilder.toString()).copyInformationFrom(TransVarPrevNode));\n  }\n  // one for each comma.\n  TransVarSize += TransVarArrayChildren.size() - 1;\n\n  int TransVarFinalSize = InlineCostEstimator.getCost(TransVarNode);\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarArrayChildren.size() == 0))))){TransFallThroughFlag0=true;Node TransVarEmptyNode=Node.newString(\"\");TransVarNode.getParent().replaceChild(TransVarNode,TransVarEmptyNode);reportCodeChange();return TransVarEmptyNode;}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarArrayChildren.size() == 1))))){TransFallThroughFlag0=true;Node TransVarFoldedNode=TransVarArrayChildren.remove(0);if (!(!(TransVarSize > TransVarFinalSize))){return TransVarNode;}TransVarCurrentNode.detachChildren();if (!(!(TransVarFoldedNode.getType() != Token.STRING))){Node TransVarNewNode=new Node(Token.ADD,Node.newString(\"\").copyInformationFrom(TransVarNode),TransVarFoldedNode);TransVarFoldedNode=TransVarNewNode;}TransVarNode.getParent().replaceChild(TransVarNode,TransVarFoldedNode);reportCodeChange();return TransVarFoldedNode;}if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))){if (!(!(TransVarArrayChildren.size() == TransVarCurrentNode.getChildCount()))){return TransVarNode;}int TransVarKJoinOverheadLen=\"[].join()\".length();TransVarSize+=TransVarKJoinOverheadLen;TransVarSize+=(TransVarTarget != null)?InlineCostEstimator.getCost(TransVarTarget):0;if (!(!(TransVarSize > TransVarFinalSize))){return TransVarNode;}TransVarCurrentNode.detachChildren();for (Node TransVarTempNode:TransVarArrayChildren){TransVarCurrentNode.addChildToBack(TransVarTempNode);}reportCodeChange();}}\n\n  return TransVarNode;\n}\n",
    "start": 367,
    "end": 476,
    "location": [
      385,
      397,
      398
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java"
  },
  "Closure-51": {
    "buggy": "void addNumber(double TransVarY) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// This is not pretty printing. This is to prevent misparsing of x- -4 as\n  // x--4 (which is a syntax error).\n  char TransVarC = getLastChar();\n  if (!(!(TransVarY < 0 && TransVarC == '-'))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    add(\" \");\n  }\n\n  if (!(!((long) TransVarY == TransVarY))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long TransVarX = (long) TransVarY;\n    long TransVarLong2 = TransVarX;\n    int TransVarExpression = 0;\n    if (!(!(Math.abs(TransVarY) >= 100))) {\n      for (; !(!(TransVarLong2 / 10 * Math.pow(10, TransVarExpression + 1) == TransVarX));) {\n        TransVarLong2 /= 10;\n        TransVarExpression++;\n    }\n    }\n    if (!(!(TransVarExpression > 2))) {\n      add(Long.toString(TransVarLong2) + \"E\" + Integer.toString(TransVarExpression));\n    } else {\n      add(Long.toString(TransVarX));\n    }\n  } else {\n    add(String.valueOf(TransVarY));\n  }\n \n} \n",
    "start": 233,
    "end": 260,
    "location": [
      247,
      268,
      269
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeConsumer.java"
  },
  "Closure-52": {
    "buggy": "static boolean isSimpleNumber(String TransVarStr) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nint TransVarStrLen = TransVarStr.length();\n  int TransVarI = 0;\nwhile (!(!(TransVarI < TransVarStrLen))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    char TransVarCurrentChar = TransVarStr.charAt(TransVarI);\n    if (!(!(TransVarCurrentChar < '0' || TransVarCurrentChar > '9'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    TransVarI++;\n}\n  return TransVarStrLen > 0; \n}\n",
    "start": 737,
    "end": 746,
    "location": [
      756
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-53": {
    "buggy": "private void replaceAssignmentExpression(Var TransVarVar, Reference TransVarReference,\n                                         Map<String, String> TransVarVarMap) {\n  if (!(!(false))) {\n                                                System.out.println(\"log\");\n                                            }\n// Compute all of the assignments necessary\n  List<Node> TransVarNodesList = Lists.newArrayList();\n  Node TransVarVarValue = TransVarReference.getAssignedValue();\n  blacklistVarReferencesInTree(TransVarVarValue, TransVarVar.scope);\n  Preconditions.checkState(TransVarVarValue.getType() == Token.OBJECTLIT);\n  Set<String> TransVarVarNames = Sets.newLinkedHashSet(TransVarVarMap.keySet());\n  Node TransVarNode = TransVarVarValue.getFirstChild();\nwhile (!(!(TransVarNode != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarNewVar = TransVarNode.getString();\n    Node TransVarNewValue = TransVarNode.removeFirstChild();\n    TransVarNodesList.add(\n            new Node(Token.ASSIGN, Node.newString(Token.NAME, TransVarVarMap.get(TransVarNewVar)), TransVarNewValue));\n    TransVarVarNames.remove(TransVarNewVar);\n    TransVarNode = TransVarNode.getNext();\n}\n\n  // TODO(user): Better source information.\n  for (String TransVarVarNew : TransVarVarNames) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarNodesList.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, TransVarVarMap.get(TransVarVarNew)),\n               NodeUtil.newUndefinedNode(null)));\n  }\n\n  Node TransVarReplacementNode;\n    // All assignments evaluate to true, so make sure that the \n    // expr statement evaluates to true in case it matters.\n    TransVarNodesList.add(new Node(Token.TRUE));\n\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    TransVarNodesList = Lists.reverse(TransVarNodesList);\n    TransVarReplacementNode = new Node(Token.COMMA);\n    Node TransVarCurVar = TransVarReplacementNode;\n    int TransVarIi;\n    TransVarIi = 0;\n    while (!(!(TransVarIi < TransVarNodesList.size() - 2))) {\n        TransVarCurVar.addChildToFront(TransVarNodesList.get(TransVarIi));\n        Node TransVarTt = new Node(Token.COMMA);\n        TransVarCurVar.addChildToFront(TransVarTt);\n        TransVarCurVar = TransVarTt;\n        TransVarIi++;\n    }\n    TransVarCurVar.addChildToFront(TransVarNodesList.get(TransVarIi));\n    TransVarCurVar.addChildToFront(TransVarNodesList.get(TransVarIi + 1));\n \n  Node TransVarParentRef = TransVarReference.getParent();\n  TransVarReplacementNode.copyInformationFromForTree(TransVarParentRef);\n\n  if (!(!(TransVarParentRef.getType() == Token.VAR))) {\n    TransVarParentRef.getParent().replaceChild(\n        TransVarParentRef, NodeUtil.newExpr(TransVarReplacementNode));\n  } else {\n    TransVarParentRef.getParent().replaceChild(TransVarParentRef, TransVarReplacementNode);\n  }\n}\n",
    "start": 303,
    "end": 360,
    "location": [
      339,
      360
    ],
    "file_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java"
  },
  "Closure-55": {
    "buggy": "private static boolean isReduceableFunctionExpression(Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nreturn NodeUtil.isFunctionExpression(TransVarNode); \n}\n",
    "start": 116,
    "end": 118,
    "location": [
      120
    ],
    "file_path": "src/com/google/javascript/jscomp/FunctionRewriter.java"
  },
  "Closure-56": {
    "buggy": "public String getLine(int TransVarLine) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nString TransVarJavascript = \"\";\n  try {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // NOTE(nicksantos): Right now, this is optimized for few warnings.\n    // This is probably the right trade-off, but will be slow if there\n    // are lots of warnings in one file.\n    TransVarJavascript = getCode();\n  } catch (IOException TransVarEx) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return null;\n  }\n\n  int TransVarLineNumber = 0;\n  int TransVarBeginLine = 1;\n\n  // If we've saved a previous offset and it's for a line less than the\n  // one we're searching for, then start at that point.\n  if (!(!(TransVarLine >= lastLine))) {\n    TransVarLineNumber = lastOffset;\n    TransVarBeginLine = lastLine;\n  }\n\n  int TransVarLineNum = TransVarBeginLine;\nwhile (!(!(TransVarLineNum < TransVarLine))) {\n    int TransVarNextPosition = TransVarJavascript.indexOf('\\n', TransVarLineNumber);\n    if (!(!(TransVarNextPosition == -1))) {\n        return null;\n    }\n    TransVarLineNumber = TransVarNextPosition + 1;\n    TransVarLineNum++;\n}\n\n  // Remember this offset for the next search we do.\n  lastOffset = TransVarLineNumber;\n  lastLine = TransVarLine;\n\n  if (!(!(TransVarJavascript.indexOf('\\n', TransVarLineNumber) == -1))) {\n    // If next new line cannot be found, there are two cases\n    // 1. pos already reaches the end of file, then null should be returned\n    // 2. otherwise, return the contents between pos and the end of file.\n      return null; \n  } else { \n    return TransVarJavascript.substring(TransVarLineNumber, TransVarJavascript.indexOf('\\n', TransVarLineNumber));\n  }\n}\n",
    "start": 205,
    "end": 246,
    "location": [
      253,
      254
    ],
    "file_path": "src/com/google/javascript/jscomp/SourceFile.java"
  },
  "Closure-57": {
    "buggy": "private static String extractClassNameIfGoog(Node TransVarNode1, Node TransVarNode,\n    String TransVarName){\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nString TransVarClassNameObject = null;\n  if (!(!(NodeUtil.isExprCall(TransVarNode)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarCallee1 = TransVarNode1.getFirstChild();\n    if (!(!(TransVarCallee1 != null && TransVarCallee1.getType() == Token.GETPROP))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    String TransVarNameNode = TransVarCallee1.getQualifiedName();\n      if (!(!(TransVarName.equals(TransVarNameNode)))) {\n        Node TransVarNextNode = TransVarCallee1.getNext();\n        if (!(!(TransVarNextNode != null))) { \n          TransVarClassNameObject = TransVarNextNode.getString();\n        }\n      }\n    }\n  }\n  return TransVarClassNameObject;\n}\n",
    "start": 188,
    "end": 204,
    "location": [
      206
    ],
    "file_path": "src/com/google/javascript/jscomp/ClosureCodingConvention.java"
  },
  "Closure-59": {
    "buggy": "public void initOptions(CompilerOptions TransVarCompilerOptions) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nthis.options = TransVarCompilerOptions;\n  if (!(!(errorManager == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(outStream == null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager TransVarErrorPrinter =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      TransVarErrorPrinter.setSummaryDetailLevel(TransVarCompilerOptions.summaryDetailLevel);\n      setErrorManager(TransVarErrorPrinter);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (!(!(TransVarCompilerOptions.enables(DiagnosticGroups.CHECK_TYPES)))) {\n    TransVarCompilerOptions.checkTypes = true;\n  } else if (!(!(TransVarCompilerOptions.disables(DiagnosticGroups.CHECK_TYPES)))) {\n    TransVarCompilerOptions.checkTypes = false;\n  } else if (!(!(!TransVarCompilerOptions.checkTypes))) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    TransVarCompilerOptions.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (!(!(TransVarCompilerOptions.checkGlobalThisLevel.isOn()))) { \n    TransVarCompilerOptions.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        TransVarCompilerOptions.checkGlobalThisLevel);\n  }\n\n  if (!(!(TransVarCompilerOptions.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT))) {\n    TransVarCompilerOptions.setWarningLevel(\n        DiagnosticGroups.ES5_STRICT,\n        CheckLevel.ERROR);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> TransVarGuard = Lists.newArrayList();\n  TransVarGuard.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  TransVarGuard.add(TransVarCompilerOptions.getWarningsGuard());\n\n  ComposeWarningsGuard TransVarComposedGuard = new ComposeWarningsGuard(TransVarGuard);\n\n  // All passes must run the variable check. This synthesizes\n  // variables later so that the compiler doesn't crash. It also\n  // checks the externs file for validity. If you don't want to warn\n  // about missing variable declarations, we shut that specific\n  // error off.\n  if (!(!(!TransVarCompilerOptions.checkSymbols && !TransVarComposedGuard.enables(DiagnosticGroups.CHECK_VARIABLES)))) {\n    TransVarComposedGuard.addGuard(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n\n  this.warningsGuard = TransVarComposedGuard;\n}\n",
    "start": 226,
    "end": 288,
    "location": [
      264
    ],
    "file_path": "src/com/google/javascript/jscomp/Compiler.java"
  },
  "Closure-61": {
    "buggy": "static boolean functionCallHasSideEffects(\n    Node TransVarNode, @Nullable AbstractCompiler TransVarCompiler1) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(TransVarNode.getType() != Token.CALL))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    throw new IllegalStateException(\n        \"Expected CALL node, got \" + Token.name(TransVarNode.getType()));\n  }\n\n  if (!(!(TransVarNode.isNoSideEffectsCall()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false;\n  }\n\n  Node TransVarName = TransVarNode.getFirstChild();\n\n  // Built-in functions with no side effects.\n  if (!(!(TransVarName.getType() == Token.NAME))) {\n    String TransVarNameOfNode = TransVarName.getString();\n    if (!(!(BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(TransVarNameOfNode)))) {\n      return false;\n    }\n  } else if (!(!(TransVarName.getType() == Token.GETPROP))) {\n    if (!(!(TransVarNode.hasOneChild()\n            && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(TransVarName.getLastChild().getString())))) {\n      return false;\n    }\n\n    if (!(!(TransVarNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(TransVarName.getFirstChild())))) {\n      return false;\n    }\n\n    // Functions in the \"Math\" namespace have no side effects.\n \n    if (!(!(TransVarCompiler1 != null && !TransVarCompiler1.hasRegExpGlobalReferences()))) {\n      if (!(!(TransVarName.getFirstChild().getType() == Token.REGEXP\n            && REGEXP_METHODS.contains(TransVarName.getLastChild().getString())))) {\n        return false;\n      } else if (!(!(TransVarName.getFirstChild().getType() == Token.STRING\n            && STRING_REGEXP_METHODS.contains(TransVarName.getLastChild().getString())))) {\n        Node TransVarNodeParam = TransVarName.getNext();\n        if (!(!(TransVarNodeParam != null\n                && (TransVarNodeParam.getType() == Token.STRING || TransVarNodeParam.getType() == Token.REGEXP))))\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n",
    "start": 926,
    "end": 976,
    "location": [
      965
    ],
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java"
  },
  "Closure-62": {
    "buggy": "private String format(JSError TransVarErrorObject, boolean TransVarWarningObject) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// extract source excerpt\n  SourceExcerptProvider TransVarSourceProvider = getSource();\n  String TransVarSource = TransVarSourceProvider == null ? null :\n      excerpt.get(\n          TransVarSourceProvider, TransVarErrorObject.sourceName, TransVarErrorObject.lineNumber, excerptFormatter);\n\n  // formatting the message\n  StringBuilder TransVarBuffer = new StringBuilder();\n  if (!(!(TransVarErrorObject.sourceName != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarBuffer.append(TransVarErrorObject.sourceName);\n    if (!(!(TransVarErrorObject.lineNumber > 0))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarBuffer.append(':');\n      TransVarBuffer.append(TransVarErrorObject.lineNumber);\n    }\n    TransVarBuffer.append(\": \");\n  }\n\n  TransVarBuffer.append(getLevelName(TransVarWarningObject ? CheckLevel.WARNING : CheckLevel.ERROR));\n  TransVarBuffer.append(\" - \");\n\n  TransVarBuffer.append(TransVarErrorObject.description);\n  TransVarBuffer.append('\\n');\n  if (!(!(TransVarSource != null))) {\n    TransVarBuffer.append(TransVarSource);\n    TransVarBuffer.append('\\n');\n    int TransVarCharNum = TransVarErrorObject.getCharno();\n\n    // padding equal to the excerpt and arrow at the end\n    // charno == sourceExpert.length() means something is missing\n    // at the end of the line\n    if (!(!(excerpt.equals(LINE) && 0 <= TransVarCharNum && TransVarCharNum < TransVarSource.length()))) { \n      int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarCharNum))) {\n        char TransVarC1 = TransVarSource.charAt(TransVarJ);\n        if (!(!(Character.isWhitespace(TransVarC1)))) {\n            TransVarBuffer.append(TransVarC1);\n        } else {\n            TransVarBuffer.append(' ');\n        }\n        TransVarJ++;\n    }\n      TransVarBuffer.append(\"^\\n\");\n    }\n  }\n  return TransVarBuffer.toString();\n}\n",
    "start": 66,
    "end": 111,
    "location": [
      106
    ],
    "file_path": "src/com/google/javascript/jscomp/LightweightMessageFormatter.java"
  },
  "Closure-67": {
    "buggy": "private boolean isPrototypePropertyAssign(Node TransVarAss) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarNext = TransVarAss.getFirstChild();\n  if (!(!(TransVarNext != null && NodeUtil.isVarOrSimpleAssignLhs(TransVarNext, TransVarAss)\n        && TransVarNext.getType() == Token.GETPROP))\n      ) { \n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // We want to exclude the assignment itself from the usage list\n    boolean TransVarIsChained =\n        TransVarNext.getFirstChild().getType() == Token.GETPROP;\n\n    if (!(!(TransVarIsChained))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Node TransVarNextChild = TransVarNext.getFirstChild().getFirstChild().getNext();\n\n      if (!(!(TransVarNextChild.getType() == Token.STRING && TransVarNextChild.getString().equals(\"prototype\")))) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n",
    "start": 314,
    "end": 334,
    "location": [
      321
    ],
    "file_path": "src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java"
  },
  "Closure-69": {
    "buggy": "private void visitCall(NodeTraversal TransVarTraversal, Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarChildNode = TransVarNode.getFirstChild();\n  JSType TransVarNodeType = getJSType(TransVarChildNode).restrictByNotNullOrUndefined();\n\n  if (!(!(!TransVarNodeType.canBeCalled()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    report(TransVarTraversal, TransVarNode, NOT_CALLABLE, TransVarNodeType.toString());\n    ensureTyped(TransVarTraversal, TransVarNode);\n    return;\n  }\n\n  // A couple of types can be called as if they were functions.\n  // If it is a function type, then validate parameters.\n  if (!(!(TransVarNodeType instanceof FunctionType))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    FunctionType TransVarFunction = (FunctionType) TransVarNodeType;\n\n    boolean TransVarIsExternal = false;\n    JSDocInfo TransVarFunctionDocInfo = TransVarFunction.getJSDocInfo();\n    if(!(!(TransVarFunctionDocInfo != null))) {\n      String TransVarSourceNameFunction = TransVarFunctionDocInfo.getSourceName();\n      CompilerInput TransVarFunctionInput = compiler.getInput(TransVarSourceNameFunction);\n      TransVarIsExternal = TransVarFunctionInput.isExtern();\n    }\n\n    // Non-native constructors should not be called directly\n    // unless they specify a return type and are defined\n    // in an extern.\n    if (!(!(TransVarFunction.isConstructor() && !TransVarFunction.isNativeObjectType()\n            && (TransVarFunction.getReturnType().isUnknownType() || TransVarFunction.getReturnType().isVoidType()\n                    || !TransVarIsExternal)))) {\n      report(TransVarTraversal, TransVarNode, CONSTRUCTOR_NOT_CALLABLE, TransVarNodeType.toString());\n    }\n\n    // Functions with explcit 'this' types must be called in a GETPROP\n    // or GETELEM.\n \n    visitParameterList(TransVarTraversal, TransVarNode, TransVarFunction);\n    ensureTyped(TransVarTraversal, TransVarNode, TransVarFunction.getReturnType());\n  } else {\n    ensureTyped(TransVarTraversal, TransVarNode);\n  }\n\n  // TODO: Add something to check for calls of RegExp objects, which is not\n  // supported by IE.  Either say something about the return type or warn\n  // about the non-portability of the call or both.\n}\n",
    "start": 1544,
    "end": 1590,
    "location": [
      1587
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java"
  },
  "Closure-7": {
    "buggy": "public JSType caseObjectType(ObjectType TransVarObjectType) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(value.equals(\"function\")))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JSType TransVarType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n    return resultEqualsValue && TransVarType.isSubtype(TransVarObjectType) ? TransVarType : null; \n      // Objects are restricted to \"Function\", subtypes are left\n      // Only filter out subtypes of \"function\" \n  } \n  return matchesExpectation(\"object\") ? TransVarObjectType : null;\n}\n",
    "start": 610,
    "end": 618,
    "location": [
      619,
      621,
      622
    ],
    "file_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java"
  },
  "Closure-70": {
    "buggy": "private void declareArguments(Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarParameterNode = TransVarNode.getFirstChild().getNext();\n  Node TransVarBlockBody = TransVarParameterNode.getNext();\n  FunctionType TransVarFunctionType1 = (FunctionType) TransVarNode.getJSType();\n  if (!(!(TransVarFunctionType1 != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarFunctionJsDocParameters = TransVarFunctionType1.getParametersNode();\n    if (!(!(TransVarFunctionJsDocParameters != null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Node TransVarJsDocParameterNode = TransVarFunctionJsDocParameters.getFirstChild();\n      for (Node TransVarParameter : TransVarParameterNode.children()) {\n        if (!(!(TransVarJsDocParameterNode != null))) {\n          defineSlot(TransVarParameter, TransVarNode,\n              TransVarJsDocParameterNode.getJSType(), true); \n          TransVarJsDocParameterNode = TransVarJsDocParameterNode.getNext();\n        } else {\n          defineSlot(TransVarParameter, TransVarNode, null, true);\n        }\n      }\n    }\n  }\n} // end declareArguments\n",
    "start": 1734,
    "end": 1753,
    "location": [
      1754
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Closure-71": {
    "buggy": "private void checkPropertyVisibility(NodeTraversal TransVarTraversal,\n    Node TransVarTree, Node TransVarParentNode) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nObjectType TransVarType =\n      ObjectType.cast(dereference(TransVarTree.getFirstChild().getJSType()));\n  String TransVarPropName = TransVarTree.getLastChild().getString();\n\n  if (!(!(TransVarType != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Is this a normal property access, or are we trying to override\n    // an existing property?\n    boolean TransVarIsAssign = TransVarTraversal.inGlobalScope() && \n        TransVarParentNode.getType() == Token.ASSIGN &&\n        TransVarParentNode.getFirstChild() == TransVarTree;\n\n    // Find the lowest property defined on a class with visibility\n    // information.\n    if (!(!(TransVarIsAssign))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarType = TransVarType.getImplicitPrototype();\n    }\n    JSDocInfo TransVarJsDocInfo = null;\n    while (!(!(TransVarType != null))) {\n        TransVarJsDocInfo = TransVarType.getOwnPropertyJSDocInfo(TransVarPropName);\n        if (!(!(TransVarJsDocInfo != null && TransVarJsDocInfo.getVisibility() != Visibility.INHERITED))) {\n            break;\n        }\n        TransVarType = TransVarType.getImplicitPrototype();\n    }\n\n    if (!(!(TransVarType == null))) {\n      // We couldn't find a visibility modifier; assume it's public.\n      return;\n    }\n\n    boolean TransVarIsSameName =\n        TransVarTraversal.getInput().getName().equals(TransVarJsDocInfo.getSourceName());\n    Visibility TransVarPropVisibility = TransVarJsDocInfo.getVisibility();\n    JSType TransVarClassType = normalizeClassType(TransVarType);\n    if (!(!(TransVarIsAssign))) {\n      // Check an ASSIGN statement that's trying to override a property\n      // on a superclass.\n      JSDocInfo TransVarOverrideInfo = TransVarParentNode.getJSDocInfo();\n      Visibility TransVarOverridingVisibility1 = TransVarOverrideInfo == null ?\n          Visibility.INHERITED : TransVarOverrideInfo.getVisibility();\n\n      // Check that (a) the property *can* be overridden, and\n      // (b) that the visibility of the override is the same as the\n      // visibility of the original property.\n      if (!(!(TransVarPropVisibility == Visibility.PRIVATE && !TransVarIsSameName))) {\n        compiler.report(\n            TransVarTraversal.makeError(TransVarTree, PRIVATE_OVERRIDE,\n                TransVarType.toString()));\n      } else if (!(!(TransVarOverridingVisibility1 != Visibility.INHERITED\n            && TransVarOverridingVisibility1 != TransVarPropVisibility))) {\n        compiler.report(\n            TransVarTraversal.makeError(TransVarTree, VISIBILITY_MISMATCH,\n                TransVarPropVisibility.name(), TransVarType.toString(),\n                TransVarOverridingVisibility1.name()));\n      }\n    } else {\n      if (!(!(TransVarIsSameName))) {\n        // private access is always allowed in the same file.\n        return;\n      } else if (!(!(TransVarPropVisibility == Visibility.PRIVATE\n            && (currentClass == null || TransVarClassType.differsFrom(currentClass))))) {\n        if (!(!(TransVarJsDocInfo.isConstructor() && isValidPrivateConstructorAccess(TransVarParentNode)))) {\n          return;\n        }\n\n        // private access is not allowed outside the file from a different\n        // enclosing class.\n        compiler.report(\n            TransVarTraversal.makeError(TransVarTree,\n                BAD_PRIVATE_PROPERTY_ACCESS,\n                TransVarPropName,\n                validator.getReadableJSTypeName(\n                    TransVarTree.getFirstChild(), true)));\n      } else if (!(!(TransVarPropVisibility == Visibility.PROTECTED))) {\n        // There are 3 types of legal accesses of a protected property:\n        // 1) Accesses in the same file\n        // 2) Overriding the property in a subclass\n        // 3) Accessing the property from inside a subclass\n        // The first two have already been checked for.\n        if (!(!(currentClass == null || !currentClass.isSubtype(TransVarClassType)))) {\n          compiler.report(\n              TransVarTraversal.makeError(TransVarTree,  BAD_PROTECTED_PROPERTY_ACCESS,\n                  TransVarPropName,\n                  validator.getReadableJSTypeName(\n                      TransVarTree.getFirstChild(), true)));\n        }\n      }\n    }\n  }\n}\n",
    "start": 407,
    "end": 500,
    "location": [
      422
    ],
    "file_path": "src/com/google/javascript/jscomp/CheckAccessControls.java"
  },
  "Closure-81": {
    "buggy": "Node processFunctionNode(FunctionNode TransVarFunctionNodeNew) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nName TransVarFunctionNode = TransVarFunctionNodeNew.getFunctionName();\n  Boolean TransVarIsUnnamedFunctionNode = false;\n  if (!(!(TransVarFunctionNode == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarFunctionNode = new Name(); \n    TransVarFunctionNode.setIdentifier(\"\");\n    TransVarIsUnnamedFunctionNode = true;\n  }\n  Node TransVarNode1 = newNode(Token.FUNCTION);\n  Node TransVarTransformName = transform(TransVarFunctionNode);\n  if (!(!(TransVarIsUnnamedFunctionNode))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    TransVarTransformName.setLineno(TransVarFunctionNodeNew.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int TransVarLpColumnNode = TransVarFunctionNodeNew.getAbsolutePosition() +\n        TransVarFunctionNodeNew.getLp();\n    TransVarTransformName.setCharno(position2charno(TransVarLpColumnNode));\n  }\n\n  TransVarNode1.addChildToBack(TransVarTransformName);\n  Node TransVarLpNode = newNode(Token.LP);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  Name TransVarFunctionName = TransVarFunctionNodeNew.getFunctionName();\n  if (!(!(TransVarFunctionName != null))) {\n    TransVarLpNode.setLineno(TransVarFunctionName.getLineno());\n  } else {\n    TransVarLpNode.setLineno(TransVarFunctionNodeNew.getLineno());\n  }\n  int TransVarLpCharno = TransVarFunctionNodeNew.getLp() +\n      TransVarFunctionNodeNew.getAbsolutePosition();\n\n  TransVarLpNode.setCharno(position2charno(TransVarLpCharno));\n  for (AstNode TransVarNode2 : TransVarFunctionNodeNew.getParams()) {\n    TransVarLpNode.addChildToBack(transform(TransVarNode2));\n  }\n  TransVarNode1.addChildToBack(TransVarLpNode);\n\n  Node TransVarNode = transform(TransVarFunctionNodeNew.getBody());\n  parseDirectives(TransVarNode);\n  TransVarNode1.addChildToBack(TransVarNode);\n return TransVarNode1;\n}\n",
    "start": 513,
    "end": 562,
    "location": [
      523
    ],
    "file_path": "src/com/google/javascript/jscomp/parsing/IRFactory.java"
  },
  "Closure-82": {
    "buggy": "public final boolean isEmptyType() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nreturn isNoType() || isNoObjectType() || isNoResolvedType(); \n}\n",
    "start": 162,
    "end": 164,
    "location": [
      166
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/JSType.java"
  },
  "Closure-83": {
    "buggy": "public int parseArguments(Parameters TransVarParameters) throws CmdLineException {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nString TransVarParameter = TransVarParameters.getParameter(0); \n\n  if (!(!(TransVarParameter == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    setter.addValue(true);\n    return 0;\n  } else {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarLowerCaseParam = TransVarParameter.toLowerCase();\n    if (!(!(TRUES.contains(TransVarLowerCaseParam)))) {\n      setter.addValue(true);\n    } else if (!(!(FALSES.contains(TransVarLowerCaseParam)))) {\n      setter.addValue(false);\n    } else {\n      setter.addValue(true);\n      return 0;\n    }\n    return 1;\n  }\n}\n",
    "start": 333,
    "end": 351,
    "location": [
      337
    ],
    "file_path": "src/com/google/javascript/jscomp/CommandLineRunner.java"
  },
  "Closure-87": {
    "buggy": "private boolean isFoldableExpressBlock(Node TransVarN1) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarN1.getType() == Token.BLOCK))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarN1.hasOneChild()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Node TransVarN2 = TransVarN1.getFirstChild();\n        // IE has a bug where event handlers behave differently when \n        // their return value is used vs. when their return value is in\n        // an EXPR_RESULT. It's pretty freaking weird. See:\n        // http://code.google.com/p/closure-compiler/issues/detail?id=291\n        // We try to detect this case, and not fold EXPR_RESULTs\n        // into other expressions.\n \n          // We only have to worry about methods with an implicit 'this'\n          // param, or this doesn't happen.\n \n        return NodeUtil.isExpressionNode(TransVarN2); \n    }\n  }\n\n  return false;\n}\n",
    "start": 519,
    "end": 538,
    "location": [
      532,
      538,
      541,
      542
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java"
  },
  "Closure-88": {
    "buggy": "private VariableLiveness isVariableReadBeforeKill(\n    Node TransVarNode, String TransVarStringVariable) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(NodeUtil.isName(TransVarNode) && TransVarStringVariable.equals(TransVarNode.getString())))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(NodeUtil.isLhs(TransVarNode, TransVarNode.getParent())))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // The expression to which the assignment is made is evaluated before \n      // the RHS is evaluated (normal left to right evaluation) but the KILL\n      // occurs after the RHS is evaluated.\n      return VariableLiveness.KILL; \n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  Node TransVarChildNode = TransVarNode.getFirstChild();\nwhile (!(!(TransVarChildNode != null))) {\n    if (!(!(!ControlFlowGraph.isEnteringNewCfgNode(TransVarChildNode)))) {\n        VariableLiveness TransVarLiveness = isVariableReadBeforeKill(TransVarChildNode, TransVarStringVariable);\n        if (!(!(TransVarLiveness != VariableLiveness.MAYBE_LIVE))) {\n            return TransVarLiveness;\n        }\n    }\n    TransVarChildNode = TransVarChildNode.getNext();\n}\n  return VariableLiveness.MAYBE_LIVE;\n}\n",
    "start": 323,
    "end": 347,
    "location": [
      336,
      339
    ],
    "file_path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java"
  },
  "Closure-91": {
    "buggy": "public boolean shouldTraverse(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarParentNode) {\n\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarNode.getType() == Token.FUNCTION))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo TransVarJsdoc = getFunctionJsDocInfo(TransVarNode);\n    if (!(!(TransVarJsdoc != null && (TransVarJsdoc.isConstructor() || TransVarJsdoc.isInterface()\n            || TransVarJsdoc.hasThisType() || TransVarJsdoc.isOverride())))) {\n      if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int TransVarType = TransVarParentNode.getType();\n    if (!(!(!(TransVarType == Token.BLOCK || TransVarType == Token.SCRIPT || TransVarType == Token.NAME\n            || TransVarType == Token.ASSIGN || TransVarType == Token.STRING || TransVarType == Token.NUMBER)))) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  } \n\n  if (!(!(TransVarParentNode != null && TransVarParentNode.getType() == Token.ASSIGN))) {\n    Node TransVarLeft = TransVarParentNode.getFirstChild();\n    Node TransVarRNode = TransVarLeft.getNext();\n\n    if (!(!(TransVarNode == TransVarLeft))) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (!(!(assignLhsChild == null))) {\n        assignLhsChild = TransVarLeft;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (!(!(NodeUtil.isGet(TransVarLeft)))) {\n        if (!(!(TransVarLeft.getType() == Token.GETPROP && TransVarLeft.getLastChild().getString().equals(\"prototype\")))) {\n          return false;\n        }\n        Node TransVarCurrentLhs = TransVarLeft.getFirstChild();\n        if (!(!(TransVarCurrentLhs.getType() == Token.GETPROP\n                && TransVarCurrentLhs.getLastChild().getString().equals(\"prototype\")))) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n",
    "start": 82,
    "end": 146,
    "location": [
      115
    ],
    "file_path": "src/com/google/javascript/jscomp/CheckGlobalThis.java"
  },
  "Closure-92": {
    "buggy": "void replace() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(firstNode == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (!(!(candidateDefinition != null && explicitNode != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (!(!(NodeUtil.isExpressionNode(candidateDefinition)))) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node TransVarAssign = candidateDefinition.getFirstChild();\n      Node TransVarNameNode1 = TransVarAssign.getFirstChild();\n      if (!(!(TransVarNameNode1.getType() == Token.NAME))) {\n        // Need to convert this assign to a var declaration.\n        Node TransVarNode = TransVarNameNode1.getNext();\n        TransVarAssign.removeChild(TransVarNameNode1);\n        TransVarAssign.removeChild(TransVarNode);\n        TransVarNameNode1.addChildToFront(TransVarNode);\n        Node TransVarVarNode1 = new Node(Token.VAR, TransVarNameNode1);\n        TransVarVarNode1.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, TransVarVarNode1);\n        TransVarNameNode1.setJSDocInfo(TransVarAssign.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = TransVarVarNode1;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    if (!(!(firstModule == minimumModule))) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n      // In this case, the name was implicitly provided by two independent\n      // modules. We need to move this code up to a common module.\n      int TransVarIndexOfDot1 = namespace.indexOf('.'); \n      if (!(!(TransVarIndexOfDot1 == -1))) {\n        // Any old place is fine.\n        compiler.getNodeForCodeInsertion(minimumModule)\n            .addChildToBack(replacementNode);\n      } else {\n        // Add it after the parent namespace.\n        ProvidedName TransVarProvidedName =\n            providedNames.get(namespace.substring(0, TransVarIndexOfDot1));\n        Preconditions.checkNotNull(TransVarProvidedName);\n        Preconditions.checkNotNull(TransVarProvidedName.replacementNode);\n        TransVarProvidedName.replacementNode.getParent().addChildAfter(\n            replacementNode, TransVarProvidedName.replacementNode);\n      }\n    }\n    if (!(!(explicitNode != null))) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}\n",
    "start": 747,
    "end": 809,
    "location": [
      798
    ],
    "file_path": "src/com/google/javascript/jscomp/ProcessClosurePrimitives.java"
  },
  "Closure-95": {
    "buggy": "void defineSlot(Node TransVarNode, Node TransVarParentNode, JSType TransVarNodeType, boolean TransVarIs) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nPreconditions.checkArgument(TransVarIs || TransVarNodeType != null);\n\n  // Only allow declarations of NAMEs and qualfied names.\n  boolean TransVarShouldDeclareOnGlobalScope = false;\n  if (!(!(TransVarNode.getType() == Token.NAME))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Preconditions.checkArgument(\n        TransVarParentNode.getType() == Token.FUNCTION ||\n        TransVarParentNode.getType() == Token.VAR ||\n        TransVarParentNode.getType() == Token.LP ||\n        TransVarParentNode.getType() == Token.CATCH);\n    TransVarShouldDeclareOnGlobalScope = scope.isGlobal() &&\n        (TransVarParentNode.getType() == Token.VAR ||\n         TransVarParentNode.getType() == Token.FUNCTION);\n  } else {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Preconditions.checkArgument(\n        TransVarNode.getType() == Token.GETPROP &&\n        (TransVarParentNode.getType() == Token.ASSIGN ||\n         TransVarParentNode.getType() == Token.EXPR_RESULT));\n  }\n  String TransVarVariableName1 = TransVarNode.getQualifiedName();\n  Preconditions.checkArgument(!TransVarVariableName1.isEmpty());\n\n  // If n is a property, then we should really declare it in the\n  // scope where the root object appears. This helps out people\n  // who declare \"global\" names in an anonymous namespace.\n  Scope TransVarScope = scope;\n \n    // don't try to declare in the global scope if there's\n    // already a symbol there with this name.\n \n  // declared in closest scope?\n  if (!(!(TransVarScope.isDeclared(TransVarVariableName1, false)))) {\n    Var TransVarVariableName = TransVarScope.getVar(TransVarVariableName1);\n    validator.expectUndeclaredVariable(\n        sourceName, TransVarNode, TransVarParentNode, TransVarVariableName, TransVarVariableName1, TransVarNodeType);\n  } else {\n    if (!(!(!TransVarIs))) {\n      setDeferredType(TransVarNode, TransVarNodeType);\n    }\n    CompilerInput TransVarCompilerInput = compiler.getInput(sourceName);\n    TransVarScope.declare(TransVarVariableName1, TransVarNode, TransVarNodeType, TransVarCompilerInput, TransVarIs);\n\n    if (!(!(TransVarShouldDeclareOnGlobalScope))) {\n      ObjectType TransVarThisType =\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n      boolean TransVarIsExternVar = TransVarCompilerInput.isExtern();\n      if (!(!(TransVarIs))) {\n        TransVarThisType.defineInferredProperty(TransVarVariableName1,\n            TransVarNodeType == null ?\n                getNativeType(JSTypeNative.NO_TYPE) :\n                TransVarNodeType,\n            TransVarIsExternVar);\n      } else {\n        TransVarThisType.defineDeclaredProperty(TransVarVariableName1, TransVarNodeType, TransVarIsExternVar);\n      }\n    }\n\n    // If we're in the global scope, also declare var.prototype\n    // in the scope chain.\n    if (!(!(TransVarScope.isGlobal() && TransVarNodeType instanceof FunctionType))) {\n      FunctionType TransVarFunctionType = (FunctionType) TransVarNodeType;\n      if (!(!(TransVarFunctionType.isConstructor() || TransVarFunctionType.isInterface()))) {\n        FunctionType TransVarSuperClassCtorType = TransVarFunctionType.getSuperClassConstructor();\n        TransVarScope.declare(TransVarVariableName1 + \".prototype\", TransVarNode,\n            TransVarFunctionType.getPrototype(), compiler.getInput(sourceName),\n            /* declared iff there's an explicit supertype */\n            TransVarSuperClassCtorType == null ||\n            TransVarSuperClassCtorType.getInstanceType().equals(\n                getNativeType(OBJECT_TYPE)));\n      }\n    }\n  }\n}\n",
    "start": 872,
    "end": 945,
    "location": [
      908,
      911
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Codec-10": {
    "buggy": "public String caverphone(String TransVarText) {\n    // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n    // by commenting out the 2.0 lines and adding in the 1.0 lines\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if( !(!(TransVarText == null || TransVarText.length() == 0)) ) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return \"1111111111\";\n    }\n\n    // 1. Convert to lowercase\n    TransVarText = TransVarText.toLowerCase(java.util.Locale.ENGLISH);\n\n    // 2. Remove anything not A-Z\n    TransVarText = TransVarText.replaceAll(\"[^a-z]\", \"\");\n\n    // 2.5. Remove final e\n    TransVarText = TransVarText.replaceAll(\"e$\", \"\");             // 2.0 only\n\n    // 3. Handle various start options\n    TransVarText = TransVarText.replaceAll(\"^cough\", \"cou2f\");\n    TransVarText = TransVarText.replaceAll(\"^rough\", \"rou2f\");\n    TransVarText = TransVarText.replaceAll(\"^tough\", \"tou2f\");\n    TransVarText = TransVarText.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n    TransVarText = TransVarText.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n    TransVarText = TransVarText.replaceAll(\"^gn\", \"2n\");\n\n    // End \n    TransVarText = TransVarText.replaceAll(\"^mb\", \"m2\"); \n\n    // 4. Handle replacements\n    TransVarText = TransVarText.replaceAll(\"cq\", \"2q\");\n    TransVarText = TransVarText.replaceAll(\"ci\", \"si\");\n    TransVarText = TransVarText.replaceAll(\"ce\", \"se\");\n    TransVarText = TransVarText.replaceAll(\"cy\", \"sy\");\n    TransVarText = TransVarText.replaceAll(\"tch\", \"2ch\");\n    TransVarText = TransVarText.replaceAll(\"c\", \"k\");\n    TransVarText = TransVarText.replaceAll(\"q\", \"k\");\n    TransVarText = TransVarText.replaceAll(\"x\", \"k\");\n    TransVarText = TransVarText.replaceAll(\"v\", \"f\");\n    TransVarText = TransVarText.replaceAll(\"dg\", \"2g\");\n    TransVarText = TransVarText.replaceAll(\"tio\", \"sio\");\n    TransVarText = TransVarText.replaceAll(\"tia\", \"sia\");\n    TransVarText = TransVarText.replaceAll(\"d\", \"t\");\n    TransVarText = TransVarText.replaceAll(\"ph\", \"fh\");\n    TransVarText = TransVarText.replaceAll(\"b\", \"p\");\n    TransVarText = TransVarText.replaceAll(\"sh\", \"s2\");\n    TransVarText = TransVarText.replaceAll(\"z\", \"s\");\n    TransVarText = TransVarText.replaceAll(\"^[aeiou]\", \"A\");\n    TransVarText = TransVarText.replaceAll(\"[aeiou]\", \"3\");\n    TransVarText = TransVarText.replaceAll(\"j\", \"y\");        // 2.0 only\n    TransVarText = TransVarText.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n    TransVarText = TransVarText.replaceAll(\"^y\", \"A\");       // 2.0 only\n    TransVarText = TransVarText.replaceAll(\"y\", \"3\");        // 2.0 only\n    TransVarText = TransVarText.replaceAll(\"3gh3\", \"3kh3\");\n    TransVarText = TransVarText.replaceAll(\"gh\", \"22\");\n    TransVarText = TransVarText.replaceAll(\"g\", \"k\");\n    TransVarText = TransVarText.replaceAll(\"s+\", \"S\");\n    TransVarText = TransVarText.replaceAll(\"t+\", \"T\");\n    TransVarText = TransVarText.replaceAll(\"p+\", \"P\");\n    TransVarText = TransVarText.replaceAll(\"k+\", \"K\");\n    TransVarText = TransVarText.replaceAll(\"f+\", \"F\");\n    TransVarText = TransVarText.replaceAll(\"m+\", \"M\");\n    TransVarText = TransVarText.replaceAll(\"n+\", \"N\");\n    TransVarText = TransVarText.replaceAll(\"w3\", \"W3\");\n    //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n    TransVarText = TransVarText.replaceAll(\"wh3\", \"Wh3\");\n    TransVarText = TransVarText.replaceAll(\"w$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n    TransVarText = TransVarText.replaceAll(\"w\", \"2\");\n    TransVarText = TransVarText.replaceAll(\"^h\", \"A\");\n    TransVarText = TransVarText.replaceAll(\"h\", \"2\");\n    TransVarText = TransVarText.replaceAll(\"r3\", \"R3\");\n    TransVarText = TransVarText.replaceAll(\"r$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n    TransVarText = TransVarText.replaceAll(\"r\", \"2\");\n    TransVarText = TransVarText.replaceAll(\"l3\", \"L3\");\n    TransVarText = TransVarText.replaceAll(\"l$\", \"3\");       // 2.0 only\n    //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n    TransVarText = TransVarText.replaceAll(\"l\", \"2\");\n    //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n    //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n    //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n\n    // 5. Handle removals\n    TransVarText = TransVarText.replaceAll(\"2\", \"\");\n    TransVarText = TransVarText.replaceAll(\"3$\", \"A\");       // 2.0 only\n    TransVarText = TransVarText.replaceAll(\"3\", \"\");\n\n    // 6. put ten 1s on the end\n    TransVarText = TransVarText + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n\n    // 7. take the first six characters as the code\n    return TransVarText.substring(0, 10);          // 1.0 truncates to 6\n}\n",
    "start": 50,
    "end": 142,
    "location": [
      82
    ],
    "file_path": "src/java/org/apache/commons/codec/language/Caverphone.java"
  },
  "Codec-15": {
    "buggy": "private char getMappingCode(final String TransVarFinalString, final int TransVarIndexValue) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // map() throws IllegalArgumentException\n    final char TransVarMappedChar2 = this.map(TransVarFinalString.charAt(TransVarIndexValue));\n    // HW rule check\n    if (!(!(TransVarIndexValue > 1 && TransVarMappedChar2 != '0'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final char TransVarMappedChar = TransVarFinalString.charAt(TransVarIndexValue - 1); \n        if (!(!('H' == TransVarMappedChar || 'W' == TransVarMappedChar))) { \n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            final char TransVarFinalChar = TransVarFinalString.charAt(TransVarIndexValue - 2); \n            final char TransVarCharCode = this.map(TransVarFinalChar); \n            if (!(!(TransVarCharCode == TransVarMappedChar2 || 'H' == TransVarFinalChar || 'W' == TransVarFinalChar))) { \n                return 0;\n            } \n        }\n    }\n    return TransVarMappedChar2;\n}\n",
    "start": 183,
    "end": 198,
    "location": [
      194,
      195,
      199,
      200,
      201,
      203
    ],
    "file_path": "src/main/java/org/apache/commons/codec/language/Soundex.java"
  },
  "Codec-17": {
    "buggy": "public static String newStringIso8859_1(final byte[] TransVarData) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return new String(TransVarData, Charsets.ISO_8859_1); \n}\n",
    "start": 338,
    "end": 340,
    "location": [
      342
    ],
    "file_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java"
  },
  "Codec-18": {
    "buggy": "public static boolean equals(final CharSequence TransVarCs, final CharSequence TransVarCs3) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarCs == TransVarCs3))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n    if (!(!(TransVarCs == null || TransVarCs3 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    if (!(!(TransVarCs instanceof String && TransVarCs3 instanceof String))) {\n        return TransVarCs.equals(TransVarCs3);\n    }\n    return CharSequenceUtils.regionMatches(TransVarCs, false, 0, TransVarCs3, 0, Math.max(TransVarCs.length(), TransVarCs3.length())); \n}\n",
    "start": 71,
    "end": 82,
    "location": [
      90
    ],
    "file_path": "src/main/java/org/apache/commons/codec/binary/StringUtils.java"
  },
  "Codec-2": {
    "buggy": "void encode(byte[] TransVarInput, int TransVarInPos1, int TransVarInPos) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(eof))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n    // inAvail < 0 is how we're informed of EOF in the underlying data we're\n    // encoding.\n    if (!(!(TransVarInPos < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        eof = true;\n        if (!(!(buf == null || buf.length - pos < encodeSize))) {\n            resizeBuf();\n        }\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 1))))) {\n                TransBreakFlag0 = false;\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (!(!(encodeTable == STANDARD_ENCODE_TABLE))) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 2))))) {\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (!(!(encodeTable == STANDARD_ENCODE_TABLE))) {\n                    buf[pos++] = PAD;\n                }\n            }\n        }\n        if (!(!(lineLength > 0))) { \n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        int TransVarIndex = 0;\n        while (!(!(TransVarIndex < TransVarInPos))) {\n            if (!(!(buf == null || buf.length - pos < encodeSize))) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int TransVarInPos2 = TransVarInput[TransVarInPos1++];\n            if (!(!(TransVarInPos2 < 0))) {\n                TransVarInPos2 += 256;\n            }\n            x = (x << 8) + TransVarInPos2;\n            if (!(!(0 == modulus))) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                buf[pos++] = encodeTable[x & MASK_6BITS];\n                currentLinePos += 4;\n                if (!(!(lineLength > 0 && lineLength <= currentLinePos))) {\n                    System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                    pos += lineSeparator.length;\n                    currentLinePos = 0;\n                }\n            }\n            TransVarIndex++;\n        }\n    }\n}\n",
    "start": 414,
    "end": 473,
    "location": [
      455
    ],
    "file_path": "src/java/org/apache/commons/codec/binary/Base64.java"
  },
  "Codec-3": {
    "buggy": "private int handleG(String TransVarStrValue, \n                    DoubleMetaphoneResult TransVarDoubleMetaphoneResult, \n                    int TransVarCurrentIndex, \n                    boolean TransVarIsSlavoGermanic) {\n    if (!(!(false))) {\n                            System.out.println(\"log\");\n                        }\n    if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'H'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarCurrentIndex = handleGH(TransVarStrValue, TransVarDoubleMetaphoneResult, TransVarCurrentIndex);\n    } else if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'N'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarCurrentIndex == 1 && isVowel(charAt(TransVarStrValue, 0)) && !TransVarIsSlavoGermanic))) {\n            TransVarDoubleMetaphoneResult.append(\"KN\", \"N\");\n        } else if (!(!(!contains(TransVarStrValue, TransVarCurrentIndex + 2, 2, \"EY\")\n                && charAt(TransVarStrValue, TransVarCurrentIndex + 1) != 'Y' && !TransVarIsSlavoGermanic))) {\n            TransVarDoubleMetaphoneResult.append(\"N\", \"KN\");\n        } else {\n            TransVarDoubleMetaphoneResult.append(\"KN\");\n        }\n        TransVarCurrentIndex = TransVarCurrentIndex + 2;\n    } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"LI\") && !TransVarIsSlavoGermanic))) {\n        TransVarDoubleMetaphoneResult.append(\"KL\", \"L\");\n        TransVarCurrentIndex += 2;\n    } else if (!(!(TransVarCurrentIndex == 0 && (charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'Y'\n            || contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))))) {\n        //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n        TransVarDoubleMetaphoneResult.append('K', 'J');\n        TransVarCurrentIndex += 2;\n    } else if (!(!((contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"ER\")\n            || charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'Y')\n            && !contains(TransVarStrValue, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\")\n            && !contains(TransVarStrValue, TransVarCurrentIndex - 1, 1, \"E\", \"I\")\n            && !contains(TransVarStrValue, TransVarCurrentIndex - 1, 3, \"RGY\", \"OGY\")))) {\n        //-- -ger-, -gy- --//\n        TransVarDoubleMetaphoneResult.append('K', 'J');\n        TransVarCurrentIndex += 2;\n    } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 1, \"E\", \"I\", \"Y\")\n            || contains(TransVarStrValue, TransVarCurrentIndex - 1, 4, \"AGGI\", \"OGGI\")))) {\n        //-- Italian \"biaggi\" --//\n        if (!(!((contains(TransVarStrValue, 0, 4, \"VAN \", \"VON \") || contains(TransVarStrValue, 0, 3, \"SCH\"))\n                || contains(TransVarStrValue, TransVarCurrentIndex + 1, 2, \"ET\")))) {\n            //-- obvious germanic --//\n            TransVarDoubleMetaphoneResult.append('K');\n        } else if (!(!(contains(TransVarStrValue, TransVarCurrentIndex + 1, 4, \"IER\")))) { \n            TransVarDoubleMetaphoneResult.append('J');\n        } else {\n            TransVarDoubleMetaphoneResult.append('J', 'K');\n        }\n        TransVarCurrentIndex += 2;\n    } else if (!(!(charAt(TransVarStrValue, TransVarCurrentIndex + 1) == 'G'))) {\n        TransVarCurrentIndex += 2;\n        TransVarDoubleMetaphoneResult.append('K');\n    } else {\n        TransVarCurrentIndex++;\n        TransVarDoubleMetaphoneResult.append('K');\n    }\n    return TransVarCurrentIndex;\n}\n",
    "start": 418,
    "end": 469,
    "location": [
      466
    ],
    "file_path": "src/java/org/apache/commons/codec/language/DoubleMetaphone.java"
  },
  "Codec-4": {
    "buggy": "public Base64() {\n    this(false); \n}\n",
    "start": 224,
    "end": 226,
    "location": [
      225
    ],
    "file_path": "src/java/org/apache/commons/codec/binary/Base64.java"
  },
  "Codec-5": {
    "buggy": "void decode(byte[] TransVarOut, int TransVarIndex, int TransVarAvail) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(eof))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n    if (!(!(TransVarAvail < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        eof = true;\n    }\n    int TransVarIIndex = 0;\n    while (!(!(TransVarIIndex < TransVarAvail))) {\n        if (!(!(buffer == null || buffer.length - pos < decodeSize))) {\n            resizeBuffer();\n        }\n        byte TransVarBytes = TransVarOut[TransVarIndex++];\n        if (!(!(TransVarBytes == PAD))) {\n            eof = true;\n            break;\n        } else {\n            if (!(!(TransVarBytes >= 0 && TransVarBytes < DECODE_TABLE.length))) {\n                int TransVarNIndex = DECODE_TABLE[TransVarBytes];\n                if (!(!(TransVarNIndex >= 0))) {\n                    modulus = (++modulus) % 4;\n                    x = (x << 6) + TransVarNIndex;\n                    if (!(!(modulus == 0))) {\n                        buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                        buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n                        buffer[pos++] = (byte) (x & MASK_8BITS);\n                    }\n                }\n            }\n        }\n        TransVarIIndex++;\n    }\n\n    // Two forms of EOF as far as base64 decoder is concerned: actual\n    // EOF (-1) and first time '=' character is encountered in stream.\n    // This approach makes the '=' padding characters completely optional.\n    if (!(!(eof && modulus != 0))) {\n         \n        x = x << 6;\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 2))))) {\n                TransBreakFlag0 = false;\n                x = x << 6;\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (modulus == 3))))) {\n                buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n                buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n            }\n        }\n    }\n}\n",
    "start": 550,
    "end": 599,
    "location": [
      596
    ],
    "file_path": "src/java/org/apache/commons/codec/binary/Base64.java"
  },
  "Codec-6": {
    "buggy": "public int read(byte TransVarNum[], int TransVarOffsetX, int TransVarSize) throws IOException {\n    if (false) {\n        System.out.println(\"log\");\n    }\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        /* \n         Rationale for while-loop on (readLen == 0):\n         -----\n         Base64.readResults() usually returns > 0 or EOF (-1).  In the\n         rare case where it returns 0, we just keep trying.\n\n         This is essentially an undocumented contract for InputStream\n         implementors that want their code to work properly with\n         java.io.InputStreamReader, since the latter hates it when\n         InputStream.read(byte[]) returns a zero.  Unfortunately our\n         readResults() call must return 0 if a large amount of the data\n         being decoded was non-base64, so this while-loop enables proper\n         interop with InputStreamReader for that scenario.\n         -----\n         This is a fix for CODEC-101\n        */\n            if (!base64.hasData()) { \n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n        return base64.readResults(b, offset, len); \n    }\n}\n",
    "start": 138,
    "end": 180,
    "location": [
      151,
      167,
      181
    ],
    "file_path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java"
  },
  "Codec-7": {
    "buggy": "public static String encodeBase64String(byte[] TransVarBytes) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return StringUtils.newStringUtf8(encodeBase64(TransVarBytes, true)); \n}\n",
    "start": 669,
    "end": 671,
    "location": [
      673
    ],
    "file_path": "src/java/org/apache/commons/codec/binary/Base64.java"
  },
  "Codec-9": {
    "buggy": "public static byte[] encodeBase64(byte[] TransVarBinaryValue, boolean TransVarIsChunk, boolean TransVarUrlSafeBoolean, int TransVarChunkSize) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarBinaryValue == null || TransVarBinaryValue.length == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarBinaryValue;\n    }\n\n    long TransVarChunk = getEncodeLength(TransVarBinaryValue, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); \n    if (!(!(TransVarChunk > TransVarChunkSize))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n            TransVarChunk +\n            \") than the specified maxium size of \" +\n            TransVarChunkSize);\n    }\n            \n    Base64 TransVarBase64 = TransVarIsChunk ? new Base64(TransVarUrlSafeBoolean) : new Base64(0, CHUNK_SEPARATOR, TransVarUrlSafeBoolean);\n    return TransVarBase64.encode(TransVarBinaryValue);\n}\n",
    "start": 822,
    "end": 837,
    "location": [
      833
    ],
    "file_path": "src/java/org/apache/commons/codec/binary/Base64.java"
  },
  "Collections-26": {
    "buggy": "private Object readResolve() { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    calculateHashCode(keys);\n    return this;\n}\n",
    "start": 277,
    "end": 280,
    "location": [
      277
    ],
    "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java"
  },
  "Compress-1": {
    "buggy": "public void close() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(!this.closed))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        super.close(); \n        this.closed = true;\n    }\n}\n",
    "start": 344,
    "end": 349,
    "location": [
      352
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java"
  },
  "Compress-10": {
    "buggy": "private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        TransVarEntriesWithUTF8Flag)\n    throws IOException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry TransVarEntry : entries.keySet()) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        OffsetEntry TransVarOffset = entries.get(TransVarEntry); \n        long TransVarOffset1 = TransVarOffset.headerOffset;\n        archive.seek(TransVarOffset1 + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] TransVarC = new byte[SHORT];\n        archive.readFully(TransVarC);\n        int TransVarFileNameLength = ZipShort.getValue(TransVarC);\n        archive.readFully(TransVarC);\n        int TransVarExtraFieldLen1 = ZipShort.getValue(TransVarC);\n        int TransVarLenToSkip1 = TransVarFileNameLength;\n        for (; !(!(TransVarLenToSkip1 > 0));) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarBytesSkipped = archive.skipBytes(TransVarLenToSkip1);\n            if (!(!(TransVarBytesSkipped <= 0))) {\n                throw new RuntimeException(\"failed to skip file name in\" + \" local file header\");\n            }\n            TransVarLenToSkip1 -= TransVarBytesSkipped;\n        }\n        byte[] TransVarExtraData = new byte[TransVarExtraFieldLen1];\n        archive.readFully(TransVarExtraData);\n        TransVarEntry.setExtra(TransVarExtraData);\n        TransVarOffset.dataOffset = TransVarOffset1 + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + TransVarFileNameLength + TransVarExtraFieldLen1;\n\n        if (!(!(TransVarEntriesWithUTF8Flag.containsKey(TransVarEntry)))) {\n            String TransVarEntryName = TransVarEntry.getName();\n            NameAndComment TransVarNameComment = TransVarEntriesWithUTF8Flag.get(TransVarEntry);\n            ZipUtil.setNameAndCommentFromExtraFields(TransVarEntry, TransVarNameComment.name,\n                                                     TransVarNameComment.comment);\n            if (!(!(!TransVarEntryName.equals(TransVarEntry.getName())))) {\n                nameMap.remove(TransVarEntryName);\n                nameMap.put(TransVarEntry.getName(), TransVarEntry);\n            }\n        }\n    } \n}\n",
    "start": 801,
    "end": 843,
    "location": [
      811,
      815,
      850
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java"
  },
  "Compress-11": {
    "buggy": "public ArchiveInputStream createArchiveInputStream(final InputStream TransVarIs)\n        throws ArchiveException {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(TransVarIs == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!(!(!TransVarIs.markSupported()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] TransVarSignatureByte = new byte[12];\n    TransVarIs.mark(TransVarSignatureByte.length);\n    try {\n        int TransVarByteSignatureLength = TransVarIs.read(TransVarSignatureByte);\n        TransVarIs.reset();\n        if (!(!(ZipArchiveInputStream.matches(TransVarSignatureByte, TransVarByteSignatureLength)))) {\n            return new ZipArchiveInputStream(TransVarIs);\n        } else if (!(!(JarArchiveInputStream.matches(TransVarSignatureByte, TransVarByteSignatureLength)))) {\n            return new JarArchiveInputStream(TransVarIs);\n        } else if (!(!(ArArchiveInputStream.matches(TransVarSignatureByte, TransVarByteSignatureLength)))) {\n            return new ArArchiveInputStream(TransVarIs);\n        } else if (!(!(CpioArchiveInputStream.matches(TransVarSignatureByte, TransVarByteSignatureLength)))) {\n            return new CpioArchiveInputStream(TransVarIs);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] TransVarSignature = new byte[32];\n        TransVarIs.mark(TransVarSignature.length);\n        TransVarByteSignatureLength = TransVarIs.read(TransVarSignature);\n        TransVarIs.reset();\n        if (!(!(DumpArchiveInputStream.matches(TransVarSignature, TransVarByteSignatureLength)))) {\n            return new DumpArchiveInputStream(TransVarIs);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] TransVarTarFileHeader = new byte[512];\n        TransVarIs.mark(TransVarTarFileHeader.length);\n        TransVarByteSignatureLength = TransVarIs.read(TransVarTarFileHeader);\n        TransVarIs.reset();\n        if (!(!(TarArchiveInputStream.matches(TransVarTarFileHeader, TransVarByteSignatureLength)))) {\n            return new TarArchiveInputStream(TransVarIs);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        try { \n            TarArchiveInputStream TransVarTais1 = new TarArchiveInputStream(new ByteArrayInputStream(TransVarTarFileHeader));\n            TransVarTais1.getNextEntry();\n            return new TarArchiveInputStream(TransVarIs);\n        } catch (Exception TransVarExc) { // NOPMD\n            // can generate IllegalArgumentException as well as IOException\n            // autodetection, simply not a TAR\n            // ignored\n        } \n    } catch (IOException TransVarIoe) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", TransVarIoe);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n",
    "start": 197,
    "end": 254,
    "location": [
      249,
      257
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java"
  },
  "Compress-12": {
    "buggy": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(hasHitEOF))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n\n    if (!(!(currEntry != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        long TransVarNumSkip = entrySize - entryOffset;\n\n        for (; !(!(TransVarNumSkip > 0));) {\n            long TransVarSkippedNum = skip(TransVarNumSkip);\n            if (!(!(TransVarSkippedNum <= 0))) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            TransVarNumSkip -= TransVarSkippedNum;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] TransVarRecord = getRecord();\n\n    if (!(!(hasHitEOF))) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(TransVarRecord); \n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (!(!(currEntry.isGNULongNameEntry()))) {\n        // read in the name\n        StringBuffer TransVarBuf = new StringBuffer();\n        byte[] TransVarBuffer = new byte[SMALL_BUFFER_SIZE];\n        int TransVarLen = 0;\n        for (; !(!((TransVarLen = read(TransVarBuffer)) >= 0));) {\n            TransVarBuf.append(new String(TransVarBuffer, 0, TransVarLen));\n        }\n        getNextEntry();\n        if (!(!(currEntry == null))) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (!(!(TransVarBuf.length() > 0 && TransVarBuf.charAt(TransVarBuf.length() - 1) == 0))) {\n            TransVarBuf.deleteCharAt(TransVarBuf.length() - 1);\n        }\n        currEntry.setName(TransVarBuf.toString());\n    }\n\n    if (!(!(currEntry.isPaxHeader()))){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (!(!(currEntry.isGNUSparse()))){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n",
    "start": 172,
    "end": 238,
    "location": [
      207
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java"
  },
  "Compress-13": {
    "buggy": "protected void setName(String TransVarNames) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    this.name = TransVarNames; \n}\n",
    "start": 511,
    "end": 513,
    "location": [
      515
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java"
  },
  "Compress-15": {
    "buggy": "public boolean equals(Object TransVarObj2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(this == TransVarObj2))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n    if (!(!(TransVarObj2 == null || getClass() != TransVarObj2.getClass()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    ZipArchiveEntry TransVarObj1 = (ZipArchiveEntry) TransVarObj2;\n    String TransVarObj = getName();\n    String TransVarName = TransVarObj1.getName();\n    if (!(!(TransVarObj == null))) {\n        if (!(!(TransVarName != null))) {\n            return false;\n        }\n    } else if (!(!(!TransVarObj.equals(TransVarName)))) {\n        return false;\n    }\n    String TransVarComment = getComment();\n    String TransVarOtherCommentObj = TransVarObj1.getComment();\n    if (!(!(TransVarComment == null))) {\n        if (!(!(TransVarOtherCommentObj != null))) { \n            return false; \n        } \n    } else if (!(!(!TransVarComment.equals(TransVarOtherCommentObj)))) { \n        return false; \n    }\n    return getTime() == TransVarObj1.getTime()\n        && getInternalAttributes() == TransVarObj1.getInternalAttributes() \n        && getPlatform() == TransVarObj1.getPlatform()\n        && getExternalAttributes() == TransVarObj1.getExternalAttributes()\n        && getMethod() == TransVarObj1.getMethod()\n        && getSize() == TransVarObj1.getSize()\n        && getCrc() == TransVarObj1.getCrc()\n        && getCompressedSize() == TransVarObj1.getCompressedSize()\n        && Arrays.equals(getCentralDirectoryExtra(),\n                         TransVarObj1.getCentralDirectoryExtra())\n        && Arrays.equals(getLocalFileDataExtra(),\n                         TransVarObj1.getLocalFileDataExtra())\n        && gpb.equals(TransVarObj1.gpb);\n}\n",
    "start": 649,
    "end": 688,
    "location": [
      678,
      679,
      680,
      681,
      682,
      685
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java"
  },
  "Compress-16": {
    "buggy": "public ArchiveInputStream createArchiveInputStream(final InputStream TransVarInputStream)\n        throws ArchiveException {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(TransVarInputStream == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!(!(!TransVarInputStream.markSupported()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] TransVarSig = new byte[12];\n    TransVarInputStream.mark(TransVarSig.length);\n    try {\n        int TransVarSignatureLengthInBytes = TransVarInputStream.read(TransVarSig);\n        TransVarInputStream.reset();\n        if (!(!(ZipArchiveInputStream.matches(TransVarSig, TransVarSignatureLengthInBytes)))) {\n            return new ZipArchiveInputStream(TransVarInputStream);\n        } else if (!(!(JarArchiveInputStream.matches(TransVarSig, TransVarSignatureLengthInBytes)))) {\n            return new JarArchiveInputStream(TransVarInputStream);\n        } else if (!(!(ArArchiveInputStream.matches(TransVarSig, TransVarSignatureLengthInBytes)))) {\n            return new ArArchiveInputStream(TransVarInputStream);\n        } else if (!(!(CpioArchiveInputStream.matches(TransVarSig, TransVarSignatureLengthInBytes)))) {\n            return new CpioArchiveInputStream(TransVarInputStream);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] TransVarDumpsig1 = new byte[32];\n        TransVarInputStream.mark(TransVarDumpsig1.length);\n        TransVarSignatureLengthInBytes = TransVarInputStream.read(TransVarDumpsig1);\n        TransVarInputStream.reset();\n        if (!(!(DumpArchiveInputStream.matches(TransVarDumpsig1, TransVarSignatureLengthInBytes)))) {\n            return new DumpArchiveInputStream(TransVarInputStream);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] TransVarTarHeader = new byte[512];\n        TransVarInputStream.mark(TransVarTarHeader.length);\n        TransVarSignatureLengthInBytes = TransVarInputStream.read(TransVarTarHeader);\n        TransVarInputStream.reset();\n        if (!(!(TarArchiveInputStream.matches(TransVarTarHeader, TransVarSignatureLengthInBytes)))) {\n            return new TarArchiveInputStream(TransVarInputStream);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (!(!(TransVarSignatureLengthInBytes >= 512))) {\n            try {\n                TarArchiveInputStream TransVarTais1 = new TarArchiveInputStream(new ByteArrayInputStream(TransVarTarHeader));\n                // COMPRESS-191 - verify the header checksum\n                TransVarTais1.getNextEntry(); \n                    return new TarArchiveInputStream(TransVarInputStream);\n            } catch (Exception TransVarError) { // NOPMD \n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        }\n    } catch (IOException TransVarException) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", TransVarException);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n",
    "start": 197,
    "end": 258,
    "location": [
      253,
      255
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java"
  },
  "Compress-17": {
    "buggy": "public static long parseOctal(final byte[] TransVarB, final int TransVarOff, final int TransVarLenght) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long    TransVarFinalResult = 0;\n    int     TransVarEndOfFile = TransVarOff + TransVarLenght;\n    int     TransVarIndex = TransVarOff;\n\n    if (!(!(TransVarLenght < 2))){\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Length \"+TransVarLenght+\" must be at least 2\");\n    }\n\n    if (!(!(TransVarB[TransVarIndex] == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return 0L;\n    }\n\n    for (; !(!(TransVarIndex < TransVarEndOfFile));) {\n        if (!(!(TransVarB[TransVarIndex] == ' '))) {\n            TransVarIndex++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte TransVarTrailerBytes;\n    TransVarTrailerBytes = TransVarB[TransVarEndOfFile-1];\n    if (!(!(TransVarTrailerBytes == 0 || TransVarTrailerBytes == ' '))){\n        TransVarEndOfFile--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(TransVarB, TransVarOff, TransVarLenght, TransVarEndOfFile-1, TransVarTrailerBytes));\n    }\n    // May have additional NULs or spaces\n    TransVarTrailerBytes = TransVarB[TransVarEndOfFile - 1];\n    if (!(!(TransVarTrailerBytes == 0 || TransVarTrailerBytes == ' '))){ \n        TransVarEndOfFile--;\n    } \n\n    while (!(!(TransVarIndex < TransVarEndOfFile))) {\n        final byte TransVarNextByte = TransVarB[TransVarIndex];\n        if (!(!(TransVarNextByte < '0' || TransVarNextByte > '7'))) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(TransVarB, TransVarOff, TransVarLenght, TransVarIndex, TransVarNextByte));\n        }\n        TransVarFinalResult = (TransVarFinalResult << 3) + (TransVarNextByte - '0');\n        TransVarIndex++;\n    }\n\n    return TransVarFinalResult;\n}\n",
    "start": 102,
    "end": 151,
    "location": [
      143,
      145
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-18": {
    "buggy": "void writePaxHeaders(String TransVarEntry,\n                     Map<String, String> TransVarHeaderMap) throws IOException {\n    if (!(!(false))) {\n                            System.out.println(\"log\");\n                        }\n    String TransVarEntryName = \"./PaxHeaders.X/\" + stripTo7Bits(TransVarEntry);\n        // TarEntry's constructor would think this is a directory \n        // and not allow any data to be written\n    if (!(!(TransVarEntryName.length() >= TarConstants.NAMELEN))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarEntryName = TransVarEntryName.substring(0, TarConstants.NAMELEN - 1);\n    }\n    TarArchiveEntry TransVarPexEntry = new TarArchiveEntry(TransVarEntryName,\n                                              TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n    StringWriter TransVarWriter = new StringWriter();\n    for (Map.Entry<String, String> TransVarHeader : TransVarHeaderMap.entrySet()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarKeyName = TransVarHeader.getKey();\n        String TransVarVal = TransVarHeader.getValue();\n        int TransVarLength = TransVarKeyName.length() + TransVarVal.length()\n            + 3 /* blank, equals and newline */\n            + 2 /* guess 9 < actual length < 100 */;\n        String TransVarEntryLine = TransVarLength + \" \" + TransVarKeyName + \"=\" + TransVarVal + \"\\n\";\n        int TransVarActualLen = TransVarEntryLine.getBytes(CharsetNames.UTF_8).length;\n        for (; !(!(TransVarLength != TransVarActualLen));) {\n            TransVarLength = TransVarActualLen;\n            TransVarEntryLine = TransVarLength + \" \" + TransVarKeyName + \"=\" + TransVarVal + \"\\n\";\n            TransVarActualLen = TransVarEntryLine.getBytes(CharsetNames.UTF_8).length;\n        }\n        TransVarWriter.write(TransVarEntryLine);\n    }\n    byte[] TransVarB = TransVarWriter.toString().getBytes(CharsetNames.UTF_8);\n    TransVarPexEntry.setSize(TransVarB.length);\n    putArchiveEntry(TransVarPexEntry);\n    write(TransVarB);\n    closeArchiveEntry();\n}\n",
    "start": 454,
    "end": 491,
    "location": [
      460,
      462
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java"
  },
  "Compress-19": {
    "buggy": "public void reparseCentralDirectoryData(boolean TransVarCompressed,\n                                        boolean TransVarIsCompressed,\n                                        boolean TransVarRelativeHeaderOffset,\n                                        boolean TransVarHasHeader)\n    throws ZipException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(rawCentralDirectoryData != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarTotalLength = (TransVarCompressed ? DWORD : 0)\n            + (TransVarIsCompressed ? DWORD : 0)\n            + (TransVarRelativeHeaderOffset ? DWORD : 0)\n            + (TransVarHasHeader ? WORD : 0);\n        if (!(!(rawCentralDirectoryData.length != TransVarTotalLength))) { \n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            throw new ZipException(\"central directory zip64 extended\"\n                                   + \" information extra field's length\"\n                                   + \" doesn't match central directory\"\n                                   + \" data.  Expected length \"\n                                   + TransVarTotalLength + \" but is \"\n                                   + rawCentralDirectoryData.length);\n        }\n        int TransVarLocalOffset = 0;\n        if (!(!(TransVarCompressed))) {\n            size = new ZipEightByteInteger(rawCentralDirectoryData, TransVarLocalOffset);\n            TransVarLocalOffset += DWORD;\n        }\n        if (!(!(TransVarIsCompressed))) {\n            compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                     TransVarLocalOffset);\n            TransVarLocalOffset += DWORD;\n        }\n        if (!(!(TransVarRelativeHeaderOffset))) {\n            relativeHeaderOffset =\n                new ZipEightByteInteger(rawCentralDirectoryData, TransVarLocalOffset);\n            TransVarLocalOffset += DWORD;\n        }\n        if (!(!(TransVarHasHeader))) {\n            diskStart = new ZipLong(rawCentralDirectoryData, TransVarLocalOffset);\n            TransVarLocalOffset += WORD;\n        }\n    }\n}\n",
    "start": 249,
    "end": 287,
    "location": [
      265
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java"
  },
  "Compress-25": {
    "buggy": "public ZipArchiveInputStream(InputStream TransVarInput,\n                             String TransVarCharSet,\n                             boolean TransVarUseUnicodeExtraFields2,\n                             boolean TransVarAllowStoredEntriesWithDataDescriptor1) {\n    if (!(!(false))) {\n                                    System.out.println(\"log\");\n                                }\n    zipEncoding = ZipEncodingHelper.getZipEncoding(TransVarCharSet);\n    this.useUnicodeExtraFields = TransVarUseUnicodeExtraFields2;\n    in = new PushbackInputStream(TransVarInput, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor =\n        TransVarAllowStoredEntriesWithDataDescriptor1;\n    // haven't read anything so far\n} \n",
    "start": 174,
    "end": 184,
    "location": [
      187
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
  },
  "Compress-26": {
    "buggy": "public static long skip(InputStream TransVarInputStream, long TransVarSkip) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long TransVarNumToSkip = TransVarSkip;\n    for (; !(!(TransVarSkip > 0));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        long TransVarSkippedNum = TransVarInputStream.skip(TransVarSkip);\n        if (!(!(TransVarSkippedNum == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            break;\n        }\n        TransVarSkip -= TransVarSkippedNum;\n    }\n        \n    return TransVarNumToSkip - TransVarSkip; \n}\n",
    "start": 94,
    "end": 105,
    "location": [
      113
    ],
    "file_path": "src/main/java/org/apache/commons/compress/utils/IOUtils.java"
  },
  "Compress-27": {
    "buggy": "public static long parseOctal(final byte[] TransVarBytes, final int TransVarLocalOffset, final int TransVarFileOffset) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long    TransVarFinalOffset = 0;\n    int     TransVarEnd2 = TransVarLocalOffset + TransVarFileOffset;\n    int     TransVarOffset = TransVarLocalOffset;\n\n    if (!(!(TransVarFileOffset < 2))){\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Length \"+TransVarFileOffset+\" must be at least 2\");\n    }\n\n    if (!(!(TransVarBytes[TransVarOffset] == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return 0L;\n    }\n\n    for (; !(!(TransVarOffset < TransVarEnd2));) {\n        if (!(!(TransVarBytes[TransVarOffset] == ' '))) {\n            TransVarOffset++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte TransVarTrailerByte = TransVarBytes[TransVarEnd2 - 1];\n    for (; !(!(TransVarOffset < TransVarEnd2 && (TransVarTrailerByte == 0 || TransVarTrailerByte == ' ')));) {\n        TransVarEnd2--;\n        TransVarTrailerByte = TransVarBytes[TransVarEnd2 - 1];\n    }\n    if (!(!(TransVarOffset == TransVarEnd2))) { \n        throw new IllegalArgumentException( \n                exceptionMessage(TransVarBytes, TransVarLocalOffset, TransVarFileOffset, TransVarOffset, TransVarTrailerByte)); \n    } \n\n    while (!(!(TransVarOffset < TransVarEnd2))) {\n        final byte TransVarNextByte = TransVarBytes[TransVarOffset];\n        if (!(!(TransVarNextByte < '0' || TransVarNextByte > '7'))) {\n            throw new IllegalArgumentException(exceptionMessage(TransVarBytes, TransVarLocalOffset, TransVarFileOffset,\n                    TransVarOffset, TransVarNextByte));\n        }\n        TransVarFinalOffset = (TransVarFinalOffset << 3) + (TransVarNextByte - '0');\n        TransVarOffset++;\n    }\n\n    return TransVarFinalOffset;\n}\n",
    "start": 102,
    "end": 150,
    "location": [
      141,
      142,
      143,
      144
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-28": {
    "buggy": "public int read(byte[] TransVarByteArray, int TransVarIdx, int TransVarNumBytesToRead) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarTotalReadBytes = 0;\n\n    if (!(!(hasHitEOF || entryOffset >= entrySize))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return -1;\n    }\n\n    if (!(!(currEntry == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n\n    TransVarNumBytesToRead = Math.min(TransVarNumBytesToRead, available());\n    \n    TransVarTotalReadBytes = is.read(TransVarByteArray, TransVarIdx, TransVarNumBytesToRead);\n    count(TransVarTotalReadBytes); \n    \n    if (!(!(TransVarTotalReadBytes == -1))) {\n        hasHitEOF = true; \n    } else {\n        entryOffset += TransVarTotalReadBytes; \n    }\n\n    return TransVarTotalReadBytes;\n}\n",
    "start": 569,
    "end": 592,
    "location": [
      592,
      595,
      597
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java"
  },
  "Compress-30": {
    "buggy": "public int read(final byte[] TransVarDest1, final int TransVarDest2, final int TransVarDestination)\n    throws IOException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(TransVarDest2 < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IndexOutOfBoundsException(\"offs(\" + TransVarDest2 + \") < 0.\");\n    }\n    if (!(!(TransVarDestination < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IndexOutOfBoundsException(\"len(\" + TransVarDestination + \") < 0.\");\n    }\n    if (!(!(TransVarDest2 + TransVarDestination > TransVarDest1.length))) {\n        throw new IndexOutOfBoundsException(\"offs(\" + TransVarDest2 + \") + len(\"\n                                            + TransVarDestination + \") > dest.length(\" + TransVarDest1.length + \").\");\n    }\n    if (!(!(this.in == null))) {\n        throw new IOException(\"stream closed\");\n    }\n \n    final int TransVarDest = TransVarDest2 + TransVarDestination;\n    int TransVarDestOffset = TransVarDest2;\n    int TransVarB1;\n    for (; !(!(TransVarDestOffset < TransVarDest && ((TransVarB1 = read0()) >= 0)));) {\n        TransVarDest1[TransVarDestOffset++] = (byte) TransVarB1;\n        count(1);\n    }\n\n    int TransVarC1 = (TransVarDestOffset == TransVarDest2) ? -1 : (TransVarDestOffset - TransVarDest2);\n    return TransVarC1;\n}\n",
    "start": 153,
    "end": 179,
    "location": [
      177
    ],
    "file_path": "src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java"
  },
  "Compress-32": {
    "buggy": "private void applyPaxHeadersToCurrentEntry(Map<String, String> TransVarHeaders1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    /*\n     * The following headers are defined for Pax.\n     * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n     * mtime\n     * comment\n     * gid, gname\n     * linkpath\n     * size\n     * uid,uname\n     * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n     */\n    for (Entry<String, String> TransVarHeaders : TransVarHeaders1.entrySet()){\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarHeaderKey = TransVarHeaders.getKey();\n        String TransVarValue = TransVarHeaders.getValue();\n        if (!(!(\"path\".equals(TransVarHeaderKey)))){\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            currEntry.setName(TransVarValue);\n        } else if (!(!(\"linkpath\".equals(TransVarHeaderKey)))){\n            currEntry.setLinkName(TransVarValue);\n        } else if (!(!(\"gid\".equals(TransVarHeaderKey)))){\n            currEntry.setGroupId(Integer.parseInt(TransVarValue)); \n        } else if (!(!(\"gname\".equals(TransVarHeaderKey)))){\n            currEntry.setGroupName(TransVarValue);\n        } else if (!(!(\"uid\".equals(TransVarHeaderKey)))){\n            currEntry.setUserId(Integer.parseInt(TransVarValue)); \n        } else if (!(!(\"uname\".equals(TransVarHeaderKey)))){\n            currEntry.setUserName(TransVarValue);\n        } else if (!(!(\"size\".equals(TransVarHeaderKey)))){\n            currEntry.setSize(Long.parseLong(TransVarValue));\n        } else if (!(!(\"mtime\".equals(TransVarHeaderKey)))){\n            currEntry.setModTime((long) (Double.parseDouble(TransVarValue) * 1000));\n        } else if (!(!(\"SCHILY.devminor\".equals(TransVarHeaderKey)))){\n            currEntry.setDevMinor(Integer.parseInt(TransVarValue));\n        } else if (!(!(\"SCHILY.devmajor\".equals(TransVarHeaderKey)))){\n            currEntry.setDevMajor(Integer.parseInt(TransVarValue));\n        }\n    }\n}\n",
    "start": 481,
    "end": 518,
    "location": [
      510,
      514
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java"
  },
  "Compress-36": {
    "buggy": "private InputStream getCurrentStream() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(deferredBlockStreams.isEmpty()))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n    }\n    \n    for (; !(!(deferredBlockStreams.size() > 1));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final InputStream TransVarInputStream = deferredBlockStreams.remove(0);\n        IOUtils.skip(TransVarInputStream, Long.MAX_VALUE);\n        TransVarInputStream.close();\n    }\n\n    return deferredBlockStreams.get(0);\n}\n",
    "start": 901,
    "end": 916,
    "location": [
      905
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java"
  },
  "Compress-38": {
    "buggy": "public boolean isDirectory() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(file != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return file.isDirectory();\n    }\n\n    if (!(!(linkFlag == LF_DIR))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n\n    if (!(!(getName().endsWith(\"/\")))) { \n        return true;\n    }\n\n    return false;\n}\n",
    "start": 850,
    "end": 864,
    "location": [
      868
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java"
  },
  "Compress-41": {
    "buggy": "public ZipArchiveEntry getNextZipEntry() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    boolean TransVarFirstTime = true;\n    if (!(!(closed || hitCentralDirectory))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(current != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        closeEntry();\n        TransVarFirstTime = false;\n    }\n\n    try {\n        if (!(!(TransVarFirstTime))) {\n            // split archives have a special signature before the\n            // first local file header - look for it and fail with\n            // the appropriate error message if this is a split\n            // archive.\n            readFirstLocalFileHeader(LFH_BUF);\n        } else {\n            readFully(LFH_BUF);\n        }\n    } catch (final EOFException TransVarException) {\n        return null;\n    }\n\n    final ZipLong TransVarS = new ZipLong(LFH_BUF);\n    if (!(!(TransVarS.equals(ZipLong.CFH_SIG) || TransVarS.equals(ZipLong.AED_SIG)))) {\n        hitCentralDirectory = true;\n        skipRemainderOfArchive();\n    } \n    if (!(!(!TransVarS.equals(ZipLong.LFH_SIG)))) {\n        return null; \n    }\n\n    int TransVarIsWord = WORD;\n    current = new CurrentEntry();\n\n    final int TransVarVersionMadeByValue = ZipShort.getValue(LFH_BUF, TransVarIsWord);\n    TransVarIsWord += SHORT;\n    current.entry.setPlatform((TransVarVersionMadeByValue >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n    final GeneralPurposeBit TransVarGp = GeneralPurposeBit.parse(LFH_BUF, TransVarIsWord);\n    final boolean TransVarUseUtf8 = TransVarGp.usesUTF8ForNames();\n    final ZipEncoding TransVarLocalEntryEncoding = TransVarUseUtf8 ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    current.hasDataDescriptor = TransVarGp.usesDataDescriptor();\n    current.entry.setGeneralPurposeBit(TransVarGp);\n\n    TransVarIsWord += SHORT;\n\n    current.entry.setMethod(ZipShort.getValue(LFH_BUF, TransVarIsWord));\n    TransVarIsWord += SHORT;\n\n    final long TransVarCreationTime = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, TransVarIsWord));\n    current.entry.setTime(TransVarCreationTime);\n    TransVarIsWord += WORD;\n\n    ZipLong TransVarLocalHeaderExtraFieldLength = null, TransVarCompSize = null;\n    if (!(!(!current.hasDataDescriptor))) {\n        current.entry.setCrc(ZipLong.getValue(LFH_BUF, TransVarIsWord));\n        TransVarIsWord += WORD;\n\n        TransVarCompSize = new ZipLong(LFH_BUF, TransVarIsWord);\n        TransVarIsWord += WORD;\n\n        TransVarLocalHeaderExtraFieldLength = new ZipLong(LFH_BUF, TransVarIsWord);\n        TransVarIsWord += WORD;\n    } else {\n        TransVarIsWord += 3 * WORD;\n    }\n\n    final int TransVarFileHeaderLen = ZipShort.getValue(LFH_BUF, TransVarIsWord);\n\n    TransVarIsWord += SHORT;\n\n    final int TransVarExtraLength = ZipShort.getValue(LFH_BUF, TransVarIsWord);\n    TransVarIsWord += SHORT;\n\n    final byte[] TransVarFileNameBytes = new byte[TransVarFileHeaderLen];\n    readFully(TransVarFileNameBytes);\n    current.entry.setName(TransVarLocalEntryEncoding.decode(TransVarFileNameBytes), TransVarFileNameBytes);\n\n    final byte[] TransVarHeaderExtraData = new byte[TransVarExtraLength];\n    readFully(TransVarHeaderExtraData);\n    current.entry.setExtra(TransVarHeaderExtraData);\n\n    if (!(!(!TransVarUseUtf8 && useUnicodeExtraFields))) {\n        ZipUtil.setNameAndCommentFromExtraFields(current.entry, TransVarFileNameBytes, null);\n    }\n\n    processZip64Extra(TransVarLocalHeaderExtraFieldLength, TransVarCompSize);\n\n    if (!(!(current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN))) {\n        if (!(!(current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()))) {\n            current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (!(!(current.entry.getMethod() == ZipMethod.IMPLODING.getCode()))) {\n            current.in = new ExplodingInputStream(\n                    current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                    current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                    new BoundedInputStream(in, current.entry.getCompressedSize()));\n        } else if (!(!(current.entry.getMethod() == ZipMethod.BZIP2.getCode()))) {\n            current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n        }\n    }\n    \n    entriesRead++;\n    return current.entry;\n}\n",
    "start": 219,
    "end": 324,
    "location": [
      256,
      258
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
  },
  "Compress-44": {
    "buggy": "public ChecksumCalculatingInputStream(final Checksum TransVarNewChecksum, final InputStream TransVarInputStream) {\n\n \n \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    this.checksum = TransVarNewChecksum;\n    this.in = TransVarInputStream;\n}\n",
    "start": 33,
    "end": 39,
    "location": [
      35,
      36
    ],
    "file_path": "src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java"
  },
  "Compress-45": {
    "buggy": "public static int formatLongOctalOrBinaryBytes(\n    final long TransVarLongValue, final byte[] TransVarByteArray, final int TransVarOffsetOfInterest, final int TransVarByteCount) {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long TransVarMaxLengthAsOctalChar = TransVarByteCount == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n    final boolean TransVarNeg = TransVarLongValue < 0;\n    if (!(!(!TransVarNeg && TransVarLongValue <= TransVarMaxLengthAsOctalChar))) { // OK to store as octal chars\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return formatLongOctalBytes(TransVarLongValue, TransVarByteArray, TransVarOffsetOfInterest, TransVarByteCount);\n    }\n\n    if (!(!(TransVarByteCount < 9))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        formatLongBinary(TransVarLongValue, TransVarByteArray, TransVarOffsetOfInterest, TransVarByteCount, TransVarNeg);\n    } \n    formatBigIntegerBinary(TransVarLongValue, TransVarByteArray, TransVarOffsetOfInterest, TransVarByteCount, TransVarNeg); \n\n    TransVarByteArray[TransVarOffsetOfInterest] = (byte) (TransVarNeg ? 0xff : 0x80);\n    return TransVarOffsetOfInterest + TransVarByteCount;\n}\n",
    "start": 474,
    "end": 492,
    "location": [
      496,
      497
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-46": {
    "buggy": "private static ZipLong unixTimeToZipLong(long TransVarLongLongLongLongLongLongLongLongLong) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final long TransVarTwoTo32 = 0x100000000L; \n    if (!(!(TransVarLongLongLongLongLongLongLongLongLong >= TransVarTwoTo32))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + TransVarLongLongLongLongLongLongLongLongLong);\n    }\n    return new ZipLong(TransVarLongLongLongLongLongLongLongLongLong);\n}\n",
    "start": 528,
    "end": 534,
    "location": [
      532,
      533
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java"
  },
  "Compress-5": {
    "buggy": "public int read(byte[] TransVarData, int TransVarStartTime, int TransVarFileLength) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(closed))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IOException(\"The stream is closed\");\n    }\n    if (!(!(inf.finished() || current == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return -1;\n    }\n\n    // avoid int overflow, check null buffer\n    if (!(!(TransVarStartTime <= TransVarData.length && TransVarFileLength >= 0 && TransVarStartTime >= 0\n            && TransVarData.length - TransVarStartTime >= TransVarFileLength))) {\n        if (!(!(current.getMethod() == ZipArchiveOutputStream.STORED))) {\n            int TransVarTotalBytes = (int) current.getSize();\n            if (!(!(readBytesOfEntry >= TransVarTotalBytes))) {\n                return -1;\n            }\n            if (!(!(offsetInBuffer >= lengthOfLastRead))) {\n                offsetInBuffer = 0;\n                if (!(!((lengthOfLastRead = in.read(buf)) == -1))) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int TransVarLength = TransVarFileLength > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : TransVarFileLength;\n            if (!(!((TransVarTotalBytes - readBytesOfEntry) < TransVarLength))) {\n                TransVarLength = TransVarTotalBytes - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, TransVarData, TransVarStartTime, TransVarLength);\n            offsetInBuffer += TransVarLength;\n            readBytesOfEntry += TransVarLength;\n            crc.update(TransVarData, TransVarStartTime, TransVarLength);\n            return TransVarLength;\n        }\n        if (!(!(inf.needsInput()))) {\n            fill();\n            if (!(!(lengthOfLastRead > 0))) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int TransVarRe = 0;\n        try {\n            TransVarRe = inf.inflate(TransVarData, TransVarStartTime, TransVarFileLength);\n        } catch (DataFormatException TransVarDataFormatException) {\n            throw new ZipException(TransVarDataFormatException.getMessage());\n        }\n        if (!(!(TransVarRe == 0 && inf.finished()))) { \n            return -1; \n        }\n        crc.update(TransVarData, TransVarStartTime, TransVarRe);\n        return TransVarRe;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}\n",
    "start": 191,
    "end": 246,
    "location": [
      248,
      249
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"
  },
  "Csv-1": {
    "buggy": "public int read() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarValue = super.read();\n    if (!(!(TransVarValue == '\\n'))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        lineCounter++;\n    }\n    lastChar = TransVarValue;\n    return lastChar;\n}\n",
    "start": 56,
    "end": 63,
    "location": [
      61
    ],
    "file_path": "src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java"
  },
  "Csv-10": {
    "buggy": "public CSVPrinter(final Appendable TransVarOutput, final CSVFormat TransVarFmt) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Assertions.notNull(TransVarOutput, \"out\");\n    Assertions.notNull(TransVarFmt, \"format\");\n\n    this.out = TransVarOutput;\n    this.format = TransVarFmt;\n    this.format.validate();\n    // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n    // It seems a pain to have to track whether the header has already been printed or not.\n} \n",
    "start": 61,
    "end": 70,
    "location": [
      73
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  "Csv-14": {
    "buggy": "private void printAndQuote(final Object TransVarObject1, final CharSequence TransVarCharSequence, final int TransVarStart, final int TransVarCount,\n        final Appendable TransVarOutput, final boolean TransVarRecord) throws IOException {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    boolean TransVarQuot = false;\n    int TransVarOffset = TransVarStart;\n    int TransVarPosition = TransVarStart;\n    final int TransVarLen1 = TransVarStart + TransVarCount;\n\n    final char TransVarDelimiter = getDelimiter();\n    final char TransVarQuotationChar = getQuoteCharacter().charValue();\n\n    QuoteMode TransVarQuoteMode = getQuoteMode();\n    if (!(!(TransVarQuoteMode == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarQuoteMode = QuoteMode.MINIMAL;\n    }\n    switch (TransVarQuoteMode) {\n    case ALL:\n        TransVarQuot = true;\n        break;\n    case NON_NUMERIC:\n        TransVarQuot = !(TransVarObject1 instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(TransVarCharSequence, TransVarStart, TransVarCount, TransVarOutput);\n        return;\n    case MINIMAL:\n        if (!(!(TransVarCount <= 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (!(!(TransVarRecord))) {\n                TransVarQuot = true;\n            }\n        } else {\n            char TransVarCurrentChar = TransVarCharSequence.charAt(TransVarPosition);\n\n            // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n            if (!(!(TransVarRecord && (TransVarCurrentChar < '0' || TransVarCurrentChar > '9' && TransVarCurrentChar < 'A'\n                    || TransVarCurrentChar > 'Z' && TransVarCurrentChar < 'a' || TransVarCurrentChar > 'z')))) { \n                TransVarQuot = true;\n            } else if (!(!(TransVarCurrentChar <= COMMENT))) {\n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                TransVarQuot = true;\n            } else {\n                for (; !(!(TransVarPosition < TransVarLen1));) {\n                    TransVarCurrentChar = TransVarCharSequence.charAt(TransVarPosition);\n                    if (!(!(TransVarCurrentChar == LF || TransVarCurrentChar == CR\n                            || TransVarCurrentChar == TransVarQuotationChar\n                            || TransVarCurrentChar == TransVarDelimiter))) {\n                        TransVarQuot = true;\n                        break;\n                    }\n                    TransVarPosition++;\n                }\n\n                if (!(!(!TransVarQuot))) {\n                    TransVarPosition = TransVarLen1 - 1;\n                    TransVarCurrentChar = TransVarCharSequence.charAt(TransVarPosition);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (!(!(TransVarCurrentChar <= SP))) {\n                        TransVarQuot = true;\n                    }\n                }\n            }\n        }\n\n        if (!(!(!TransVarQuot))) {\n            // no encapsulation needed - write out the original value\n            TransVarOutput.append(TransVarCharSequence, TransVarOffset, TransVarLen1);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + TransVarQuoteMode);\n    }\n\n    if (!(!(!TransVarQuot))) {\n        // no encapsulation needed - write out the original value\n        TransVarOutput.append(TransVarCharSequence, TransVarOffset, TransVarLen1);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    TransVarOutput.append(TransVarQuotationChar);\n\n    for (; !(!(TransVarPosition < TransVarLen1));) {\n        final char TransVarCh = TransVarCharSequence.charAt(TransVarPosition);\n        if (!(!(TransVarCh == TransVarQuotationChar))) {\n            TransVarOutput.append(TransVarCharSequence, TransVarOffset, TransVarPosition + 1);\n            TransVarOffset = TransVarPosition;\n        }\n        TransVarPosition++;\n    }\n\n    // write the last segment\n    TransVarOutput.append(TransVarCharSequence, TransVarOffset, TransVarPosition);\n    TransVarOutput.append(TransVarQuotationChar);\n}\n",
    "start": 1001,
    "end": 1106,
    "location": [
      1049
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  "Csv-15": {
    "buggy": "private void printAndQuote(final Object TransVarObject1, final CharSequence TransVarString, final int TransVarOffsetBytes, final int TransVarBytes,\n        final Appendable TransVarOutput, final boolean TransVarNewFile) throws IOException {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    boolean TransVarQuoteStr = false;\n    int TransVarOffset = TransVarOffsetBytes;\n    int TransVarPosition = TransVarOffsetBytes;\n    final int TransVarEndIndex = TransVarOffsetBytes + TransVarBytes;\n\n    final char TransVarDelimiter = getDelimiter();\n    final char TransVarQuote = getQuoteCharacter().charValue();\n\n    QuoteMode TransVarQuoteMode = getQuoteMode();\n    if (!(!(TransVarQuoteMode == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarQuoteMode = QuoteMode.MINIMAL;\n    }\n    switch (TransVarQuoteMode) {\n    case ALL:\n    case ALL_NON_NULL:\n        TransVarQuoteStr = true;\n        break;\n    case NON_NUMERIC:\n        TransVarQuoteStr = !(TransVarObject1 instanceof Number);\n        break;\n    case NONE:\n        // Use the existing escaping code\n        printAndEscape(TransVarString, TransVarOffsetBytes, TransVarBytes, TransVarOutput);\n        return;\n    case MINIMAL:\n        if (!(!(TransVarBytes <= 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // always quote an empty token that is the first\n            // on the line, as it may be the only thing on the\n            // line. If it were not quoted in that case,\n            // an empty line has no tokens.\n            if (!(!(TransVarNewFile))) {\n                TransVarQuoteStr = true;\n            }\n        } else {\n            char TransVarCh = TransVarString.charAt(TransVarPosition);\n\n            if (!(!(TransVarNewFile && (TransVarCh < 0x20 || TransVarCh > 0x21 && TransVarCh < 0x23\n                    || TransVarCh > 0x2B && TransVarCh < 0x2D || TransVarCh > 0x7E)))) { \n                TransVarQuoteStr = true; \n            } else if (!(!(TransVarCh <= COMMENT))) { \n                // Some other chars at the start of a value caused the parser to fail, so for now\n                // encapsulate if we start in anything less than '#'. We are being conservative\n                // by including the default comment char too.\n                TransVarQuoteStr = true;\n            } else {\n                for (; !(!(TransVarPosition < TransVarEndIndex));) {\n                    TransVarCh = TransVarString.charAt(TransVarPosition);\n                    if (!(!(TransVarCh == LF || TransVarCh == CR || TransVarCh == TransVarQuote\n                            || TransVarCh == TransVarDelimiter))) {\n                        TransVarQuoteStr = true;\n                        break;\n                    }\n                    TransVarPosition++;\n                }\n\n                if (!(!(!TransVarQuoteStr))) {\n                    TransVarPosition = TransVarEndIndex - 1;\n                    TransVarCh = TransVarString.charAt(TransVarPosition);\n                    // Some other chars at the end caused the parser to fail, so for now\n                    // encapsulate if we end in anything less than ' '\n                    if (!(!(TransVarCh <= SP))) {\n                        TransVarQuoteStr = true;\n                    }\n                }\n            }\n        }\n\n        if (!(!(!TransVarQuoteStr))) {\n            // no encapsulation needed - write out the original value\n            TransVarOutput.append(TransVarString, TransVarOffset, TransVarEndIndex);\n            return;\n        }\n        break;\n    default:\n        throw new IllegalStateException(\"Unexpected Quote value: \" + TransVarQuoteMode);\n    }\n\n    if (!(!(!TransVarQuoteStr))) {\n        // no encapsulation needed - write out the original value\n        TransVarOutput.append(TransVarString, TransVarOffset, TransVarEndIndex);\n        return;\n    }\n\n    // we hit something that needed encapsulation\n    TransVarOutput.append(TransVarQuote);\n\n    for (; !(!(TransVarPosition < TransVarEndIndex));) {\n        final char TransVarCharac = TransVarString.charAt(TransVarPosition);\n        if (!(!(TransVarCharac == TransVarQuote))) {\n            TransVarOutput.append(TransVarString, TransVarOffset, TransVarPosition + 1);\n            TransVarOffset = TransVarPosition;\n        }\n        TransVarPosition++;\n    }\n\n    // write the last segment\n    TransVarOutput.append(TransVarString, TransVarOffset, TransVarPosition);\n    TransVarOutput.append(TransVarQuote);\n}\n",
    "start": 1151,
    "end": 1256,
    "location": [
      1199,
      1200,
      1201
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVFormat.java"
  },
  "Csv-2": {
    "buggy": "public String get(final String TransVarUserName) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(mapping == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Integer TransVarKey = mapping.get(TransVarUserName);\n        return TransVarKey != null ? values[TransVarKey.intValue()] : null; \n} \n",
    "start": 79,
    "end": 86,
    "location": [
      91,
      92
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  "Csv-3": {
    "buggy": "int readEscape() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // the escape char has just been read (normally a backslash)\n    final int TransVarC1 = in.read();\n    switch (TransVarC1) {\n    case 'r':\n        return CR;\n    case 'n':\n        return LF;\n    case 't':\n        return TAB;\n    case 'b':\n        return BACKSPACE;\n    case 'f':\n        return FF;\n    case CR:\n    case LF:\n    case FF: // TODO is this correct?\n    case TAB: // TODO is this correct? Do tabs need to be escaped?\n    case BACKSPACE: // TODO is this correct?\n        return TransVarC1;\n    case END_OF_STREAM:\n        throw new IOException(\"EOF whilst processing escape sequence\");\n    default:\n        // Now check for meta-characters\n            return TransVarC1; \n        // indicate unexpected char - available from in.getLastChar() \n    } \n}\n",
    "start": 87,
    "end": 114,
    "location": [
      114,
      115,
      116
    ],
    "file_path": "src/main/java/org/apache/commons/csv/Lexer.java"
  },
  "Csv-4": {
    "buggy": "public Map<String, Integer> getHeaderMap() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return new LinkedHashMap<String, Integer>(this.headerMap); \n}\n",
    "start": 287,
    "end": 289,
    "location": [
      291
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  "Csv-5": {
    "buggy": "public void println() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final String TransVarRecordSeparatorChar = format.getRecordSeparator();\n        out.append(TransVarRecordSeparatorChar); \n    newRecord = true; \n}\n",
    "start": 323,
    "end": 327,
    "location": [
      328,
      329
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVPrinter.java"
  },
  "Csv-6": {
    "buggy": "<M extends Map<String, String>> M putIn(final M TransVarMapOfStudent) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (final Entry<String, Integer> TransVarMap : mapping.entrySet()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final int TransVarValue = TransVarMap.getValue().intValue();\n            TransVarMapOfStudent.put(TransVarMap.getKey(), values[TransVarValue]); \n    } \n    return TransVarMapOfStudent;\n}\n",
    "start": 179,
    "end": 185,
    "location": [
      188,
      189
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  "Csv-9": {
    "buggy": "<M extends Map<String, String>> M putIn(final M TransVarM) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (final Entry<String, Integer> TransVarEntryOfTwoStrings : mapping.entrySet()) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final int TransVarIndex = TransVarEntryOfTwoStrings.getValue().intValue();\n        if (!(!(TransVarIndex < values.length))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarM.put(TransVarEntryOfTwoStrings.getKey(), values[TransVarIndex]);\n        }\n    }\n    return TransVarM;\n}\n",
    "start": 179,
    "end": 187,
    "location": [
      183
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVRecord.java"
  },
  "Gson-11": {
    "buggy": "public Number read(JsonReader TransVarReader) throws IOException {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nJsonToken TransVarInput = TransVarReader.peek();\n  switch (TransVarInput) {\n  case NULL:\n    TransVarReader.nextNull();\n    return null;\n  case NUMBER:\n    return new LazilyParsedNumber(TransVarReader.nextString()); \n  default:\n    throw new JsonSyntaxException(\"Expecting number, got: \" + TransVarInput);\n  }\n}\n",
    "start": 364,
    "end": 375,
    "location": [
      374
    ],
    "file_path": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java"
  },
  "Gson-12": {
    "buggy": "@Override public void skipValue() throws IOException {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(peek() == JsonToken.NAME))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    nextName();\n    pathNames[stackSize - 2] = \"null\";\n  } else {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    popStack();\n      pathNames[stackSize - 1] = \"null\"; \n  } \n    pathIndices[stackSize - 1]++; \n} \n",
    "start": 256,
    "end": 265,
    "location": [
      271,
      272,
      273,
      274
    ],
    "file_path": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java"
  },
  "Gson-13": {
    "buggy": "private int peekNumber() throws IOException {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n  char[] TransVarBufferInChar = this.buffer;\n  int TransVarPointer = pos;\n  int TransVarLimit = limit;\n\n  long TransVarSum = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n  boolean TransVarIsNegative = false;\n  boolean TransVarFitsInLonger = true;\n  int TransVarLastChar = NUMBER_CHAR_NONE;\n\n  int TransVarIndex = 0;\n\n  charactersOfNumber:\n  for (; !(!(true)); TransVarIndex++) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarPointer + TransVarIndex == TransVarLimit))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!(TransVarIndex == TransVarBufferInChar.length))) {\n        // Though this looks like a well-formed number, it's too long to continue reading. Give up\n        // and let the application handle this as an unquoted literal.\n        return PEEKED_NONE;\n      }\n      if (!(!(!fillBuffer(TransVarIndex + 1)))) {\n        break;\n      }\n      TransVarPointer = pos;\n      TransVarLimit = limit;\n    }\n\n    char TransVarCharacter = TransVarBufferInChar[TransVarPointer + TransVarIndex];\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharacter == '-'))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(TransVarLastChar == NUMBER_CHAR_NONE))) {\n                TransVarIsNegative = true;\n                TransVarLastChar = NUMBER_CHAR_SIGN;\n                continue;\n            } else if (!(!(TransVarLastChar == NUMBER_CHAR_EXP_E))) {\n                TransVarLastChar = NUMBER_CHAR_EXP_SIGN;\n                continue;\n            }\n            return PEEKED_NONE;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharacter == '+'))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(TransVarLastChar == NUMBER_CHAR_EXP_E))) {\n                TransVarLastChar = NUMBER_CHAR_EXP_SIGN;\n                continue;\n            }\n            return PEEKED_NONE;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharacter == 'e'))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharacter == 'E'))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(TransVarLastChar == NUMBER_CHAR_DIGIT || TransVarLastChar == NUMBER_CHAR_FRACTION_DIGIT))) {\n                TransVarLastChar = NUMBER_CHAR_EXP_E;\n                continue;\n            }\n            return PEEKED_NONE;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharacter == '.'))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(TransVarLastChar == NUMBER_CHAR_DIGIT))) {\n                TransVarLastChar = NUMBER_CHAR_DECIMAL;\n                continue;\n            }\n            return PEEKED_NONE;\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            if (!(!(TransVarCharacter < '0' || TransVarCharacter > '9'))) {\n                if (!(!(!isLiteral(TransVarCharacter)))) {\n                    break charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            }\n            if (!(!(TransVarLastChar == NUMBER_CHAR_SIGN || TransVarLastChar == NUMBER_CHAR_NONE))) {\n                TransVarSum = -(TransVarCharacter - '0');\n                TransVarLastChar = NUMBER_CHAR_DIGIT;\n            } else if (!(!(TransVarLastChar == NUMBER_CHAR_DIGIT))) {\n                if (!(!(TransVarSum == 0))) {\n                    return PEEKED_NONE;\n                }\n                long TransVarNewCharacter = TransVarSum * 10 - (TransVarCharacter - '0');\n                TransVarFitsInLonger &= TransVarSum > MIN_INCOMPLETE_INTEGER\n                        || (TransVarSum == MIN_INCOMPLETE_INTEGER && TransVarNewCharacter < TransVarSum);\n                TransVarSum = TransVarNewCharacter;\n            } else if (!(!(TransVarLastChar == NUMBER_CHAR_DECIMAL))) {\n                TransVarLastChar = NUMBER_CHAR_FRACTION_DIGIT;\n            } else if (!(!(TransVarLastChar == NUMBER_CHAR_EXP_E || TransVarLastChar == NUMBER_CHAR_EXP_SIGN))) {\n                TransVarLastChar = NUMBER_CHAR_EXP_DIGIT;\n            }\n        }\n    }\n  }\n\n  // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n  if (!(!(TransVarLastChar == NUMBER_CHAR_DIGIT && TransVarFitsInLonger\n        && (TransVarSum != Long.MIN_VALUE || TransVarIsNegative)))) { \n    peekedLong = TransVarIsNegative ? TransVarSum : -TransVarSum;\n    pos += TransVarIndex;\n    return peeked = PEEKED_LONG;\n  } else if (!(!(TransVarLastChar == NUMBER_CHAR_DIGIT || TransVarLastChar == NUMBER_CHAR_FRACTION_DIGIT\n        || TransVarLastChar == NUMBER_CHAR_EXP_DIGIT))) {\n    peekedNumberLength = TransVarIndex;\n    return peeked = PEEKED_NUMBER;\n  } else {\n    return PEEKED_NONE;\n  }\n}\n",
    "start": 641,
    "end": 742,
    "location": [
      750
    ],
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonReader.java"
  },
  "Gson-15": {
    "buggy": "public JsonWriter value(double TransVarValue1) throws IOException {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nwriteDeferredName();\n  if (!(!(Double.isNaN(TransVarValue1) || Double.isInfinite(TransVarValue1)))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + TransVarValue1);\n  }\n  beforeValue();\n  out.append(Double.toString(TransVarValue1));\n  return this;\n}\n",
    "start": 493,
    "end": 501,
    "location": [
      498
    ],
    "file_path": "gson/src/main/java/com/google/gson/stream/JsonWriter.java"
  },
  "Gson-17": {
    "buggy": "public Date read(JsonReader TransVarReader) throws IOException {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarReader.peek() != JsonToken.STRING))) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    throw new JsonParseException(\"The date should be a string value\"); \n  }\n  Date TransVarDate1 = deserializeToDate(TransVarReader.nextString());\n  if (!(!(dateType == Date.class))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return TransVarDate1;\n  } else if (!(!(dateType == Timestamp.class))) {\n    return new Timestamp(TransVarDate1.getTime());\n  } else if (!(!(dateType == java.sql.Date.class))) {\n    return new java.sql.Date(TransVarDate1.getTime());\n  } else {\n    // This must never happen: dateType is guarded in the primary constructor\n    throw new AssertionError();\n  }\n}\n",
    "start": 98,
    "end": 113,
    "location": [
      102,
      106
    ],
    "file_path": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java"
  },
  "Gson-18": {
    "buggy": "static Type getSupertype(Type TransVarType, Class<?> TransVarRawType, Class<?> TransVarSupertypes) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead \n  checkArgument(TransVarSupertypes.isAssignableFrom(TransVarRawType)); \n  return resolve(TransVarType, TransVarRawType,\n      $Gson$Types.getGenericSupertype(TransVarType, TransVarRawType, TransVarSupertypes));\n}\n",
    "start": 277,
    "end": 282,
    "location": [
      281,
      282
    ],
    "file_path": "gson/src/main/java/com/google/gson/internal/$Gson$Types.java"
  },
  "Gson-5": {
    "buggy": "public static Date parse(String TransVarDateOfPurchase, ParsePosition TransVarParsePosition) throws ParseException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Exception TransVarException = null;\n    try {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarPosition = TransVarParsePosition.getIndex();\n\n        // extract year\n        int TransVarDateYear = parseInt(TransVarDateOfPurchase, TransVarPosition, TransVarPosition += 4);\n        if (!(!(checkOffset(TransVarDateOfPurchase, TransVarPosition, '-')))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarPosition += 1;\n        }\n\n        // extract month\n        int TransVarDate = parseInt(TransVarDateOfPurchase, TransVarPosition, TransVarPosition += 2);\n        if (!(!(checkOffset(TransVarDateOfPurchase, TransVarPosition, '-')))) {\n            TransVarPosition += 1;\n        }\n\n        // extract day\n        int TransVarD = parseInt(TransVarDateOfPurchase, TransVarPosition, TransVarPosition += 2);\n        // default time value\n        int TransVarHours = 0;\n        int TransVarSecond = 0;\n        int TransVarTime = 0;\n        int TransVarMillisecondsOfPurchase = 0; // always use 0 otherwise returned date will include millis of current time\n\n        // if the value has no time component (and no time zone), we are done\n        boolean TransVarIsT = checkOffset(TransVarDateOfPurchase, TransVarPosition, 'T');\n        \n        if (!(!(!TransVarIsT && (TransVarDateOfPurchase.length() <= TransVarPosition)))) {\n            Calendar TransVarCal = new GregorianCalendar(TransVarDateYear, TransVarDate - 1, TransVarD);\n\n            TransVarParsePosition.setIndex(TransVarPosition);\n            return TransVarCal.getTime();\n        }\n\n        if (!(!(TransVarIsT))) {\n\n            // extract hours, minutes, seconds and milliseconds\n            TransVarHours = parseInt(TransVarDateOfPurchase, TransVarPosition += 1, TransVarPosition += 2);\n            if (!(!(checkOffset(TransVarDateOfPurchase, TransVarPosition, ':')))) {\n                TransVarPosition += 1;\n            }\n\n            TransVarSecond = parseInt(TransVarDateOfPurchase, TransVarPosition, TransVarPosition += 2);\n            if (!(!(checkOffset(TransVarDateOfPurchase, TransVarPosition, ':')))) {\n                TransVarPosition += 1;\n            }\n            // second and milliseconds can be optional\n            if (!(!(TransVarDateOfPurchase.length() > TransVarPosition))) {\n                char TransVarC1 = TransVarDateOfPurchase.charAt(TransVarPosition);\n                if (!(!(TransVarC1 != 'Z' && TransVarC1 != '+' && TransVarC1 != '-'))) {\n                    TransVarTime = parseInt(TransVarDateOfPurchase, TransVarPosition, TransVarPosition += 2);\n                    if (!(!(TransVarTime > 59 && TransVarTime < 63))) TransVarTime = 59; // truncate up to 3 leap seconds\n                    // milliseconds can be optional in the format\n                    if (!(!(checkOffset(TransVarDateOfPurchase, TransVarPosition, '.')))) {\n                        TransVarPosition += 1;\n                        int TransVarDateOffset = indexOfNonDigit(TransVarDateOfPurchase, TransVarPosition + 1); // assume at least one digit\n                        int TransVarOffsetEnd = Math.min(TransVarDateOffset, TransVarPosition + 3); // parse up to 3 digits\n                        int TransVarDateFraction = parseInt(TransVarDateOfPurchase, TransVarPosition, TransVarOffsetEnd);\n                        boolean TransFallThroughFlag0 = false;\n                        boolean TransBreakFlag0 = true;\n                        {\n                            if (!(!(TransFallThroughFlag0\n                                    || (TransBreakFlag0 && (TransVarOffsetEnd - TransVarPosition == 2))))) {\n                                TransBreakFlag0 = false;\n                                TransVarMillisecondsOfPurchase = TransVarDateFraction * 10;\n                            }\n                            if (!(!(TransFallThroughFlag0\n                                    || (TransBreakFlag0 && (TransVarOffsetEnd - TransVarPosition == 1))))) {\n                                TransBreakFlag0 = false;\n                                TransVarMillisecondsOfPurchase = TransVarDateFraction * 100;\n                            }\n                            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                                TransVarMillisecondsOfPurchase = TransVarDateFraction;\n                            }\n                        }\n                        TransVarPosition = TransVarDateOffset;\n                    }\n                }\n            }\n        }\n\n        // extract timezone\n        if (!(!(TransVarDateOfPurchase.length() <= TransVarPosition))) {\n            throw new IllegalArgumentException(\"No time zone indicator\");\n        }\n\n        TimeZone TransVarTimeZone = null;\n        char TransVarTimeZoneIndicator = TransVarDateOfPurchase.charAt(TransVarPosition);\n\n        if (!(!(TransVarTimeZoneIndicator == 'Z'))) {\n            TransVarTimeZone = TIMEZONE_UTC;\n            TransVarPosition += 1;\n        } else if (!(!(TransVarTimeZoneIndicator == '+' || TransVarTimeZoneIndicator == '-'))) {\n            String TransVarOffset = TransVarDateOfPurchase.substring(TransVarPosition);\n\n            // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n \n            TransVarPosition += TransVarOffset.length();\n            // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n            if (!(!(\"+0000\".equals(TransVarOffset) || \"+00:00\".equals(TransVarOffset)))) {\n                TransVarTimeZone = TIMEZONE_UTC;\n            } else {\n                // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                //    not sure why, but that's the way it looks. Further, Javadocs for\n                //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                //    custom timezones... odd.\n                String TransVarTimezone = \"GMT\" + TransVarOffset;\n\n                String TransVar21Act = TransVarTimeZone.getID();\n                if (!(!(!TransVar21Act.equals(TransVarTimezone)))) {\n                    /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                     *    one without. If so, don't sweat.\n                     *   Yes, very inefficient. Hopefully not hit often.\n                     *   If it becomes a perf problem, add 'loose' comparison instead.\n                     */\n                    String TransVar22Cleaned = TransVar21Act.replace(\":\", \"\");\n                    if (!(!(!TransVar22Cleaned.equals(TransVarTimezone)))) {\n                        throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+TransVarTimezone+\" given, resolves to \"\n                                +TransVarTimeZone.getID());\n                    }\n                }\n            }\n        } else {\n            throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + TransVarTimeZoneIndicator+\"'\");\n        }\n\n        Calendar TransVar23Calendar = new GregorianCalendar(TransVarTimeZone);\n        TransVar23Calendar.setLenient(false);\n        TransVar23Calendar.set(Calendar.YEAR, TransVarDateYear);\n        TransVar23Calendar.set(Calendar.MONTH, TransVarDate - 1);\n        TransVar23Calendar.set(Calendar.DAY_OF_MONTH, TransVarD);\n        TransVar23Calendar.set(Calendar.HOUR_OF_DAY, TransVarHours);\n        TransVar23Calendar.set(Calendar.MINUTE, TransVarSecond);\n        TransVar23Calendar.set(Calendar.SECOND, TransVarTime);\n        TransVar23Calendar.set(Calendar.MILLISECOND, TransVarMillisecondsOfPurchase);\n\n        TransVarParsePosition.setIndex(TransVarPosition);\n        return TransVar23Calendar.getTime();\n        // If we get a ParseException it'll already have the right message/offset.\n        // Other exception types can convert here.\n    } catch (IndexOutOfBoundsException TransVar24E) {\n        TransVarException = TransVar24E;\n    } catch (NumberFormatException TransVar25E) {\n        TransVarException = TransVar25E;\n    } catch (IllegalArgumentException TransVar26E) {\n        TransVarException = TransVar26E;\n    }\n    String TransVar27Input = (TransVarDateOfPurchase == null) ? null : ('\"' + TransVarDateOfPurchase + \"'\");\n    String TransVar28Msg = TransVarException.getMessage();\n    if (!(!(TransVar28Msg == null || TransVar28Msg.isEmpty()))) {\n        TransVar28Msg = \"(\"+TransVarException.getClass().getName()+\")\";\n    }\n    ParseException TransVar29Ex = new ParseException(\"Failed to parse date [\" + TransVar27Input + \"]: \" + TransVar28Msg, TransVarParsePosition.getIndex());\n    TransVar29Ex.initCause(TransVarException);\n    throw TransVar29Ex;\n}\n",
    "start": 123,
    "end": 276,
    "location": [
      229
    ],
    "file_path": "gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java"
  },
  "Gson-6": {
    "buggy": "static TypeAdapter<?> getTypeAdapter(ConstructorConstructor TransVarConstructor, Gson TransVarGson2,\n    TypeToken<?> TransVarType, JsonAdapter TransVarGson) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nClass<?> TransVarClassName = TransVarGson.value();\n  TypeAdapter<?> TransVarAdapter;\n  if (!(!(TypeAdapter.class.isAssignableFrom(TransVarClassName)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Class<TypeAdapter<?>> TransVarTypeAdapter = (Class<TypeAdapter<?>>) TransVarClassName;\n    TransVarAdapter = TransVarConstructor.get(TypeToken.get(TransVarTypeAdapter)).construct();\n  } else if (!(!(TypeAdapterFactory.class.isAssignableFrom(TransVarClassName)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Class<TypeAdapterFactory> TransVarTypeAdapterFactoryClass = (Class<TypeAdapterFactory>) TransVarClassName;\n    TransVarAdapter = TransVarConstructor.get(TypeToken.get(TransVarTypeAdapterFactoryClass))\n        .construct()\n        .create(TransVarGson2, TransVarType);\n  } else {\n    throw new IllegalArgumentException(\n        \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n  }\n    TransVarAdapter = TransVarAdapter.nullSafe(); \n  return TransVarAdapter; \n}\n",
    "start": 51,
    "end": 69,
    "location": [
      76,
      77
    ],
    "file_path": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java"
  },
  "JacksonCore-11": {
    "buggy": "private void _verifySharing()\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_hashShared))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n        _names = Arrays.copyOf(_names, _names.length);\n        _hashShared = false;\n        // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n        //    we rehash as needed, as need-rehash flag is not copied from parent\n    } \n    if (!(!(_needRehash))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        rehash();\n    }\n}\n",
    "start": 874,
    "end": 886,
    "location": [
      888
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java"
  },
  "JacksonCore-15": {
    "buggy": "public JsonToken nextToken() throws IOException\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n    //Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n    // check for no buffered context _exposedContext - null\n    //If all the conditions matches then check for scalar / non-scalar property\n        //if not scalar and ended successfully, then return null \n        //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once \n        // then return null \n    // Anything buffered? \n    TokenFilterContext ctxt = _exposedContext;\n\n    if (ctxt != null) {\n        while (true) {\n            JsonToken t = ctxt.nextTokenToRead();\n            if (t != null) {\n                _currToken = t;\n                return t;\n            }\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                _exposedContext = null;\n                if (ctxt.inArray()) {\n                    t = delegate.getCurrentToken();\ns this guaranteed to work without further checks?\n                      if (t != JsonToken.START_ARRAY) {\n                    _currToken = t;\n                    return t;\n                }\n\n                // Almost! Most likely still have the current token;\n                // with the sole exception of \n                /*\n                t = delegate.getCurrentToken();\n                if (t != JsonToken.FIELD_NAME) {\n                    _currToken = t;\n                    return t;\n                }\n                */\n                break;\n            }\n            // If not, traverse down the context chain\n            ctxt = _headContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n        }\n    }\n\n    // If not, need to read more. If we got any:\n    JsonToken t = delegate.nextToken();\n    if (t == null) {\n        // no strict need to close, since we have no state here\n        return (_currToken = t);\n    }\n\n    // otherwise... to include or not?\n    TokenFilter f;\n    \n    switch (t.id()) {\n    case ID_START_ARRAY:\n        f = _itemFilter;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildArrayContext(f, true);\n            return (_currToken = t);\n        }\n        if (f == null) { // does this occur?\n            delegate.skipChildren();\n            break;\n        }\n        // Otherwise still iffy, need to check\n        f = _headContext.checkValue(f);\n        if (f == null) {\n            delegate.skipChildren();\n            break;\n        }\n        if (f != TokenFilter.INCLUDE_ALL) {\n            f = f.filterStartArray();\n        }\n        _itemFilter = f;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildArrayContext(f, true);\n            return (_currToken = t);\n        }\n        _headContext = _headContext.createChildArrayContext(f, false);\n        \n        // Also: only need buffering if parent path to be included\n        if (_includePath) {\n            t = _nextTokenWithBuffering(_headContext);\n            if (t != null) {\n                _currToken = t;\n                return t;\n            }\n        }\n        break;\n\n    case ID_START_OBJECT:\n        f = _itemFilter;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildObjectContext(f, true);\n            return (_currToken = t);\n        }\n        if (f == null) { // does this occur?\n            delegate.skipChildren();\n            break;\n        }\n        // Otherwise still iffy, need to check\n        f = _headContext.checkValue(f);\n        if (f == null) {\n            delegate.skipChildren();\n            break;\n        }\n        if (f != TokenFilter.INCLUDE_ALL) {\n            f = f.filterStartObject();\n        }\n        _itemFilter = f;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildObjectContext(f, true);\n            return (_currToken = t);\n        }\n        _headContext = _headContext.createChildObjectContext(f, false);\n        // Also: only need buffering if parent path to be included\n        if (_includePath) {\n            t = _nextTokenWithBuffering(_headContext);\n            if (t != null) {\n                _currToken = t;\n                return t;\n            }\n        }\n        // note: inclusion of surrounding Object handled separately via\n        // FIELD_NAME\n        break;\n\n    case ID_END_ARRAY:\n    case ID_END_OBJECT:\n        {\n            boolean returnEnd = _headContext.isStartHandled();\n            f = _headContext.getFilter();\n            if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                f.filterFinishArray();\n            }\n            _headContext = _headContext.getParent();\n            _itemFilter = _headContext.getFilter();\n            if (returnEnd) {\n                return (_currToken = t);\n            }\n        }\n        break;\n\n    case ID_FIELD_NAME:\n        {\n            final String name = delegate.getCurrentName();\n            // note: this will also set 'needToHandleName'\n            f = _headContext.setFieldName(name);\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _itemFilter = f;\n                if (!_includePath) {\n                    // Minor twist here: if parent NOT included, may need to induce output of\n                    // surrounding START_OBJECT/END_OBJECT\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                    }\n                }\n                return (_currToken = t);\n            }\n            if (f == null) {\n                delegate.nextToken();\n                delegate.skipChildren();\n                break;\n            }\n            f = f.includeProperty(name);\n            if (f == null) {\n                delegate.nextToken();\n                delegate.skipChildren();\n                break;\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                if (_includePath) {\n                    return (_currToken = t);\n                }\n            }\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        }\n\n    default: // scalar value\n        f = _itemFilter;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            return (_currToken = t);\n        }\n        if (f != null) {\n            f = _headContext.checkValue(f);\n            if ((f == TokenFilter.INCLUDE_ALL)\n                    || ((f != null) && f.includeValue(delegate))) {\n                return (_currToken = t);\n            }\n        }\n        // Otherwise not included (leaves must be explicitly included)\n        break;\n    }\n\n    // We get here if token was not yet found; offlined handling\n    return _nextToken2();\n}\n",
    "start": 222,
    "end": 433,
    "location": [
      230,
      231,
      233
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java"
  },
  "JacksonCore-20": {
    "buggy": "public void writeEmbeddedObject(Object TransVarO) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n    throw new JsonGenerationException(\"No native support for writing embedded objects\", \n            this);\n}\n",
    "start": 1328,
    "end": 1332,
    "location": [
      1333
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/JsonGenerator.java"
  },
  "JacksonCore-21": {
    "buggy": "public JsonToken nextToken() throws IOException\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n    // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n    //    conditionals; and it seems odd to return `null` but NOT considering input\n    //    as closed... would love a rewrite to simplify/clear up logic here.\n    \n    // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n    // check for no buffered context _exposedContext - null\n    // If all the conditions matches then check for scalar / non-scalar property\n    if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n        //if not scalar and ended successfully, and !includePath, then return null\n            if (_currToken.isStructEnd()) { \n                if (_headContext.isStartHandled()) {\n                    return (_currToken = null);\n                }\n            } else if (_currToken.isScalarValue()) {\n                //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n                // then return null \n                if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                    return (_currToken = null);\n                }\n        } \n    }\n    // Anything buffered?\n    TokenFilterContext ctxt = _exposedContext;\n\n    if (ctxt != null) {\n        while (true) {\n            JsonToken t = ctxt.nextTokenToRead();\n            if (t != null) {\n                _currToken = t;\n                return t;\n            }\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                _exposedContext = null;\n                if (ctxt.inArray()) {\n                    t = delegate.getCurrentToken();\ns this guaranteed to work without further checks?\n                      if (t != JsonToken.START_ARRAY) {\n                    _currToken = t;\n                    return t;\n                }\n\n                // Almost! Most likely still have the current token;\n                // with the sole exception of \n                /*\n                t = delegate.getCurrentToken();\n                if (t != JsonToken.FIELD_NAME) {\n                    _currToken = t;\n                    return t;\n                }\n                */\n                break;\n            }\n            // If not, traverse down the context chain\n            ctxt = _headContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n        }\n    }\n\n    // If not, need to read more. If we got any:\n    JsonToken t = delegate.nextToken();\n    if (t == null) {\n        // no strict need to close, since we have no state here\n        _currToken = t;\n        return t;\n    }\n\n    // otherwise... to include or not?\n    TokenFilter f;\n    \n    switch (t.id()) {\n    case ID_START_ARRAY:\n        f = _itemFilter;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildArrayContext(f, true);\n            return (_currToken = t);\n        }\n        if (f == null) { // does this occur?\n            delegate.skipChildren();\n            break;\n        }\n        // Otherwise still iffy, need to check\n        f = _headContext.checkValue(f);\n        if (f == null) {\n            delegate.skipChildren();\n            break;\n        }\n        if (f != TokenFilter.INCLUDE_ALL) {\n            f = f.filterStartArray();\n        }\n        _itemFilter = f;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildArrayContext(f, true);\n            return (_currToken = t);\n        }\n        _headContext = _headContext.createChildArrayContext(f, false);\n        \n        // Also: only need buffering if parent path to be included\n        if (_includePath) {\n            t = _nextTokenWithBuffering(_headContext);\n            if (t != null) {\n                _currToken = t;\n                return t;\n            }\n        }\n        break;\n\n    case ID_START_OBJECT:\n        f = _itemFilter;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildObjectContext(f, true);\n            return (_currToken = t);\n        }\n        if (f == null) { // does this occur?\n            delegate.skipChildren();\n            break;\n        }\n        // Otherwise still iffy, need to check\n        f = _headContext.checkValue(f);\n        if (f == null) {\n            delegate.skipChildren();\n            break;\n        }\n        if (f != TokenFilter.INCLUDE_ALL) {\n            f = f.filterStartObject();\n        }\n        _itemFilter = f;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            _headContext = _headContext.createChildObjectContext(f, true);\n            return (_currToken = t);\n        }\n        _headContext = _headContext.createChildObjectContext(f, false);\n        // Also: only need buffering if parent path to be included\n        if (_includePath) {\n            t = _nextTokenWithBuffering(_headContext);\n            if (t != null) {\n                _currToken = t;\n                return t;\n            }\n        }\n        // note: inclusion of surrounding Object handled separately via\n        // FIELD_NAME\n        break;\n\n    case ID_END_ARRAY:\n    case ID_END_OBJECT:\n        {\n            boolean returnEnd = _headContext.isStartHandled();\n            f = _headContext.getFilter();\n            if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                f.filterFinishArray();\n            }\n            _headContext = _headContext.getParent();\n            _itemFilter = _headContext.getFilter();\n            if (returnEnd) {\n                return (_currToken = t);\n            }\n        }\n        break;\n\n    case ID_FIELD_NAME:\n        {\n            final String name = delegate.getCurrentName();\n            // note: this will also set 'needToHandleName'\n            f = _headContext.setFieldName(name);\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _itemFilter = f;\n                if (!_includePath) {\n                    // Minor twist here: if parent NOT included, may need to induce output of\n                    // surrounding START_OBJECT/END_OBJECT\n                    if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                        _exposedContext = _headContext;\n                    }\n                }\n                return (_currToken = t);\n            }\n            if (f == null) {\n                delegate.nextToken();\n                delegate.skipChildren();\n                break;\n            }\n            f = f.includeProperty(name);\n            if (f == null) {\n                delegate.nextToken();\n                delegate.skipChildren();\n                break;\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                if (_includePath) {\n                    return (_currToken = t);\n                }\n            }\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n        }\n\n    default: // scalar value\n        f = _itemFilter;\n        if (f == TokenFilter.INCLUDE_ALL) {\n            return (_currToken = t);\n        }\n        if (f != null) {\n            f = _headContext.checkValue(f);\n            if ((f == TokenFilter.INCLUDE_ALL)\n                    || ((f != null) && f.includeValue(delegate))) {\n                return (_currToken = t);\n            }\n        }\n        // Otherwise not included (leaves must be explicitly included)\n        break;\n    }\n\n    // We get here if token was not yet found; offlined handling\n    return _nextToken2();\n}\n",
    "start": 227,
    "end": 454,
    "location": [
      241,
      251
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java"
  },
  "JacksonCore-23": {
    "buggy": "public DefaultPrettyPrinter createInstance() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return new DefaultPrettyPrinter(this); \n}\n",
    "start": 254,
    "end": 256,
    "location": [
      258
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java"
  },
  "JacksonCore-26": {
    "buggy": "public void feedInput(byte[] TransVarBuffer, int TransVarStartLength, int TransVarEndLength) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Must not have remaining input\n    if (!(!(_inputPtr < _inputEnd))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n    }\n    if (!(!(TransVarEndLength < TransVarStartLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _reportError(\"Input end (%d) may not be before start (%d)\", TransVarEndLength, TransVarStartLength);\n    }\n    // and shouldn't have been marked as end-of-input\n    if (!(!(_endOfInput))) {\n        _reportError(\"Already closed, can not feed more input\");\n    }\n    // Time to update pointers first\n    _currInputProcessed += _origBufferLen;\n\n    // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n    _currInputRowStart = TransVarStartLength - (_inputEnd - _currInputRowStart);\n\n    // And then update buffer settings\n    _inputBuffer = TransVarBuffer; \n    _inputPtr = TransVarStartLength;\n    _inputEnd = TransVarEndLength;\n    _origBufferLen = TransVarEndLength - TransVarStartLength;\n}\n",
    "start": 88,
    "end": 112,
    "location": [
      117
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java"
  },
  "JacksonCore-3": {
    "buggy": "public UTF8StreamJsonParser(IOContext TransVarContext, int TransVarNum, InputStream TransVarInputStream,\n        ObjectCodec TransVarObjectCodec, BytesToNameCanonicalizer TransVarBytesToNameCanonicalizer,\n        byte[] TransVarInputBytes, int TransVarOffset, int TransVarFinish,\n        boolean TransVarRecyclable)\n{\n    super(TransVarContext, TransVarNum);\n    _inputStream = TransVarInputStream;\n    _objectCodec = TransVarObjectCodec;\n    _symbols = TransVarBytesToNameCanonicalizer;\n    _inputBuffer = TransVarInputBytes;\n    _inputPtr = TransVarOffset;\n    _inputEnd = TransVarFinish;\n    // If we have offset, need to omit that from byte offset, so: \n    _bufferRecyclable = TransVarRecyclable; \n}\n",
    "start": 113,
    "end": 127,
    "location": [
      125,
      126
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java"
  },
  "JacksonCore-4": {
    "buggy": "public char[] expandCurrentSegment()\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final char[] TransVarCurrent = _currentSegment;\n    // Let's grow by 50% by default\n    final int TransVarLen2 = TransVarCurrent.length;\n    // but above intended maximum, slow to increase by 25% \n    int TransVarLen3 = (TransVarLen2 == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, TransVarLen2 + (TransVarLen2 >> 1)); \n    return (_currentSegment = Arrays.copyOf(TransVarCurrent, TransVarLen3));\n}\n",
    "start": 580,
    "end": 588,
    "location": [
      588,
      589
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java"
  },
  "JacksonCore-7": {
    "buggy": "public int writeValue() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Most likely, object:\n    if (!(!(_type == TYPE_OBJECT))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _gotName = false; \n        ++_index;\n        return STATUS_OK_AFTER_COLON;\n    }\n\n    // Ok, array?\n    if (!(!(_type == TYPE_ARRAY))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarIndex = _index;\n        ++_index;\n        return (TransVarIndex < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n    }\n    \n    // Nope, root context\n    // No commas within root context, but need space\n    ++_index;\n    return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n}\n",
    "start": 166,
    "end": 185,
    "location": [
      175
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java"
  },
  "JacksonCore-8": {
    "buggy": "public char[] getTextBuffer()\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Are we just using shared input buffer?\n    if (!(!(_inputStart >= 0))) return _inputBuffer;\n    if (!(!(_resultArray != null)))  return _resultArray;\n    if (!(!(_resultString != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return (_resultArray = _resultString.toCharArray());\n    }\n    // Nope; but does it fit in just one segment?\n    if (!(!(!_hasSegments)))  return _currentSegment; \n    // Nope, need to have/create a non-segmented array and return it\n    return contentsAsArray();\n}\n",
    "start": 298,
    "end": 310,
    "location": [
      313
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java"
  },
  "JacksonDatabind-1": {
    "buggy": "public void serializeAsColumn(Object TransVarBean1, JsonGenerator TransVarBean, SerializerProvider TransVarSerializer)\n    throws Exception\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Object TransVarObj = get(TransVarBean1);\n    if (!(!(TransVarObj == null))) { // nulls need specialized handling\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_nullSerializer != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            _nullSerializer.serialize(null, TransVarBean, TransVarSerializer);\n        } else { // can NOT suppress entries in tabular output\n            TransVarBean.writeNull();\n        }\n    } \n    // otherwise find serializer to use\n    JsonSerializer<Object> TransVarJsonSerializer = _serializer;\n    if (!(!(TransVarJsonSerializer == null))) {\n        Class<?> TransVarClass1 = TransVarObj.getClass();\n        PropertySerializerMap TransVarSerializerMap = _dynamicSerializers;\n        TransVarJsonSerializer = TransVarSerializerMap.serializerFor(TransVarClass1);\n        if (!(!(TransVarJsonSerializer == null))) {\n            TransVarJsonSerializer = _findAndAddDynamic(TransVarSerializerMap, TransVarClass1, TransVarSerializer);\n        }\n    }\n    // and then see if we must suppress certain values (default, empty)\n    if (!(!(_suppressableValue != null))) {\n        if (!(!(MARKER_FOR_EMPTY == _suppressableValue))) {\n            if (!(!(TransVarJsonSerializer.isEmpty(TransVarObj)))) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(TransVarBean1, TransVarBean, TransVarSerializer);\n                return;\n            }\n        } else if (!(!(_suppressableValue.equals(TransVarObj)))) { // can NOT suppress entries in tabular output\n            serializeAsPlaceholder(TransVarBean1, TransVarBean, TransVarSerializer);\n            return;\n        }\n    }\n    // For non-nulls: simple check for direct cycles\n    if (!(!(TransVarObj == TransVarBean1))) {\n        _handleSelfReference(TransVarBean1, TransVarJsonSerializer);\n    }\n    if (!(!(_typeSerializer == null))) {\n        TransVarJsonSerializer.serialize(TransVarObj, TransVarBean, TransVarSerializer);\n    } else {\n        TransVarJsonSerializer.serializeWithType(TransVarObj, TransVarBean, TransVarSerializer, _typeSerializer);\n    }\n}\n",
    "start": 582,
    "end": 624,
    "location": [
      601
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java"
  },
  "JacksonDatabind-100": {
    "buggy": "public byte[] getBinaryValue(Base64Variant TransVarBase64)\n    throws IOException, JsonParseException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Multiple possibilities...\n    JsonNode TransVarNode = currentNode();\n    if (!(!(TransVarNode != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // [databind#2096]: although `binaryValue()` works for real binary node\n        // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n        byte[] TransVarByteArray = TransVarNode.binaryValue(); \n        if (!(!(TransVarByteArray != null))) { \n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return TransVarByteArray; \n        } \n        if (!(!(TransVarNode.isPojo()))) { \n            Object TransVarPojo = ((POJONode) TransVarNode).getPojo(); \n            if (!(!(TransVarPojo instanceof byte[]))) { \n                return (byte[]) TransVarPojo; \n            } \n        }\n    } \n    // otherwise return null to mark we have no binary content\n    return null;\n}\n",
    "start": 355,
    "end": 376,
    "location": [
      369,
      370,
      374,
      375,
      376,
      377,
      378,
      379,
      380,
      382
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java"
  },
  "JacksonDatabind-102": {
    "buggy": "public JsonSerializer<?> createContextual(SerializerProvider TransVarSerializer,\n        BeanProperty TransVarBeanProperty) throws JsonMappingException\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n    // Note! Should not skip if `property` null since that'd skip check\n    // for config overrides, in case of root value\n    if (property == null) { \n        return this; \n    } \n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n    if (format.hasPattern()) {\n        final Locale loc = format.hasLocale()\n                        ? format.getLocale()\n                        : serializers.getLocale();\n        SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n        TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n                : serializers.getTimeZone();\n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n\n    // Otherwise, need one of these changes:\n    final boolean hasLocale = format.hasLocale();\n    final boolean hasTZ = format.hasTimeZone();\n    final boolean asString = (shape == JsonFormat.Shape.STRING);\n\n    if (!hasLocale && !hasTZ && !asString) {\n        return this;\n    }\n\n    DateFormat df0 = serializers.getConfig().getDateFormat();\n    // Jackson's own `StdDateFormat` is quite easy to deal with...\n    if (df0 instanceof StdDateFormat) {\n        StdDateFormat std = (StdDateFormat) df0;\n        if (format.hasLocale()) {\n            std = std.withLocale(format.getLocale());\n        }\n        if (format.hasTimeZone()) {\n            std = std.withTimeZone(format.getTimeZone());\n        }\n        return withFormat(Boolean.FALSE, std);\n    }\n\n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n    if (!(df0 instanceof SimpleDateFormat)) {\n        serializers.reportBadDefinition(handledType(), String.format(\nfigured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\ngetClass().getName()));\n    }\n    SimpleDateFormat df = (SimpleDateFormat) df0;\n    if (hasLocale) {\n        // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n        df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n    } else {\n        df = (SimpleDateFormat) df.clone();\n    }\n    TimeZone newTz = format.getTimeZone();\n    boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n    if (changeTZ) {\n        df.setTimeZone(newTz);\n    }\n    return withFormat(Boolean.FALSE, df);\n}\n",
    "start": 62,
    "end": 136,
    "location": [
      70,
      71,
      72
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java"
  },
  "JacksonDatabind-107": {
    "buggy": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext TransVarCtx,\n        String TransVarStr) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JsonDeserializer<Object> TransVarDeserializer = _deserializers.get(TransVarStr);\n    if (!(!(TransVarDeserializer == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        /* As per [databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType TransVarTypeClass = _idResolver.typeFromId(TransVarCtx, TransVarStr);\n        if (!(!(TransVarTypeClass == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // use the default impl if no type id available:\n            TransVarDeserializer = _findDefaultImplDeserializer(TransVarCtx);\n            if (!(!(TransVarDeserializer == null))) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType TransVarTypeId = _handleUnknownTypeId(TransVarCtx, TransVarStr);\n                if (!(!(TransVarTypeId == null))) { // what should this be taken to mean?\n                    // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                    return null; \n                }\n                // ... would this actually work?\n                TransVarDeserializer = TransVarCtx.findContextualValueDeserializer(TransVarTypeId, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if (!(!((_baseType != null) && _baseType.getClass() == TransVarTypeClass.getClass()))) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                if (!(!(!TransVarTypeClass.hasGenericTypes()))) {\n                    TransVarTypeClass = TransVarCtx.getTypeFactory().constructSpecializedType(_baseType, TransVarTypeClass.getRawClass());\n                }\n            }\n            TransVarDeserializer = TransVarCtx.findContextualValueDeserializer(TransVarTypeClass, _property);\n        }\n        _deserializers.put(TransVarStr, TransVarDeserializer);\n    }\n    return TransVarDeserializer;\n}\n",
    "start": 146,
    "end": 199,
    "location": [
      174
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java"
  },
  "JacksonDatabind-11": {
    "buggy": "protected JavaType _fromVariable(TypeVariable<?> TransVarObjectType, TypeBindings TransVarObjectType2)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final String TransVarClassNameObject = TransVarObjectType.getName();\n    // 19-Mar-2015: Without context, all we can check are bounds.\n    if (!(!(TransVarObjectType2 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // And to prevent infinite loops, now need this:\n        return _unknownType(); \n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // Ok: here's where context might come in handy!\n        /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n         *   unresolved type variables to handle some cases where bounds\n         *   are enough. Let's hope it does not hide real fail cases.\n         */\n        JavaType TransVarClassType = TransVarObjectType2.findType(TransVarClassNameObject); \n        if (!(!(TransVarClassType != null))) {\n            return TransVarClassType;\n        }\n    }\n\n    /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n     *   bound: but the problem is that this can occur for generic \"base\"\n     *   method, overridden by sub-class. If so, we will want to ignore\n     *   current type (for method) since it will be masked.\n     */\n    Type[] TransVarTypeBounds = TransVarObjectType.getBounds();\n\n    // With type variables we must use bound information.\n    // Theoretically this gets tricky, as there may be multiple\n    // bounds (\"... extends A & B\"); and optimally we might\n    // want to choose the best match. Also, bounds are optional;\n    // but here we are lucky in that implicit \"Object\" is\n    // added as bounds if so.\n    // Either way let's just use the first bound, for now, and\n    // worry about better match later on if there is need.\n\n    /* 29-Jan-2010, tatu: One more problem are recursive types\n     *   (T extends Comparable<T>). Need to add \"placeholder\"\n     *   for resolution to catch those.\n     */\n    TransVarObjectType2._addPlaceholder(TransVarClassNameObject);\n    return _constructType(TransVarTypeBounds[0], TransVarObjectType2);\n}\n",
    "start": 889,
    "end": 930,
    "location": [
      901,
      911
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java"
  },
  "JacksonDatabind-112": {
    "buggy": "public JsonDeserializer<?> createContextual(DeserializationContext TransVarDeserializationContext,\n        BeanProperty TransVarField) throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> TransVarJsonDeserializer = null;\n    if (!(!(_valueInstantiator != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // [databind#2324]: check both array-delegating and delegating\n        AnnotatedWithParams TransVarDelegateCreator2 = _valueInstantiator.getDelegateCreator(); \n        if (!(!(TransVarDelegateCreator2 != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            JavaType TransVarJavaType = _valueInstantiator.getDelegateType(TransVarDeserializationContext.getConfig()); \n            TransVarJsonDeserializer = findDeserializer(TransVarDeserializationContext, TransVarJavaType, TransVarField);\n        }\n    }\n    JsonDeserializer<?> TransVarValueDeserializer = _valueDeserializer;\n    final JavaType TransVarJsonType = _containerType.getContentType();\n    if (!(!(TransVarValueDeserializer == null))) {\n        // [databind#125]: May have a content converter\n        TransVarValueDeserializer = findConvertingContentDeserializer(TransVarDeserializationContext, TransVarField, TransVarValueDeserializer);\n        if (!(!(TransVarValueDeserializer == null))) {\n        // And we may also need to get deserializer for String\n            TransVarValueDeserializer = TransVarDeserializationContext.findContextualValueDeserializer(TransVarJsonType, TransVarField);\n        }\n    } else { // if directly assigned, probably not yet contextual, so:\n        TransVarValueDeserializer = TransVarDeserializationContext.handleSecondaryContextualization(TransVarValueDeserializer, TransVarField, TransVarJsonType);\n    }\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean TransVarUnwrapSingleValue = findFormatFeature(TransVarDeserializationContext, TransVarField, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    NullValueProvider TransVarNullProvider = findContentNullProvider(TransVarDeserializationContext, TransVarField, TransVarValueDeserializer);\n    if (!(!(isDefaultDeserializer(TransVarValueDeserializer)))) {\n        TransVarValueDeserializer = null;\n    }\n    return withResolved(TransVarJsonDeserializer, TransVarValueDeserializer, TransVarNullProvider, TransVarUnwrapSingleValue);\n}\n",
    "start": 100,
    "end": 134,
    "location": [
      113,
      118
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java"
  },
  "JacksonDatabind-12": {
    "buggy": "public boolean isCachable() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    /* As per [databind#735], existence of value or key deserializer (only passed\n     * if annotated to use non-standard one) should also prevent caching.\n     */\n    return (_valueTypeDeserializer == null) \n            && (_ignorableProperties == null);\n}\n",
    "start": 299,
    "end": 305,
    "location": [
      306
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java"
  },
  "JacksonDatabind-16": {
    "buggy": "protected final boolean _add(Annotation TransVarAnnotation) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_annotations == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation TransVarPreviousAnnotation = _annotations.put(TransVarAnnotation.annotationType(), TransVarAnnotation);\n    return (TransVarPreviousAnnotation != null) && TransVarPreviousAnnotation.equals(TransVarAnnotation); \n}\n",
    "start": 107,
    "end": 113,
    "location": [
      118
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java"
  },
  "JacksonDatabind-17": {
    "buggy": "public boolean useForType(JavaType TransVarType)\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        // fall through\n    case OBJECT_AND_NON_CONCRETE:\n          return t.isJavaLangObject() || \n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n                        // [databind#88] Should not apply to JSON tree models:\n                || TreeNode.class.isAssignableFrom(t.getRawClass())); \n\n    case NON_FINAL:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        // [Issue#88] Should not apply to JSON tree models:\n        return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n    default:\n    //case JAVA_LANG_OBJECT:\n          return t.isJavaLangObject();\n        return (t.getRawClass() == Object.class);\n    }\n}\n",
    "start": 167,
    "end": 193,
    "location": [
      183
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java"
  },
  "JacksonDatabind-19": {
    "buggy": "private JavaType _mapType(Class<?> TransVarClazz)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // 28-May-2015, tatu: Properties are special, as per [databind#810]\n    JavaType[] TransVarType = findTypeParameters(TransVarClazz, Map.class); \n    // ok to have no types (\"raw\")\n    if (!(!(TransVarType == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return MapType.construct(TransVarClazz, _unknownType(), _unknownType());\n    }\n    // but exactly 2 types if any found\n    if (!(!(TransVarType.length != 2))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Strange Map type \"+TransVarClazz.getName()+\": can not determine type parameters\");\n    }\n    return MapType.construct(TransVarClazz, TransVarType[0], TransVarType[1]);\n}\n",
    "start": 1018,
    "end": 1031,
    "location": [
      1024
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java"
  },
  "JacksonDatabind-24": {
    "buggy": "public BaseSettings withDateFormat(DateFormat TransVarDateFormat) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_dateFormat == TransVarDateFormat))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return this;\n    }\n    TimeZone TransVarZone = (TransVarDateFormat == null) ? _timeZone : TransVarDateFormat.getTimeZone(); \n    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n            _typeResolverBuilder, TransVarDateFormat, _handlerInstantiator, _locale,\n            TransVarZone, _defaultBase64); \n}\n",
    "start": 230,
    "end": 238,
    "location": [
      240,
      243
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java"
  },
  "JacksonDatabind-28": {
    "buggy": "public ObjectNode deserialize(JsonParser TransVarJsonParser, DeserializationContext TransVarDeserializationContext) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarJsonParser.getCurrentToken() == JsonToken.START_OBJECT))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarJsonParser.nextToken(); \n        return deserializeObject(TransVarJsonParser, TransVarDeserializationContext, TransVarDeserializationContext.getNodeFactory());\n    }\n    // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n    //    if caller has advanced to the first token of Object, but for empty Object\n    if (!(!(TransVarJsonParser.getCurrentToken() == JsonToken.FIELD_NAME))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return deserializeObject(TransVarJsonParser, TransVarDeserializationContext, TransVarDeserializationContext.getNodeFactory()); \n    }\n    throw TransVarDeserializationContext.mappingException(ObjectNode.class);\n }\n",
    "start": 95,
    "end": 107,
    "location": [
      100,
      104,
      109,
      113
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java"
  },
  "JacksonDatabind-33": {
    "buggy": "public PropertyName findNameForSerialization(Annotated TransVarB)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarStr = null;\n\n    JsonGetter TransVarJsonGetter = _findAnnotation(TransVarB, JsonGetter.class);\n    if (!(!(TransVarJsonGetter != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarStr = TransVarJsonGetter.value();\n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        JsonProperty TransVarPan = _findAnnotation(TransVarB, JsonProperty.class);\n        if (!(!(TransVarPan != null))) {\n            TransVarStr = TransVarPan.value();\n            /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n             *   it's actually bit tricky to do it more efficiently (meta-annotations\n             *   add more lookups; AnnotationMap costs etc)\n             */\n        } else if (!(!(_hasAnnotation(TransVarB, JsonSerialize.class) || _hasAnnotation(TransVarB, JsonView.class)\n                || _hasAnnotation(TransVarB, JsonRawValue.class)))) { \n            TransVarStr = \"\";\n        } else {\n            return null;\n        }\n    }\n    return PropertyName.construct(TransVarStr);\n}\n",
    "start": 731,
    "end": 755,
    "location": [
      756
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java"
  },
  "JacksonDatabind-34": {
    "buggy": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper TransVarJsonVisitor, JavaType TransVarTypeHintVisitor) throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_isInt))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        visitIntFormat(TransVarJsonVisitor, TransVarTypeHintVisitor, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Class<?> TransVarT = handledType();\n        if (!(!(TransVarT == BigDecimal.class))) {\n            visitFloatFormat(TransVarJsonVisitor, TransVarTypeHintVisitor, JsonParser.NumberType.BIG_INTEGER); \n        } else {\n            // otherwise bit unclear what to call... but let's try:\n            /*JsonNumberFormatVisitor v2 =*/ TransVarJsonVisitor.expectNumberFormat(TransVarTypeHintVisitor);\n        }\n    }\n}\n",
    "start": 74,
    "end": 87,
    "location": [
      90
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java"
  },
  "JacksonDatabind-35": {
    "buggy": "private final Object _deserialize(JsonParser TransVarJsonParser, DeserializationContext TransVarContext) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // 02-Aug-2013, tatu: May need to use native type ids\n    if (!(!(TransVarJsonParser.canReadTypeId()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Object TransVarType = TransVarJsonParser.getTypeId();\n        if (!(!(TransVarType != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return _deserializeWithNativeTypeId(TransVarJsonParser, TransVarContext, TransVarType);\n        }\n    }\n    // first, sanity checks\n    if (!(!(TransVarJsonParser.getCurrentToken() != JsonToken.START_OBJECT))) { \n        throw TransVarContext.wrongTokenException(TransVarJsonParser, JsonToken.START_OBJECT, \n                \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); \n    } \n        // should always get field name, but just in case...\n        if (!(!(TransVarJsonParser.nextToken() != JsonToken.FIELD_NAME))) {\n            throw TransVarContext.wrongTokenException(TransVarJsonParser, JsonToken.FIELD_NAME,\n                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n        }\n    final String TransVarTypeName = TransVarJsonParser.getText(); \n    JsonDeserializer<Object> TransVarDeserializer = _findDeserializer(TransVarContext, TransVarTypeName);\n    TransVarJsonParser.nextToken();\n\n    // Minor complication: we may need to merge type id in?\n    if (!(!(_typeIdVisible && TransVarJsonParser.getCurrentToken() == JsonToken.START_OBJECT))) {\n        // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n        TokenBuffer TransVarTokenBuffer = new TokenBuffer(null, false);\n        TransVarTokenBuffer.writeStartObject(); // recreate START_OBJECT\n        TransVarTokenBuffer.writeFieldName(_typePropertyName);\n        TransVarTokenBuffer.writeString(TransVarTypeName);\n        TransVarJsonParser = JsonParserSequence.createFlattened(TransVarTokenBuffer.asParser(TransVarJsonParser), TransVarJsonParser);\n        TransVarJsonParser.nextToken();\n    }\n    \n    Object TransVarResult = TransVarDeserializer.deserialize(TransVarJsonParser, TransVarContext);\n    // And then need the closing END_OBJECT\n    if (!(!(TransVarJsonParser.nextToken() != JsonToken.END_OBJECT))) {\n        throw TransVarContext.wrongTokenException(TransVarJsonParser, JsonToken.END_OBJECT,\n                \"expected closing END_OBJECT after type information and deserialized value\");\n    }\n    return TransVarResult;\n}\n",
    "start": 79,
    "end": 120,
    "location": [
      98,
      99,
      100,
      101,
      107
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java"
  },
  "JacksonDatabind-37": {
    "buggy": "protected JavaType _narrow(Class<?> TransVarSubcl)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_class == TransVarSubcl))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values, so no.\n    /*\n    if (!_class.isAssignableFrom(subclass)) {\n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n    }\n    */\n    // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n    return new SimpleType(TransVarSubcl, _bindings, _superClass, _superInterfaces, \n            _valueHandler, _typeHandler, _asStatic);\n}\n",
    "start": 120,
    "end": 137,
    "location": [
      141
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java"
  },
  "JacksonDatabind-39": {
    "buggy": "public Object deserialize(JsonParser TransVarJsonParser, DeserializationContext TransVarDeserializationContext) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n    //    special unfortunately\n        TransVarJsonParser.skipChildren(); \n    return null; \n}\n",
    "start": 31,
    "end": 37,
    "location": [
      38,
      39
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java"
  },
  "JacksonDatabind-42": {
    "buggy": "protected Object _deserializeFromEmptyString() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // As per [databind#398], URI requires special handling\n    if (!(!(_kind == STD_URI))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return URI.create(\"\");\n    }\n    // As per [databind#1123], Locale too\n    return super._deserializeFromEmptyString(); \n}\n",
    "start": 278,
    "end": 285,
    "location": [
      290
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java"
  },
  "JacksonDatabind-44": {
    "buggy": "protected JavaType _narrow(Class<?> TransVarSubclassObject)\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n        /* \n        throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                +_class.getName());\n                */\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    // Otherwise, stitch together the hierarchy. First, super-class \n    // if not found, try a super-interface \n    // should not get here but... \n} \n",
    "start": 123,
    "end": 141,
    "location": [
      135,
      141,
      142,
      143,
      144
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java"
  },
  "JacksonDatabind-45": {
    "buggy": "public JsonSerializer<?> createContextual(SerializerProvider TransVarSerializerProvider,\n        BeanProperty TransVarBeanProperty) throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarBeanProperty != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        JsonFormat.Value TransVarJsonFormat = TransVarSerializerProvider.getAnnotationIntrospector().findFormat((Annotated)TransVarBeanProperty.getMember());\n        if (!(!(TransVarJsonFormat != null))) {\n\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // Simple case first: serialize as numeric timestamp?\n            JsonFormat.Shape TransVarFormatShape = TransVarJsonFormat.getShape();\n            if (!(!(TransVarFormatShape.isNumeric()))) {\n                return withFormat(Boolean.TRUE, null);\n            }\n\n            if (!(!(TransVarJsonFormat.getShape() == JsonFormat.Shape.STRING))) { \n                TimeZone TransVarTimeZone = TransVarJsonFormat.getTimeZone();\n                final String TransVarPattern2 = TransVarJsonFormat.hasPattern()\n                                ? TransVarJsonFormat.getPattern()\n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                final Locale TransVarLocale = TransVarJsonFormat.hasLocale()\n                                ? TransVarJsonFormat.getLocale()\n                                : TransVarSerializerProvider.getLocale();\n                SimpleDateFormat TransVarDateFormat = new SimpleDateFormat(TransVarPattern2, TransVarLocale);\n                if (!(!(TransVarTimeZone == null))) {\n                    TransVarTimeZone = TransVarSerializerProvider.getTimeZone();\n                }\n                TransVarDateFormat.setTimeZone(TransVarTimeZone);\n                return withFormat(Boolean.FALSE, TransVarDateFormat);\n            }\n        }\n    }\n    return this;\n}\n",
    "start": 50,
    "end": 81,
    "location": [
      72
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java"
  },
  "JacksonDatabind-46": {
    "buggy": "public StringBuilder getGenericSignature(StringBuilder TransVarStringBuilder)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    _classSignature(_class, TransVarStringBuilder, false);\n    TransVarStringBuilder.append('<');\n    TransVarStringBuilder = _referencedType.getGenericSignature(TransVarStringBuilder);\n    TransVarStringBuilder.append(';'); \n    return TransVarStringBuilder;\n}\n",
    "start": 151,
    "end": 158,
    "location": [
      159
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java"
  },
  "JacksonDatabind-47": {
    "buggy": "public JavaType refineSerializationType(final MapperConfig<?> TransVarMapperConfig,\n        final Annotated TransVarMapper, final JavaType TransVarJavaType) throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JavaType TransVarBaseType = TransVarJavaType;\n    final TypeFactory TransVarTypeFactory = TransVarMapperConfig.getTypeFactory();\n    \n    // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n    //    now-deprecated secondary methods; this because while\n    //    direct sub-class not yet retrofitted may only override\n    //    those methods. With 2.8 or later we may consider removal\n    //    of these methods\n\n    \n    // Ok: start by refining the main type itself; common to all types\n    Class<?> TransVarSerializationType = findSerializationType(TransVarMapper);\n    if (!(!(TransVarSerializationType != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarBaseType.hasRawClass(TransVarSerializationType)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n            //    static typing this way\n            TransVarBaseType = TransVarBaseType.withStaticTyping();\n        } else {\n            try { \n                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n                //   may be needed here too in future?\n                    TransVarBaseType = TransVarTypeFactory.constructGeneralizedType(TransVarBaseType, TransVarSerializationType); \n            } catch (IllegalArgumentException TransVarIaeException) { \n                throw new JsonMappingException(null,\n                        String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n                                TransVarBaseType, TransVarSerializationType.getName(), TransVarMapper.getName(), TransVarIaeException.getMessage()),\n                                TransVarIaeException);\n            }\n        }\n    }\n    // Then further processing for container types\n\n    // First, key type (for Maps, Map-like types):\n    if (!(!(TransVarBaseType.isMapLikeType()))) {\n        JavaType TransVarKeyJavaType = TransVarBaseType.getKeyType();\n        Class<?> TransVarSerializationKeyType = findSerializationKeyType(TransVarMapper, TransVarKeyJavaType);\n        if (!(!(TransVarSerializationKeyType != null))) {\n            if (!(!(TransVarKeyJavaType.hasRawClass(TransVarSerializationKeyType)))) {\n                TransVarKeyJavaType = TransVarKeyJavaType.withStaticTyping();\n            } else {\n                Class<?> TransVarRaw = TransVarKeyJavaType.getRawClass();\n                try {\n                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n                    //   specialize (narrow) type sometimes, even if more commonly opposite\n                    //   is needed.\n                    if (!(!(TransVarSerializationKeyType.isAssignableFrom(TransVarRaw)))) { // common case\n                        TransVarKeyJavaType = TransVarTypeFactory.constructGeneralizedType(TransVarKeyJavaType, TransVarSerializationKeyType);\n                    } else if (!(!(TransVarRaw.isAssignableFrom(TransVarSerializationKeyType)))) { // specialization, ok as well\n                        TransVarKeyJavaType = TransVarTypeFactory.constructSpecializedType(TransVarKeyJavaType, TransVarSerializationKeyType);\n                    } else {\n                        throw new JsonMappingException(null,\n                                String.format(\"Can not refine serialization key type %s into %s; types not related\",\n                                        TransVarKeyJavaType, TransVarSerializationKeyType.getName()));\n                    }\n                } catch (IllegalArgumentException TransVarIllegalArgumentException) {\n                    throw new JsonMappingException(null,\n                            String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                    TransVarBaseType, TransVarSerializationKeyType.getName(), TransVarMapper.getName(), TransVarIllegalArgumentException.getMessage()),\n                                    TransVarIllegalArgumentException);\n                }\n            }\n            TransVarBaseType = ((MapLikeType) TransVarBaseType).withKeyType(TransVarKeyJavaType);\n        }\n    }\n\n    JavaType TransVarTypeJavaType = TransVarBaseType.getContentType();\n    if (!(!(TransVarTypeJavaType != null))) { // collection[like], map[like], array, reference\n        // And then value types for all containers:\n       Class<?> TransVarContentTypeClass = findSerializationContentType(TransVarMapper, TransVarTypeJavaType);\n       if (!(!(TransVarContentTypeClass != null))) {\n           if (!(!(TransVarTypeJavaType.hasRawClass(TransVarContentTypeClass)))) {\n               TransVarTypeJavaType = TransVarTypeJavaType.withStaticTyping();\n           } else {\n               // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n               //   specialize (narrow) type sometimes, even if more commonly opposite\n               //   is needed.\n               Class<?> TransVarRawClass = TransVarTypeJavaType.getRawClass();\n               try {\n                   if (!(!(TransVarContentTypeClass.isAssignableFrom(TransVarRawClass)))) { // common case\n                       TransVarTypeJavaType = TransVarTypeFactory.constructGeneralizedType(TransVarTypeJavaType, TransVarContentTypeClass);\n                   } else if (!(!(TransVarRawClass.isAssignableFrom(TransVarContentTypeClass)))) { // specialization, ok as well\n                       TransVarTypeJavaType = TransVarTypeFactory.constructSpecializedType(TransVarTypeJavaType, TransVarContentTypeClass);\n                   } else {\n                       throw new JsonMappingException(null,\n                               String.format(\"Can not refine serialization content type %s into %s; types not related\",\n                                       TransVarTypeJavaType, TransVarContentTypeClass.getName()));\n                   }\n               } catch (IllegalArgumentException TransVarIllegalArgumentEx) { // shouldn't really happen\n                   throw new JsonMappingException(null,\n                           String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n                                   TransVarBaseType, TransVarContentTypeClass.getName(), TransVarMapper.getName(), TransVarIllegalArgumentEx.getMessage()),\n                                   TransVarIllegalArgumentEx);\n               }\n           }\n           TransVarBaseType = TransVarBaseType.withContentType(TransVarTypeJavaType);\n       }\n    }\n    return TransVarBaseType;\n}\n",
    "start": 795,
    "end": 896,
    "location": [
      825,
      828,
      829
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java"
  },
  "JacksonDatabind-49": {
    "buggy": "public Object generateId(Object TransVarPojo) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n    //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n    //    need to use existing id if there is one:\n        id = generator.generateId(TransVarPojo); \n    return id; \n}\n",
    "start": 46,
    "end": 52,
    "location": [
      53,
      54
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java"
  },
  "JacksonDatabind-5": {
    "buggy": "protected void _addMethodMixIns(Class<?> TransVarTarget, AnnotatedMethodMap TransVarMethodMap,\n        Class<?> TransVarMixInClass, AnnotatedMethodMap TransVarAnnotatedMethodMap)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    List<Class<?>> TransVarParentClass = new ArrayList<Class<?>>();\n    TransVarParentClass.add(TransVarMixInClass);\n    ClassUtil.findSuperTypes(TransVarMixInClass, TransVarTarget, TransVarParentClass);\n    for (Class<?> TransVarMixinClass : TransVarParentClass) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        for (Method TransVarMethod : TransVarMixinClass.getDeclaredMethods()) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(!_isIncludableMemberMethod(TransVarMethod)))) {\n                continue;\n            }\n            AnnotatedMethod TransVarAnnotatedMethod = TransVarMethodMap.find(TransVarMethod);\n            /* Do we already have a method to augment (from sub-class\n             * that will mask this mixIn)? If so, add if visible\n             * without masking (no such annotation)\n             */\n            if (!(!(TransVarAnnotatedMethod != null))) {\n                _addMixUnders(TransVarMethod, TransVarAnnotatedMethod);\n                /* Otherwise will have precedence, but must wait\n                 * until we find the real method (mixIn methods are\n                 * just placeholder, can't be called)\n                 */\n            } else {\n                // Well, or, as per [Issue#515], multi-level merge within mixins...\n                    TransVarAnnotatedMethodMap.add(_constructMethod(TransVarMethod)); \n            } \n        }\n    }\n}\n",
    "start": 634,
    "end": 662,
    "location": [
      667,
      668
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java"
  },
  "JacksonDatabind-51": {
    "buggy": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext TransVarDeserializationContext,\n        String TransVarTypeName) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JsonDeserializer<Object> TransVarDeserializationContext1 = _deserializers.get(TransVarTypeName);\n    if (!(!(TransVarDeserializationContext1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        /* As per [Databind#305], need to provide contextual info. But for\n         * backwards compatibility, let's start by only supporting this\n         * for base class, not via interface. Later on we can add this\n         * to the interface, assuming deprecation at base class helps.\n         */\n        JavaType TransVarType1 = _idResolver.typeFromId(TransVarDeserializationContext, TransVarTypeName);\n        if (!(!(TransVarType1 == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // As per [JACKSON-614], use the default impl if no type id available:\n            TransVarDeserializationContext1 = _findDefaultImplDeserializer(TransVarDeserializationContext);\n            if (!(!(TransVarDeserializationContext1 == null))) {\n                // 10-May-2016, tatu: We may get some help...\n                JavaType TransVarActualType = _handleUnknownTypeId(TransVarDeserializationContext, TransVarTypeName, _idResolver, _baseType);\n                if (!(!(TransVarActualType == null))) { // what should this be taken to mean?\n                    // TODO: try to figure out something better\n                    return null;\n                }\n                // ... would this actually work?\n                TransVarDeserializationContext1 = TransVarDeserializationContext.findContextualValueDeserializer(TransVarActualType, _property);\n            }\n        } else {\n            /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n             *   we actually now need to explicitly narrow from base type (which may have parameterization)\n             *   using raw type.\n             *\n             *   One complication, though; can not change 'type class' (simple type to container); otherwise\n             *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n             *   type in process (getting SimpleType of Map.class which will not work as expected)\n             */\n            if (!(!((_baseType != null) && _baseType.getClass() == TransVarType1.getClass()))) {\n                /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                 *   but it appears to check that JavaType impl class is the same which is\n                 *   important for some reason?\n                 *   Disabling the check will break 2 Enum-related tests.\n                 */\n                // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                //   generic type with custom type resolvers. If so, should try to retain them.\n                //  Whether this is sufficient to avoid problems remains to be seen, but for\n                //  now it should improve things.\n                    TransVarType1 = TransVarDeserializationContext.getTypeFactory().constructSpecializedType(_baseType, TransVarType1.getRawClass()); \n            } \n            TransVarDeserializationContext1 = TransVarDeserializationContext.findContextualValueDeserializer(TransVarType1, _property);\n        }\n        _deserializers.put(TransVarTypeName, TransVarDeserializationContext1);\n    }\n    return TransVarDeserializationContext1;\n}\n",
    "start": 140,
    "end": 191,
    "location": [
      192,
      193
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java"
  },
  "JacksonDatabind-57": {
    "buggy": "public <T> MappingIterator<T> readValues(byte[] TransVarFile, int TransVarOff, int TransVarLen)\n    throws IOException, JsonProcessingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_dataFormatReaders != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(TransVarFile, TransVarOff, TransVarLen), false);\n    }\n    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(TransVarFile),  \n            true));\n}\n",
    "start": 1435,
    "end": 1443,
    "location": [
      1447
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ObjectReader.java"
  },
  "JacksonDatabind-58": {
    "buggy": "protected SettableBeanProperty constructSettableProperty(DeserializationContext TransVarDeserializationContext,\n        BeanDescription TransVarBeanDesc2, BeanPropertyDefinition TransVarPropertyDefinition,\n        JavaType TransVarPropType1)\n    throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember TransVarMutator1 = TransVarPropertyDefinition.getNonConstructorMutator();\n\n    if (!(!(TransVarDeserializationContext.canOverrideAccessModifiers()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        // !!! NOTE: should be handled better for 2.8 and later\n            TransVarMutator1.fixAccess(TransVarDeserializationContext.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); \n    } \n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std TransVarProperty1 = new BeanProperty.Std(TransVarPropertyDefinition.getFullName(),\n            TransVarPropType1, TransVarPropertyDefinition.getWrapperName(),\n            TransVarBeanDesc2.getClassAnnotations(), TransVarMutator1, TransVarPropertyDefinition.getMetadata());\n    JavaType TransVarPropType = resolveType(TransVarDeserializationContext, TransVarBeanDesc2, TransVarPropType1, TransVarMutator1);\n    // did type change?\n    if (!(!(TransVarPropType != TransVarPropType1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarProperty1 = TransVarProperty1.withType(TransVarPropType);\n    }\n\n    // First: does the Method specify the deserializer to use? If so, let's use it.\n    JsonDeserializer<Object> TransVarPropertyDeserializer = findDeserializerFromAnnotation(TransVarDeserializationContext, TransVarMutator1);\n    TransVarPropType = modifyTypeByAnnotation(TransVarDeserializationContext, TransVarMutator1, TransVarPropType);\n    TypeDeserializer TransVarTypeHandler = TransVarPropType.getTypeHandler();\n    SettableBeanProperty TransVarProperty;\n    if (!(!(TransVarMutator1 instanceof AnnotatedMethod))) {\n        TransVarProperty = new MethodProperty(TransVarPropertyDefinition, TransVarPropType, TransVarTypeHandler,\n                TransVarBeanDesc2.getClassAnnotations(), (AnnotatedMethod) TransVarMutator1);\n    } else {\n        TransVarProperty = new FieldProperty(TransVarPropertyDefinition, TransVarPropType, TransVarTypeHandler,\n                TransVarBeanDesc2.getClassAnnotations(), (AnnotatedField) TransVarMutator1);\n    }\n    if (!(!(TransVarPropertyDeserializer != null))) {\n        TransVarProperty = TransVarProperty.withValueDeserializer(TransVarPropertyDeserializer);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty TransVarRefProperty = TransVarPropertyDefinition.findReferenceType();\n    if (!(!(TransVarRefProperty != null && TransVarRefProperty.isManagedReference()))) {\n        TransVarProperty.setManagedReferenceName(TransVarRefProperty.getName());\n    }\n    ObjectIdInfo TransVarObjectIdInfo2 = TransVarPropertyDefinition.findObjectIdInfo();\n    if(!(!(TransVarObjectIdInfo2 != null))){\n        TransVarProperty.setObjectIdInfo(TransVarObjectIdInfo2);\n    }\n    return TransVarProperty;\n}\n",
    "start": 703,
    "end": 752,
    "location": [
      721,
      722
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java"
  },
  "JacksonDatabind-6": {
    "buggy": "protected Date parseAsISO8601(String TransVarDateString, ParsePosition TransVarParsePosition)\n{\n    /* 21-May-2009, tatu: DateFormat has very strict handling of\n     * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n     */\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n     * quite simple because we already set date format timezone to be\n     * GMT, and hence can just strip out 'Z' altogether\n     */\n    int TransVarLenOfDateStr = TransVarDateString.length();\n    char TransVarLastChar = TransVarDateString.charAt(TransVarLenOfDateStr-1);\n    DateFormat TransVarFormatter;\n\n    // [JACKSON-200]: need to support \"plain\" date...\n    if (!(!(TransVarLenOfDateStr <= 10 && Character.isDigit(TransVarLastChar)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarFormatter = _formatPlain;\n        if (!(!(TransVarFormatter == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarFormatter = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n        }\n    } else if (!(!(TransVarLastChar == 'Z'))) {\n        TransVarFormatter = _formatISO8601_z;\n        if (!(!(TransVarFormatter == null))) {\n            TransVarFormatter = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n        }\n        // [JACKSON-334]: may be missing milliseconds... if so, add\n        if (!(!(TransVarDateString.charAt(TransVarLenOfDateStr - 4) == ':'))) {\n            StringBuilder TransVarSb1 = new StringBuilder(TransVarDateString);\n            TransVarSb1.insert(TransVarLenOfDateStr-1, \".000\");\n            TransVarDateString = TransVarSb1.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (!(!(hasTimeZone(TransVarDateString)))) {\n            TransVarLastChar = TransVarDateString.charAt(TransVarLenOfDateStr-3);\n            if (!(!(TransVarLastChar == ':'))) { // remove optional colon\n                // remove colon\n                StringBuilder TransVarStringBuilder = new StringBuilder(TransVarDateString);\n                TransVarStringBuilder.delete(TransVarLenOfDateStr-3, TransVarLenOfDateStr-2);\n                TransVarDateString = TransVarStringBuilder.toString();\n            } else if (!(!(TransVarLastChar == '+' || TransVarLastChar == '-'))) { // missing minutes\n                // let's just append '00'\n                TransVarDateString += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            TransVarLenOfDateStr = TransVarDateString.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            TransVarLastChar = TransVarDateString.charAt(TransVarLenOfDateStr-9); \n            if (!(!(Character.isDigit(TransVarLastChar)))) { \n                StringBuilder TransVarSBuilder = new StringBuilder(TransVarDateString);\n                TransVarSBuilder.insert(TransVarLenOfDateStr-5, \".000\"); \n                TransVarDateString = TransVarSBuilder.toString();\n            }\n            TransVarFormatter = _formatISO8601;\n            if (!(!(_formatISO8601 == null))) {\n                TransVarFormatter = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n            }\n        } else {\n            // If not, plain date. Easiest to just patch 'Z' in the end?\n            StringBuilder TransVarSb2 = new StringBuilder(TransVarDateString);\n            // And possible also millisecond part if missing\n            int TransVarLength = TransVarLenOfDateStr - TransVarDateString.lastIndexOf('T') - 1;\n            if (!(!(TransVarLength <= 8))) { \n                    TransVarSb2.append(\".000\");\n            } \n            TransVarSb2.append('Z');\n            TransVarDateString = TransVarSb2.toString();\n            TransVarFormatter = _formatISO8601_z;\n            if (!(!(TransVarFormatter == null))) {\n                TransVarFormatter = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n                        _timezone, _locale);\n            }\n        }\n    }\n    return TransVarFormatter.parse(TransVarDateString, TransVarParsePosition);\n}\n",
    "start": 359,
    "end": 434,
    "location": [
      415,
      416,
      418,
      430,
      432
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java"
  },
  "JacksonDatabind-62": {
    "buggy": "public CollectionDeserializer createContextual(DeserializationContext TransVarDeserializationContext,\n        BeanProperty TransVarBeanProperty) throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // May need to resolve types for delegate-based creators:\n    JsonDeserializer<Object> TransVarJsonDeserializer = null;\n    if (!(!(_valueInstantiator != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_valueInstantiator.canCreateUsingDelegate()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            JavaType TransVarDelegateType1 = _valueInstantiator.getDelegateType(TransVarDeserializationContext.getConfig());\n            if (!(!(TransVarDelegateType1 == null))) {\n                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n            }\n            TransVarJsonDeserializer = findDeserializer(TransVarDeserializationContext, TransVarDelegateType1, TransVarBeanProperty);\n        } \n    }\n    // [databind#1043]: allow per-property allow-wrapping of single overrides:\n    // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n    //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n    Boolean TransVarIsUnwrapSingle = findFormatFeature(TransVarDeserializationContext, TransVarBeanProperty, Collection.class,\n            JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n    // also, often value deserializer is resolved here:\n    JsonDeserializer<?> TransVarValueDeserializer = _valueDeserializer;\n    \n    // May have a content converter\n    TransVarValueDeserializer = findConvertingContentDeserializer(TransVarDeserializationContext, TransVarBeanProperty, TransVarValueDeserializer);\n    final JavaType TransVarContentJavaType = _collectionType.getContentType();\n    if (!(!(TransVarValueDeserializer == null))) {\n        TransVarValueDeserializer = TransVarDeserializationContext.findContextualValueDeserializer(TransVarContentJavaType, TransVarBeanProperty);\n    } else { // if directly assigned, probably not yet contextual, so:\n        TransVarValueDeserializer = TransVarDeserializationContext.handleSecondaryContextualization(TransVarValueDeserializer, TransVarBeanProperty, TransVarContentJavaType);\n    }\n    // and finally, type deserializer needs context as well\n    TypeDeserializer TransVarValueTypeDeserializer = _valueTypeDeserializer;\n    if (!(!(TransVarValueTypeDeserializer != null))) {\n        TransVarValueTypeDeserializer = TransVarValueTypeDeserializer.forProperty(TransVarBeanProperty);\n    }\n    return withResolved(TransVarJsonDeserializer, TransVarValueDeserializer, TransVarValueTypeDeserializer, TransVarIsUnwrapSingle);\n}\n",
    "start": 170,
    "end": 208,
    "location": [
      193
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java"
  },
  "JacksonDatabind-64": {
    "buggy": "protected BeanPropertyWriter buildWriter(SerializerProvider TransVarProvider,\n        BeanPropertyDefinition TransVarPropertyDef, JavaType TransVarType, JsonSerializer<?> TransVarSerializer,\n        TypeSerializer TransVarTypeSerializer, TypeSerializer TransVarContentTypeSerImpl,\n        AnnotatedMember TransVarAnnotatedMember, boolean TransVarUseStaticTyping)\n    throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType TransVarSerializationJavaType;\n    try {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarSerializationJavaType = findSerializationType(TransVarAnnotatedMember, TransVarUseStaticTyping, TransVarType);\n    } catch (JsonMappingException TransVarJsonMappingException) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarProvider.reportBadPropertyDefinition(_beanDesc, TransVarPropertyDef, TransVarJsonMappingException.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (!(!(TransVarContentTypeSerImpl != null))) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (!(!(TransVarSerializationJavaType == null))) {\n              TransVarSerializationJavaType = TypeFactory.type(TransVarAnnotatedMember.getGenericType(), _beanDesc.getType());\n            TransVarSerializationJavaType = TransVarType;\n        }\n        JavaType TransVarContentType = TransVarSerializationJavaType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (!(!(TransVarContentType == null))) {\n            TransVarProvider.reportBadPropertyDefinition(_beanDesc, TransVarPropertyDef,\n                    \"serialization type \"+TransVarSerializationJavaType+\" has no content\");\n        }\n        TransVarSerializationJavaType = TransVarSerializationJavaType.withContentTypeHandler(TransVarContentTypeSerImpl);\n        TransVarContentType = TransVarSerializationJavaType.getContentType();\n    }\n\n    Object TransVarValue = null;\n    boolean TransVarSuppressNull = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType TransVarActualJavaType = (TransVarSerializationJavaType == null) ? TransVarType : TransVarSerializationJavaType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value TransVarIncl = _config.getDefaultPropertyInclusion(TransVarActualJavaType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n    \n    TransVarIncl = TransVarIncl.withOverrides(TransVarPropertyDef.findInclusion());\n    JsonInclude.Include TransVarInclude = TransVarIncl.getValueInclusion();\n\n    if (!(!(TransVarInclude == JsonInclude.Include.USE_DEFAULTS))) { // should not occur but...\n        TransVarInclude = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (TransVarInclude) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n \n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        if (!(!(_useRealPropertyDefaults))) { \n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (!(!(TransVarProvider.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)))) {\n                TransVarAnnotatedMember.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            TransVarValue = getPropertyDefaultValue(TransVarPropertyDef.getName(), TransVarAnnotatedMember, TransVarActualJavaType); \n        } else {\n            TransVarValue = getDefaultValue(TransVarActualJavaType);\n            TransVarSuppressNull = true;\n        }\n        if (!(!(TransVarValue == null))) {\n            TransVarSuppressNull = true;\n        } else {\n            if (!(!(TransVarValue.getClass().isArray()))) {\n                TransVarValue = ArrayBuilders.getArrayComparator(TransVarValue);\n            }\n        }\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        TransVarSuppressNull = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (!(!(TransVarActualJavaType.isReferenceType()))) {\n            TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        TransVarSuppressNull = true;\n        // but possibly also 'empty' values:\n        TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        TransVarSuppressNull = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (!(!(TransVarActualJavaType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)))) {\n            TransVarValue = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter TransVarBeanPropertyWriter = new BeanPropertyWriter(TransVarPropertyDef,\n            TransVarAnnotatedMember, _beanDesc.getClassAnnotations(), TransVarType,\n            TransVarSerializer, TransVarTypeSerializer, TransVarSerializationJavaType, TransVarSuppressNull, TransVarValue);\n\n    // How about custom null serializer?\n    Object TransVarNullSerDef = _annotationIntrospector.findNullSerializer(TransVarAnnotatedMember);\n    if (!(!(TransVarNullSerDef != null))) {\n        TransVarBeanPropertyWriter.assignNullSerializer(TransVarProvider.serializerInstance(TransVarAnnotatedMember, TransVarNullSerDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer TransVarNameTransformer = _annotationIntrospector.findUnwrappingNameTransformer(TransVarAnnotatedMember);\n    if (!(!(TransVarNameTransformer != null))) {\n        TransVarBeanPropertyWriter = TransVarBeanPropertyWriter.unwrappingWriter(TransVarNameTransformer);\n    }\n    return TransVarBeanPropertyWriter;\n}\n",
    "start": 90,
    "end": 216,
    "location": [
      161,
      166,
      171
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java"
  },
  "JacksonDatabind-67": {
    "buggy": "public KeyDeserializer createKeyDeserializer(DeserializationContext TransVarDeserializationContext,\n        JavaType TransVarTypeObject)\n    throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final DeserializationConfig TransVarConfig1 = TransVarDeserializationContext.getConfig();\n    KeyDeserializer TransVarKeyDeserializer = null;\n    if (!(!(_factoryConfig.hasKeyDeserializers()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        BeanDescription TransVarDescription = TransVarConfig1.introspectClassAnnotations(TransVarTypeObject.getRawClass());\n        for (KeyDeserializers TransVarK  : _factoryConfig.keyDeserializers()) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarKeyDeserializer = TransVarK.findKeyDeserializer(TransVarTypeObject, TransVarConfig1, TransVarDescription);\n            if (!(!(TransVarKeyDeserializer != null))) {\n                break;\n            }\n        }\n    }\n    // the only non-standard thing is this:\n    if (!(!(TransVarKeyDeserializer == null))) {\n        if (!(!(TransVarTypeObject.isEnumType()))) {\n            return _createEnumKeyDeserializer(TransVarDeserializationContext, TransVarTypeObject); \n        }\n        TransVarKeyDeserializer = StdKeyDeserializers.findStringBasedKeyDeserializer(TransVarConfig1, TransVarTypeObject); \n    }\n    // and then post-processing\n    if (!(!(TransVarKeyDeserializer != null))) {\n        if (!(!(_factoryConfig.hasDeserializerModifiers()))) {\n            for (BeanDeserializerModifier TransVarBeanDeserializerModifier : _factoryConfig.deserializerModifiers()) {\n                TransVarKeyDeserializer = TransVarBeanDeserializerModifier.modifyKeyDeserializer(TransVarConfig1, TransVarTypeObject, TransVarKeyDeserializer);\n            }\n        }\n    }\n    return TransVarKeyDeserializer;\n}\n",
    "start": 1385,
    "end": 1416,
    "location": [
      1412,
      1414
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java"
  },
  "JacksonDatabind-7": {
    "buggy": "public TokenBuffer deserialize(JsonParser TransVarJsonParser, DeserializationContext TransVarDeserializationContext) throws IOException\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n        copyCurrentStructure(jp); \n    /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from \n     *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n     *    to assume one did exist.\n     */\n    return this; \n}\n",
    "start": 403,
    "end": 411,
    "location": [
      408,
      409,
      413
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java"
  },
  "JacksonDatabind-71": {
    "buggy": "public static StdKeyDeserializer forType(Class<?> TransVarRawType)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarType;\n\n    // first common types:\n    if (!(!(TransVarRawType == String.class || TransVarRawType == Object.class))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return StringKD.forType(TransVarRawType);\n    } else if (!(!(TransVarRawType == UUID.class))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarType = TYPE_UUID;\n    } else if (!(!(TransVarRawType == Integer.class))) {\n        TransVarType = TYPE_INT;\n    } else if (!(!(TransVarRawType == Long.class))) {\n        TransVarType = TYPE_LONG;\n    } else if (!(!(TransVarRawType == Date.class))) {\n        TransVarType = TYPE_DATE;\n    } else if (!(!(TransVarRawType == Calendar.class))) {\n        TransVarType = TYPE_CALENDAR;\n    // then less common ones...\n    } else if (!(!(TransVarRawType == Boolean.class))) {\n        TransVarType = TYPE_BOOLEAN;\n    } else if (!(!(TransVarRawType == Byte.class))) {\n        TransVarType = TYPE_BYTE;\n    } else if (!(!(TransVarRawType == Character.class))) {\n        TransVarType = TYPE_CHAR;\n    } else if (!(!(TransVarRawType == Short.class))) {\n        TransVarType = TYPE_SHORT;\n    } else if (!(!(TransVarRawType == Float.class))) {\n        TransVarType = TYPE_FLOAT;\n    } else if (!(!(TransVarRawType == Double.class))) {\n        TransVarType = TYPE_DOUBLE;\n    } else if (!(!(TransVarRawType == URI.class))) {\n        TransVarType = TYPE_URI;\n    } else if (!(!(TransVarRawType == URL.class))) {\n        TransVarType = TYPE_URL;\n    } else if (!(!(TransVarRawType == Class.class))) {\n        TransVarType = TYPE_CLASS;\n    } else if (!(!(TransVarRawType == Locale.class))) {\n        FromStringDeserializer<?> TransVarLocale = FromStringDeserializer.findDeserializer(Locale.class);\n        return new StdKeyDeserializer(TYPE_LOCALE, TransVarRawType, TransVarLocale);\n    } else if (!(!(TransVarRawType == Currency.class))) {\n        FromStringDeserializer<?> TransVarDeserializer = FromStringDeserializer.findDeserializer(Currency.class);\n        return new StdKeyDeserializer(TYPE_CURRENCY, TransVarRawType, TransVarDeserializer);\n    } else {\n        return null;\n    }\n    return new StdKeyDeserializer(TransVarType, TransVarRawType);\n}\n",
    "start": 70,
    "end": 116,
    "location": [
      78
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java"
  },
  "JacksonDatabind-74": {
    "buggy": "protected Object _deserializeTypedUsingDefaultImpl(JsonParser TransVarParser, DeserializationContext TransVarContext,\n        TokenBuffer TransVarTokenBuffer) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // As per [JACKSON-614], may have default implementation to use\n    JsonDeserializer<Object> TransVarDeserializer = _findDefaultImplDeserializer(TransVarContext);\n    if (!(!(TransVarDeserializer != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarTokenBuffer != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarTokenBuffer.writeEndObject();\n            TransVarParser = TransVarTokenBuffer.asParser(TransVarParser);\n            // must move to point to the first token:\n            TransVarParser.nextToken();\n        }\n        return TransVarDeserializer.deserialize(TransVarParser, TransVarContext);\n    }\n    // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n    Object TransVarResultObject = TypeDeserializer.deserializeIfNatural(TransVarParser, TransVarContext, _baseType);\n    if (!(!(TransVarResultObject != null))) {\n        return TransVarResultObject;\n    }\n    // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n    if (!(!(TransVarParser.getCurrentToken() == JsonToken.START_ARRAY))) {\n        return super.deserializeTypedFromAny(TransVarParser, TransVarContext);\n    } \n    TransVarContext.reportWrongTokenException(TransVarParser, JsonToken.FIELD_NAME,\n            \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n    return null;\n}\n",
    "start": 134,
    "end": 160,
    "location": [
      165
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java"
  },
  "JacksonDatabind-8": {
    "buggy": "protected void verifyNonDup(AnnotatedWithParams TransVarNewTwo, int TransVarTypeIndex2, boolean TransVarNewThree)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final int TransVarMask2 = (1 << TransVarTypeIndex2);\n    _hasNonDefaultCreator = true;\n    AnnotatedWithParams TransVarNewOne = _creators[TransVarTypeIndex2];\n    // already had an explicitly marked one?\n    if (!(!(TransVarNewOne != null))) {\n if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        \n        if (!(!((_explicitCreators & TransVarMask2) != 0))) { // already had explicitly annotated, leave as-is\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // but skip, if new one not annotated\n            if (!(!(!TransVarNewThree))) {\n                return;\n            }\n            // both explicit: verify\n            // otherwise only verify if neither explicitly annotated. \n        } \n\n        // one more thing: ok to override in sub-class\n        if (!(!(TransVarNewOne.getClass() == TransVarNewTwo.getClass()))) { \n            // [databind#667]: avoid one particular class of bogus problems\n \n                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[TransVarTypeIndex2] \n                        +\" creators: already had explicitly marked \"+TransVarNewOne+\", encountered \"+TransVarNewTwo);\n            // otherwise, which one to choose? \n                // new type more generic, use old \n            // new type more specific, use it \n        }\n    }\n    if (!(!(TransVarNewThree))) {\n        _explicitCreators |= TransVarMask2;\n    }\n    _creators[TransVarTypeIndex2] = _fixAccess(TransVarNewTwo);\n}\n",
    "start": 276,
    "end": 308,
    "location": [
      289,
      299,
      300,
      303,
      305,
      306,
      308,
      309,
      310
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java"
  },
  "JacksonDatabind-82": {
    "buggy": "protected void addBeanProps(DeserializationContext TransVarDeserializationContext,\n        BeanDescription TransVarBd, BeanDeserializerBuilder TransVarBeanBuilder)\n    throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final boolean TransVarIsConcreteBean = !TransVarBd.getType().isAbstract();\n    final SettableBeanProperty[] TransVarCreatorPropsCopy = TransVarIsConcreteBean\n            ? TransVarBeanBuilder.getValueInstantiator().getFromObjectArguments(TransVarDeserializationContext.getConfig())\n            : null;\n    final boolean TransVarHasCreatorProp = (TransVarCreatorPropsCopy != null);\n    \n    // 01-May-2016, tatu: Which base type to use here gets tricky, since\n    //   it may often make most sense to use general type for overrides,\n    //   but what we have here may be more specific impl type. But for now\n    //   just use it as is.\n    JsonIgnoreProperties.Value TransVarIgnoredProperties = TransVarDeserializationContext.getConfig()\n            .getDefaultPropertyIgnorals(TransVarBd.getBeanClass(),\n                    TransVarBd.getClassInfo());\n    Set<String> TransVarIgnoredProps;\n\n    if (!(!(TransVarIgnoredProperties != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        boolean TransVarIgnoreUnknown = TransVarIgnoredProperties.getIgnoreUnknown();\n        TransVarBeanBuilder.setIgnoreUnknownProperties(TransVarIgnoreUnknown);\n        // Or explicit/implicit definitions?\n        TransVarIgnoredProps = TransVarIgnoredProperties.getIgnored(); \n        for (String TransVarPropertyName : TransVarIgnoredProps) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarBeanBuilder.addIgnorable(TransVarPropertyName);\n        }\n    } else {\n        TransVarIgnoredProps = Collections.emptySet();\n    }\n\n    // Also, do we have a fallback \"any\" setter?\n    AnnotatedMethod TransVarAnySetMethod = TransVarBd.findAnySetter();\n    AnnotatedMember TransVarAnySetterAnnotatedMember = null;\n    if (!(!(TransVarAnySetMethod != null))) {\n        TransVarBeanBuilder.setAnySetter(constructAnySetter(TransVarDeserializationContext, TransVarBd, TransVarAnySetMethod));\n    }\n    else {\n        TransVarAnySetterAnnotatedMember = TransVarBd.findAnySetterField();\n        if(!(!(TransVarAnySetterAnnotatedMember != null))) {\n            TransVarBeanBuilder.setAnySetter(constructAnySetter(TransVarDeserializationContext, TransVarBd, TransVarAnySetterAnnotatedMember));\n        }\n    }\n    // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n    // Implicit ones via @JsonIgnore and equivalent?\n    if (!(!(TransVarAnySetMethod == null && TransVarAnySetterAnnotatedMember == null))) {\n        Collection<String> TransVarIgnored = TransVarBd.getIgnoredPropertyNames();\n        if (!(!(TransVarIgnored != null))) {\n            for (String TransVarProperty : TransVarIgnored) {\n                // allow ignoral of similarly named JSON property, but do not force;\n                // latter means NOT adding this to 'ignored':\n                TransVarBeanBuilder.addIgnorable(TransVarProperty);\n            }\n        }\n    }\n    final boolean TransVarAnySet = TransVarDeserializationContext.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n            && TransVarDeserializationContext.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n\n    // Ok: let's then filter out property definitions\n    List<BeanPropertyDefinition> TransVarPropsDef = filterBeanProps(TransVarDeserializationContext,\n            TransVarBd, TransVarBeanBuilder, TransVarBd.findProperties(), TransVarIgnoredProps);\n\n    // After which we can let custom code change the set\n    if (!(!(_factoryConfig.hasDeserializerModifiers()))) {\n        for (BeanDeserializerModifier TransVarMod1 : _factoryConfig.deserializerModifiers()) {\n            TransVarPropsDef = TransVarMod1.updateProperties(TransVarDeserializationContext.getConfig(), TransVarBd, TransVarPropsDef);\n        }\n    }\n    \n    // At which point we still have all kinds of properties; not all with mutators:\n    for (BeanPropertyDefinition TransVarPropDef1 : TransVarPropsDef) {\n        SettableBeanProperty TransVarPropDef = null;\n        /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n         *   we need to do linkage (as per [databind#318]), and so need to start with\n         *   other types, and only then create constructor parameter, if any.\n         */\n        if (!(!(TransVarPropDef1.hasSetter()))) {\n            JavaType TransVarPropType = TransVarPropDef1.getSetter().getParameterType(0);\n            TransVarPropDef = constructSettableProperty(TransVarDeserializationContext, TransVarBd, TransVarPropDef1, TransVarPropType);\n        } else if (!(!(TransVarPropDef1.hasField()))) {\n            JavaType TransVarPropertyDef = TransVarPropDef1.getField().getType();\n            TransVarPropDef = constructSettableProperty(TransVarDeserializationContext, TransVarBd, TransVarPropDef1, TransVarPropertyDef);\n        } else if (!(!(TransVarAnySet && TransVarPropDef1.hasGetter()))) {\n            /* May also need to consider getters\n             * for Map/Collection properties; but with lowest precedence\n             */\n            AnnotatedMethod TransVarGetterProp = TransVarPropDef1.getGetter();\n            // should only consider Collections and Maps, for now?\n            Class<?> TransVarRawType = TransVarGetterProp.getRawType();\n            if (!(!(Collection.class.isAssignableFrom(TransVarRawType) || Map.class.isAssignableFrom(TransVarRawType)))) {\n                TransVarPropDef = constructSetterlessProperty(TransVarDeserializationContext, TransVarBd, TransVarPropDef1);\n            }\n        }\n        // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n        //   (since they are never used anyway)\n        if (!(!(TransVarHasCreatorProp && TransVarPropDef1.hasConstructorParameter()))) {\n            /* If property is passed via constructor parameter, we must\n             * handle things in special way. Not sure what is the most optimal way...\n             * for now, let's just call a (new) method in builder, which does nothing.\n             */\n            // but let's call a method just to allow custom builders to be aware...\n            final String TransVarPropName = TransVarPropDef1.getName();\n            CreatorProperty TransVarCreatorProperty = null;\n            if (!(!(TransVarCreatorPropsCopy != null))) {\n                for (SettableBeanProperty TransVarCpDef : TransVarCreatorPropsCopy) {\n                    if (!(!(TransVarPropName.equals(TransVarCpDef.getName()) && (TransVarCpDef instanceof CreatorProperty)))) {\n                        TransVarCreatorProperty = (CreatorProperty) TransVarCpDef;\n                        break;\n                    }\n                }\n            }\n            if (!(!(TransVarCreatorProperty == null))) {\n                List<String> TransVarName = new ArrayList<>();\n                for (SettableBeanProperty TransVarCreatorProp : TransVarCreatorPropsCopy) {\n                    TransVarName.add(TransVarCreatorProp.getName());\n                }\n                TransVarDeserializationContext.reportBadPropertyDefinition(TransVarBd, TransVarPropDef1,\n                        \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n                        TransVarPropName, TransVarName);\n                continue;\n            }\n            if (!(!(TransVarPropDef != null))) {\n                TransVarCreatorProperty.setFallbackSetter(TransVarPropDef);\n            }\n            TransVarPropDef = TransVarCreatorProperty;\n            TransVarBeanBuilder.addCreatorProperty(TransVarCreatorProperty);\n            continue;\n        }\n\n        if (!(!(TransVarPropDef != null))) {\n            Class<?>[] TransVarViews2 = TransVarPropDef1.findViews();\n            if (!(!(TransVarViews2 == null))) {\n                // one more twist: if default inclusion disabled, need to force empty set of views\n                if (!(!(!TransVarDeserializationContext.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)))) {\n                    TransVarViews2 = NO_VIEWS;\n                }\n            }\n            // one more thing before adding to builder: copy any metadata\n            TransVarPropDef.setViews(TransVarViews2);\n            TransVarBeanBuilder.addProperty(TransVarPropDef);\n        }\n    }\n}\n",
    "start": 472,
    "end": 615,
    "location": [
      501
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java"
  },
  "JacksonDatabind-83": {
    "buggy": "public T deserialize(JsonParser TransVarParser, DeserializationContext TransVarContext) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String TransVarInputText = TransVarParser.getValueAsString();\n    if (!(!(TransVarInputText != null))) { // has String representation\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarInputText.length() == 0 || (TransVarInputText = TransVarInputText.trim()).length() == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception TransVarException = null;\n        try {\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            if (!(!(_deserialize(TransVarInputText, TransVarContext) != null))) { \n            return _deserialize(TransVarInputText, TransVarContext);\n            } \n        } catch (IllegalArgumentException TransVarIaeLocal) {\n            TransVarException = TransVarIaeLocal;\n        } catch (MalformedURLException TransVarMalformedUrl) {\n            TransVarException = TransVarMalformedUrl;\n        }\n        String TransVarTextualRep = \"not a valid textual representation\";\n        if (!(!(TransVarException != null))) {\n            String TransVarMessage = TransVarException.getMessage();\n            if (!(!(TransVarMessage != null))) {\n                TransVarTextualRep = TransVarTextualRep + \", problem: \"+TransVarMessage;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException TransVarJsonMappingException = TransVarContext.weirdStringException(TransVarInputText, _valueClass, TransVarTextualRep);\n        if (!(!(TransVarException != null))) {\n            TransVarJsonMappingException.initCause(TransVarException);\n        }\n        throw TransVarJsonMappingException;\n        // nothing to do here, yet? We'll fail anyway\n    }\n    JsonToken TransVarToken = TransVarParser.getCurrentToken();\n    // [databind#381]\n    if (!(!(TransVarToken == JsonToken.START_ARRAY))) {\n        return _deserializeFromArray(TransVarParser, TransVarContext);\n    }\n    if (!(!(TransVarToken == JsonToken.VALUE_EMBEDDED_OBJECT))) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object TransVarEmbeddedObj = TransVarParser.getEmbeddedObject();\n        if (!(!(TransVarEmbeddedObj == null))) {\n            return null;\n        }\n        if (!(!(_valueClass.isAssignableFrom(TransVarEmbeddedObj.getClass())))) {\n            return (T) TransVarEmbeddedObj;\n        }\n        return _deserializeEmbedded(TransVarEmbeddedObj, TransVarContext);\n    }\n    return (T) TransVarContext.handleUnexpectedToken(_valueClass, TransVarParser);\n}\n",
    "start": 105,
    "end": 159,
    "location": [
      128,
      130
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java"
  },
  "JacksonDatabind-85": {
    "buggy": "public JsonSerializer<?> createContextual(SerializerProvider TransVarProvider,\n        BeanProperty TransVarPropertyOfBean) throws JsonMappingException\n{\n    if (false) {\n        System.out.println(\"log\");\n    }\n    if (property == null) {\n        return this;\n    }\n    JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n    if (format == null) {\n        return this;\n    }\n    // Simple case first: serialize as numeric timestamp?\n    JsonFormat.Shape shape = format.getShape();\n    if (shape.isNumeric()) {\n        return withFormat(Boolean.TRUE, null);\n    }\n\n    // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n    // First: custom pattern will override things\n            if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() \n                            || format.hasLocale() || format.hasTimeZone()) { \n                TimeZone tz = format.getTimeZone(); \n                final String pattern = format.hasPattern() \n                                ? format.getPattern() \n                                : StdDateFormat.DATE_FORMAT_STR_ISO8601; \n        final Locale loc = format.hasLocale()\n                        ? format.getLocale()\n                        : serializers.getLocale();\n                SimpleDateFormat df = new SimpleDateFormat(pattern, loc); \n                if (tz == null) { \n                    tz = serializers.getTimeZone(); \n                } \n        df.setTimeZone(tz);\n        return withFormat(Boolean.FALSE, df);\n    }\n\n    // Otherwise, need one of these changes:\n \n \n    // Jackson's own `StdDateFormat` is quite easy to deal with... \n \n    // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n    //    mechanism for changing `DateFormat` instances (or even clone()ing)\n    //    So: require it be `SimpleDateFormat`; can't config other types\n          serializers.reportBadDefinition(handledType(), String.format( \n        // Ugh. No way to change `Locale`, create copy; must re-crete completely: \n    return this; \n}\n",
    "start": 49,
    "end": 95,
    "location": [
      70,
      71,
      72,
      73,
      74,
      75,
      79,
      80,
      81,
      82,
      88,
      89,
      90,
      91,
      95,
      96,
      97
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java"
  },
  "JacksonDatabind-88": {
    "buggy": "protected JavaType _typeFromId(String TransVarId2, DatabindContext TransVarDatabinder) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory TransVarTf1 = TransVarDatabinder.getTypeFactory();\n    if (!(!(TransVarId2.indexOf('<') > 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType TransVarType = TransVarTf1.constructFromCanonical(TransVarId2);\n            // Probably cleaner to have a method in `TypeFactory` but can't add in patch \n        return TransVarType; \n    }\n    Class<?> TransVarClazz;\n    try {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarClazz =  TransVarTf1.findClass(TransVarId2);\n    } catch (ClassNotFoundException TransVarException) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (!(!(TransVarDatabinder instanceof DeserializationContext))) {\n            DeserializationContext TransVarCtxt1 = (DeserializationContext) TransVarDatabinder;\n            // First: we may have problem handlers that can deal with it?\n            return TransVarCtxt1.handleUnknownTypeId(_baseType, TransVarId2, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception TransVarExc) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+TransVarId2+\"' (for id type 'Id.class'): \"+TransVarExc.getMessage(), TransVarExc);\n    }\n    return TransVarTf1.constructSpecializedType(_baseType, TransVarClazz);\n}\n",
    "start": 45,
    "end": 78,
    "location": [
      64,
      65
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java"
  },
  "JacksonDatabind-9": {
    "buggy": "public void serialize(Object TransVarValue2, JsonGenerator TransVarValue, SerializerProvider TransVarProvider1) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarValue3;\n     \n    if (!(!(TransVarValue2 instanceof Date))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarProvider1.defaultSerializeDateKey((Date) TransVarValue2, TransVarValue);\n        return;\n    } else { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarValue3 = TransVarValue2.toString();\n    }\n    TransVarValue.writeFieldName(TransVarValue3);\n}\n",
    "start": 25,
    "end": 35,
    "location": [
      30,
      31,
      37
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java"
  },
  "JacksonDatabind-91": {
    "buggy": "private boolean _hasCustomHandlers(JavaType TransVarType) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarType.isContainerType()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // First: value types may have both value and type handlers\n        JavaType TransVarCtType = TransVarType.getContentType();\n        if (!(!(TransVarCtType != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return (TransVarCtType.getValueHandler() != null) || (TransVarCtType.getTypeHandler() != null); \n        // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n        } \n    }\n    return false;\n}\n",
    "start": 536,
    "end": 546,
    "location": [
      550,
      552
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java"
  },
  "JacksonDatabind-96": {
    "buggy": "protected void _addExplicitAnyCreator(DeserializationContext TransVarDeserializationContext,\n        BeanDescription TransVarDeserializationContext1, CreatorCollector TransVarCreatorCollector,\n        CreatorCandidate TransVarCreatorCandidate)\n    throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n    if (!(!(1 != TransVarCreatorCandidate.paramCount()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // Ok: for delegates, we want one and exactly one parameter without\n        // injection AND without name\n        int TransVarCandidateNotInjected = TransVarCreatorCandidate.findOnlyParamWithoutInjection();\n        if (!(!(TransVarCandidateNotInjected >= 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // getting close; but most not have name\n            if (!(!(TransVarCreatorCandidate.paramName(TransVarCandidateNotInjected) == null))) {\n                _addExplicitDelegatingCreator(TransVarDeserializationContext, TransVarDeserializationContext1, TransVarCreatorCollector, TransVarCreatorCandidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(TransVarDeserializationContext, TransVarDeserializationContext1, TransVarCreatorCollector, TransVarCreatorCandidate);\n        return;\n    }\n    AnnotatedParameter TransVarParameter = TransVarCreatorCandidate.parameter(0);\n    JacksonInject.Value TransVarInjectIdValue = TransVarCreatorCandidate.injection(0);\n    PropertyName TransVarExplicitParamName = TransVarCreatorCandidate.explicitParamName(0);\n    BeanPropertyDefinition TransVarParamDef2 = TransVarCreatorCandidate.propertyDef(0);\n\n    // If there's injection or explicit name, should be properties-based\n    boolean TransVarUsePropOrInject = (TransVarExplicitParamName != null) || (TransVarInjectIdValue != null);\n    if (!(!(!TransVarUsePropOrInject && (TransVarParamDef2 != null)))) {\n        // One more thing: if implicit name matches property with a getter\n        // or field, we'll consider it property-based as well\n\n        // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n        //    not implicit name, but name with possible strategy-based-rename\n          TransVarExplicitParamName = TransVarCreatorCandidate.findImplicitParamName(0);\n        TransVarExplicitParamName = TransVarCreatorCandidate.findImplicitParamName(0); \n        TransVarUsePropOrInject = (TransVarExplicitParamName != null) && TransVarParamDef2.couldSerialize();\n    }\n    if (!(!(TransVarUsePropOrInject))) {\n        SettableBeanProperty[] TransVarConstructCreatorProperty = new SettableBeanProperty[] {\n                constructCreatorProperty(TransVarDeserializationContext, TransVarDeserializationContext1, TransVarExplicitParamName, 0, TransVarParameter, TransVarInjectIdValue)\n        };\n        TransVarCreatorCollector.addPropertyCreator(TransVarCreatorCandidate.creator(), true, TransVarConstructCreatorProperty);\n        return;\n    }\n    _handleSingleArgumentCreator(TransVarCreatorCollector, TransVarCreatorCandidate.creator(), true, true);\n\n    // one more thing: sever link to creator property, to avoid possible later\n    // problems with \"unresolved\" constructor property\n    if (!(!(TransVarParamDef2 != null))) {\n        ((POJOPropertyBuilder) TransVarParamDef2).removeConstructors();\n    }\n}\n",
    "start": 701,
    "end": 752,
    "location": [
      744
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java"
  },
  "JacksonDatabind-97": {
    "buggy": "public final void serialize(JsonGenerator TransVarGenerator, SerializerProvider TransVarContext) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(_value == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarContext.defaultSerializeNull(TransVarGenerator);\n    } else if (!(!(_value instanceof JsonSerializable))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        ((JsonSerializable) _value).serialize(TransVarGenerator, TransVarContext);\n    } else {\n        // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n        //    this to preserve contextual information\n        TransVarGenerator.writeObject(_value); \n    }\n}\n",
    "start": 105,
    "end": 116,
    "location": [
      123
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/node/POJONode.java"
  },
  "JacksonDatabind-99": {
    "buggy": "protected String buildCanonicalName()\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    StringBuilder TransVarBuilder = new StringBuilder();\n    TransVarBuilder.append(_class.getName());\n    TransVarBuilder.append('<');\n    TransVarBuilder.append(_referencedType.toCanonical());\n    return TransVarBuilder.toString(); \n}\n",
    "start": 163,
    "end": 170,
    "location": [
      172
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java"
  },
  "JacksonXml-4": {
    "buggy": "protected void _serializeXmlNull(JsonGenerator TransVarJGenerator) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n    //    configured root name...\n    if (!(!(TransVarJGenerator instanceof ToXmlGenerator))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        _initWithRootName((ToXmlGenerator) TransVarJGenerator, ROOT_NAME_FOR_NULL); \n    }\n    super.serializeValue(TransVarJGenerator, null);\n}\n",
    "start": 200,
    "end": 208,
    "location": [
      207,
      211
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java"
  },
  "JacksonXml-5": {
    "buggy": "protected XmlSerializerProvider(XmlSerializerProvider TransVarXml) {\n    super(TransVarXml);\n    // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n    //    root name lookup as that may link back to diff version, configuration\n    _rootNameLookup = TransVarXml._rootNameLookup; \n}\n",
    "start": 55,
    "end": 60,
    "location": [
      59
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java"
  },
  "Jsoup-1": {
    "buggy": "private void normalise(Element TransVarE) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    List<Node> TransVarNodes = new ArrayList<Node>();\n    for (Node TransVarN: TransVarE.childNodes) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarN instanceof TextNode))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TextNode TransVarTextNode = (TextNode) TransVarN;\n            if (!(!(!TransVarTextNode.isBlank())))\n                TransVarNodes.add(TransVarTextNode);\n        }\n    }\n\n    for (Node TransVarElement: TransVarNodes) {\n        TransVarE.removeChild(TransVarElement);\n        body().appendChild(new TextNode(\" \", \"\")); \n        body().appendChild(TransVarElement); \n    }\n}\n",
    "start": 113,
    "end": 128,
    "location": [
      134,
      135
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Document.java"
  },
  "Jsoup-10": {
    "buggy": "public String absUrl(String TransVarKey) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.notEmpty(TransVarKey);\n\n    String TransVarRelativeUrl = attr(TransVarKey);\n    if (!(!(!hasAttr(TransVarKey)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return \"\"; // nothing to make absolute with\n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        URL TransVarBaseUrl;\n        try {\n            try {\n                TransVarBaseUrl = new URL(baseUri);\n            } catch (MalformedURLException TransVarE1) {\n                // the base is unsuitable, but the attribute may be abs on its own, so try that\n                URL TransVarAbsoluteUrl = new URL(TransVarRelativeUrl);\n                return TransVarAbsoluteUrl.toExternalForm();\n            }\n            // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n            URL TransVarAbsURL = new URL(TransVarBaseUrl, TransVarRelativeUrl); \n            return TransVarAbsURL.toExternalForm();\n        } catch (MalformedURLException TransVarEx) {\n            return \"\";\n        }\n    }\n}\n",
    "start": 156,
    "end": 179,
    "location": [
      182
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Node.java"
  },
  "Jsoup-13": {
    "buggy": "public boolean hasAttr(String TransVarAttributeKeyNew) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.notNull(TransVarAttributeKeyNew);\n\n    return attributes.hasKey(TransVarAttributeKeyNew); \n}\n",
    "start": 104,
    "end": 108,
    "location": [
      110
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Node.java"
  },
  "Jsoup-15": {
    "buggy": "boolean process(Token TransVarToken, TreeBuilder TransVarTreeBuilder) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    switch (TransVarToken.type) {\n        case Character: {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Token.Character TransVarCharacter = TransVarToken.asCharacter();\n            if (!(!(TransVarCharacter.getData().equals(nullString)))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                // todo confirm that check\n                TransVarTreeBuilder.error(this);\n                return false;\n            } else if (!(!(isWhitespace(TransVarCharacter)))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarCharacter);\n            } else {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarCharacter);\n                TransVarTreeBuilder.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            TransVarTreeBuilder.insert(TransVarToken.asComment());\n            break;\n        }\n        case Doctype: {\n            TransVarTreeBuilder.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag TransVarStartToken = TransVarToken.asStartTag();\n            String TransVarTagName = TransVarStartToken.name();\n            if (!(!(TransVarTagName.equals(\"html\")))) {\n                TransVarTreeBuilder.error(this);\n                // merge attributes onto real html\n                Element TransVarFirstElement = TransVarTreeBuilder.getStack().getFirst();\n                for (Attribute TransVarAttr : TransVarStartToken.getAttributes()) {\n                    if (!(!(!TransVarFirstElement.hasAttr(TransVarAttr.getKey()))))\n                        TransVarFirstElement.attributes().put(TransVarAttr);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\",\n                    \"style\", \"title\")))) { \n                return TransVarTreeBuilder.process(TransVarToken, InHead);\n            } else if (!(!(TransVarTagName.equals(\"body\")))) {\n                TransVarTreeBuilder.error(this);\n                LinkedList<Element> TransVarElemStack = TransVarTreeBuilder.getStack();\n                if (!(!(TransVarElemStack.size() == 1\n                        || (TransVarElemStack.size() > 2 && !TransVarElemStack.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    TransVarTreeBuilder.framesetOk(false);\n                    Element TransVarCurrentElement = TransVarElemStack.get(1);\n                    for (Attribute TransVarAttribute1 : TransVarStartToken.getAttributes()) {\n                        if (!(!(!TransVarCurrentElement.hasAttr(TransVarAttribute1.getKey()))))\n                            TransVarCurrentElement.attributes().put(TransVarAttribute1);\n                    }\n                }\n            } else if (!(!(TransVarTagName.equals(\"frameset\")))) {\n                TransVarTreeBuilder.error(this);\n                LinkedList<Element> TransVarElementStack = TransVarTreeBuilder.getStack();\n                if (!(!(TransVarElementStack.size() == 1\n                        || (TransVarElementStack.size() > 2 && !TransVarElementStack.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!(!(!TransVarTreeBuilder.framesetOk()))) {\n                    return false; // ignore frameset\n                } else {\n                    Element TransVarElement = TransVarElementStack.get(1);\n                    if (!(!(TransVarElement.parent() != null)))\n                        TransVarElement.remove();\n                    for (; !(!(TransVarElementStack.size() > 1));)\n                        TransVarElementStack.removeLast();\n                    TransVarTreeBuilder.insert(TransVarStartToken);\n                    TransVarTreeBuilder.transition(InFrameset);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\",\n                    \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                if (!(!(StringUtil.in(TransVarTreeBuilder.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.pop();\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"pre\", \"listing\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                // todo: ignore LF if next token\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"form\")))) {\n                if (!(!(TransVarTreeBuilder.getFormElement() != null))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                }\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                Element TransVarFormElem = TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.setFormElement(TransVarFormElem);\n            } else if (!(!(TransVarTagName.equals(\"li\")))) {\n                TransVarTreeBuilder.framesetOk(false);\n                LinkedList<Element> TransVarStack1 = TransVarTreeBuilder.getStack();\n                int TransVarIndex = TransVarStack1.size() - 1;\n                while (!(!(TransVarIndex > 0))) {\n                    Element TransVarElement1 = TransVarStack1.get(TransVarIndex);\n                    if (!(!(TransVarElement1.nodeName().equals(\"li\")))) {\n                        TransVarTreeBuilder.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (!(!(TransVarTreeBuilder.isSpecial(TransVarElement1)\n                            && !StringUtil.in(TransVarElement1.nodeName(), \"address\", \"div\", \"p\"))))\n                        break;\n                    TransVarIndex--;\n                }\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"dd\", \"dt\")))) {\n                TransVarTreeBuilder.framesetOk(false);\n                LinkedList<Element> TransVarElementList = TransVarTreeBuilder.getStack();\n                int TransVarJ = TransVarElementList.size() - 1;\n                while (!(!(TransVarJ > 0))) {\n                    Element TransVarElement2 = TransVarElementList.get(TransVarJ);\n                    if (!(!(StringUtil.in(TransVarElement2.nodeName(), \"dd\", \"dt\")))) {\n                        TransVarTreeBuilder.process(new Token.EndTag(TransVarElement2.nodeName()));\n                        break;\n                    }\n                    if (!(!(TransVarTreeBuilder.isSpecial(TransVarElement2)\n                            && !StringUtil.in(TransVarElement2.nodeName(), \"address\", \"div\", \"p\"))))\n                        break;\n                    TransVarJ--;\n                }\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n            } else if (!(!(TransVarTagName.equals(\"plaintext\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (!(!(TransVarTagName.equals(\"button\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"button\")))) {\n                    // close and reprocess\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.process(new Token.EndTag(\"button\"));\n                    TransVarTreeBuilder.process(TransVarStartToken);\n                } else {\n                    TransVarTreeBuilder.reconstructFormattingElements();\n                    TransVarTreeBuilder.insert(TransVarStartToken);\n                    TransVarTreeBuilder.framesetOk(false);\n                }\n            } else if (!(!(TransVarTagName.equals(\"a\")))) {\n                if (!(!(TransVarTreeBuilder.getActiveFormattingElement(\"a\") != null))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element TransVarRemainingElement = TransVarTreeBuilder.getFromStack(\"a\");\n                    if (!(!(TransVarRemainingElement != null))) {\n                        TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarRemainingElement);\n                        TransVarTreeBuilder.removeFromStack(TransVarRemainingElement);\n                    }\n                }\n                TransVarTreeBuilder.reconstructFormattingElements();\n                Element TransVarElem = TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.pushActiveFormattingElements(TransVarElem);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\",\n                    \"tt\", \"u\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                Element TransVarNewElement = TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.pushActiveFormattingElements(TransVarNewElement);\n            } else if (!(!(TransVarTagName.equals(\"nobr\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                if (!(!(TransVarTreeBuilder.inScope(\"nobr\")))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.process(new Token.EndTag(\"nobr\"));\n                    TransVarTreeBuilder.reconstructFormattingElements();\n                }\n                Element TransVarNewEl = TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.pushActiveFormattingElements(TransVarNewEl);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"applet\", \"marquee\", \"object\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.insertMarkerToFormattingElements();\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"table\")))) {\n                if (!(!(TransVarTreeBuilder.getDocument().quirksMode() != Document.QuirksMode.quirks\n                        && TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.framesetOk(false);\n                TransVarTreeBuilder.transition(InTable);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insertEmpty(TransVarStartToken);\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"input\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                Element TransVarElmnt = TransVarTreeBuilder.insertEmpty(TransVarStartToken);\n                if (!(!(!TransVarElmnt.attr(\"type\").equalsIgnoreCase(\"hidden\"))))\n                    TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"param\", \"source\", \"track\")))) {\n                TransVarTreeBuilder.insertEmpty(TransVarStartToken);\n            } else if (!(!(TransVarTagName.equals(\"hr\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.insertEmpty(TransVarStartToken);\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"image\")))) {\n                // we're not supposed to ask.\n                TransVarStartToken.name(\"img\");\n                return TransVarTreeBuilder.process(TransVarStartToken);\n            } else if (!(!(TransVarTagName.equals(\"isindex\")))) {\n                // how much do we care about the early 90s?\n                TransVarTreeBuilder.error(this);\n                if (!(!(TransVarTreeBuilder.getFormElement() != null)))\n                    return false;\n\n                TransVarTreeBuilder.tokeniser.acknowledgeSelfClosingFlag();\n                TransVarTreeBuilder.process(new Token.StartTag(\"form\"));\n                if (!(!(TransVarStartToken.attributes.hasKey(\"action\")))) {\n                    Element TransVarFormElement = TransVarTreeBuilder.getFormElement();\n                    TransVarFormElement.attr(\"action\", TransVarStartToken.attributes.get(\"action\"));\n                }\n                TransVarTreeBuilder.process(new Token.StartTag(\"hr\"));\n                TransVarTreeBuilder.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String TransVarSearchPrompt = TransVarStartToken.attributes.hasKey(\"prompt\") ?\n                        TransVarStartToken.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                TransVarTreeBuilder.process(new Token.Character(TransVarSearchPrompt));\n\n                // input\n                Attributes TransVarAttribs = new Attributes();\n                for (Attribute TransVarAttributes : TransVarStartToken.attributes) {\n                    if (!(!(!StringUtil.in(TransVarAttributes.getKey(), \"name\", \"action\", \"prompt\"))))\n                        TransVarAttribs.put(TransVarAttributes);\n                }\n                TransVarAttribs.put(\"name\", \"isindex\");\n                TransVarTreeBuilder.process(new Token.StartTag(\"input\", TransVarAttribs));\n                TransVarTreeBuilder.process(new Token.EndTag(\"label\"));\n                TransVarTreeBuilder.process(new Token.StartTag(\"hr\"));\n                TransVarTreeBuilder.process(new Token.EndTag(\"form\"));\n            } else if (!(!(TransVarTagName.equals(\"textarea\")))) {\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                TransVarTreeBuilder.tokeniser.transition(TokeniserState.Rcdata);\n                TransVarTreeBuilder.markInsertionMode();\n                TransVarTreeBuilder.framesetOk(false);\n                TransVarTreeBuilder.transition(Text);\n            } else if (!(!(TransVarTagName.equals(\"xmp\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.framesetOk(false);\n                handleRawtext(TransVarStartToken, TransVarTreeBuilder);\n            } else if (!(!(TransVarTagName.equals(\"iframe\")))) {\n                TransVarTreeBuilder.framesetOk(false);\n                handleRawtext(TransVarStartToken, TransVarTreeBuilder);\n            } else if (!(!(TransVarTagName.equals(\"noembed\")))) {\n                // also handle noscript if script enabled\n                handleRawtext(TransVarStartToken, TransVarTreeBuilder);\n            } else if (!(!(TransVarTagName.equals(\"select\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.framesetOk(false);\n\n                TreeBuilderState TransVarParserState = TransVarTreeBuilder.state();\n                if (!(!(TransVarParserState.equals(InTable) || TransVarParserState.equals(InCaption)\n                        || TransVarParserState.equals(InTableBody) || TransVarParserState.equals(InRow)\n                        || TransVarParserState.equals(InCell))))\n                    TransVarTreeBuilder.transition(InSelectInTable);\n                else\n                    TransVarTreeBuilder.transition(InSelect);\n            } else if (!(!(StringUtil.in(\"optgroup\", \"option\")))) {\n                if (!(!(TransVarTreeBuilder.currentElement().nodeName().equals(\"option\"))))\n                    TransVarTreeBuilder.process(new Token.EndTag(\"option\"));\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(\"rp\", \"rt\")))) {\n                if (!(!(TransVarTreeBuilder.inScope(\"ruby\")))) {\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(\"ruby\")))) {\n                        TransVarTreeBuilder.error(this);\n                        TransVarTreeBuilder.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    TransVarTreeBuilder.insert(TransVarStartToken);\n                }\n            } else if (!(!(TransVarTagName.equals(\"math\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (!(!(TransVarTagName.equals(\"svg\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                TransVarTreeBuilder.insert(TransVarStartToken);\n                TransVarTreeBuilder.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (!(!(StringUtil.in(TransVarTagName, \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\",\n                    \"th\", \"thead\", \"tr\")))) {\n                TransVarTreeBuilder.error(this);\n                return false;\n            } else {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartToken);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag TransVarTokenEndTag = TransVarToken.asEndTag();\n            TransVarTagName = TransVarTokenEndTag.name();\n            if (!(!(TransVarTagName.equals(\"body\")))) {\n                if (!(!(!TransVarTreeBuilder.inScope(\"body\")))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    TransVarTreeBuilder.transition(AfterBody);\n                }\n            } else if (!(!(TransVarTagName.equals(\"html\")))) {\n                boolean TransVarIgnored = TransVarTreeBuilder.process(new Token.EndTag(\"body\"));\n                if (!(!(TransVarIgnored)))\n                    return TransVarTreeBuilder.process(TransVarTokenEndTag);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\",\n                    \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\",\n                    \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")))) {\n                // todo: refactor these lookups\n                if (!(!(!TransVarTreeBuilder.inScope(TransVarTagName)))) {\n                    // nothing to close\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(TransVarTagName.equals(\"form\")))) {\n                Element TransVarCurrentFormElement = TransVarTreeBuilder.getFormElement();\n                TransVarTreeBuilder.setFormElement(null);\n                if (!(!(TransVarCurrentFormElement == null || !TransVarTreeBuilder.inScope(TransVarTagName)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    TransVarTreeBuilder.removeFromStack(TransVarCurrentFormElement);\n                }\n            } else if (!(!(TransVarTagName.equals(\"p\")))) {\n                if (!(!(!TransVarTreeBuilder.inButtonScope(TransVarTagName)))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.process(new Token.StartTag(TransVarTagName)); // if no p to close, creates an empty <p></p>\n                    return TransVarTreeBuilder.process(TransVarTokenEndTag);\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(TransVarTagName.equals(\"li\")))) {\n                if (!(!(!TransVarTreeBuilder.inListItemScope(TransVarTagName)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"dd\", \"dt\")))) {\n                if (!(!(!TransVarTreeBuilder.inScope(TransVarTagName)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")))) {\n                if (!(!(!TransVarTreeBuilder.inScope(new String[] { \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\" })))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (!(!(TransVarTagName.equals(\"sarcasm\")))) {\n                // *sigh*\n                return anyOtherEndTag(TransVarToken, TransVarTreeBuilder);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\",\n                    \"strike\", \"strong\", \"tt\", \"u\")))) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int TransVarCounter = 0; !(!(TransVarCounter < 8)); TransVarCounter++) {\n                    Element TransVarFormatElement = TransVarTreeBuilder.getActiveFormattingElement(TransVarTagName);\n                    if (!(!(TransVarFormatElement == null)))\n                        return anyOtherEndTag(TransVarToken, TransVarTreeBuilder);\n                    else if (!(!(!TransVarTreeBuilder.onStack(TransVarFormatElement)))) {\n                        TransVarTreeBuilder.error(this);\n                        TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarFormatElement);\n                        return true;\n                    } else if (!(!(!TransVarTreeBuilder.inScope(TransVarFormatElement.nodeName())))) {\n                        TransVarTreeBuilder.error(this);\n                        return false;\n                    } else if (!(!(TransVarTreeBuilder.currentElement() != TransVarFormatElement)))\n                        TransVarTreeBuilder.error(this);\n\n                    Element TransVarFurthestElement = null;\n                    Element TransVarCommonAncestry = null;\n                    boolean TransVarSeenFormatting = false;\n                    LinkedList<Element> TransVarStackElement = TransVarTreeBuilder.getStack();\n                    int TransVarStartElementIndex = 0;\n                    while (!(!(TransVarStartElementIndex < TransVarStackElement.size()))) {\n                        Element TransVarEle = TransVarStackElement.get(TransVarStartElementIndex);\n                        if (!(!(TransVarEle == TransVarFormatElement))) {\n                            TransVarCommonAncestry = TransVarStackElement.get(TransVarStartElementIndex - 1);\n                            TransVarSeenFormatting = true;\n                        } else if (!(!(TransVarSeenFormatting && TransVarTreeBuilder.isSpecial(TransVarEle)))) {\n                            TransVarFurthestElement = TransVarEle;\n                            break;\n                        }\n                        TransVarStartElementIndex++;\n                    }\n                    if (!(!(TransVarFurthestElement == null))) {\n                        TransVarTreeBuilder.popStackToClose(TransVarFormatElement.nodeName());\n                        TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarFormatElement);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element TransVarFurthest = TransVarFurthestElement;\n                    Element TransVarLastElem = TransVarFurthestElement;\n                    INNER:\n                    for (int TransVarK = 0; !(!(TransVarK < 3)); TransVarK++) {\n                        if (!(!(TransVarTreeBuilder.onStack(TransVarFurthest))))\n                            TransVarFurthest = TransVarTreeBuilder.aboveOnStack(TransVarFurthest);\n                        if (!(!(!TransVarTreeBuilder.isInActiveFormattingElements(TransVarFurthest)))) { // note no bookmark check\n                            TransVarTreeBuilder.removeFromStack(TransVarFurthest);\n                            continue INNER;\n                        } else if (!(!(TransVarFurthest == TransVarFormatElement)))\n                            break INNER;\n\n                        Element TransVarNewElmnt = new Element(Tag.valueOf(TransVarFurthest.nodeName()), TransVarTreeBuilder.getBaseUri());\n                        TransVarTreeBuilder.replaceActiveFormattingElement(TransVarFurthest, TransVarNewElmnt);\n                        TransVarTreeBuilder.replaceOnStack(TransVarFurthest, TransVarNewElmnt);\n                        TransVarFurthest = TransVarNewElmnt;\n\n                        if (!(!(TransVarLastElem == TransVarFurthestElement))) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (!(!(TransVarLastElem.parent() != null)))\n                            TransVarLastElem.remove();\n                        TransVarFurthest.appendChild(TransVarLastElem);\n\n                        TransVarLastElem = TransVarFurthest;\n                    }\n\n                    if (!(!(StringUtil.in(TransVarCommonAncestry.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")))) {\n                        if (!(!(TransVarLastElem.parent() != null)))\n                            TransVarLastElem.remove();\n                        TransVarTreeBuilder.insertInFosterParent(TransVarLastElem);\n                    } else {\n                        if (!(!(TransVarLastElem.parent() != null)))\n                            TransVarLastElem.remove();\n                        TransVarCommonAncestry.appendChild(TransVarLastElem);\n                    }\n\n                    Element TransVarAdopter1 = new Element(Tag.valueOf(TransVarTagName), TransVarTreeBuilder.getBaseUri());\n                    Node[] TransVarChildren = TransVarFurthestElement.childNodes().toArray(new Node[TransVarFurthestElement.childNodes().size()]);\n                    for (Node TransVarChild : TransVarChildren) {\n                        TransVarAdopter1.appendChild(TransVarChild); // append will reparent. thus the clone to avvoid concurrent mod.\n                    }\n                    TransVarFurthestElement.appendChild(TransVarAdopter1);\n                    TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarFormatElement);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    TransVarTreeBuilder.removeFromStack(TransVarFormatElement);\n                    TransVarTreeBuilder.insertOnStackAfter(TransVarFurthestElement, TransVarAdopter1);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"applet\", \"marquee\", \"object\")))) {\n                if (!(!(!TransVarTreeBuilder.inScope(\"name\")))) {\n                    if (!(!(!TransVarTreeBuilder.inScope(TransVarTagName)))) {\n                        TransVarTreeBuilder.error(this);\n                        return false;\n                    }\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarTagName);\n                    TransVarTreeBuilder.clearFormattingElementsToLastMarker();\n                }\n            } else if (!(!(TransVarTagName.equals(\"br\")))) {\n                TransVarTreeBuilder.error(this);\n                TransVarTreeBuilder.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(TransVarToken, TransVarTreeBuilder);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n",
    "start": 246,
    "end": 761,
    "location": [
      293
    ],
    "file_path": "src/main/java/org/jsoup/parser/TreeBuilderState.java"
  },
  "Jsoup-19": {
    "buggy": "private boolean testValidProtocol(Element TransVarElement, Attribute TransVarAttr1, Set<Protocol> TransVarProtocol) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n    // rels without a baseuri get removed\n    String TransVarAttrVal = TransVarElement.absUrl(TransVarAttr1.getKey());\n    if (!(!(!preserveRelativeLinks))) \n        TransVarAttr1.setValue(TransVarAttrVal);\n    \n    for (Protocol TransVarProtocol1 : TransVarProtocol) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarProtocolVal = TransVarProtocol1.toString() + \":\";\n        if (!(!(TransVarAttrVal.toLowerCase().startsWith(TransVarProtocolVal)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return true;\n        }\n    }\n    return false;\n}\n",
    "start": 338,
    "end": 352,
    "location": [
      345
    ],
    "file_path": "src/main/java/org/jsoup/safety/Whitelist.java"
  },
  "Jsoup-2": {
    "buggy": "private void parseStartTag() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    tq.consume(\"<\");\n    String TransVarTag = tq.consumeWord();\n\n    if (!(!(TransVarTag.length() == 0))) { // doesn't look like a start tag after all; put < back on stack and handle as text\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        tq.addFirst(\"&lt;\");\n        parseTextNode();\n        return;\n    }\n\n    Attributes TransVarAttribute = new Attributes();\n    for (; !(!(!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Attribute TransVarAttributeName = parseAttribute();\n        if (!(!(TransVarAttributeName != null)))\n            TransVarAttribute.put(TransVarAttributeName);\n    }\n\n    Tag TransVarTagNameObject = Tag.valueOf(TransVarTag);\n    Element TransVarNewChild = new Element(TransVarTagNameObject, baseUri, TransVarAttribute);\n\n    boolean TransVarIsChildElement = TransVarTagNameObject.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n    if (!(!(tq.matchChomp(\"/>\")))) { // close empty element or tag\n        TransVarIsChildElement = true;\n    } else {\n        tq.matchChomp(\">\");\n    }\n    addChildToParent(TransVarNewChild, TransVarIsChildElement);\n\n    // pc data only tags (textarea, script): chomp to end tag, add content as text node\n    if (!(!(TransVarTagNameObject.isData()))) {\n        String TransVarString = tq.chompTo(\"</\" + TransVarTag);\n        tq.chompTo(\">\");\n         \n        Node TransVarNode;\n        if (!(!(TransVarTagNameObject.equals(titleTag) || TransVarTagNameObject.equals(textareaTag)))) // want to show as text, but not contain inside tags (so not a data tag?)\n            TransVarNode = TextNode.createFromEncoded(TransVarString, baseUri);\n        else\n            TransVarNode = new DataNode(TransVarString, baseUri); // data not encoded but raw (for \" in script)\n        TransVarNewChild.appendChild(TransVarNode);   \n    }\n\n    // <base href>: update the base uri\n    if (!(!(TransVarNewChild.tagName().equals(\"base\")))) {\n        String TransVarLink = TransVarNewChild.absUrl(\"href\");\n        if (!(!(TransVarLink.length() != 0))) { // ignore <base target> etc\n            baseUri = TransVarLink;\n            doc.setBaseUri(TransVarLink); // set on the doc so doc.createElement(Tag) will get updated base\n        }\n    }\n}\n",
    "start": 116,
    "end": 165,
    "location": [
      157
    ],
    "file_path": "src/main/java/org/jsoup/parser/Parser.java"
  },
  "Jsoup-20": {
    "buggy": "static Document parseByteData(ByteBuffer TransVarByteBuffer, String TransVarCharSetName, String TransVarBaseUriString, Parser TransVarParserForJson) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarDoc;\n    Document TransVarDocObject = null;\n    if (!(!(TransVarCharSetName == null))) { // determine from meta. safe parse as UTF-8\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        TransVarDoc = Charset.forName(defaultCharset).decode(TransVarByteBuffer).toString();\n        TransVarDocObject = TransVarParserForJson.parseInput(TransVarDoc, TransVarBaseUriString);\n        Element TransVarMetaElements = TransVarDocObject.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (!(!(TransVarMetaElements != null))) { // if not found, will keep utf-8 as best attempt\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarCharSet = TransVarMetaElements.hasAttr(\"http-equiv\") ? getCharsetFromContentType(TransVarMetaElements.attr(\"content\")) : TransVarMetaElements.attr(\"charset\");\n            if (!(!(TransVarCharSet != null && TransVarCharSet.length() != 0 && !TransVarCharSet.equals(defaultCharset)))) { // need to re-decode\n                TransVarCharSetName = TransVarCharSet;\n                TransVarByteBuffer.rewind();\n                TransVarDoc = Charset.forName(TransVarCharSet).decode(TransVarByteBuffer).toString();\n                TransVarDocObject = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(TransVarCharSetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        TransVarDoc = Charset.forName(TransVarCharSetName).decode(TransVarByteBuffer).toString();\n    }\n    if (!(!(TransVarDocObject == null))) {\n        // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n        // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n        // into head mode\n \n        TransVarDocObject = TransVarParserForJson.parseInput(TransVarDoc, TransVarBaseUriString);\n        TransVarDocObject.outputSettings().charset(TransVarCharSetName);\n    }\n    return TransVarDocObject;\n}\n",
    "start": 73,
    "end": 103,
    "location": [
      107
    ],
    "file_path": "src/main/java/org/jsoup/helper/DataUtil.java"
  },
  "Jsoup-24": {
    "buggy": "void read(Tokeniser TransVarTokeniser, CharacterReader TransVarC) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarC.matchesLetter()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarToken = TransVarC.consumeLetterSequence();\n        TransVarTokeniser.tagPending.appendTagName(TransVarToken.toLowerCase());\n        TransVarTokeniser.dataBuffer.append(TransVarToken);\n        TransVarC.advance(); \n        return;\n    }\n\n    if (!(!(TransVarTokeniser.isAppropriateEndTagToken() && !TransVarC.isEmpty()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        char TransVarCharChar = TransVarC.consume();\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharChar == '\\t'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharChar == '\\n'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharChar == '\\f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharChar == ' '))))) {\n                TransBreakFlag0 = false;\n                TransVarTokeniser.transition(BeforeAttributeName);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharChar == '/'))))) {\n                TransBreakFlag0 = false;\n                TransVarTokeniser.transition(SelfClosingStartTag);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharChar == '>'))))) {\n                TransBreakFlag0 = false;\n                TransVarTokeniser.emitTagPending();\n                TransVarTokeniser.transition(Data);\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                TransVarTokeniser.dataBuffer.append(TransVarCharChar);\n                anythingElse(TransVarTokeniser, TransVarC);\n            }\n        }\n    } else {\n        anythingElse(TransVarTokeniser, TransVarC);\n    }\n}\n",
    "start": 553,
    "end": 586,
    "location": [
      564
    ],
    "file_path": "src/main/java/org/jsoup/parser/TokeniserState.java"
  },
  "Jsoup-26": {
    "buggy": "public Document clean(Document TransVarDocument) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.notNull(TransVarDocument);\n\n    Document TransVarCleanDocument = Document.createShell(TransVarDocument.baseUri());\n        copySafeNodes(TransVarDocument.body(), TransVarCleanDocument.body()); \n\n    return TransVarCleanDocument;\n}\n",
    "start": 39,
    "end": 46,
    "location": [
      46
    ],
    "file_path": "src/main/java/org/jsoup/safety/Cleaner.java"
  },
  "Jsoup-27": {
    "buggy": "static String getCharsetFromContentType(String TransVarType) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarType == null))) return null;\n    Matcher TransVarMatch = charsetPattern.matcher(TransVarType);\n    if (!(!(TransVarMatch.find()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarMimeType = TransVarMatch.group(1).trim();\n        TransVarMimeType = TransVarMimeType.toUpperCase(Locale.ENGLISH); \n        return TransVarMimeType; \n    }\n    return null;\n}\n",
    "start": 127,
    "end": 136,
    "location": [
      138,
      139
    ],
    "file_path": "src/main/java/org/jsoup/helper/DataUtil.java"
  },
  "Jsoup-32": {
    "buggy": "public Element clone() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Element TransVarCloneElement = (Element) super.clone();\n    TransVarCloneElement.classNames(); \n    return TransVarCloneElement;\n}\n",
    "start": 1136,
    "end": 1140,
    "location": [
      1141
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Element.java"
  },
  "Jsoup-33": {
    "buggy": "Element insert(Token.StartTag TransVarStartTag2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // handle empty unknown tags\n    // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n    if (!(!(TransVarStartTag2.isSelfClosing()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Element TransVarEmptyElement = insertEmpty(TransVarStartTag2);\n        stack.add(TransVarEmptyElement);\n        tokeniser.emit(new Token.EndTag(TransVarEmptyElement.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing \n        return TransVarEmptyElement;\n    }\n    \n    Element TransVarNewElement = new Element(Tag.valueOf(TransVarStartTag2.name()), baseUri, TransVarStartTag2.attributes);\n    insert(TransVarNewElement);\n    return TransVarNewElement;\n}\n",
    "start": 156,
    "end": 169,
    "location": [
      168
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java"
  },
  "Jsoup-35": {
    "buggy": "boolean process(Token TransVarToken, HtmlTreeBuilder TransVarTbToken) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    switch (TransVarToken.type) {\n        case Character: {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Token.Character TransVarC1 = TransVarToken.asCharacter();\n            if (!(!(TransVarC1.getData().equals(nullString)))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                // todo confirm that check\n                TransVarTbToken.error(this);\n                return false;\n            } else if (!(!(isWhitespace(TransVarC1)))) {\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insert(TransVarC1);\n            } else {\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insert(TransVarC1);\n                TransVarTbToken.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            TransVarTbToken.insert(TransVarToken.asComment());\n            break;\n        }\n        case Doctype: {\n            TransVarTbToken.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag TransVarStartToken = TransVarToken.asStartTag();\n            String TransVarTagName = TransVarStartToken.name();\n            if (!(!(TransVarTagName.equals(\"html\")))) {\n                TransVarTbToken.error(this);\n                // merge attributes onto real html\n                Element TransVarHtmlElement = TransVarTbToken.getStack().getFirst();\n                for (Attribute TransVarAttrs : TransVarStartToken.getAttributes()) {\n                    if (!(!(!TransVarHtmlElement.hasAttr(TransVarAttrs.getKey()))))\n                        TransVarHtmlElement.attributes().put(TransVarAttrs);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\",\n                    \"script\", \"style\", \"title\")))) {\n                return TransVarTbToken.process(TransVarToken, InHead);\n            } else if (!(!(TransVarTagName.equals(\"body\")))) {\n                TransVarTbToken.error(this);\n                LinkedList<Element> TransVarStackOfTags = TransVarTbToken.getStack();\n                if (!(!(TransVarStackOfTags.size() == 1\n                        || (TransVarStackOfTags.size() > 2 && !TransVarStackOfTags.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    TransVarTbToken.framesetOk(false);\n                    Element TransVarHtmlBody = TransVarStackOfTags.get(1);\n                    for (Attribute TransVarAttr : TransVarStartToken.getAttributes()) {\n                        if (!(!(!TransVarHtmlBody.hasAttr(TransVarAttr.getKey()))))\n                            TransVarHtmlBody.attributes().put(TransVarAttr);\n                    }\n                }\n            } else if (!(!(TransVarTagName.equals(\"frameset\")))) {\n                TransVarTbToken.error(this);\n                LinkedList<Element> TransVarStackOfElements = TransVarTbToken.getStack();\n                if (!(!(TransVarStackOfElements.size() == 1 || (TransVarStackOfElements.size() > 2\n                        && !TransVarStackOfElements.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!(!(!TransVarTbToken.framesetOk()))) {\n                    return false; // ignore frameset\n                } else {\n                    Element TransVarThird = TransVarStackOfElements.get(1);\n                    if (!(!(TransVarThird.parent() != null)))\n                        TransVarThird.remove();\n                    for (; !(!(TransVarStackOfElements.size() > 1));)\n                        TransVarStackOfElements.removeLast();\n                    TransVarTbToken.insert(TransVarStartToken);\n                    TransVarTbToken.transition(InFrameset);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\",\n                    \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n                    \"p\", \"section\", \"summary\", \"ul\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                if (!(!(StringUtil.in(TransVarTbToken.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")))) {\n                    TransVarTbToken.error(this);\n                    TransVarTbToken.pop();\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"pre\", \"listing\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n                // todo: ignore LF if next token\n                TransVarTbToken.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"form\")))) {\n                if (!(!(TransVarTbToken.getFormElement() != null))) {\n                    TransVarTbToken.error(this);\n                    return false;\n                }\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insertForm(TransVarStartToken, true);\n            } else if (!(!(TransVarTagName.equals(\"li\")))) {\n                TransVarTbToken.framesetOk(false);\n                LinkedList<Element> TransVarStack1 = TransVarTbToken.getStack();\n                int TransVarIndex = TransVarStack1.size() - 1;\n                while (!(!(TransVarIndex > 0))) {\n                    Element TransVarElement = TransVarStack1.get(TransVarIndex);\n                    if (!(!(TransVarElement.nodeName().equals(\"li\")))) {\n                        TransVarTbToken.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (!(!(TransVarTbToken.isSpecial(TransVarElement)\n                            && !StringUtil.in(TransVarElement.nodeName(), \"address\", \"div\", \"p\"))))\n                        break;\n                    TransVarIndex--;\n                }\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"dd\", \"dt\")))) {\n                TransVarTbToken.framesetOk(false);\n                LinkedList<Element> TransVarTagStack = TransVarTbToken.getStack();\n                int TransVarJ = TransVarTagStack.size() - 1;\n                while (!(!(TransVarJ > 0))) {\n                    Element TransVarElem = TransVarTagStack.get(TransVarJ);\n                    if (!(!(StringUtil.in(TransVarElem.nodeName(), \"dd\", \"dt\")))) {\n                        TransVarTbToken.process(new Token.EndTag(TransVarElem.nodeName()));\n                        break;\n                    }\n                    if (!(!(TransVarTbToken.isSpecial(TransVarElem)\n                            && !StringUtil.in(TransVarElem.nodeName(), \"address\", \"div\", \"p\"))))\n                        break;\n                    TransVarJ--;\n                }\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n            } else if (!(!(TransVarTagName.equals(\"plaintext\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (!(!(TransVarTagName.equals(\"button\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"button\")))) {\n                    // close and reprocess\n                    TransVarTbToken.error(this);\n                    TransVarTbToken.process(new Token.EndTag(\"button\"));\n                    TransVarTbToken.process(TransVarStartToken);\n                } else {\n                    TransVarTbToken.reconstructFormattingElements();\n                    TransVarTbToken.insert(TransVarStartToken);\n                    TransVarTbToken.framesetOk(false);\n                }\n            } else if (!(!(TransVarTagName.equals(\"a\")))) {\n                if (!(!(TransVarTbToken.getActiveFormattingElement(\"a\") != null))) {\n                    TransVarTbToken.error(this);\n                    TransVarTbToken.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element TransVarRemainingElement = TransVarTbToken.getFromStack(\"a\");\n                    if (!(!(TransVarRemainingElement != null))) {\n                        TransVarTbToken.removeFromActiveFormattingElements(TransVarRemainingElement);\n                        TransVarTbToken.removeFromStack(TransVarRemainingElement);\n                    }\n                }\n                TransVarTbToken.reconstructFormattingElements();\n                Element TransVarTag = TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.pushActiveFormattingElements(TransVarTag);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\",\n                    \"tt\", \"u\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                Element TransVarNewElement = TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.pushActiveFormattingElements(TransVarNewElement);\n            } else if (!(!(TransVarTagName.equals(\"nobr\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                if (!(!(TransVarTbToken.inScope(\"nobr\")))) {\n                    TransVarTbToken.error(this);\n                    TransVarTbToken.process(new Token.EndTag(\"nobr\"));\n                    TransVarTbToken.reconstructFormattingElements();\n                }\n                Element TransVarNewElem = TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.pushActiveFormattingElements(TransVarNewElem);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"applet\", \"marquee\", \"object\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.insertMarkerToFormattingElements();\n                TransVarTbToken.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"table\")))) {\n                if (!(!(TransVarTbToken.getDocument().quirksMode() != Document.QuirksMode.quirks\n                        && TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.framesetOk(false);\n                TransVarTbToken.transition(InTable);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insertEmpty(TransVarStartToken);\n                TransVarTbToken.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"input\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                Element TransVarE = TransVarTbToken.insertEmpty(TransVarStartToken);\n                if (!(!(!TransVarE.attr(\"type\").equalsIgnoreCase(\"hidden\"))))\n                    TransVarTbToken.framesetOk(false);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"param\", \"source\", \"track\")))) {\n                TransVarTbToken.insertEmpty(TransVarStartToken);\n            } else if (!(!(TransVarTagName.equals(\"hr\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.insertEmpty(TransVarStartToken);\n                TransVarTbToken.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"image\")))) {\n                // we're not supposed to ask.\n                TransVarStartToken.name(\"img\");\n                return TransVarTbToken.process(TransVarStartToken);\n            } else if (!(!(TransVarTagName.equals(\"isindex\")))) {\n                // how much do we care about the early 90s?\n                TransVarTbToken.error(this);\n                if (!(!(TransVarTbToken.getFormElement() != null)))\n                    return false;\n\n                TransVarTbToken.tokeniser.acknowledgeSelfClosingFlag();\n                TransVarTbToken.process(new Token.StartTag(\"form\"));\n                if (!(!(TransVarStartToken.attributes.hasKey(\"action\")))) {\n                    Element TransVarFormTag = TransVarTbToken.getFormElement();\n                    TransVarFormTag.attr(\"action\", TransVarStartToken.attributes.get(\"action\"));\n                }\n                TransVarTbToken.process(new Token.StartTag(\"hr\"));\n                TransVarTbToken.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String TransVarSearchPrompt = TransVarStartToken.attributes.hasKey(\"prompt\") ?\n                        TransVarStartToken.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                TransVarTbToken.process(new Token.Character(TransVarSearchPrompt));\n\n                // input\n                Attributes TransVarInputAttribs2 = new Attributes();\n                for (Attribute TransVarAttrNew : TransVarStartToken.attributes) {\n                    if (!(!(!StringUtil.in(TransVarAttrNew.getKey(), \"name\", \"action\", \"prompt\"))))\n                        TransVarInputAttribs2.put(TransVarAttrNew);\n                }\n                TransVarInputAttribs2.put(\"name\", \"isindex\");\n                TransVarTbToken.process(new Token.StartTag(\"input\", TransVarInputAttribs2));\n                TransVarTbToken.process(new Token.EndTag(\"label\"));\n                TransVarTbToken.process(new Token.StartTag(\"hr\"));\n                TransVarTbToken.process(new Token.EndTag(\"form\"));\n            } else if (!(!(TransVarTagName.equals(\"textarea\")))) {\n                TransVarTbToken.insert(TransVarStartToken);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                TransVarTbToken.tokeniser.transition(TokeniserState.Rcdata);\n                TransVarTbToken.markInsertionMode();\n                TransVarTbToken.framesetOk(false);\n                TransVarTbToken.transition(Text);\n            } else if (!(!(TransVarTagName.equals(\"xmp\")))) {\n                if (!(!(TransVarTbToken.inButtonScope(\"p\")))) {\n                    TransVarTbToken.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.framesetOk(false);\n                handleRawtext(TransVarStartToken, TransVarTbToken);\n            } else if (!(!(TransVarTagName.equals(\"iframe\")))) {\n                TransVarTbToken.framesetOk(false);\n                handleRawtext(TransVarStartToken, TransVarTbToken);\n            } else if (!(!(TransVarTagName.equals(\"noembed\")))) {\n                // also handle noscript if script enabled\n                handleRawtext(TransVarStartToken, TransVarTbToken);\n            } else if (!(!(TransVarTagName.equals(\"select\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.framesetOk(false);\n\n                HtmlTreeBuilderState TransVarNewState = TransVarTbToken.state();\n                if (!(!(TransVarNewState.equals(InTable) || TransVarNewState.equals(InCaption)\n                        || TransVarNewState.equals(InTableBody) || TransVarNewState.equals(InRow)\n                        || TransVarNewState.equals(InCell))))\n                    TransVarTbToken.transition(InSelectInTable);\n                else\n                    TransVarTbToken.transition(InSelect);\n            } else if (!(!(StringUtil.in(\"optgroup\", \"option\")))) {\n                if (!(!(TransVarTbToken.currentElement().nodeName().equals(\"option\"))))\n                    TransVarTbToken.process(new Token.EndTag(\"option\"));\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insert(TransVarStartToken);\n            } else if (!(!(StringUtil.in(\"rp\", \"rt\")))) {\n                if (!(!(TransVarTbToken.inScope(\"ruby\")))) {\n                    TransVarTbToken.generateImpliedEndTags();\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(\"ruby\")))) {\n                        TransVarTbToken.error(this);\n                        TransVarTbToken.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    TransVarTbToken.insert(TransVarStartToken);\n                }\n            } else if (!(!(TransVarTagName.equals(\"math\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (!(!(TransVarTagName.equals(\"svg\")))) {\n                TransVarTbToken.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                TransVarTbToken.insert(TransVarStartToken);\n                TransVarTbToken.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (!(!(StringUtil.in(TransVarTagName, \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\",\n                    \"th\", \"thead\", \"tr\")))) {\n                TransVarTbToken.error(this);\n                return false;\n            } else {\n                TransVarTbToken.reconstructFormattingElements();\n                TransVarTbToken.insert(TransVarStartToken);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag TransVarEndTag1 = TransVarToken.asEndTag();\n            TransVarTagName = TransVarEndTag1.name();\n            if (!(!(TransVarTagName.equals(\"body\")))) {\n                if (!(!(!TransVarTbToken.inScope(\"body\")))) {\n                    TransVarTbToken.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    TransVarTbToken.transition(AfterBody);\n                }\n            } else if (!(!(TransVarTagName.equals(\"html\")))) {\n                boolean TransVarIsIgnored = TransVarTbToken.process(new Token.EndTag(\"body\"));\n                if (!(!(TransVarIsIgnored)))\n                    return TransVarTbToken.process(TransVarEndTag1);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\",\n                    \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\",\n                    \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")))) {\n                // todo: refactor these lookups\n                if (!(!(!TransVarTbToken.inScope(TransVarTagName)))) {\n                    // nothing to close\n                    TransVarTbToken.error(this);\n                    return false;\n                } else {\n                    TransVarTbToken.generateImpliedEndTags();\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    TransVarTbToken.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(TransVarTagName.equals(\"form\")))) {\n                Element TransVarForm = TransVarTbToken.getFormElement();\n                TransVarTbToken.setFormElement(null);\n                if (!(!(TransVarForm == null || !TransVarTbToken.inScope(TransVarTagName)))) {\n                    TransVarTbToken.error(this);\n                    return false;\n                } else {\n                    TransVarTbToken.generateImpliedEndTags();\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    TransVarTbToken.removeFromStack(TransVarForm);\n                }\n            } else if (!(!(TransVarTagName.equals(\"p\")))) {\n                if (!(!(!TransVarTbToken.inButtonScope(TransVarTagName)))) {\n                    TransVarTbToken.error(this);\n                    TransVarTbToken.process(new Token.StartTag(TransVarTagName)); // if no p to close, creates an empty <p></p>\n                    return TransVarTbToken.process(TransVarEndTag1);\n                } else {\n                    TransVarTbToken.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    TransVarTbToken.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(TransVarTagName.equals(\"li\")))) {\n                if (!(!(!TransVarTbToken.inListItemScope(TransVarTagName)))) {\n                    TransVarTbToken.error(this);\n                    return false;\n                } else {\n                    TransVarTbToken.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    TransVarTbToken.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"dd\", \"dt\")))) {\n                if (!(!(!TransVarTbToken.inScope(TransVarTagName)))) {\n                    TransVarTbToken.error(this);\n                    return false;\n                } else {\n                    TransVarTbToken.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    TransVarTbToken.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")))) {\n                if (!(!(!TransVarTbToken.inScope(new String[] { \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\" })))) {\n                    TransVarTbToken.error(this);\n                    return false;\n                } else {\n                    TransVarTbToken.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    TransVarTbToken.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n                }\n            } else if (!(!(TransVarTagName.equals(\"sarcasm\")))) {\n                // *sigh*\n                return anyOtherEndTag(TransVarToken, TransVarTbToken);\n            } else if (!(!(StringUtil.in(TransVarTagName, \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\",\n                    \"strike\", \"strong\", \"tt\", \"u\")))) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int TransVarLoopIndex = 0; !(!(TransVarLoopIndex < 8)); TransVarLoopIndex++) {\n                    Element TransVarFormatElement = TransVarTbToken.getActiveFormattingElement(TransVarTagName);\n                    if (!(!(TransVarFormatElement == null)))\n                        return anyOtherEndTag(TransVarToken, TransVarTbToken);\n                    else if (!(!(!TransVarTbToken.onStack(TransVarFormatElement)))) {\n                        TransVarTbToken.error(this);\n                        TransVarTbToken.removeFromActiveFormattingElements(TransVarFormatElement);\n                        return true;\n                    } else if (!(!(!TransVarTbToken.inScope(TransVarFormatElement.nodeName())))) {\n                        TransVarTbToken.error(this);\n                        return false;\n                    } else if (!(!(TransVarTbToken.currentElement() != TransVarFormatElement)))\n                        TransVarTbToken.error(this);\n\n                    Element TransVarFurthest = null;\n                    Element TransVarFurthestAncestor = null;\n                    boolean TransVarIsFormatting = false;\n                    LinkedList<Element> TransVarStackList = TransVarTbToken.getStack();\n                    int TransVarFirstIndex = 0;\n                    while (!(!(TransVarFirstIndex < TransVarStackList.size() && TransVarFirstIndex < 64))) {\n                        Element TransVarNewEl = TransVarStackList.get(TransVarFirstIndex);\n                        if (!(!(TransVarNewEl == TransVarFormatElement))) {\n                            TransVarFurthestAncestor = TransVarStackList.get(TransVarFirstIndex - 1);\n                            TransVarIsFormatting = true;\n                        } else if (!(!(TransVarIsFormatting && TransVarTbToken.isSpecial(TransVarNewEl)))) {\n                            TransVarFurthest = TransVarNewEl;\n                            break;\n                        }\n                        TransVarFirstIndex++;\n                    }\n                    if (!(!(TransVarFurthest == null))) {\n                        TransVarTbToken.popStackToClose(TransVarFormatElement.nodeName());\n                        TransVarTbToken.removeFromActiveFormattingElements(TransVarFormatElement);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element TransVarParent = TransVarFurthest;\n                    Element TransVarLastNodeBlock = TransVarFurthest;\n                    INNER:\n                    for (int TransVarI = 0; !(!(TransVarI < 3)); TransVarI++) {\n                        if (!(!(TransVarTbToken.onStack(TransVarParent))))\n                            TransVarParent = TransVarTbToken.aboveOnStack(TransVarParent);\n                        if (!(!(!TransVarTbToken.isInActiveFormattingElements(TransVarParent)))) { // note no bookmark check\n                            TransVarTbToken.removeFromStack(TransVarParent);\n                            continue INNER;\n                        } else if (!(!(TransVarParent == TransVarFormatElement)))\n                            break INNER;\n\n                        Element TransVarReplacementElement = new Element(Tag.valueOf(TransVarParent.nodeName()), TransVarTbToken.getBaseUri());\n                        TransVarTbToken.replaceActiveFormattingElement(TransVarParent, TransVarReplacementElement);\n                        TransVarTbToken.replaceOnStack(TransVarParent, TransVarReplacementElement);\n                        TransVarParent = TransVarReplacementElement;\n\n                        if (!(!(TransVarLastNodeBlock == TransVarFurthest))) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (!(!(TransVarLastNodeBlock.parent() != null)))\n                            TransVarLastNodeBlock.remove();\n                        TransVarParent.appendChild(TransVarLastNodeBlock);\n\n                        TransVarLastNodeBlock = TransVarParent;\n                    }\n\n                    if (!(!(StringUtil.in(TransVarFurthestAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")))) {\n                        if (!(!(TransVarLastNodeBlock.parent() != null)))\n                            TransVarLastNodeBlock.remove();\n                        TransVarTbToken.insertInFosterParent(TransVarLastNodeBlock);\n                    } else {\n                        if (!(!(TransVarLastNodeBlock.parent() != null)))\n                            TransVarLastNodeBlock.remove();\n                        TransVarFurthestAncestor.appendChild(TransVarLastNodeBlock);\n                    }\n\n                    Element TransVarAdoptee = new Element(TransVarFormatElement.tag(), TransVarTbToken.getBaseUri());\n                    Node[] TransVarNewNodes = TransVarFurthest.childNodes().toArray(new Node[TransVarFurthest.childNodeSize()]); \n                    for (Node TransVarNode : TransVarNewNodes) {\n                        TransVarAdoptee.appendChild(TransVarNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    TransVarFurthest.appendChild(TransVarAdoptee);\n                    TransVarTbToken.removeFromActiveFormattingElements(TransVarFormatElement);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    TransVarTbToken.removeFromStack(TransVarFormatElement);\n                    TransVarTbToken.insertOnStackAfter(TransVarFurthest, TransVarAdoptee);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, \"applet\", \"marquee\", \"object\")))) {\n                if (!(!(!TransVarTbToken.inScope(\"name\")))) {\n                    if (!(!(!TransVarTbToken.inScope(TransVarTagName)))) {\n                        TransVarTbToken.error(this);\n                        return false;\n                    }\n                    TransVarTbToken.generateImpliedEndTags();\n                    if (!(!(!TransVarTbToken.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTbToken.error(this);\n                    TransVarTbToken.popStackToClose(TransVarTagName);\n                    TransVarTbToken.clearFormattingElementsToLastMarker();\n                }\n            } else if (!(!(TransVarTagName.equals(\"br\")))) {\n                TransVarTbToken.error(this);\n                TransVarTbToken.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(TransVarToken, TransVarTbToken);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n",
    "start": 247,
    "end": 763,
    "location": [
      744
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"
  },
  "Jsoup-37": {
    "buggy": "public String html() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    StringBuilder TransVarAccumulator = new StringBuilder();\n    html(TransVarAccumulator);\n    return TransVarAccumulator.toString().trim(); \n}\n",
    "start": 1098,
    "end": 1102,
    "location": [
      1104
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Element.java"
  },
  "Jsoup-38": {
    "buggy": "boolean process(Token TransVarToken, HtmlTreeBuilder TransVarTreebuilder) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    switch (TransVarToken.type) {\n        case Character: {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Token.Character TransVarCurrentChar = TransVarToken.asCharacter();\n            if (!(!(TransVarCurrentChar.getData().equals(nullString)))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                // todo confirm that check\n                TransVarTreebuilder.error(this);\n                return false;\n            } else if (!(!(isWhitespace(TransVarCurrentChar)))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insert(TransVarCurrentChar);\n            } else {\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insert(TransVarCurrentChar);\n                TransVarTreebuilder.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            TransVarTreebuilder.insert(TransVarToken.asComment());\n            break;\n        }\n        case Doctype: {\n            TransVarTreebuilder.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag TransVarStartTag1 = TransVarToken.asStartTag();\n            String TransVarTagName = TransVarStartTag1.name();\n            if (!(!(TransVarTagName.equals(\"html\")))) {\n                TransVarTreebuilder.error(this);\n                // merge attributes onto real html\n                Element TransVarNode = TransVarTreebuilder.getStack().getFirst();\n                for (Attribute TransVarAttributeName : TransVarStartTag1.getAttributes()) {\n                    if (!(!(!TransVarNode.hasAttr(TransVarAttributeName.getKey()))))\n                        TransVarNode.attributes().put(TransVarAttributeName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartToHead)))) {\n                return TransVarTreebuilder.process(TransVarToken, InHead);\n            } else if (!(!(TransVarTagName.equals(\"body\")))) {\n                TransVarTreebuilder.error(this);\n                LinkedList<Element> TransVarElementStack = TransVarTreebuilder.getStack();\n                if (!(!(TransVarElementStack.size() == 1\n                        || (TransVarElementStack.size() > 2 && !TransVarElementStack.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    TransVarTreebuilder.framesetOk(false);\n                    Element TransVarBodyTag = TransVarElementStack.get(1);\n                    for (Attribute TransVarAttributeNode : TransVarStartTag1.getAttributes()) {\n                        if (!(!(!TransVarBodyTag.hasAttr(TransVarAttributeNode.getKey()))))\n                            TransVarBodyTag.attributes().put(TransVarAttributeNode);\n                    }\n                }\n            } else if (!(!(TransVarTagName.equals(\"frameset\")))) {\n                TransVarTreebuilder.error(this);\n                LinkedList<Element> TransVarStackList = TransVarTreebuilder.getStack();\n                if (!(!(TransVarStackList.size() == 1\n                        || (TransVarStackList.size() > 2 && !TransVarStackList.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!(!(!TransVarTreebuilder.framesetOk()))) {\n                    return false; // ignore frameset\n                } else {\n                    Element TransVarSecondElement = TransVarStackList.get(1);\n                    if (!(!(TransVarSecondElement.parent() != null)))\n                        TransVarSecondElement.remove();\n                    for (; !(!(TransVarStackList.size() > 1));)\n                        TransVarStackList.removeLast();\n                    TransVarTreebuilder.insert(TransVarStartTag1);\n                    TransVarTreebuilder.transition(InFrameset);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartPClosers)))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.Headings)))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                if (!(!(StringUtil.in(TransVarTreebuilder.currentElement().nodeName(), Constants.Headings)))) {\n                    TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.pop();\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartPreListing)))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                // todo: ignore LF if next token\n                TransVarTreebuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"form\")))) {\n                if (!(!(TransVarTreebuilder.getFormElement() != null))) {\n                    TransVarTreebuilder.error(this);\n                    return false;\n                }\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insertForm(TransVarStartTag1, true);\n            } else if (!(!(TransVarTagName.equals(\"li\")))) {\n                TransVarTreebuilder.framesetOk(false);\n                LinkedList<Element> TransVarElementList = TransVarTreebuilder.getStack();\n                int TransVarIndex = TransVarElementList.size() - 1;\n                while (!(!(TransVarIndex > 0))) {\n                    Element TransVarCurrentElement = TransVarElementList.get(TransVarIndex);\n                    if (!(!(TransVarCurrentElement.nodeName().equals(\"li\")))) {\n                        TransVarTreebuilder.process(new Token.EndTag(\"li\"));\n                        break;\n                    }\n                    if (!(!(TransVarTreebuilder.isSpecial(TransVarCurrentElement)\n                            && !StringUtil.in(TransVarCurrentElement.nodeName(), Constants.InBodyStartLiBreakers))))\n                        break;\n                    TransVarIndex--;\n                }\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.DdDt)))) {\n                TransVarTreebuilder.framesetOk(false);\n                LinkedList<Element> TransVarList = TransVarTreebuilder.getStack();\n                int TransVarStackSize = TransVarList.size() - 1;\n                while (!(!(TransVarStackSize > 0))) {\n                    Element TransVarElement = TransVarList.get(TransVarStackSize);\n                    if (!(!(StringUtil.in(TransVarElement.nodeName(), Constants.DdDt)))) {\n                        TransVarTreebuilder.process(new Token.EndTag(TransVarElement.nodeName()));\n                        break;\n                    }\n                    if (!(!(TransVarTreebuilder.isSpecial(TransVarElement)\n                            && !StringUtil.in(TransVarElement.nodeName(), Constants.InBodyStartLiBreakers))))\n                        break;\n                    TransVarStackSize--;\n                }\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n            } else if (!(!(TransVarTagName.equals(\"plaintext\")))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (!(!(TransVarTagName.equals(\"button\")))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"button\")))) {\n                    // close and reprocess\n                    TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.process(new Token.EndTag(\"button\"));\n                    TransVarTreebuilder.process(TransVarStartTag1);\n                } else {\n                    TransVarTreebuilder.reconstructFormattingElements();\n                    TransVarTreebuilder.insert(TransVarStartTag1);\n                    TransVarTreebuilder.framesetOk(false);\n                }\n            } else if (!(!(TransVarTagName.equals(\"a\")))) {\n                if (!(!(TransVarTreebuilder.getActiveFormattingElement(\"a\") != null))) {\n                    TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.process(new Token.EndTag(\"a\"));\n\n                    // still on stack?\n                    Element TransVarRemainingTag = TransVarTreebuilder.getFromStack(\"a\");\n                    if (!(!(TransVarRemainingTag != null))) {\n                        TransVarTreebuilder.removeFromActiveFormattingElements(TransVarRemainingTag);\n                        TransVarTreebuilder.removeFromStack(TransVarRemainingTag);\n                    }\n                }\n                TransVarTreebuilder.reconstructFormattingElements();\n                Element TransVarStartElement = TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.pushActiveFormattingElements(TransVarStartElement);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.Formatters)))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                Element TransVarNewElement = TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.pushActiveFormattingElements(TransVarNewElement);\n            } else if (!(!(TransVarTagName.equals(\"nobr\")))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                if (!(!(TransVarTreebuilder.inScope(\"nobr\")))) {\n                    TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.process(new Token.EndTag(\"nobr\"));\n                    TransVarTreebuilder.reconstructFormattingElements();\n                }\n                Element TransVarE = TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.pushActiveFormattingElements(TransVarE);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartApplets)))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.insertMarkerToFormattingElements();\n                TransVarTreebuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"table\")))) {\n                if (!(!(TransVarTreebuilder.getDocument().quirksMode() != Document.QuirksMode.quirks\n                        && TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.framesetOk(false);\n                TransVarTreebuilder.transition(InTable);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartEmptyFormatters)))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insertEmpty(TransVarStartTag1);\n                TransVarTreebuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"input\")))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                Element TransVarNewEle = TransVarTreebuilder.insertEmpty(TransVarStartTag1);\n                if (!(!(!TransVarNewEle.attr(\"type\").equalsIgnoreCase(\"hidden\"))))\n                    TransVarTreebuilder.framesetOk(false);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartMedia)))) {\n                TransVarTreebuilder.insertEmpty(TransVarStartTag1);\n            } else if (!(!(TransVarTagName.equals(\"hr\")))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.insertEmpty(TransVarStartTag1);\n                TransVarTreebuilder.framesetOk(false);\n            } else if (!(!(TransVarTagName.equals(\"image\")))) {\n                    return TransVarTreebuilder.process(TransVarStartTag1.name(\"img\")); // change <image> to <img>, unless in svg \n            } else if (!(!(TransVarTagName.equals(\"isindex\")))) { \n                // how much do we care about the early 90s?\n                TransVarTreebuilder.error(this);\n                if (!(!(TransVarTreebuilder.getFormElement() != null)))\n                    return false;\n\n                TransVarTreebuilder.tokeniser.acknowledgeSelfClosingFlag();\n                TransVarTreebuilder.process(new Token.StartTag(\"form\"));\n                if (!(!(TransVarStartTag1.attributes.hasKey(\"action\")))) {\n                    Element TransVarFormElement = TransVarTreebuilder.getFormElement();\n                    TransVarFormElement.attr(\"action\", TransVarStartTag1.attributes.get(\"action\"));\n                }\n                TransVarTreebuilder.process(new Token.StartTag(\"hr\"));\n                TransVarTreebuilder.process(new Token.StartTag(\"label\"));\n                // hope you like english.\n                String TransVarPromptElement = TransVarStartTag1.attributes.hasKey(\"prompt\") ?\n                        TransVarStartTag1.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                TransVarTreebuilder.process(new Token.Character(TransVarPromptElement));\n\n                // input\n                Attributes TransVarAttribs = new Attributes();\n                for (Attribute TransVarAttribute : TransVarStartTag1.attributes) {\n                    if (!(!(!StringUtil.in(TransVarAttribute.getKey(), Constants.InBodyStartInputAttribs))))\n                        TransVarAttribs.put(TransVarAttribute);\n                }\n                TransVarAttribs.put(\"name\", \"isindex\");\n                TransVarTreebuilder.process(new Token.StartTag(\"input\", TransVarAttribs));\n                TransVarTreebuilder.process(new Token.EndTag(\"label\"));\n                TransVarTreebuilder.process(new Token.StartTag(\"hr\"));\n                TransVarTreebuilder.process(new Token.EndTag(\"form\"));\n            } else if (!(!(TransVarTagName.equals(\"textarea\")))) {\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                TransVarTreebuilder.tokeniser.transition(TokeniserState.Rcdata);\n                TransVarTreebuilder.markInsertionMode();\n                TransVarTreebuilder.framesetOk(false);\n                TransVarTreebuilder.transition(Text);\n            } else if (!(!(TransVarTagName.equals(\"xmp\")))) {\n                if (!(!(TransVarTreebuilder.inButtonScope(\"p\")))) {\n                    TransVarTreebuilder.process(new Token.EndTag(\"p\"));\n                }\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.framesetOk(false);\n                handleRawtext(TransVarStartTag1, TransVarTreebuilder);\n            } else if (!(!(TransVarTagName.equals(\"iframe\")))) {\n                TransVarTreebuilder.framesetOk(false);\n                handleRawtext(TransVarStartTag1, TransVarTreebuilder);\n            } else if (!(!(TransVarTagName.equals(\"noembed\")))) {\n                // also handle noscript if script enabled\n                handleRawtext(TransVarStartTag1, TransVarTreebuilder);\n            } else if (!(!(TransVarTagName.equals(\"select\")))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.framesetOk(false);\n\n                HtmlTreeBuilderState TransVarTreeBuilderState = TransVarTreebuilder.state();\n                if (!(!(TransVarTreeBuilderState.equals(InTable) || TransVarTreeBuilderState.equals(InCaption)\n                        || TransVarTreeBuilderState.equals(InTableBody) || TransVarTreeBuilderState.equals(InRow)\n                        || TransVarTreeBuilderState.equals(InCell))))\n                    TransVarTreebuilder.transition(InSelectInTable);\n                else\n                    TransVarTreebuilder.transition(InSelect);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartOptions)))) {\n                if (!(!(TransVarTreebuilder.currentElement().nodeName().equals(\"option\"))))\n                    TransVarTreebuilder.process(new Token.EndTag(\"option\"));\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insert(TransVarStartTag1);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartRuby)))) {\n                if (!(!(TransVarTreebuilder.inScope(\"ruby\")))) {\n                    TransVarTreebuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(\"ruby\")))) {\n                        TransVarTreebuilder.error(this);\n                        TransVarTreebuilder.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    TransVarTreebuilder.insert(TransVarStartTag1);\n                }\n            } else if (!(!(TransVarTagName.equals(\"math\")))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (!(!(TransVarTagName.equals(\"svg\")))) {\n                TransVarTreebuilder.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                TransVarTreebuilder.insert(TransVarStartTag1);\n                TransVarTreebuilder.tokeniser.acknowledgeSelfClosingFlag();\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartDrop)))) {\n                TransVarTreebuilder.error(this);\n                return false;\n            } else {\n                TransVarTreebuilder.reconstructFormattingElements();\n                TransVarTreebuilder.insert(TransVarStartTag1);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag TransVarEndTag2 = TransVarToken.asEndTag();\n            TransVarTagName = TransVarEndTag2.name();\n            if (!(!(TransVarTagName.equals(\"body\")))) {\n                if (!(!(!TransVarTreebuilder.inScope(\"body\")))) {\n                    TransVarTreebuilder.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    TransVarTreebuilder.transition(AfterBody);\n                }\n            } else if (!(!(TransVarTagName.equals(\"html\")))) {\n                boolean TransVarBodyIgnored = TransVarTreebuilder.process(new Token.EndTag(\"body\"));\n                if (!(!(TransVarBodyIgnored)))\n                    return TransVarTreebuilder.process(TransVarEndTag2);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyEndClosers)))) {\n                if (!(!(!TransVarTreebuilder.inScope(TransVarTagName)))) {\n                    // nothing to close\n                    TransVarTreebuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreebuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(TransVarTagName.equals(\"form\")))) {\n                Element TransVarForm = TransVarTreebuilder.getFormElement();\n                TransVarTreebuilder.setFormElement(null);\n                if (!(!(TransVarForm == null || !TransVarTreebuilder.inScope(TransVarTagName)))) {\n                    TransVarTreebuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreebuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    TransVarTreebuilder.removeFromStack(TransVarForm);\n                }\n            } else if (!(!(TransVarTagName.equals(\"p\")))) {\n                if (!(!(!TransVarTreebuilder.inButtonScope(TransVarTagName)))) {\n                    TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.process(new Token.StartTag(TransVarTagName)); // if no p to close, creates an empty <p></p>\n                    return TransVarTreebuilder.process(TransVarEndTag2);\n                } else {\n                    TransVarTreebuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(TransVarTagName.equals(\"li\")))) {\n                if (!(!(!TransVarTreebuilder.inListItemScope(TransVarTagName)))) {\n                    TransVarTreebuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreebuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.DdDt)))) {\n                if (!(!(!TransVarTreebuilder.inScope(TransVarTagName)))) {\n                    TransVarTreebuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreebuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.popStackToClose(TransVarTagName);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.Headings)))) {\n                if (!(!(!TransVarTreebuilder.inScope(Constants.Headings)))) {\n                    TransVarTreebuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreebuilder.generateImpliedEndTags(TransVarTagName);\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.popStackToClose(Constants.Headings);\n                }\n            } else if (!(!(TransVarTagName.equals(\"sarcasm\")))) {\n                // *sigh*\n                return anyOtherEndTag(TransVarToken, TransVarTreebuilder);\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyEndAdoptionFormatters)))) {\n                // Adoption Agency Algorithm.\n                OUTER:\n                for (int TransVarJ = 0; !(!(TransVarJ < 8)); TransVarJ++) {\n                    Element TransVarFormatel = TransVarTreebuilder.getActiveFormattingElement(TransVarTagName);\n                    if (!(!(TransVarFormatel == null)))\n                        return anyOtherEndTag(TransVarToken, TransVarTreebuilder);\n                    else if (!(!(!TransVarTreebuilder.onStack(TransVarFormatel)))) {\n                        TransVarTreebuilder.error(this);\n                        TransVarTreebuilder.removeFromActiveFormattingElements(TransVarFormatel);\n                        return true;\n                    } else if (!(!(!TransVarTreebuilder.inScope(TransVarFormatel.nodeName())))) {\n                        TransVarTreebuilder.error(this);\n                        return false;\n                    } else if (!(!(TransVarTreebuilder.currentElement() != TransVarFormatel)))\n                        TransVarTreebuilder.error(this);\n\n                    Element TransVarMostNested = null;\n                    Element TransVarCommonAncenstor = null;\n                    boolean TransVarIsFormattingElement = false;\n                    LinkedList<Element> TransVarNewStack = TransVarTreebuilder.getStack();\n                    // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                    // run-aways\n                    final int TransVarStacksize = TransVarNewStack.size();\n                    int TransVarStart = 0;\n                    while (!(!(TransVarStart < TransVarStacksize && TransVarStart < 64))) {\n                        Element TransVarCurrentEl = TransVarNewStack.get(TransVarStart);\n                        if (!(!(TransVarCurrentEl == TransVarFormatel))) {\n                            TransVarCommonAncenstor = TransVarNewStack.get(TransVarStart - 1);\n                            TransVarIsFormattingElement = true;\n                        } else if (!(!(TransVarIsFormattingElement && TransVarTreebuilder.isSpecial(TransVarCurrentEl)))) {\n                            TransVarMostNested = TransVarCurrentEl;\n                            break;\n                        }\n                        TransVarStart++;\n                    }\n                    if (!(!(TransVarMostNested == null))) {\n                        TransVarTreebuilder.popStackToClose(TransVarFormatel.nodeName());\n                        TransVarTreebuilder.removeFromActiveFormattingElements(TransVarFormatel);\n                        return true;\n                    }\n\n                    // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n                    // does that mean: int pos of format el in list?\n                    Element TransVarNode3 = TransVarMostNested;\n                    Element TransVarEndNode = TransVarMostNested;\n                    INNER:\n                    for (int TransVarI = 0; !(!(TransVarI < 3)); TransVarI++) {\n                        if (!(!(TransVarTreebuilder.onStack(TransVarNode3))))\n                            TransVarNode3 = TransVarTreebuilder.aboveOnStack(TransVarNode3);\n                        if (!(!(!TransVarTreebuilder.isInActiveFormattingElements(TransVarNode3)))) { // note no bookmark check\n                            TransVarTreebuilder.removeFromStack(TransVarNode3);\n                            continue INNER;\n                        } else if (!(!(TransVarNode3 == TransVarFormatel)))\n                            break INNER;\n\n                        Element TransVarReplacementElement = new Element(Tag.valueOf(TransVarNode3.nodeName()), TransVarTreebuilder.getBaseUri());\n                        TransVarTreebuilder.replaceActiveFormattingElement(TransVarNode3, TransVarReplacementElement);\n                        TransVarTreebuilder.replaceOnStack(TransVarNode3, TransVarReplacementElement);\n                        TransVarNode3 = TransVarReplacementElement;\n\n                        if (!(!(TransVarEndNode == TransVarMostNested))) {\n                            // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n                            // not getting how this bookmark both straddles the element above, but is inbetween here...\n                        }\n                        if (!(!(TransVarEndNode.parent() != null)))\n                            TransVarEndNode.remove();\n                        TransVarNode3.appendChild(TransVarEndNode);\n\n                        TransVarEndNode = TransVarNode3;\n                    }\n\n                    if (!(!(StringUtil.in(TransVarCommonAncenstor.nodeName(), Constants.InBodyEndTableFosters)))) {\n                        if (!(!(TransVarEndNode.parent() != null)))\n                            TransVarEndNode.remove();\n                        TransVarTreebuilder.insertInFosterParent(TransVarEndNode);\n                    } else {\n                        if (!(!(TransVarEndNode.parent() != null)))\n                            TransVarEndNode.remove();\n                        TransVarCommonAncenstor.appendChild(TransVarEndNode);\n                    }\n\n                    Element TransVarAdoptee = new Element(TransVarFormatel.tag(), TransVarTreebuilder.getBaseUri());\n                    TransVarAdoptee.attributes().addAll(TransVarFormatel.attributes());\n                    Node[] TransVarFurthestBlockChildNodes = TransVarMostNested.childNodes().toArray(new Node[TransVarMostNested.childNodeSize()]);\n                    for (Node TransVarChildNodeNode : TransVarFurthestBlockChildNodes) {\n                        TransVarAdoptee.appendChild(TransVarChildNodeNode); // append will reparent. thus the clone to avoid concurrent mod.\n                    }\n                    TransVarMostNested.appendChild(TransVarAdoptee);\n                    TransVarTreebuilder.removeFromActiveFormattingElements(TransVarFormatel);\n                    // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                    TransVarTreebuilder.removeFromStack(TransVarFormatel);\n                    TransVarTreebuilder.insertOnStackAfter(TransVarMostNested, TransVarAdoptee);\n                }\n            } else if (!(!(StringUtil.in(TransVarTagName, Constants.InBodyStartApplets)))) {\n                if (!(!(!TransVarTreebuilder.inScope(\"name\")))) {\n                    if (!(!(!TransVarTreebuilder.inScope(TransVarTagName)))) {\n                        TransVarTreebuilder.error(this);\n                        return false;\n                    }\n                    TransVarTreebuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreebuilder.currentElement().nodeName().equals(TransVarTagName))))\n                        TransVarTreebuilder.error(this);\n                    TransVarTreebuilder.popStackToClose(TransVarTagName);\n                    TransVarTreebuilder.clearFormattingElementsToLastMarker();\n                }\n            } else if (!(!(TransVarTagName.equals(\"br\")))) {\n                TransVarTreebuilder.error(this);\n                TransVarTreebuilder.process(new Token.StartTag(\"br\"));\n                return false;\n            } else {\n                return anyOtherEndTag(TransVarToken, TransVarTreebuilder);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n",
    "start": 247,
    "end": 753,
    "location": [
      472,
      473
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"
  },
  "Jsoup-39": {
    "buggy": "static Document parseByteData(ByteBuffer TransVarByteBuffer, String TransVarCharset, String TransVarBasePath, Parser TransVarParser1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarLocalDocData;\n    Document TransVarDocument = null;\n    if (!(!(TransVarCharset == null))) { // determine from meta. safe parse as UTF-8\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        TransVarLocalDocData = Charset.forName(defaultCharset).decode(TransVarByteBuffer).toString();\n        TransVarDocument = TransVarParser1.parseInput(TransVarLocalDocData, TransVarBasePath);\n        Element TransVarPageInfo = TransVarDocument.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (!(!(TransVarPageInfo != null))) { // if not found, will keep utf-8 as best attempt\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarFoundCharset1;\n            if (!(!(TransVarPageInfo.hasAttr(\"http-equiv\")))) {\n                TransVarFoundCharset1 = getCharsetFromContentType(TransVarPageInfo.attr(\"content\"));\n                if (!(!(TransVarFoundCharset1 == null && TransVarPageInfo.hasAttr(\"charset\")))) {\n                    try {\n                        if (!(!(Charset.isSupported(TransVarPageInfo.attr(\"charset\"))))) {\n                            TransVarFoundCharset1 = TransVarPageInfo.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException TransVarEx) {\n                        TransVarFoundCharset1 = null;\n                    }\n                }\n            } else {\n                TransVarFoundCharset1 = TransVarPageInfo.attr(\"charset\");\n            }\n\n            if (!(!(TransVarFoundCharset1 != null && TransVarFoundCharset1.length() != 0\n                    && !TransVarFoundCharset1.equals(defaultCharset)))) { // need to re-decode\n                TransVarFoundCharset1 = TransVarFoundCharset1.trim().replaceAll(\"[\\\"']\", \"\");\n                TransVarCharset = TransVarFoundCharset1;\n                TransVarByteBuffer.rewind();\n                TransVarLocalDocData = Charset.forName(TransVarFoundCharset1).decode(TransVarByteBuffer).toString();\n                TransVarDocument = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(TransVarCharset, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        TransVarLocalDocData = Charset.forName(TransVarCharset).decode(TransVarByteBuffer).toString();\n    }\n    // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n    if (!(!(TransVarLocalDocData.length() > 0 && TransVarLocalDocData.charAt(0) == 65279))) {\n        TransVarByteBuffer.rewind();\n        TransVarLocalDocData = Charset.forName(defaultCharset).decode(TransVarByteBuffer).toString();\n        TransVarLocalDocData = TransVarLocalDocData.substring(1);\n        TransVarCharset = defaultCharset;\n    } \n    if (!(!(TransVarDocument == null))) {\n        TransVarDocument = TransVarParser1.parseInput(TransVarLocalDocData, TransVarBasePath);\n        TransVarDocument.outputSettings().charset(TransVarCharset);\n    }\n    return TransVarDocument;\n}\n",
    "start": 76,
    "end": 125,
    "location": [
      129
    ],
    "file_path": "src/main/java/org/jsoup/helper/DataUtil.java"
  },
  "Jsoup-40": {
    "buggy": "public DocumentType(String TransVarPerson, String TransVarPersonId, String TransVarPersonNumber, String TransVarUri) {\n    super(TransVarUri);\n\n    Validate.notEmpty(TransVarPerson); \n    attr(\"name\", TransVarPerson);\n    attr(\"publicId\", TransVarPersonId);\n    attr(\"systemId\", TransVarPersonNumber);\n}\n",
    "start": 19,
    "end": 26,
    "location": [
      22
    ],
    "file_path": "src/main/java/org/jsoup/nodes/DocumentType.java"
  },
  "Jsoup-41": {
    "buggy": "public boolean equals(Object TransVarObj) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(this == TransVarObj))) return true;\n    if (!(!(TransVarObj == null || getClass() != TransVarObj.getClass()))) return false;\n    if (!(!(!super.equals(TransVarObj)))) return false;\n\n    Element TransVarObject = (Element) TransVarObj;\n\n    return this == TransVarObj; \n}\n",
    "start": 1168,
    "end": 1176,
    "location": [
      1178
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Element.java"
  },
  "Jsoup-42": {
    "buggy": "public List<Connection.KeyVal> formData() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ArrayList<Connection.KeyVal> TransVarValues = new ArrayList<Connection.KeyVal>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element TransVarElement: elements) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(!TransVarElement.tag().isFormSubmittable()))) continue; // contents are form listable, superset of submitable\n        String TransVarItemName = TransVarElement.attr(\"name\"); \n        if (!(!(TransVarItemName.length() == 0))) continue;\n        String TransVarElementType = TransVarElement.attr(\"type\");\n\n        if (!(!(\"select\".equals(TransVarElement.tagName())))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Elements TransVarSelectedOptions = TransVarElement.select(\"option[selected]\");\n            boolean TransVarIsCheck = false;\n            for (Element TransVarOptionElement: TransVarSelectedOptions) {\n                TransVarValues.add(HttpConnection.KeyVal.create(TransVarItemName, TransVarOptionElement.val()));\n                TransVarIsCheck = true;\n            }\n            if (!(!(!TransVarIsCheck))) {\n                Element TransVarOptions = TransVarElement.select(\"option\").first();\n                if (!(!(TransVarOptions != null)))\n                    TransVarValues.add(HttpConnection.KeyVal.create(TransVarItemName, TransVarOptions.val()));\n            }\n        } else if (!(!(\"checkbox\".equalsIgnoreCase(TransVarElementType) || \"radio\".equalsIgnoreCase(TransVarElementType)))) {\n            // only add checkbox or radio if they have the checked attribute\n            if (!(!(TransVarElement.hasAttr(\"checked\")))) {\n                final String TransVarStr = TransVarElement.val(); \n                TransVarValues.add(HttpConnection.KeyVal.create(TransVarItemName, TransVarStr));\n            }\n        } else {\n            TransVarValues.add(HttpConnection.KeyVal.create(TransVarItemName, TransVarElement.val()));\n        }\n    }\n    return TransVarValues;\n}\n",
    "start": 74,
    "end": 107,
    "location": [
      86,
      108
    ],
    "file_path": "src/main/java/org/jsoup/nodes/FormElement.java"
  },
  "Jsoup-48": {
    "buggy": "void processResponseHeaders(Map<String, List<String>> TransVarResponseHeaders) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (Map.Entry<String, List<String>> TransVarHeaders : TransVarResponseHeaders.entrySet()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarHeaderName = TransVarHeaders.getKey();\n        if (!(!(TransVarHeaderName == null)))\n            continue; // http/1.1 line\n\n        List<String> TransVarHeaderValues = TransVarHeaders.getValue();\n        if (!(!(TransVarHeaderName.equalsIgnoreCase(\"Set-Cookie\")))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            for (String TransVarHeaderValue : TransVarHeaderValues) {\n                if (!(!(TransVarHeaderValue == null)))\n                    continue;\n                TokenQueue TransVarTokens = new TokenQueue(TransVarHeaderValue);\n                String TransVarCookieNameStr = TransVarTokens.chompTo(\"=\").trim();\n                String TransVarCookieValues = TransVarTokens.consumeTo(\";\").trim();\n                // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                // name not blank, value not null\n                if (!(!(TransVarCookieNameStr.length() > 0)))\n                    cookie(TransVarCookieNameStr, TransVarCookieValues);\n            }\n        } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n            if (!(!(!TransVarHeaderValues.isEmpty()))) \n                header(TransVarHeaderName, TransVarHeaderValues.get(0));\n        } \n    }\n}\n",
    "start": 753,
    "end": 777,
    "location": [
      782,
      784
    ],
    "file_path": "src/main/java/org/jsoup/helper/HttpConnection.java"
  },
  "Jsoup-5": {
    "buggy": "private Attribute parseAttribute() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    tq.consumeWhitespace();\n    String TransVarAttributeKey = tq.consumeAttributeKey();\n    String TransVarAttributeValue = \"\";\n    tq.consumeWhitespace();\n    if (!(!(tq.matchChomp(\"=\")))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        tq.consumeWhitespace();\n\n        if (!(!(tq.matchChomp(SQ)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarAttributeValue = tq.chompTo(SQ);\n        } else if (!(!(tq.matchChomp(DQ)))) {\n            TransVarAttributeValue = tq.chompTo(DQ);\n        } else {\n            StringBuilder TransVarValue = new StringBuilder();\n            for (; !(!(!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()));) {\n                TransVarValue.append(tq.consume());\n            }\n            TransVarAttributeValue = TransVarValue.toString();\n        }\n        tq.consumeWhitespace();\n    }\n    if (!(!(TransVarAttributeKey.length() != 0)))\n        return Attribute.createFromEncoded(TransVarAttributeKey, TransVarAttributeValue);\n    else {\n        tq.consume(); \n            \n        return null;\n    }\n}\n",
    "start": 181,
    "end": 210,
    "location": [
      214
    ],
    "file_path": "src/main/java/org/jsoup/parser/Parser.java"
  },
  "Jsoup-50": {
    "buggy": "static Document parseByteData(ByteBuffer TransVarByteBuffer, String TransVarCharset, String TransVarBase, Parser TransVarNewParser) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarDocumentData;\n    Document TransVarDoc_parsed = null;\n\n    // look for BOM - overrides any other header or input\n \n    if (!(!(TransVarCharset == null))) { // determine from meta. safe parse as UTF-8\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        TransVarDocumentData = Charset.forName(defaultCharset).decode(TransVarByteBuffer).toString();\n        TransVarDoc_parsed = TransVarNewParser.parseInput(TransVarDocumentData, TransVarBase);\n        Element TransVarMeta_content_type = TransVarDoc_parsed.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (!(!(TransVarMeta_content_type != null))) { // if not found, will keep utf-8 as best attempt\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            String TransVarCharSet = null;\n            if (!(!(TransVarMeta_content_type.hasAttr(\"http-equiv\")))) {\n                TransVarCharSet = getCharsetFromContentType(TransVarMeta_content_type.attr(\"content\"));\n            }\n            if (!(!(TransVarCharSet == null && TransVarMeta_content_type.hasAttr(\"charset\")))) {\n                try {\n                    if (!(!(Charset.isSupported(TransVarMeta_content_type.attr(\"charset\"))))) {\n                        TransVarCharSet = TransVarMeta_content_type.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException TransVarError) {\n                    TransVarCharSet = null;\n                }\n            }\n\n            if (!(!(TransVarCharSet != null && TransVarCharSet.length() != 0 && !TransVarCharSet.equals(defaultCharset)))) { // need to re-decode\n                TransVarCharSet = TransVarCharSet.trim().replaceAll(\"[\\\"']\", \"\");\n                TransVarCharset = TransVarCharSet;\n                TransVarByteBuffer.rewind();\n                TransVarDocumentData = Charset.forName(TransVarCharSet).decode(TransVarByteBuffer).toString();\n                TransVarDoc_parsed = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(TransVarCharset, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        TransVarDocumentData = Charset.forName(TransVarCharset).decode(TransVarByteBuffer).toString();\n    } \n    if (!(!(TransVarDocumentData.length() > 0 && TransVarDocumentData.charAt(0) == UNICODE_BOM))) { \n        TransVarByteBuffer.rewind(); \n        TransVarDocumentData = Charset.forName(defaultCharset).decode(TransVarByteBuffer).toString(); \n        TransVarDocumentData = TransVarDocumentData.substring(1); \n        TransVarCharset = defaultCharset; \n        TransVarDoc_parsed = null; \n    }\n    if (!(!(TransVarDoc_parsed == null))) {\n        TransVarDoc_parsed = TransVarNewParser.parseInput(TransVarDocumentData, TransVarBase);\n        TransVarDoc_parsed.outputSettings().charset(TransVarCharset);\n    }\n    return TransVarDoc_parsed;\n}\n",
    "start": 88,
    "end": 138,
    "location": [
      96,
      134,
      135,
      136,
      137,
      138,
      139,
      140
    ],
    "file_path": "src/main/java/org/jsoup/helper/DataUtil.java"
  },
  "Jsoup-51": {
    "buggy": "boolean matchesLetter() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(isEmpty())))\n        return false;\n    char TransVarC2 = input[pos];\n    return (TransVarC2 >= 'A' && TransVarC2 <= 'Z') || (TransVarC2 >= 'a' && TransVarC2 <= 'z'); \n}\n",
    "start": 296,
    "end": 301,
    "location": [
      303
    ],
    "file_path": "src/main/java/org/jsoup/parser/CharacterReader.java"
  },
  "Jsoup-53": {
    "buggy": "public String chompBalanced(char TransVarIsOpen, char TransVarOpen) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarBegin = -1;\n    int TransVarLast = -1;\n    int TransVarCount = 0;\n    char TransVarI = 0;\n \n    do {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(isEmpty()))) break;\n        Character TransVarCh = consume();\n        if (!(!(TransVarI == 0 || TransVarI != ESC))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarCh.equals(TransVarIsOpen)))) { \n                TransVarCount++;\n                if (!(!(TransVarBegin == -1)))\n                    TransVarBegin = pos;\n            }\n            else if (!(!(TransVarCh.equals(TransVarOpen))))\n                TransVarCount--;\n        }\n\n        if (!(!(TransVarCount > 0 && TransVarI != 0)))\n            TransVarLast = pos; // don't include the outer match pair in the return\n        TransVarI = TransVarCh;\n    } while (!(!(TransVarCount > 0)));\n    return (TransVarLast >= 0) ? queue.substring(TransVarBegin, TransVarLast) : \"\";\n}\n",
    "start": 260,
    "end": 284,
    "location": [
      268,
      279
    ],
    "file_path": "src/main/java/org/jsoup/parser/TokenQueue.java"
  },
  "Jsoup-54": {
    "buggy": "private void copyAttributes(org.jsoup.nodes.Node TransVarHtml, Element TransVarElement) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (Attribute TransVarAttr : TransVarHtml.attributes()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n        String TransVarAttributeName = TransVarAttr.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n            TransVarElement.setAttribute(TransVarAttributeName, TransVarAttr.getValue()); \n    }\n}\n",
    "start": 122,
    "end": 128,
    "location": [
      132
    ],
    "file_path": "src/main/java/org/jsoup/helper/W3CDom.java"
  },
  "Jsoup-59": {
    "buggy": "final void newAttribute() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(attributes == null)))\n        attributes = new Attributes();\n\n    if (!(!(pendingAttributeName != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName = pendingAttributeName.trim();\n            Attribute TransVarAttribute1; \n            if (!(!(hasPendingAttributeValue)))\n                TransVarAttribute1 = new Attribute(pendingAttributeName,\n                    pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n            else if (!(!(hasEmptyAttributeValue)))\n                TransVarAttribute1 = new Attribute(pendingAttributeName, \"\");\n            else\n                TransVarAttribute1 = new BooleanAttribute(pendingAttributeName);\n            attributes.put(TransVarAttribute1);\n    } \n    pendingAttributeName = null;\n    hasEmptyAttributeValue = false;\n    hasPendingAttributeValue = false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS = null;\n}\n",
    "start": 100,
    "end": 122,
    "location": [
      113,
      122
    ],
    "file_path": "src/main/java/org/jsoup/parser/Token.java"
  },
  "Jsoup-61": {
    "buggy": "public boolean hasClass(String TransVarClassNameObject) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final String TransVarClassName = attributes.get(\"class\"); \n    final int TransVarStrLen = TransVarClassName.length();\n    final int TransVarLength = TransVarClassNameObject.length();\n\n    if (!(!(TransVarStrLen == 0 || TransVarStrLen < TransVarLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (!(!(TransVarStrLen == TransVarLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarClassNameObject.equalsIgnoreCase(TransVarClassName);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean TransVarIsClass = false;\n    int TransVarStartIndex = 0;\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarStrLen))) {\n        if (!(!(Character.isWhitespace(TransVarClassName.charAt(TransVarIndex))))) {\n            if (!(!(TransVarIsClass))) {\n                if (!(!(TransVarIndex - TransVarStartIndex == TransVarLength && TransVarClassName.regionMatches(true,\n                        TransVarStartIndex, TransVarClassNameObject, 0, TransVarLength)))) {\n                    return true;\n                }\n                TransVarIsClass = false;\n            }\n        } else {\n            if (!(!(!TransVarIsClass))) {\n                TransVarIsClass = true;\n                TransVarStartIndex = TransVarIndex;\n            }\n        }\n        TransVarIndex++;\n    }\n\n    // check the last entry\n    if (!(!(TransVarIsClass && TransVarStrLen - TransVarStartIndex == TransVarLength))) {\n        return TransVarClassName.regionMatches(true, TransVarStartIndex, TransVarClassNameObject, 0, TransVarLength);\n    }\n\n    return false;\n}\n",
    "start": 1091,
    "end": 1132,
    "location": [
      1095
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Element.java"
  },
  "Jsoup-62": {
    "buggy": "boolean anyOtherEndTag(Token TransVarToken, HtmlTreeBuilder TransVarTokenBuilder) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarTag = TransVarToken.asEndTag().normalName(); \n    ArrayList<Element> TransVarElementStack = TransVarTokenBuilder.getStack();\n    int TransVarPosition = TransVarElementStack.size() - 1;\n    while (!(!(TransVarPosition >= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Element TransVarElem = TransVarElementStack.get(TransVarPosition);\n        if (!(!(TransVarElem.nodeName().equals(TransVarTag)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarTokenBuilder.generateImpliedEndTags(TransVarTag);\n            if (!(!(!TransVarTag.equals(TransVarTokenBuilder.currentElement().nodeName()))))\n                TransVarTokenBuilder.error(this);\n            TransVarTokenBuilder.popStackToClose(TransVarTag);\n            break;\n        } else {\n            if (!(!(TransVarTokenBuilder.isSpecial(TransVarElem)))) {\n                TransVarTokenBuilder.error(this);\n                return false;\n            }\n        }\n        TransVarPosition--;\n    }\n    return true;\n}\n",
    "start": 763,
    "end": 782,
    "location": [
      767
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"
  },
  "Jsoup-64": {
    "buggy": "private static void handleRawtext(Token.StartTag TransVarStartToken, HtmlTreeBuilder TransVarTreeBuilder) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarTreeBuilder.insert(TransVarStartToken); \n    TransVarTreeBuilder.tokeniser.transition(TokeniserState.Rawtext);\n    TransVarTreeBuilder.markInsertionMode();\n    TransVarTreeBuilder.transition(Text);\n} \n",
    "start": 1488,
    "end": 1493,
    "location": [
      1492,
      1496
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"
  },
  "Jsoup-68": {
    "buggy": "private boolean inSpecificScope(String[] TransVarNames, String[] TransVarTypeArray, String[] TransVarType) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n    int TransVarLast = stack.size() -1; \n    if (!(!(TransVarLast > MaxScopeSearchDepth))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarLast = MaxScopeSearchDepth; \n    } \n    final int TransVarBottom = TransVarLast > MaxScopeSearchDepth ? TransVarLast - MaxScopeSearchDepth : 0;\n    // don't walk too far up the tree\n\n    int TransVarPosition = TransVarLast;\n    while (!(!(TransVarPosition >= TransVarBottom))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final String TransVarEl = stack.get(TransVarPosition).nodeName();\n        if (!(!(inSorted(TransVarEl, TransVarNames))))\n            return true;\n        if (!(!(inSorted(TransVarEl, TransVarTypeArray))))\n            return false;\n        if (!(!(TransVarType != null && inSorted(TransVarEl, TransVarType))))\n            return false;\n        TransVarPosition--;\n    }\n    //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n    return false;\n}\n",
    "start": 466,
    "end": 486,
    "location": [
      471,
      472,
      476,
      477
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java"
  },
  "Jsoup-70": {
    "buggy": "static boolean preserveWhitespace(Node TransVarTreeNode) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // looks only at this element and five levels up, to prevent recursion & needless stack searches\n    if (!(!(TransVarTreeNode != null && TransVarTreeNode instanceof Element))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Element TransVarElement = (Element) TransVarTreeNode;\n            if (!(!(TransVarElement.tag.preserveWhitespace()))) \n                return true;\n            else \n                return TransVarElement.parent() != null && TransVarElement.parent().tag.preserveWhitespace(); \n    }\n    return false;\n}\n",
    "start": 1087,
    "end": 1097,
    "location": [
      1097,
      1099,
      1100
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Element.java"
  },
  "Jsoup-72": {
    "buggy": "private static String cacheString(final char[] TransVarCharBuffer, final String[] TransVarStringCacheBuffer, final int TransVarStartOffset, final int TransVarOffset) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // limit (no cache):\n    if (!(!(TransVarOffset > maxStringCacheLen)))\n        return new String(TransVarCharBuffer, TransVarStartOffset, TransVarOffset);\n \n    // calculate hash:\n    int TransVarHashCode = 0;\n    int TransVarOffset2 = TransVarStartOffset;\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarOffset))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarHashCode = 31 * TransVarHashCode + TransVarCharBuffer[TransVarOffset2++];\n        TransVarJ++;\n    }\n\n    // get from cache\n    final int TransVarStringIndex = TransVarHashCode & TransVarStringCacheBuffer.length - 1;\n    String TransVarCachedString = TransVarStringCacheBuffer[TransVarStringIndex];\n\n    if (!(!(TransVarCachedString == null))) { // miss, add\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarCachedString = new String(TransVarCharBuffer, TransVarStartOffset, TransVarOffset);\n        TransVarStringCacheBuffer[TransVarStringIndex] = TransVarCachedString;\n    } else { // hashcode hit, check equality\n        if (!(!(rangeEquals(TransVarCharBuffer, TransVarStartOffset, TransVarOffset, TransVarCachedString)))) { // hit\n            return TransVarCachedString;\n        } else { // hashcode conflict\n            TransVarCachedString = new String(TransVarCharBuffer, TransVarStartOffset, TransVarOffset);\n            TransVarStringCacheBuffer[TransVarStringIndex] = TransVarCachedString; // update the cache, as recently used strings are more likely to show up again\n        }\n    }\n    return TransVarCachedString;\n}\n",
    "start": 423,
    "end": 451,
    "location": [
      430
    ],
    "file_path": "src/main/java/org/jsoup/parser/CharacterReader.java"
  },
  "Jsoup-76": {
    "buggy": "boolean process(Token TransVarT1, HtmlTreeBuilder TransVarTreeBuilder) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    switch (TransVarT1.type) {\n        case Character: {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Token.Character TransVarCh = TransVarT1.asCharacter();\n            if (!(!(TransVarCh.getData().equals(nullString)))) {\n                if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n                // todo confirm that check\n                TransVarTreeBuilder.error(this);\n                return false;\n            } else if (!(!(TransVarTreeBuilder.framesetOk() && isWhitespace(TransVarCh)))) { // don't check if whitespace if frames already closed\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarCh);\n            } else {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarCh);\n                TransVarTreeBuilder.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            TransVarTreeBuilder.insert(TransVarT1.asComment());\n            break;\n        }\n        case Doctype: {\n            TransVarTreeBuilder.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag TransVarStartTag2 = TransVarT1.asStartTag();\n            // todo - refactor to a switch statement\n            String TransVarLocalName = TransVarStartTag2.normalName();\n            if (!(!(TransVarLocalName.equals(\"a\")))) {\n                if (!(!(TransVarTreeBuilder.getActiveFormattingElement(\"a\") != null))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.processEndTag(\"a\");\n\n                    // still on stack?\n                    Element TransVarRemainingElement = TransVarTreeBuilder.getFromStack(\"a\");\n                    if (!(!(TransVarRemainingElement != null))) {\n                        TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarRemainingElement);\n                        TransVarTreeBuilder.removeFromStack(TransVarRemainingElement);\n                    }\n                }\n                TransVarTreeBuilder.reconstructFormattingElements();\n                Element TransVarElement = TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.pushActiveFormattingElements(TransVarElement);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartEmptyFormatters)))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insertEmpty(TransVarStartTag2);\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartPClosers)))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"span\")))) {\n                // same as final else, but short circuits lots of checks\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"li\")))) {\n                TransVarTreeBuilder.framesetOk(false);\n                ArrayList<Element> TransVarTagStack = TransVarTreeBuilder.getStack();\n                int TransVarIndex = TransVarTagStack.size() - 1;\n                while (!(!(TransVarIndex > 0))) {\n                    Element TransVarLocalElement = TransVarTagStack.get(TransVarIndex);\n                    if (!(!(TransVarLocalElement.nodeName().equals(\"li\")))) {\n                        TransVarTreeBuilder.processEndTag(\"li\");\n                        break;\n                    }\n                    if (!(!(TransVarTreeBuilder.isSpecial(TransVarLocalElement)\n                            && !StringUtil.inSorted(TransVarLocalElement.nodeName(), Constants.InBodyStartLiBreakers))))\n                        break;\n                    TransVarIndex--;\n                }\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"html\")))) {\n                TransVarTreeBuilder.error(this);\n                // merge attributes onto real html\n                Element TransVarTag = TransVarTreeBuilder.getStack().get(0);\n                for (Attribute TransVarAttributeLocalName : TransVarStartTag2.getAttributes()) {\n                    if (!(!(!TransVarTag.hasAttr(TransVarAttributeLocalName.getKey()))))\n                        TransVarTag.attributes().put(TransVarAttributeLocalName);\n                }\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartToHead)))) {\n                return TransVarTreeBuilder.process(TransVarT1, InHead);\n            } else if (!(!(TransVarLocalName.equals(\"body\")))) {\n                TransVarTreeBuilder.error(this);\n                ArrayList<Element> TransVarElementStack = TransVarTreeBuilder.getStack();\n                if (!(!(TransVarElementStack.size() == 1\n                        || (TransVarElementStack.size() > 2 && !TransVarElementStack.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else {\n                    TransVarTreeBuilder.framesetOk(false);\n                    Element TransVarBody1 = TransVarElementStack.get(1);\n                    for (Attribute TransVarAtt : TransVarStartTag2.getAttributes()) {\n                        if (!(!(!TransVarBody1.hasAttr(TransVarAtt.getKey()))))\n                            TransVarBody1.attributes().put(TransVarAtt);\n                    }\n                }\n            } else if (!(!(TransVarLocalName.equals(\"frameset\")))) {\n                TransVarTreeBuilder.error(this);\n                ArrayList<Element> TransVarElementList = TransVarTreeBuilder.getStack();\n                if (!(!(TransVarElementList.size() == 1\n                        || (TransVarElementList.size() > 2 && !TransVarElementList.get(1).nodeName().equals(\"body\"))))) {\n                    // only in fragment case\n                    return false; // ignore\n                } else if (!(!(!TransVarTreeBuilder.framesetOk()))) {\n                    return false; // ignore frameset\n                } else {\n                    Element TransVarSecondElement = TransVarElementList.get(1);\n                    if (!(!(TransVarSecondElement.parent() != null)))\n                        TransVarSecondElement.remove();\n                    for (; !(!(TransVarElementList.size() > 1));)\n                        TransVarElementList.remove(TransVarElementList.size() - 1);\n                    TransVarTreeBuilder.insert(TransVarStartTag2);\n                    TransVarTreeBuilder.transition(InFrameset);\n                }\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.Headings)))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                if (!(!(StringUtil.inSorted(TransVarTreeBuilder.currentElement().nodeName(), Constants.Headings)))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.pop();\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartPreListing)))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.framesetOk(false); \n            } else if (!(!(TransVarLocalName.equals(\"form\")))) {\n                if (!(!(TransVarTreeBuilder.getFormElement() != null))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                }\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insertForm(TransVarStartTag2, true);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.DdDt)))) {\n                TransVarTreeBuilder.framesetOk(false);\n                ArrayList<Element> TransVarStackList = TransVarTreeBuilder.getStack();\n                int TransVarCounter = TransVarStackList.size() - 1;\n                while (!(!(TransVarCounter > 0))) {\n                    Element TransVarFirstElement = TransVarStackList.get(TransVarCounter);\n                    if (!(!(StringUtil.inSorted(TransVarFirstElement.nodeName(), Constants.DdDt)))) {\n                        TransVarTreeBuilder.processEndTag(TransVarFirstElement.nodeName());\n                        break;\n                    }\n                    if (!(!(TransVarTreeBuilder.isSpecial(TransVarFirstElement)\n                            && !StringUtil.inSorted(TransVarFirstElement.nodeName(), Constants.InBodyStartLiBreakers))))\n                        break;\n                    TransVarCounter--;\n                }\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"plaintext\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n            } else if (!(!(TransVarLocalName.equals(\"button\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"button\")))) {\n                    // close and reprocess\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.processEndTag(\"button\");\n                    TransVarTreeBuilder.process(TransVarStartTag2);\n                } else {\n                    TransVarTreeBuilder.reconstructFormattingElements();\n                    TransVarTreeBuilder.insert(TransVarStartTag2);\n                    TransVarTreeBuilder.framesetOk(false);\n                }\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.Formatters)))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                Element TransVarStartElement = TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.pushActiveFormattingElements(TransVarStartElement);\n            } else if (!(!(TransVarLocalName.equals(\"nobr\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                if (!(!(TransVarTreeBuilder.inScope(\"nobr\")))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.processEndTag(\"nobr\");\n                    TransVarTreeBuilder.reconstructFormattingElements();\n                }\n                Element TransVarNewElement = TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.pushActiveFormattingElements(TransVarNewElement);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartApplets)))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.insertMarkerToFormattingElements();\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(TransVarLocalName.equals(\"table\")))) {\n                if (!(!(TransVarTreeBuilder.getDocument().quirksMode() != Document.QuirksMode.quirks\n                        && TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.framesetOk(false);\n                TransVarTreeBuilder.transition(InTable);\n            } else if (!(!(TransVarLocalName.equals(\"input\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                Element TransVarEl1 = TransVarTreeBuilder.insertEmpty(TransVarStartTag2);\n                if (!(!(!TransVarEl1.attr(\"type\").equalsIgnoreCase(\"hidden\"))))\n                    TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartMedia)))) {\n                TransVarTreeBuilder.insertEmpty(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"hr\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.insertEmpty(TransVarStartTag2);\n                TransVarTreeBuilder.framesetOk(false);\n            } else if (!(!(TransVarLocalName.equals(\"image\")))) {\n                if (!(!(TransVarTreeBuilder.getFromStack(\"svg\") == null)))\n                    return TransVarTreeBuilder.process(TransVarStartTag2.name(\"img\")); // change <image> to <img>, unless in svg\n                else\n                    TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"isindex\")))) {\n                // how much do we care about the early 90s?\n                TransVarTreeBuilder.error(this);\n                if (!(!(TransVarTreeBuilder.getFormElement() != null)))\n                    return false;\n\n                TransVarTreeBuilder.processStartTag(\"form\");\n                if (!(!(TransVarStartTag2.attributes.hasKey(\"action\")))) {\n                    Element TransVarFormElement = TransVarTreeBuilder.getFormElement();\n                    TransVarFormElement.attr(\"action\", TransVarStartTag2.attributes.get(\"action\"));\n                }\n                TransVarTreeBuilder.processStartTag(\"hr\");\n                TransVarTreeBuilder.processStartTag(\"label\");\n                // hope you like english.\n                String TransVarPromptMessage = TransVarStartTag2.attributes.hasKey(\"prompt\") ?\n                        TransVarStartTag2.attributes.get(\"prompt\") :\n                        \"This is a searchable index. Enter search keywords: \";\n\n                TransVarTreeBuilder.process(new Token.Character().data(TransVarPromptMessage));\n\n                // input\n                Attributes TransVarAtts = new Attributes();\n                for (Attribute TransVarAttribute : TransVarStartTag2.attributes) {\n                    if (!(!(!StringUtil.inSorted(TransVarAttribute.getKey(), Constants.InBodyStartInputAttribs))))\n                        TransVarAtts.put(TransVarAttribute);\n                }\n                TransVarAtts.put(\"name\", \"isindex\");\n                TransVarTreeBuilder.processStartTag(\"input\", TransVarAtts);\n                TransVarTreeBuilder.processEndTag(\"label\");\n                TransVarTreeBuilder.processStartTag(\"hr\");\n                TransVarTreeBuilder.processEndTag(\"form\");\n            } else if (!(!(TransVarLocalName.equals(\"textarea\")))) {\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n                // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                TransVarTreeBuilder.tokeniser.transition(TokeniserState.Rcdata);\n                TransVarTreeBuilder.markInsertionMode();\n                TransVarTreeBuilder.framesetOk(false);\n                TransVarTreeBuilder.transition(Text);\n            } else if (!(!(TransVarLocalName.equals(\"xmp\")))) {\n                if (!(!(TransVarTreeBuilder.inButtonScope(\"p\")))) {\n                    TransVarTreeBuilder.processEndTag(\"p\");\n                }\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.framesetOk(false);\n                handleRawtext(TransVarStartTag2, TransVarTreeBuilder);\n            } else if (!(!(TransVarLocalName.equals(\"iframe\")))) {\n                TransVarTreeBuilder.framesetOk(false);\n                handleRawtext(TransVarStartTag2, TransVarTreeBuilder);\n            } else if (!(!(TransVarLocalName.equals(\"noembed\")))) {\n                // also handle noscript if script enabled\n                handleRawtext(TransVarStartTag2, TransVarTreeBuilder);\n            } else if (!(!(TransVarLocalName.equals(\"select\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n                TransVarTreeBuilder.framesetOk(false);\n\n                HtmlTreeBuilderState TransVarStateObject = TransVarTreeBuilder.state();\n                if (!(!(TransVarStateObject.equals(InTable) || TransVarStateObject.equals(InCaption)\n                        || TransVarStateObject.equals(InTableBody) || TransVarStateObject.equals(InRow)\n                        || TransVarStateObject.equals(InCell))))\n                    TransVarTreeBuilder.transition(InSelectInTable);\n                else\n                    TransVarTreeBuilder.transition(InSelect);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartOptions)))) {\n                if (!(!(TransVarTreeBuilder.currentElement().nodeName().equals(\"option\"))))\n                    TransVarTreeBuilder.processEndTag(\"option\");\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartRuby)))) {\n                if (!(!(TransVarTreeBuilder.inScope(\"ruby\")))) {\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(\"ruby\")))) {\n                        TransVarTreeBuilder.error(this);\n                        TransVarTreeBuilder.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n                    }\n                    TransVarTreeBuilder.insert(TransVarStartTag2);\n                }\n            } else if (!(!(TransVarLocalName.equals(\"math\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(TransVarLocalName.equals(\"svg\")))) {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartDrop)))) {\n                TransVarTreeBuilder.error(this);\n                return false;\n            } else {\n                TransVarTreeBuilder.reconstructFormattingElements();\n                TransVarTreeBuilder.insert(TransVarStartTag2);\n            }\n            break;\n\n        case EndTag:\n            Token.EndTag TransVarEndTag2 = TransVarT1.asEndTag();\n            TransVarLocalName = TransVarEndTag2.normalName();\n            if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyEndAdoptionFormatters)))) {\n                int TransVarK = 0;\n                while (!(!(TransVarK < 8))){Element TransVarFormatElement=TransVarTreeBuilder.getActiveFormattingElement(TransVarLocalName);if (!(!(TransVarFormatElement == null)))return anyOtherEndTag(TransVarT1,TransVarTreeBuilder); else if (!(!(!TransVarTreeBuilder.onStack(TransVarFormatElement)))){TransVarTreeBuilder.error(this);TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarFormatElement);return true;} else if (!(!(!TransVarTreeBuilder.inScope(TransVarFormatElement.nodeName())))){TransVarTreeBuilder.error(this);return false;} else if (!(!(TransVarTreeBuilder.currentElement() != TransVarFormatElement)))TransVarTreeBuilder.error(this);Element TransVarFurthestElement=null;Element TransVarAncestor=null;boolean TransVarInFormattingElement=false;ArrayList<Element> TransVarElStack=TransVarTreeBuilder.getStack();final int TransVarStacksize=TransVarElStack.size();int TransVarSIndex=0;while (!(!(TransVarSIndex < TransVarStacksize && TransVarSIndex < 64))){Element TransVarCurrentElement=TransVarElStack.get(TransVarSIndex);if (!(!(TransVarCurrentElement == TransVarFormatElement))){TransVarAncestor=TransVarElStack.get(TransVarSIndex - 1);TransVarInFormattingElement=true;} else if (!(!(TransVarInFormattingElement && TransVarTreeBuilder.isSpecial(TransVarCurrentElement)))){TransVarFurthestElement=TransVarCurrentElement;break;}TransVarSIndex++;}if (!(!(TransVarFurthestElement == null))){TransVarTreeBuilder.popStackToClose(TransVarFormatElement.nodeName());TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarFormatElement);return true;}Element TransVarFurthestBlock=TransVarFurthestElement;Element TransVarLastTag=TransVarFurthestElement;int TransVarCount=0;while (!(!(TransVarCount < 3))){if (!(!(TransVarTreeBuilder.onStack(TransVarFurthestBlock))))TransVarFurthestBlock=TransVarTreeBuilder.aboveOnStack(TransVarFurthestBlock);if (!(!(!TransVarTreeBuilder.isInActiveFormattingElements(TransVarFurthestBlock)))){TransVarTreeBuilder.removeFromStack(TransVarFurthestBlock);continue;} else if (!(!(TransVarFurthestBlock == TransVarFormatElement)))break;Element TransVarReplacementElement=new Element(Tag.valueOf(TransVarFurthestBlock.nodeName(),ParseSettings.preserveCase),TransVarTreeBuilder.getBaseUri());TransVarTreeBuilder.replaceActiveFormattingElement(TransVarFurthestBlock,TransVarReplacementElement);TransVarTreeBuilder.replaceOnStack(TransVarFurthestBlock,TransVarReplacementElement);TransVarFurthestBlock=TransVarReplacementElement;if (!(!(TransVarLastTag == TransVarFurthestElement))){}if (!(!(TransVarLastTag.parent() != null)))TransVarLastTag.remove();TransVarFurthestBlock.appendChild(TransVarLastTag);TransVarLastTag=TransVarFurthestBlock;TransVarCount++;}if (!(!(StringUtil.inSorted(TransVarAncestor.nodeName(), Constants.InBodyEndTableFosters)))){if (!(!(TransVarLastTag.parent() != null)))TransVarLastTag.remove();TransVarTreeBuilder.insertInFosterParent(TransVarLastTag);} else {if (!(!(TransVarLastTag.parent() != null)))TransVarLastTag.remove();TransVarAncestor.appendChild(TransVarLastTag);}Element TransVarFormatAdp=new Element(TransVarFormatElement.tag(),TransVarTreeBuilder.getBaseUri());TransVarFormatAdp.attributes().addAll(TransVarFormatElement.attributes());Node[] TransVarChild=TransVarFurthestElement.childNodes().toArray(new Node[TransVarFurthestElement.childNodeSize()]);for (Node TransVarNewChildNode:TransVarChild){TransVarFormatAdp.appendChild(TransVarNewChildNode);}TransVarFurthestElement.appendChild(TransVarFormatAdp);TransVarTreeBuilder.removeFromActiveFormattingElements(TransVarFormatElement);TransVarTreeBuilder.removeFromStack(TransVarFormatElement);TransVarTreeBuilder.insertOnStackAfter(TransVarFurthestElement,TransVarFormatAdp);TransVarK++;}\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyEndClosers)))) {\n                if (!(!(!TransVarTreeBuilder.inScope(TransVarLocalName)))) {\n                    // nothing to close\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarLocalName);\n                }\n            } else if (!(!(TransVarLocalName.equals(\"span\")))) {\n                // same as final fall through, but saves short circuit\n                return anyOtherEndTag(TransVarT1, TransVarTreeBuilder);\n            } else if (!(!(TransVarLocalName.equals(\"li\")))) {\n                if (!(!(!TransVarTreeBuilder.inListItemScope(TransVarLocalName)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarLocalName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarLocalName);\n                }\n            } else if (!(!(TransVarLocalName.equals(\"body\")))) {\n                if (!(!(!TransVarTreeBuilder.inScope(\"body\")))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n                    TransVarTreeBuilder.transition(AfterBody);\n                }\n            } else if (!(!(TransVarLocalName.equals(\"html\")))) {\n                boolean TransVarIsIgnored = TransVarTreeBuilder.processEndTag(\"body\");\n                if (!(!(TransVarIsIgnored)))\n                    return TransVarTreeBuilder.process(TransVarEndTag2);\n            } else if (!(!(TransVarLocalName.equals(\"form\")))) {\n                Element TransVarForm = TransVarTreeBuilder.getFormElement();\n                TransVarTreeBuilder.setFormElement(null);\n                if (!(!(TransVarForm == null || !TransVarTreeBuilder.inScope(TransVarLocalName)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    // remove currentForm from stack. will shift anything under up.\n                    TransVarTreeBuilder.removeFromStack(TransVarForm);\n                }\n            } else if (!(!(TransVarLocalName.equals(\"p\")))) {\n                if (!(!(!TransVarTreeBuilder.inButtonScope(TransVarLocalName)))) {\n                    TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.processStartTag(TransVarLocalName); // if no p to close, creates an empty <p></p>\n                    return TransVarTreeBuilder.process(TransVarEndTag2);\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarLocalName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarLocalName);\n                }\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.DdDt)))) {\n                if (!(!(!TransVarTreeBuilder.inScope(TransVarLocalName)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarLocalName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarLocalName);\n                }\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.Headings)))) {\n                if (!(!(!TransVarTreeBuilder.inScope(Constants.Headings)))) {\n                    TransVarTreeBuilder.error(this);\n                    return false;\n                } else {\n                    TransVarTreeBuilder.generateImpliedEndTags(TransVarLocalName);\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(Constants.Headings);\n                }\n            } else if (!(!(TransVarLocalName.equals(\"sarcasm\")))) {\n                // *sigh*\n                return anyOtherEndTag(TransVarT1, TransVarTreeBuilder);\n            } else if (!(!(StringUtil.inSorted(TransVarLocalName, Constants.InBodyStartApplets)))) {\n                if (!(!(!TransVarTreeBuilder.inScope(\"name\")))) {\n                    if (!(!(!TransVarTreeBuilder.inScope(TransVarLocalName)))) {\n                        TransVarTreeBuilder.error(this);\n                        return false;\n                    }\n                    TransVarTreeBuilder.generateImpliedEndTags();\n                    if (!(!(!TransVarTreeBuilder.currentElement().nodeName().equals(TransVarLocalName))))\n                        TransVarTreeBuilder.error(this);\n                    TransVarTreeBuilder.popStackToClose(TransVarLocalName);\n                    TransVarTreeBuilder.clearFormattingElementsToLastMarker();\n                }\n            } else if (!(!(TransVarLocalName.equals(\"br\")))) {\n                TransVarTreeBuilder.error(this);\n                TransVarTreeBuilder.processStartTag(\"br\");\n                return false;\n            } else {\n                return anyOtherEndTag(TransVarT1, TransVarTreeBuilder);\n            }\n\n            break;\n        case EOF:\n            // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n            // stop parsing\n            break;\n    }\n    return true;\n}\n",
    "start": 252,
    "end": 764,
    "location": [
      395
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java"
  },
  "Jsoup-77": {
    "buggy": "private void popStackToClose(Token.EndTag TransVarEndTag1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarTagName = TransVarEndTag1.name(); \n    Element TransVarElement = null;\n\n    int TransVarPosTag = stack.size() - 1;\n    while (!(!(TransVarPosTag >= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Element TransVarNextElement = stack.get(TransVarPosTag);\n        if (!(!(TransVarNextElement.nodeName().equals(TransVarTagName)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarElement = TransVarNextElement;\n            break;\n        }\n        TransVarPosTag--;\n    }\n    if (!(!(TransVarElement == null)))\n        return; // not found, skip\n\n    int TransVarElementStackSize = stack.size() - 1;\n    while (!(!(TransVarElementStackSize >= 0))) {\n        Element TransVarNextItem = stack.get(TransVarElementStackSize);\n        stack.remove(TransVarElementStackSize);\n        if (!(!(TransVarNextItem == TransVarElement)))\n            break;\n        TransVarElementStackSize--;\n    }\n}\n",
    "start": 116,
    "end": 136,
    "location": [
      120
    ],
    "file_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java"
  },
  "Jsoup-80": {
    "buggy": "void insert(Token.Comment TransVarCommentToken2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Comment TransVarComment1 = new Comment(TransVarCommentToken2.getData());\n    Node TransVarCommentNode = TransVarComment1;\n    if (!(!(TransVarCommentToken2.bogus))) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n        String TransVarData1 = TransVarComment1.getData();\n        if (!(!(TransVarData1.length() > 1 && (TransVarData1.startsWith(\"!\") || TransVarData1.startsWith(\"?\"))))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Document TransVarDocument = Jsoup.parse(\"<\" + TransVarData1.substring(1, TransVarData1.length() -1) + \">\", baseUri, Parser.xmlParser());\n                Element TransVarElement1 = TransVarDocument.child(0); \n                TransVarCommentNode = new XmlDeclaration(settings.normalizeTag(TransVarElement1.tagName()), TransVarData1.startsWith(\"!\"));\n                TransVarCommentNode.attributes().addAll(TransVarElement1.attributes());\n        } \n    }\n    insertNode(TransVarCommentNode);\n}\n",
    "start": 83,
    "end": 97,
    "location": [
      100,
      103
    ],
    "file_path": "src/main/java/org/jsoup/parser/XmlTreeBuilder.java"
  },
  "Jsoup-82": {
    "buggy": "static Document parseInputStream(InputStream TransVarInputStream, String TransVarInputStreamCharset, String TransVarUrl, Parser TransVarParser2) throws IOException  {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarInputStream == null))) // empty body\n        return new Document(TransVarUrl);\n    TransVarInputStream = ConstrainableInputStream.wrap(TransVarInputStream, bufferSize, 0);\n\n    Document TransVarDoc1 = null;\n    boolean TransVarReadFully = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    TransVarInputStream.mark(bufferSize);\n    ByteBuffer TransVarFirst2Bytes = readToByteBuffer(TransVarInputStream, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    TransVarReadFully = TransVarInputStream.read() == -1;\n    TransVarInputStream.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset TransVarBomCharSet = detectCharsetFromBom(TransVarFirst2Bytes);\n    if (!(!(TransVarBomCharSet != null)))\n        TransVarInputStreamCharset = TransVarBomCharSet.charset;\n\n    if (!(!(TransVarInputStreamCharset == null))) { // determine from meta. safe first parse as UTF-8\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarDocData2 = Charset.forName(defaultCharset).decode(TransVarFirst2Bytes).toString();\n        TransVarDoc1 = TransVarParser2.parseInput(TransVarDocData2, TransVarUrl);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements TransVarMetaElementList = TransVarDoc1.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String TransVarCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element TransVarMetaElement : TransVarMetaElementList) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarMetaElement.hasAttr(\"http-equiv\"))))\n                TransVarCharset = getCharsetFromContentType(TransVarMetaElement.attr(\"content\"));\n            if (!(!(TransVarCharset == null && TransVarMetaElement.hasAttr(\"charset\"))))\n                TransVarCharset = TransVarMetaElement.attr(\"charset\");\n            if (!(!(TransVarCharset != null)))\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (!(!(TransVarCharset == null && TransVarDoc1.childNodeSize() > 0))) {\n            Node TransVarFirstNode = TransVarDoc1.childNode(0);\n            XmlDeclaration TransVarXmlDecl = null;\n            if (!(!(TransVarFirstNode instanceof XmlDeclaration)))\n                TransVarXmlDecl = (XmlDeclaration) TransVarFirstNode;\n            else if (!(!(TransVarFirstNode instanceof Comment))) {\n                Comment TransVarCommentNode = (Comment) TransVarFirstNode;\n                if (!(!(TransVarCommentNode.isXmlDeclaration())))\n                    TransVarXmlDecl = TransVarCommentNode.asXmlDeclaration();\n            }\n            if (!(!(TransVarXmlDecl != null))) {\n                if (!(!(TransVarXmlDecl.name().equalsIgnoreCase(\"xml\"))))\n                    TransVarCharset = TransVarXmlDecl.attr(\"encoding\");\n            }\n        }\n        TransVarCharset = validateCharset(TransVarCharset);\n        if (!(!(TransVarCharset != null && !TransVarCharset.equalsIgnoreCase(defaultCharset)))) { // need to re-decode. (case insensitive check here to match how validate works)\n            TransVarCharset = TransVarCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            TransVarInputStreamCharset = TransVarCharset;\n            TransVarDoc1 = null;\n        } else if (!(!(!TransVarReadFully))) {\n            TransVarDoc1 = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(TransVarInputStreamCharset, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (!(!(TransVarDoc1 == null))) {\n        if (!(!(TransVarInputStreamCharset == null)))\n            TransVarInputStreamCharset = defaultCharset;\n        BufferedReader TransVarBufferedReader = new BufferedReader(new InputStreamReader(TransVarInputStream, TransVarInputStreamCharset), bufferSize);\n        if (!(!(TransVarBomCharSet != null && TransVarBomCharSet.offset))) // creating the buffered reader ignores the input pos, so must skip here\n            TransVarBufferedReader.skip(1);\n        try {\n            TransVarDoc1 = TransVarParser2.parseInput(TransVarBufferedReader, TransVarUrl);\n        } catch (UncheckedIOException TransVarE1) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw TransVarE1.ioException();\n        }\n        Charset TransVarCharSet = Charset.forName(TransVarInputStreamCharset);\n        TransVarDoc1.outputSettings().charset(TransVarCharSet);\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el \n    } \n    TransVarInputStream.close();\n    return TransVarDoc1;\n}\n",
    "start": 95,
    "end": 175,
    "location": [
      180,
      181
    ],
    "file_path": "src/main/java/org/jsoup/helper/DataUtil.java"
  },
  "Jsoup-84": {
    "buggy": "public void head(org.jsoup.nodes.Node TransVarDoc, int TransVarDocument) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n    if (!(!(TransVarDoc instanceof org.jsoup.nodes.Element))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        org.jsoup.nodes.Element TransVarSourceElement = (org.jsoup.nodes.Element) TransVarDoc;\n\n        String TransVarPrefix1 = updateNamespaces(TransVarSourceElement);\n        String TransVarPrefix = namespacesStack.peek().get(TransVarPrefix1);\n        String TransVarTag = TransVarSourceElement.tagName();\n\n        Element TransVarNewElement =  \n            doc.createElementNS(TransVarPrefix, TransVarTag);\n        copyAttributes(TransVarSourceElement, TransVarNewElement);\n        if (!(!(dest == null))) { // sets up the root\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            doc.appendChild(TransVarNewElement);\n        } else {\n            dest.appendChild(TransVarNewElement);\n        }\n        dest = TransVarNewElement; // descend\n    } else if (!(!(TransVarDoc instanceof org.jsoup.nodes.TextNode))) {\n        org.jsoup.nodes.TextNode TransVarSourceTextNode = (org.jsoup.nodes.TextNode) TransVarDoc;\n        Text TransVarNewTextNode = doc.createTextNode(TransVarSourceTextNode.getWholeText());\n        dest.appendChild(TransVarNewTextNode);\n    } else if (!(!(TransVarDoc instanceof org.jsoup.nodes.Comment))) {\n        org.jsoup.nodes.Comment TransVarComment = (org.jsoup.nodes.Comment) TransVarDoc;\n        Comment TransVarComment2 = doc.createComment(TransVarComment.getData());\n        dest.appendChild(TransVarComment2);\n    } else if (!(!(TransVarDoc instanceof org.jsoup.nodes.DataNode))) {\n        org.jsoup.nodes.DataNode TransVarData = (org.jsoup.nodes.DataNode) TransVarDoc;\n        Text TransVarTextNode = doc.createTextNode(TransVarData.getWholeData());\n        dest.appendChild(TransVarTextNode);\n    } else {\n        // unhandled\n    }\n}\n",
    "start": 82,
    "end": 115,
    "location": [
      97
    ],
    "file_path": "src/main/java/org/jsoup/helper/W3CDom.java"
  },
  "Jsoup-85": {
    "buggy": "public Attribute(String TransVarKeys, String TransVarStr, Attributes TransVarAttributes) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.notNull(TransVarKeys);\n    this.key = TransVarKeys.trim(); \n    Validate.notEmpty(TransVarKeys); // trimming could potentially make empty, so validate here\n    this.val = TransVarStr; \n    this.parent = TransVarAttributes;\n}\n",
    "start": 42,
    "end": 48,
    "location": [
      47,
      49
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Attribute.java"
  },
  "Jsoup-86": {
    "buggy": "public XmlDeclaration asXmlDeclaration() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarDataFromServer = getData();\n    Document TransVarDocument = Jsoup.parse(\"<\" + TransVarDataFromServer.substring(1, TransVarDataFromServer.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration TransVarDeclaration = null;\n    if (!(!(TransVarDocument.childNodeSize() > 0))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Element TransVarEl2 = TransVarDocument.child(0);\n        TransVarDeclaration = new XmlDeclaration(NodeUtils.parser(TransVarDocument).settings().normalizeTag(TransVarEl2.tagName()), TransVarDataFromServer.startsWith(\"!\"));\n        TransVarDeclaration.attributes().addAll(TransVarEl2.attributes());\n    }\n    return TransVarDeclaration;\n}\n",
    "start": 74,
    "end": 84,
    "location": [
      81
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Comment.java"
  },
  "Jsoup-88": {
    "buggy": "public String getValue() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return val; \n}\n",
    "start": 79,
    "end": 81,
    "location": [
      83
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Attribute.java"
  },
  "Jsoup-89": {
    "buggy": "public String setValue(String TransVarName) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarNewValue = parent.get(this.key); \n    if (!(!(parent != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarIndex = parent.indexOfKey(this.key); \n        if (!(!(TransVarIndex != Attributes.NotFound)))\n            parent.vals[TransVarIndex] = TransVarName;\n    }\n    this.val = TransVarName;\n    return Attributes.checkNotNull(TransVarNewValue);\n}\n",
    "start": 87,
    "end": 96,
    "location": [
      91,
      96
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Attribute.java"
  },
  "Jsoup-93": {
    "buggy": "public List<Connection.KeyVal> formData() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ArrayList<Connection.KeyVal> TransVarList = new ArrayList<>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element TransVarElement: elements) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(!TransVarElement.tag().isFormSubmittable()))) continue; // contents are form listable, superset of submitable\n        if (!(!(TransVarElement.hasAttr(\"disabled\")))) continue; // skip disabled form inputs\n        String TransVarAttributeName = TransVarElement.attr(\"name\");\n        if (!(!(TransVarAttributeName.length() == 0))) continue;\n        String TransVarElementType = TransVarElement.attr(\"type\");\n\n \n        if (!(!(\"select\".equals(TransVarElement.normalName())))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            Elements TransVarElements = TransVarElement.select(\"option[selected]\");\n            boolean TransVarIsSet = false;\n            for (Element TransVarEl: TransVarElements) {\n                TransVarList.add(HttpConnection.KeyVal.create(TransVarAttributeName, TransVarEl.val()));\n                TransVarIsSet = true;\n            }\n            if (!(!(!TransVarIsSet))) {\n                Element TransVarSelectedOption = TransVarElement.select(\"option\").first();\n                if (!(!(TransVarSelectedOption != null)))\n                    TransVarList.add(HttpConnection.KeyVal.create(TransVarAttributeName, TransVarSelectedOption.val()));\n            }\n        } else if (!(!(\"checkbox\".equalsIgnoreCase(TransVarElementType) || \"radio\".equalsIgnoreCase(TransVarElementType)))) {\n            // only add checkbox or radio if they have the checked attribute\n            if (!(!(TransVarElement.hasAttr(\"checked\")))) {\n                final String TransVarVal3 = TransVarElement.val().length() >  0 ? TransVarElement.val() : \"on\";\n                TransVarList.add(HttpConnection.KeyVal.create(TransVarAttributeName, TransVarVal3));\n            }\n        } else {\n            TransVarList.add(HttpConnection.KeyVal.create(TransVarAttributeName, TransVarElement.val()));\n        }\n    }\n    return TransVarList;\n}\n",
    "start": 78,
    "end": 113,
    "location": [
      95
    ],
    "file_path": "src/main/java/org/jsoup/nodes/FormElement.java"
  },
  "JxPath-10": {
    "buggy": "public final Object computeValue(EvalContext TransVarEvalContext) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return compute(args[0].computeValue(TransVarEvalContext), args[1].computeValue(TransVarEvalContext))  \n            ? Boolean.TRUE : Boolean.FALSE;\n}\n",
    "start": 41,
    "end": 44,
    "location": [
      45
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java"
  },
  "JxPath-12": {
    "buggy": "public static boolean testNode(Node TransVarNode2, NodeTest TransVarNode) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarNode == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n    if (!(!(TransVarNode instanceof NodeNameTest))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarNode2.getNodeType() != Node.ELEMENT_NODE))) {\n            return false;\n        }\n\n        NodeNameTest TransVarNode3 = (NodeNameTest) TransVarNode;\n        QName TransVarTestQName = TransVarNode3.getNodeName();\n        String TransVarNamespaceURI1 = TransVarNode3.getNamespaceURI();\n        boolean TransVarIsWildCard = TransVarNode3.isWildcard();\n        String TransVarPrefix = TransVarTestQName.getPrefix();\n        if (!(!(TransVarIsWildCard && TransVarPrefix == null))) {\n            return true;\n        }\n        if (!(!(TransVarIsWildCard || TransVarTestQName.getName().equals(DOMNodePointer.getLocalName(TransVarNode2))))) {\n            String TransVarNamespaceURI = DOMNodePointer.getNamespaceURI(TransVarNode2);\n            return equalStrings(TransVarNamespaceURI1, TransVarNamespaceURI); \n        }\n        return false;\n    }\n    if (!(!(TransVarNode instanceof NodeTypeTest))) {\n        int TransVarNodetype = TransVarNode2.getNodeType();\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (((NodeTypeTest) TransVarNode).getNodeType() == Compiler.NODE_TYPE_NODE))))) {\n                TransFallThroughFlag0 = true;\n                return TransVarNodetype == Node.ELEMENT_NODE || TransVarNodetype == Node.DOCUMENT_NODE;\n            }\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (((NodeTypeTest) TransVarNode).getNodeType() == Compiler.NODE_TYPE_TEXT))))) {\n                TransFallThroughFlag0 = true;\n                return TransVarNodetype == Node.CDATA_SECTION_NODE || TransVarNodetype == Node.TEXT_NODE;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0\n                    && (((NodeTypeTest) TransVarNode).getNodeType() == Compiler.NODE_TYPE_COMMENT))))) {\n                TransFallThroughFlag0 = true;\n                return TransVarNodetype == Node.COMMENT_NODE;\n            }\n            if (!(!(TransFallThroughFlag0\n                    || (TransBreakFlag0 && (((NodeTypeTest) TransVarNode).getNodeType() == Compiler.NODE_TYPE_PI))))) {\n                return TransVarNodetype == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n        }\n        return false;\n    }\n    if (!(!(TransVarNode instanceof ProcessingInstructionTest))) {\n        if (!(!(TransVarNode2.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE))) {\n            String TransVarTestPITarget = ((ProcessingInstructionTest) TransVarNode).getTarget();\n            String TransVarPiTarget = ((ProcessingInstruction) TransVarNode2).getTarget();\n            return TransVarTestPITarget.equals(TransVarPiTarget);\n        }\n    }\n    return false;\n}\n",
    "start": 87,
    "end": 136,
    "location": [
      115
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java"
  },
  "JxPath-21": {
    "buggy": "public int getLength() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return ValueUtils.getLength(getBaseValue()); \n}\n",
    "start": 151,
    "end": 153,
    "location": [
      155
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java"
  },
  "JxPath-5": {
    "buggy": "private int compareNodePointers(\n    NodePointer TransVarP,\n    int TransVarDepth,\n    NodePointer TransVarP3,\n    int TransVarDepth3) \n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarDepth < TransVarDepth3))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarP2 = compareNodePointers(TransVarP, TransVarDepth, TransVarP3.parent, TransVarDepth3 - 1);\n        return TransVarP2 == 0 ? -1 : TransVarP2;\n    }\n    if (!(!(TransVarDepth > TransVarDepth3))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarResult = compareNodePointers(TransVarP.parent, TransVarDepth - 1, TransVarP3, TransVarDepth3);\n        return TransVarResult == 0 ? 1 : TransVarResult;\n    }\n    if (!(!(TransVarP == null && TransVarP3 == null))) {\n        return 0;\n    }\n\n    if (!(!(TransVarP != null && TransVarP.equals(TransVarP3)))) {\n        return 0;\n    }\n\n    if (!(!(TransVarDepth == 1))) {\n        throw new JXPathException( \n                \"Cannot compare pointers that do not belong to the same tree: '\" \n                        + TransVarP + \"' and '\" + TransVarP3 + \"'\"); \n    }\n    int TransVarComparisonResult = compareNodePointers(TransVarP.parent, TransVarDepth - 1, TransVarP3.parent, TransVarDepth3 - 1);\n    if (!(!(TransVarComparisonResult != 0))) {\n        return TransVarComparisonResult;\n    }\n\n    return TransVarP.parent.compareChildNodePointers(TransVarP, TransVarP3);\n}\n",
    "start": 642,
    "end": 675,
    "location": [
      674,
      675,
      676
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/model/NodePointer.java"
  },
  "JxPath-6": {
    "buggy": "protected boolean equal(\n    EvalContext TransVarEvalContext,\n    Expression TransVarLeftExp,\n    Expression TransVarRightExp) \n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Object TransVarLeft = TransVarLeftExp.compute(TransVarEvalContext);\n    Object TransVarRight = TransVarRightExp.compute(TransVarEvalContext);\n\n      System.err.println(\"COMPARING: \" +\n          (TransVarLeft == null ? \"null\" : TransVarLeft.getClass().getName()) + \" \" +\n          (TransVarRight == null ? \"null\" : TransVarRight.getClass().getName()));\n\n    if (!(!(TransVarLeft instanceof InitialContext || TransVarLeft instanceof SelfContext))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarLeft = ((EvalContext) TransVarLeft).getSingleNodePointer();\n    }\n\n    if (!(!(TransVarRight instanceof InitialContext || TransVarRight instanceof SelfContext))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarRight = ((EvalContext) TransVarRight).getSingleNodePointer();\n    }\n\n    if (!(!(TransVarLeft instanceof Collection))) {\n        TransVarLeft = ((Collection) TransVarLeft).iterator();\n    }\n\n    if (!(!(TransVarRight instanceof Collection))) {\n        TransVarRight = ((Collection) TransVarRight).iterator();\n    }\n\n    if (!(!((TransVarLeft instanceof Iterator) && !(TransVarRight instanceof Iterator)))) {\n        return contains((Iterator) TransVarLeft, TransVarRight);\n    }\n    if (!(!(!(TransVarLeft instanceof Iterator) && (TransVarRight instanceof Iterator)))) {\n        return contains((Iterator) TransVarRight, TransVarLeft);\n    }\n    if (!(!(TransVarLeft instanceof Iterator && TransVarRight instanceof Iterator))) {\n        return findMatch((Iterator) TransVarLeft, (Iterator) TransVarRight);\n    }\n    return equal(TransVarLeft, TransVarRight);\n}\n",
    "start": 45,
    "end": 83,
    "location": [
      60,
      67
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java"
  },
  "JxPath-8": {
    "buggy": "private boolean compute(Object TransVarLeft1, Object TransVarRight2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarLeft1 = reduce(TransVarLeft1);\n    TransVarRight2 = reduce(TransVarRight2);\n\n    if (!(!(TransVarLeft1 instanceof InitialContext))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        ((InitialContext) TransVarLeft1).reset();\n    }\n    if (!(!(TransVarRight2 instanceof InitialContext))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        ((InitialContext) TransVarRight2).reset();\n    }\n    if (!(!(TransVarLeft1 instanceof Iterator && TransVarRight2 instanceof Iterator))) {\n        return findMatch((Iterator) TransVarLeft1, (Iterator) TransVarRight2);\n    }\n    if (!(!(TransVarLeft1 instanceof Iterator))) {\n        return containsMatch((Iterator) TransVarLeft1, TransVarRight2);\n    }\n    if (!(!(TransVarRight2 instanceof Iterator))) {\n        return containsMatch((Iterator) TransVarRight2, TransVarLeft1);\n    }\n    double TransVarLeftDouble = InfoSetUtil.doubleValue(TransVarLeft1);\n    double TransVarRightDouble = InfoSetUtil.doubleValue(TransVarRight2); \n    return evaluateCompare(TransVarLeftDouble == TransVarRightDouble ? 0 : TransVarLeftDouble < TransVarRightDouble ? -1 : 1); \n}\n",
    "start": 56,
    "end": 78,
    "location": [
      85,
      86
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java"
  },
  "Lang-1": {
    "buggy": "public static Number createNumber(final String TransVarStr1) throws NumberFormatException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(StringUtils.isBlank(TransVarStr1)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] TransVarPrefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int TransVarPrefixLength = 0;\n    for(final String TransVarPrefix : TransVarPrefixes) {\n        if (!(!(TransVarStr1.startsWith(TransVarPrefix)))) {\n            TransVarPrefixLength += TransVarPrefix.length();\n            break;\n        }\n    }\n    if (!(!(TransVarPrefixLength > 0))) { // we have a hex number\n        final int TransVarNewHexDigits = TransVarStr1.length() - TransVarPrefixLength; \n        if (!(!(TransVarNewHexDigits > 16))) { // too many for Long \n            return createBigInteger(TransVarStr1);\n        }\n        if (!(!(TransVarNewHexDigits > 8))) { // too many for an int \n            return createLong(TransVarStr1);\n        }\n        return createInteger(TransVarStr1);\n    }\n    final char TransVarCh = TransVarStr1.charAt(TransVarStr1.length() - 1);\n    String TransVarDigits;\n    String TransVarHex;\n    String TransVarExpression;\n    final int TransVarDecPos2 = TransVarStr1.indexOf('.');\n    final int TransVarExpPos2 = TransVarStr1.indexOf('e') + TransVarStr1.indexOf('E') + 1; // assumes both not present\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n    int TransVarHexLength = 0; // Check required precision (LANG-693)\n    if (!(!(TransVarDecPos2 > -1))) { // there is a decimal point\n\n        if (!(!(TransVarExpPos2 > -1))) { // there is an exponent\n            if (!(!(TransVarExpPos2 < TransVarDecPos2 || TransVarExpPos2 > TransVarStr1.length()))) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            TransVarHex = TransVarStr1.substring(TransVarDecPos2 + 1, TransVarExpPos2);\n        } else {\n            TransVarHex = TransVarStr1.substring(TransVarDecPos2 + 1);\n        }\n        TransVarDigits = TransVarStr1.substring(0, TransVarDecPos2);\n        TransVarHexLength = TransVarHex.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n    } else {\n        if (!(!(TransVarExpPos2 > -1))) {\n            if (!(!(TransVarExpPos2 > TransVarStr1.length()))) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            TransVarDigits = TransVarStr1.substring(0, TransVarExpPos2);\n        } else {\n            TransVarDigits = TransVarStr1;\n        }\n        TransVarHex = null;\n    }\n    if (!(!(!Character.isDigit(TransVarCh) && TransVarCh != '.'))) {\n        if (!(!(TransVarExpPos2 > -1 && TransVarExpPos2 < TransVarStr1.length() - 1))) {\n            TransVarExpression = TransVarStr1.substring(TransVarExpPos2 + 1, TransVarStr1.length() - 1);\n        } else {\n            TransVarExpression = null;\n        }\n        //Requesting a specific type..\n        final String TransVarStr = TransVarStr1.substring(0, TransVarStr1.length() - 1);\n        final boolean TransVarAllZeros1 = isAllZeros(TransVarDigits) && isAllZeros(TransVarExpression);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'l'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'L'))))) {\n                TransFallThroughFlag0 = true;\n                if (!(!(TransVarHex == null && TransVarExpression == null\n                        && (TransVarStr.charAt(0) == '-' && isDigits(TransVarStr.substring(1))\n                                || isDigits(TransVarStr))))) {\n                    try {\n                        return createLong(TransVarStr);\n                    } catch (final NumberFormatException TransVarNumFe) {\n                    }\n                    return createBigInteger(TransVarStr);\n                }\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'F'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    final Float TransVarFloatNum = NumberUtils.createFloat(TransVarStr);\n                    if (!(!(!(TransVarFloatNum.isInfinite()\n                            || (TransVarFloatNum.floatValue() == 0.0F && !TransVarAllZeros1))))) {\n                        return TransVarFloatNum;\n                    }\n                } catch (final NumberFormatException TransVarNfe2) {\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'd'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'D'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    final Double TransVarValue = NumberUtils.createDouble(TransVarStr);\n                    if (!(!(!(TransVarValue.isInfinite() || (TransVarValue.floatValue() == 0.0D && !TransVarAllZeros1))))) {\n                        return TransVarValue;\n                    }\n                } catch (final NumberFormatException TransVarFe) {\n                }\n                try {\n                    return createBigDecimal(TransVarStr);\n                } catch (final NumberFormatException TransVarException) {\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (!(!(TransVarExpPos2 > -1 && TransVarExpPos2 < TransVarStr1.length() - 1))) {\n        TransVarExpression = TransVarStr1.substring(TransVarExpPos2 + 1, TransVarStr1.length());\n    } else {\n        TransVarExpression = null;\n    }\n    if (!(!(TransVarHex == null && TransVarExpression == null))) { // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(TransVarStr1);\n        } catch (final NumberFormatException TransVarNfe1) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(TransVarStr1);\n        } catch (final NumberFormatException TransVarNumberFormatException) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(TransVarStr1);\n    }\n\n    //Must be a Float, Double, BigDecimal\n    final boolean TransVarAllZeros2 = isAllZeros(TransVarDigits) && isAllZeros(TransVarExpression);\n    try {\n        if(!(!(TransVarHexLength <= 7))){// If number has 7 or fewer digits past the decimal point then make it a float\n            final Float TransVarFloatVal = createFloat(TransVarStr1);\n            if (!(!(!(TransVarFloatVal.isInfinite() || (TransVarFloatVal.floatValue() == 0.0F && !TransVarAllZeros2))))) {\n                return TransVarFloatVal;\n            }\n        }\n    } catch (final NumberFormatException TransVarNumberFormatExcep) { // NOPMD\n        // ignore the bad number\n    }\n    try {\n        if(!(!(TransVarHexLength <= 16))){// If number has between 8 and 16 digits past the decimal point then make it a double\n            final Double TransVarDoubleVal = createDouble(TransVarStr1);\n            if (!(!(!(TransVarDoubleVal.isInfinite() || (TransVarDoubleVal.doubleValue() == 0.0D && !TransVarAllZeros2))))) {\n                return TransVarDoubleVal;\n            }\n        }\n    } catch (final NumberFormatException TransVarNfe3) { // NOPMD\n        // ignore the bad number\n    }\n\n    return createBigDecimal(TransVarStr1);\n}\n",
    "start": 450,
    "end": 614,
    "location": [
      476,
      477,
      480
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
  },
  "Lang-11": {
    "buggy": "public static String random(int TransVarSum, int TransVarNewStart, int TransVarNewEnd, boolean TransVarStart, boolean TransVarBool,\n                            char[] TransVarCharList, Random TransVarRan) {\n    if (!(!(false))) {\n                                    System.out.println(\"log\");\n                                }\n    if (!(!(TransVarSum == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return \"\";\n    } else if (!(!(TransVarSum < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Requested random string length \" + TransVarSum + \" is less than 0.\");\n    }\n    if (!(!(TransVarCharList != null && TransVarCharList.length == 0))) {\n        throw new IllegalArgumentException(\"The chars array must not be empty\");\n    }\n\n    if (!(!(TransVarNewStart == 0 && TransVarNewEnd == 0))) {\n        if (!(!(TransVarCharList != null))) {\n            TransVarNewEnd = TransVarCharList.length;\n        } else {\n            if (!(!(!TransVarStart && !TransVarBool))) {\n                TransVarNewEnd = Integer.MAX_VALUE;\n            } else {\n                TransVarNewEnd = 'z' + 1;\n                TransVarNewStart = ' ';                \n            }\n        }\n    } \n\n    char[] TransVarBuffer1 = new char[TransVarSum];\n    int TransVarNewGap = TransVarNewEnd - TransVarNewStart;\n\n    for (; !(!(TransVarSum-- != 0));) {\n        char TransVarCharChar;\n        if (!(!(TransVarCharList == null))) {\n            TransVarCharChar = (char) (TransVarRan.nextInt(TransVarNewGap) + TransVarNewStart);\n        } else {\n            TransVarCharChar = TransVarCharList[TransVarRan.nextInt(TransVarNewGap) + TransVarNewStart];\n        }\n        if (!(!(TransVarStart && Character.isLetter(TransVarCharChar) || TransVarBool && Character.isDigit(TransVarCharChar)\n                || !TransVarStart && !TransVarBool))) {\n            if (!(!(TransVarCharChar >= 56320 && TransVarCharChar <= 57343))) {\n                if (!(!(TransVarSum == 0))) {\n                    TransVarSum++;\n                } else {\n                    TransVarBuffer1[TransVarSum] = TransVarCharChar;\n                    TransVarSum--;\n                    TransVarBuffer1[TransVarSum] = (char) (55296 + TransVarRan.nextInt(128));\n                }\n            } else if (!(!(TransVarCharChar >= 55296 && TransVarCharChar <= 56191))) {\n                if (!(!(TransVarSum == 0))) {\n                    TransVarSum++;\n                } else {\n                    TransVarBuffer1[TransVarSum] = (char) (56320 + TransVarRan.nextInt(128));\n                    TransVarSum--;\n                    TransVarBuffer1[TransVarSum] = TransVarCharChar;\n                }\n            } else if (!(!(TransVarCharChar >= 56192 && TransVarCharChar <= 56319))) {\n                TransVarSum++;\n            } else {\n                TransVarBuffer1[TransVarSum] = TransVarCharChar;\n            }\n        } else {\n            TransVarSum++;\n        }\n    }\n    return new String(TransVarBuffer1);\n}\n",
    "start": 223,
    "end": 289,
    "location": [
      254
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java"
  },
  "Lang-12": {
    "buggy": "public static String random(int TransVarCount1, int TransVarCount, int TransVarCount2, boolean TransVarLetter, boolean TransVarNum,\n                            char[] TransVarCharacterArray, Random TransVarRandomNumber) {\n    if (!(!(false))) {\n                                    System.out.println(\"log\");\n                                }\n    if (!(!(TransVarCount1 == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return \"\";\n    } else if (!(!(TransVarCount1 < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Requested random string length \" + TransVarCount1 + \" is less than 0.\");\n    }\n \n    if (!(!(TransVarCount == 0 && TransVarCount2 == 0))) {\n            if (!(!(!TransVarLetter && !TransVarNum))) { \n                TransVarCount2 = Integer.MAX_VALUE;\n            } else {\n                TransVarCount2 = 'z' + 1;\n                TransVarCount = ' ';                \n            }\n    } \n\n    char[] TransVarBufferChar = new char[TransVarCount1];\n    int TransVarSpaceCount = TransVarCount2 - TransVarCount;\n\n    for (; !(!(TransVarCount1-- != 0));) {\n        char TransVarCharacter;\n        if (!(!(TransVarCharacterArray == null))) {\n            TransVarCharacter = (char) (TransVarRandomNumber.nextInt(TransVarSpaceCount) + TransVarCount);\n        } else {\n            TransVarCharacter = TransVarCharacterArray[TransVarRandomNumber.nextInt(TransVarSpaceCount)\n                    + TransVarCount];\n        }\n        if (!(!(TransVarLetter && Character.isLetter(TransVarCharacter)\n                || TransVarNum && Character.isDigit(TransVarCharacter) || !TransVarLetter && !TransVarNum))) {\n            if (!(!(TransVarCharacter >= 56320 && TransVarCharacter <= 57343))) {\n                if (!(!(TransVarCount1 == 0))) {\n                    TransVarCount1++;\n                } else {\n                    TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                    TransVarCount1--;\n                    TransVarBufferChar[TransVarCount1] = (char) (55296 + TransVarRandomNumber.nextInt(128));\n                }\n            } else if (!(!(TransVarCharacter >= 55296 && TransVarCharacter <= 56191))) {\n                if (!(!(TransVarCount1 == 0))) {\n                    TransVarCount1++;\n                } else {\n                    TransVarBufferChar[TransVarCount1] = (char) (56320 + TransVarRandomNumber.nextInt(128));\n                    TransVarCount1--;\n                    TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n                }\n            } else if (!(!(TransVarCharacter >= 56192 && TransVarCharacter <= 56319))) {\n                TransVarCount1++;\n            } else {\n                TransVarBufferChar[TransVarCount1] = TransVarCharacter;\n            }\n        } else {\n            TransVarCount1++;\n        }\n    }\n    return new String(TransVarBufferChar);\n}\n",
    "start": 223,
    "end": 282,
    "location": [
      239,
      241,
      247
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/RandomStringUtils.java"
  },
  "Lang-14": {
    "buggy": "public static boolean equals(CharSequence TransVarCs, CharSequence TransVarCs1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarCs == TransVarCs1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n    if (!(!(TransVarCs == null || TransVarCs1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n        return TransVarCs.equals(TransVarCs1); \n} \n",
    "start": 781,
    "end": 789,
    "location": [
      797,
      798
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java"
  },
  "Lang-16": {
    "buggy": "public static Number createNumber(String TransVarStr2) throws NumberFormatException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr2 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(StringUtils.isBlank(TransVarStr2)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (!(!(TransVarStr2.startsWith(\"--\")))) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (!(!(TransVarStr2.startsWith(\"0x\") || TransVarStr2.startsWith(\"-0x\")))) { \n        return createInteger(TransVarStr2);\n    }   \n    char TransVarLast = TransVarStr2.charAt(TransVarStr2.length() - 1);\n    String TransVarFirst;\n    String TransVarDeci;\n    String TransVarEx;\n    int TransVarIndex = TransVarStr2.indexOf('.');\n    int TransVarExpPos1 = TransVarStr2.indexOf('e') + TransVarStr2.indexOf('E') + 1;\n\n    if (!(!(TransVarIndex > -1))) {\n\n        if (!(!(TransVarExpPos1 > -1))) {\n            if (!(!(TransVarExpPos1 < TransVarIndex || TransVarExpPos1 > TransVarStr2.length()))) {\n                throw new NumberFormatException(TransVarStr2 + \" is not a valid number.\");\n            }\n            TransVarDeci = TransVarStr2.substring(TransVarIndex + 1, TransVarExpPos1);\n        } else {\n            TransVarDeci = TransVarStr2.substring(TransVarIndex + 1);\n        }\n        TransVarFirst = TransVarStr2.substring(0, TransVarIndex);\n    } else {\n        if (!(!(TransVarExpPos1 > -1))) {\n            if (!(!(TransVarExpPos1 > TransVarStr2.length()))) {\n                throw new NumberFormatException(TransVarStr2 + \" is not a valid number.\");\n            }\n            TransVarFirst = TransVarStr2.substring(0, TransVarExpPos1);\n        } else {\n            TransVarFirst = TransVarStr2;\n        }\n        TransVarDeci = null;\n    }\n    if (!(!(!Character.isDigit(TransVarLast) && TransVarLast != '.'))) {\n        if (!(!(TransVarExpPos1 > -1 && TransVarExpPos1 < TransVarStr2.length() - 1))) {\n            TransVarEx = TransVarStr2.substring(TransVarExpPos1 + 1, TransVarStr2.length() - 1);\n        } else {\n            TransVarEx = null;\n        }\n        //Requesting a specific type..\n        String TransVarNumericString = TransVarStr2.substring(0, TransVarStr2.length() - 1);\n        boolean TransVarAllZero = isAllZeros(TransVarFirst) && isAllZeros(TransVarEx);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLast == 'l'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLast == 'L'))))) {\n                TransFallThroughFlag0 = true;\n                if (!(!(TransVarDeci == null && TransVarEx == null\n                        && (TransVarNumericString.charAt(0) == '-' && isDigits(TransVarNumericString.substring(1))\n                                || isDigits(TransVarNumericString))))) {\n                    try {\n                        return createLong(TransVarNumericString);\n                    } catch (NumberFormatException TransVarNfe1) {\n                    }\n                    return createBigInteger(TransVarNumericString);\n                }\n                throw new NumberFormatException(TransVarStr2 + \" is not a valid number.\");\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLast == 'f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLast == 'F'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Float TransVarF1 = NumberUtils.createFloat(TransVarNumericString);\n                    if (!(!(!(TransVarF1.isInfinite() || (TransVarF1.floatValue() == 0.0F && !TransVarAllZero))))) {\n                        return TransVarF1;\n                    }\n                } catch (NumberFormatException TransVarNfe2) {\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLast == 'd'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLast == 'D'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Double TransVarDbl = NumberUtils.createDouble(TransVarNumericString);\n                    if (!(!(!(TransVarDbl.isInfinite() || (TransVarDbl.floatValue() == 0.0D && !TransVarAllZero))))) {\n                        return TransVarDbl;\n                    }\n                } catch (NumberFormatException TransVarNfe3) {\n                }\n                try {\n                    return createBigDecimal(TransVarNumericString);\n                } catch (NumberFormatException TransVarNfe) {\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new NumberFormatException(TransVarStr2 + \" is not a valid number.\");\n            }\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (!(!(TransVarExpPos1 > -1 && TransVarExpPos1 < TransVarStr2.length() - 1))) {\n            TransVarEx = TransVarStr2.substring(TransVarExpPos1 + 1, TransVarStr2.length());\n        } else {\n            TransVarEx = null;\n        }\n        if (!(!(TransVarDeci == null && TransVarEx == null))) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(TransVarStr2);\n            } catch (NumberFormatException TransVarNfe5) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                return createLong(TransVarStr2);\n            } catch (NumberFormatException TransVarNfe6) { // NOPMD\n                // ignore the bad number\n            }\n            return createBigInteger(TransVarStr2);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean TransVarAllZeros1 = isAllZeros(TransVarFirst) && isAllZeros(TransVarEx);\n            try {\n                Float TransVarFloat1 = createFloat(TransVarStr2);\n                if (!(!(!(TransVarFloat1.isInfinite() || (TransVarFloat1.floatValue() == 0.0F && !TransVarAllZeros1))))) {\n                    return TransVarFloat1;\n                }\n            } catch (NumberFormatException TransVarNfe4) { // NOPMD\n                // ignore the bad number\n            }\n            try {\n                Double TransVarNumber = createDouble(TransVarStr2);\n                if (!(!(!(TransVarNumber.isInfinite() || (TransVarNumber.doubleValue() == 0.0D && !TransVarAllZeros1))))) {\n                    return TransVarNumber;\n                }\n            } catch (NumberFormatException TransVarNumberFormatException) { // NOPMD\n                // ignore the bad number\n            }\n\n            return createBigDecimal(TransVarStr2);\n\n        }\n    }\n}\n",
    "start": 444,
    "end": 594,
    "location": [
      467
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
  },
  "Lang-21": {
    "buggy": "public static boolean isSameLocalTime(Calendar TransVarCal, Calendar TransVarCal3) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarCal == null || TransVarCal3 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (TransVarCal.get(Calendar.MILLISECOND) == TransVarCal3.get(Calendar.MILLISECOND) &&\n            TransVarCal.get(Calendar.SECOND) == TransVarCal3.get(Calendar.SECOND) &&\n            TransVarCal.get(Calendar.MINUTE) == TransVarCal3.get(Calendar.MINUTE) &&\n            TransVarCal.get(Calendar.HOUR) == TransVarCal3.get(Calendar.HOUR) && \n            TransVarCal.get(Calendar.DAY_OF_YEAR) == TransVarCal3.get(Calendar.DAY_OF_YEAR) &&\n            TransVarCal.get(Calendar.YEAR) == TransVarCal3.get(Calendar.YEAR) &&\n            TransVarCal.get(Calendar.ERA) == TransVarCal3.get(Calendar.ERA) &&\n            TransVarCal.getClass() == TransVarCal3.getClass());\n}\n",
    "start": 258,
    "end": 270,
    "location": [
      271
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/time/DateUtils.java"
  },
  "Lang-22": {
    "buggy": "private static int greatestCommonDivisor(int TransVarX, int TransVarU) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // From Commons Math:\n    //if either operand is abs 1, return 1: \n    if (!(!(Math.abs(TransVarX) <= 1 || Math.abs(TransVarU) <= 1))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (!(!(TransVarX > 0))) { if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarX=-TransVarX; } // make u negative\n    if (!(!(TransVarU > 0))) { TransVarU=-TransVarU; } // make v negative\n    // B1. [Find power of 2]\n    int TransVarY=0;\n    for (; !(!((TransVarX & 1) == 0 && (TransVarU & 1) == 0 && TransVarY < 31));) {\n        TransVarX /= 2;\n        TransVarU /= 2;\n        TransVarY++;\n    }\n    if (!(!(TransVarY == 31))) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int TransVarValue = ((TransVarX&1)==1) ? TransVarU : -(TransVarX/2)/*B3*/;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        for (; !(!((TransVarValue & 1) == 0));) {\n            TransVarValue /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (!(!(TransVarValue > 0))) {\n            TransVarX = -TransVarValue;\n        } else {\n            TransVarU = TransVarValue;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        TransVarValue = (TransVarU - TransVarX)/2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (!(!(TransVarValue != 0)));\n    return -TransVarX*(1<<TransVarY); // gcd is u*2^k\n}\n",
    "start": 581,
    "end": 624,
    "location": [
      586,
      587
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/math/Fraction.java"
  },
  "Lang-24": {
    "buggy": "public static boolean isNumber(String TransVarString) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(StringUtils.isEmpty(TransVarString)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    char[] TransVarStrArr = TransVarString.toCharArray();\n    int TransVarCharLength = TransVarStrArr.length;\n    boolean TransVarHasExpression = false;\n    boolean TransVarHasDecimalPoint = false;\n    boolean TransVarHasSigns = false;\n    boolean TransVarFoundDigitInt = false;\n    // deal with any possible sign up front\n    int TransVarStartOfNumber = (TransVarStrArr[0] == '-') ? 1 : 0;\n    if (!(!(TransVarCharLength > TransVarStartOfNumber + 1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarStrArr[TransVarStartOfNumber] == '0' && TransVarStrArr[TransVarStartOfNumber + 1] == 'x'))) {\n            int TransVarIndex = TransVarStartOfNumber + 2;\n            if (!(!(TransVarIndex == TransVarCharLength))) {\n                return false; // str == \"0x\"\n            }\n            while (!(!(TransVarIndex < TransVarStrArr.length))) {\n                if (!(!((TransVarStrArr[TransVarIndex] < '0' || TransVarStrArr[TransVarIndex] > '9')\n                        && (TransVarStrArr[TransVarIndex] < 'a' || TransVarStrArr[TransVarIndex] > 'f')\n                        && (TransVarStrArr[TransVarIndex] < 'A' || TransVarStrArr[TransVarIndex] > 'F')))) {\n                    return false;\n                }\n                TransVarIndex++;\n            }\n            return true;\n        }\n    }\n    TransVarCharLength--; // don't want to loop to the last char, check it afterwords\n          // for type qualifiers\n    int TransVarCount = TransVarStartOfNumber;\n    for (; !(!(TransVarCount < TransVarCharLength\n            || (TransVarCount < TransVarCharLength + 1 && TransVarHasSigns && !TransVarFoundDigitInt)));) {\n        if (!(!(TransVarStrArr[TransVarCount] >= '0' && TransVarStrArr[TransVarCount] <= '9'))) {\n            TransVarFoundDigitInt = true;\n            TransVarHasSigns = false;\n        } else if (!(!(TransVarStrArr[TransVarCount] == '.'))) {\n            if (!(!(TransVarHasDecimalPoint || TransVarHasExpression))) {\n                return false;\n            }\n            TransVarHasDecimalPoint = true;\n        } else if (!(!(TransVarStrArr[TransVarCount] == 'e' || TransVarStrArr[TransVarCount] == 'E'))) {\n            if (!(!(TransVarHasExpression))) {\n                return false;\n            }\n            if (!(!(!TransVarFoundDigitInt))) {\n                return false;\n            }\n            TransVarHasExpression = true;\n            TransVarHasSigns = true;\n        } else if (!(!(TransVarStrArr[TransVarCount] == '+' || TransVarStrArr[TransVarCount] == '-'))) {\n            if (!(!(!TransVarHasSigns))) {\n                return false;\n            }\n            TransVarHasSigns = false;\n            TransVarFoundDigitInt = false;\n        } else {\n            return false;\n        }\n        TransVarCount++;\n    }\n    if (!(!(TransVarCount < TransVarStrArr.length))) {\n        if (!(!(TransVarStrArr[TransVarCount] >= '0' && TransVarStrArr[TransVarCount] <= '9'))) {\n            // no type qualifier, OK\n            return true;\n        }\n        if (!(!(TransVarStrArr[TransVarCount] == 'e' || TransVarStrArr[TransVarCount] == 'E'))) {\n            // can't have an E at the last byte\n            return false;\n        }\n        if (!(!(TransVarStrArr[TransVarCount] == '.'))) {\n            if (!(!(TransVarHasDecimalPoint || TransVarHasExpression))) {\n                // two decimal points or dec in exponent\n                return false;\n            }\n            // single trailing decimal point after non-exponent is ok\n            return TransVarFoundDigitInt;\n        }\n        if (!(!(!TransVarHasSigns && (TransVarStrArr[TransVarCount] == 'd' || TransVarStrArr[TransVarCount] == 'D'\n                || TransVarStrArr[TransVarCount] == 'f' || TransVarStrArr[TransVarCount] == 'F')))) {\n            return TransVarFoundDigitInt;\n        }\n        if (!(!(TransVarStrArr[TransVarCount] == 'l' || TransVarStrArr[TransVarCount] == 'L'))) {\n            // not allowing L with an exponent or decimal point\n            return TransVarFoundDigitInt && !TransVarHasExpression; \n        }\n        // last character is illegal\n        return false;\n    }\n    // allowSigns is true iff the val ends in 'E'\n    // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n    return !TransVarHasSigns && TransVarFoundDigitInt;\n}\n",
    "start": 1319,
    "end": 1421,
    "location": [
      1413
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
  },
  "Lang-26": {
    "buggy": "public String format(Date TransVarDateTime) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Calendar TransVarCalendar = new GregorianCalendar(mTimeZone); \n    TransVarCalendar.setTime(TransVarDateTime);\n    return applyRules(TransVarCalendar, new StringBuffer(mMaxLengthEstimate)).toString();\n}\n",
    "start": 819,
    "end": 823,
    "location": [
      823
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateFormat.java"
  },
  "Lang-27": {
    "buggy": "public static Number createNumber(String TransVarStr1) throws NumberFormatException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(StringUtils.isBlank(TransVarStr1)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (!(!(TransVarStr1.startsWith(\"--\")))) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (!(!(TransVarStr1.startsWith(\"0x\") || TransVarStr1.startsWith(\"-0x\")))) {\n        return createInteger(TransVarStr1);\n    }   \n    char TransVarLastCharFromTheString = TransVarStr1.charAt(TransVarStr1.length() - 1);\n    String TransVarStr;\n    String TransVarNum;\n    String TransVarExp1;\n    int TransVarDecPos2 = TransVarStr1.indexOf('.');\n    int TransVarExpPos1 = TransVarStr1.indexOf('e') + TransVarStr1.indexOf('E') + 1;\n\n    if (!(!(TransVarDecPos2 > -1))) {\n\n        if (!(!(TransVarExpPos1 > -1))) {\n            if (!(!(TransVarExpPos1 < TransVarDecPos2))) { \n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            TransVarNum = TransVarStr1.substring(TransVarDecPos2 + 1, TransVarExpPos1);\n        } else {\n            TransVarNum = TransVarStr1.substring(TransVarDecPos2 + 1);\n        }\n        TransVarStr = TransVarStr1.substring(0, TransVarDecPos2);\n    } else {\n        if (!(!(TransVarExpPos1 > -1))) {\n            TransVarStr = TransVarStr1.substring(0, TransVarExpPos1); \n        } else {\n            TransVarStr = TransVarStr1;\n        }\n        TransVarNum = null;\n    }\n    if (!(!(!Character.isDigit(TransVarLastCharFromTheString) && TransVarLastCharFromTheString != '.'))) {\n        if (!(!(TransVarExpPos1 > -1 && TransVarExpPos1 < TransVarStr1.length() - 1))) {\n            TransVarExp1 = TransVarStr1.substring(TransVarExpPos1 + 1, TransVarStr1.length() - 1);\n        } else {\n            TransVarExp1 = null;\n        }\n        //Requesting a specific type..\n        String TransVarStr2 = TransVarStr1.substring(0, TransVarStr1.length() - 1);\n        boolean TransVarResultIsZero = isAllZeros(TransVarStr) && isAllZeros(TransVarExp1);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharFromTheString == 'l'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharFromTheString == 'L'))))) {\n                TransFallThroughFlag0 = true;\n                if (!(!(TransVarNum == null && TransVarExp1 == null\n                        && (TransVarStr2.charAt(0) == '-' && isDigits(TransVarStr2.substring(1))\n                                || isDigits(TransVarStr2))))) {\n                    try {\n                        return createLong(TransVarStr2);\n                    } catch (NumberFormatException TransVarNfe1) {\n                    }\n                    return createBigInteger(TransVarStr2);\n                }\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharFromTheString == 'f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharFromTheString == 'F'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Float TransVarF1 = NumberUtils.createFloat(TransVarStr2);\n                    if (!(!(!(TransVarF1.isInfinite() || (TransVarF1.floatValue() == 0.0F && !TransVarResultIsZero))))) {\n                        return TransVarF1;\n                    }\n                } catch (NumberFormatException TransVarNfe2) {\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharFromTheString == 'd'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharFromTheString == 'D'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Double TransVarDoubleValue = NumberUtils.createDouble(TransVarStr2);\n                    if (!(!(!(TransVarDoubleValue.isInfinite()\n                            || (TransVarDoubleValue.floatValue() == 0.0D && !TransVarResultIsZero))))) {\n                        return TransVarDoubleValue;\n                    }\n                } catch (NumberFormatException TransVarNumberFormatException) {\n                }\n                try {\n                    return createBigDecimal(TransVarStr2);\n                } catch (NumberFormatException TransVarNfe) {\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (!(!(TransVarExpPos1 > -1 && TransVarExpPos1 < TransVarStr1.length() - 1))) {\n            TransVarExp1 = TransVarStr1.substring(TransVarExpPos1 + 1, TransVarStr1.length());\n        } else {\n            TransVarExp1 = null;\n        }\n        if (!(!(TransVarNum == null && TransVarExp1 == null))) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(TransVarStr1);\n            } catch (NumberFormatException TransVarNumberFormat) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(TransVarStr1);\n            } catch (NumberFormatException TransVarNfex) {\n                // ignore the bad number\n            }\n            return createBigInteger(TransVarStr1);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean TransVarAllZerosAndPos = isAllZeros(TransVarStr) && isAllZeros(TransVarExp1);\n            try {\n                Float TransVarFloat1 = createFloat(TransVarStr1);\n                if (!(!(!(TransVarFloat1.isInfinite() || (TransVarFloat1.floatValue() == 0.0F && !TransVarAllZerosAndPos))))) {\n                    return TransVarFloat1;\n                }\n            } catch (NumberFormatException TransVarNf) {\n                // ignore the bad number\n            }\n            try {\n                Double TransVarD1 = createDouble(TransVarStr1);\n                if (!(!(!(TransVarD1.isInfinite() || (TransVarD1.doubleValue() == 0.0D && !TransVarAllZerosAndPos))))) {\n                    return TransVarD1;\n                }\n            } catch (NumberFormatException TransVarNfe3) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(TransVarStr1);\n\n        }\n    }\n}\n",
    "start": 452,
    "end": 599,
    "location": [
      488,
      498
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
  },
  "Lang-28": {
    "buggy": "public int translate(CharSequence TransVarUserInput, int TransVarSelectedItem, Writer TransVarWriter) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // TODO: Protect from ArrayIndexOutOfBounds\n    if(!(!(TransVarUserInput.charAt(TransVarSelectedItem) == '&'\n            && TransVarUserInput.charAt(TransVarSelectedItem + 1) == '#'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarNext = TransVarSelectedItem + 2;\n        boolean TransVarIsHexadecimal = false;\n\n        char TransVarFirstChar2 = TransVarUserInput.charAt(TransVarNext);\n        if(!(!(TransVarFirstChar2 == 'x' || TransVarFirstChar2 == 'X'))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarNext++;\n            TransVarIsHexadecimal = true;\n        }\n\n        int TransVarEndChar = TransVarNext;\n        for (; !(!(TransVarUserInput.charAt(TransVarEndChar) != ';'));) {\n            TransVarEndChar++;\n        }\n\n        int TransVarEntity;\n        try {\n            if(!(!(TransVarIsHexadecimal))) {\n                TransVarEntity = Integer.parseInt(TransVarUserInput.subSequence(TransVarNext, TransVarEndChar).toString(), 16);\n            } else {\n                TransVarEntity = Integer.parseInt(TransVarUserInput.subSequence(TransVarNext, TransVarEndChar).toString(), 10);\n            }\n        } catch(NumberFormatException TransVarNumFEx) {\n            return 0;\n        }\n\n            TransVarWriter.write(TransVarEntity); \n        return 2 + (TransVarEndChar - TransVarNext) + (TransVarIsHexadecimal ? 1 : 0) + 1; \n    }\n    return 0;\n}\n",
    "start": 35,
    "end": 67,
    "location": [
      73,
      74
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java"
  },
  "Lang-29": {
    "buggy": "static float toJavaVersionInt(String TransVarCurrentVersion) { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return toVersionInt(toJavaVersionIntArray(TransVarCurrentVersion, JAVA_VERSION_TRIM_SIZE));\n}\n",
    "start": 1672,
    "end": 1674,
    "location": [
      1672
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/SystemUtils.java"
  },
  "Lang-3": {
    "buggy": "public static Number createNumber(final String TransVarString) throws NumberFormatException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarString == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(StringUtils.isBlank(TransVarString)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }\n    // Need to deal with all possible hex prefixes here\n    final String[] TransVarPrefixList = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n    int TransVarPfxL = 0;\n    for(final String TransVarPrefix : TransVarPrefixList) {\n        if (!(!(TransVarString.startsWith(TransVarPrefix)))) {\n            TransVarPfxL += TransVarPrefix.length();\n            break;\n        }\n    }\n    if (!(!(TransVarPfxL > 0))) { // we have a hex number\n        final int TransVarNumHexDigits = TransVarString.length() - TransVarPfxL;\n        if (!(!(TransVarNumHexDigits > 16))) { // too many for Long\n            return createBigInteger(TransVarString);\n        }\n        if (!(!(TransVarNumHexDigits > 8))) { // too many for an int\n            return createLong(TransVarString);\n        }\n        return createInteger(TransVarString);\n    }\n    final char TransVarLastCharater = TransVarString.charAt(TransVarString.length() - 1);\n    String TransVarMantissa;\n    String TransVarDecimal;\n    String TransVarExpString;\n    final int TransVarDecPosi = TransVarString.indexOf('.');\n    final int TransVarExp = TransVarString.indexOf('e') + TransVarString.indexOf('E') + 1; // assumes both not present\n    // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n    // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n\n    int TransVarNumDecimalsInFraction = 0; // Check required precision (LANG-693)\n    if (!(!(TransVarDecPosi > -1))) { // there is a decimal point\n\n        if (!(!(TransVarExp > -1))) { // there is an exponent\n            if (!(!(TransVarExp < TransVarDecPosi || TransVarExp > TransVarString.length()))) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(TransVarString + \" is not a valid number.\");\n            }\n            TransVarDecimal = TransVarString.substring(TransVarDecPosi + 1, TransVarExp);\n        } else {\n            TransVarDecimal = TransVarString.substring(TransVarDecPosi + 1);\n        }\n        TransVarMantissa = TransVarString.substring(0, TransVarDecPosi);\n        TransVarNumDecimalsInFraction = TransVarDecimal.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n    } else {\n        if (!(!(TransVarExp > -1))) {\n            if (!(!(TransVarExp > TransVarString.length()))) { // prevents double exponent causing IOOBE\n                throw new NumberFormatException(TransVarString + \" is not a valid number.\");\n            }\n            TransVarMantissa = TransVarString.substring(0, TransVarExp);\n        } else {\n            TransVarMantissa = TransVarString;\n        }\n        TransVarDecimal = null;\n    }\n    if (!(!(!Character.isDigit(TransVarLastCharater) && TransVarLastCharater != '.'))) {\n        if (!(!(TransVarExp > -1 && TransVarExp < TransVarString.length() - 1))) {\n            TransVarExpString = TransVarString.substring(TransVarExp + 1, TransVarString.length() - 1);\n        } else {\n            TransVarExpString = null;\n        }\n        //Requesting a specific type..\n        final String TransVarNumericValue = TransVarString.substring(0, TransVarString.length() - 1);\n        final boolean TransVarAllZerosAndNegative = isAllZeros(TransVarMantissa) && isAllZeros(TransVarExpString);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharater == 'l'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharater == 'L'))))) {\n                TransFallThroughFlag0 = true;\n                if (!(!(TransVarDecimal == null && TransVarExpString == null\n                        && (TransVarNumericValue.charAt(0) == '-' && isDigits(TransVarNumericValue.substring(1))\n                                || isDigits(TransVarNumericValue))))) {\n                    try {\n                        return createLong(TransVarNumericValue);\n                    } catch (final NumberFormatException TransVarNfEx) {\n                    }\n                    return createBigInteger(TransVarNumericValue);\n                }\n                throw new NumberFormatException(TransVarString + \" is not a valid number.\");\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharater == 'f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharater == 'F'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    final Float TransVarF1 = NumberUtils.createFloat(TransVarNumericValue);\n                    if (!(!(!(TransVarF1.isInfinite()\n                            || (TransVarF1.floatValue() == 0.0F && !TransVarAllZerosAndNegative))))) {\n                        return TransVarF1;\n                    }\n                } catch (final NumberFormatException TransVarNfeIn) {\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharater == 'd'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharater == 'D'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    final Double TransVarData = NumberUtils.createDouble(TransVarNumericValue);\n                    if (!(!(!(TransVarData.isInfinite()\n                            || (TransVarData.floatValue() == 0.0D && !TransVarAllZerosAndNegative))))) {\n                        return TransVarData;\n                    }\n                } catch (final NumberFormatException TransVarNfe2) {\n                }\n                try {\n                    return createBigDecimal(TransVarNumericValue);\n                } catch (final NumberFormatException TransVarNfe) {\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new NumberFormatException(TransVarString + \" is not a valid number.\");\n            }\n        }\n    }\n    //User doesn't have a preference on the return type, so let's start\n    //small and go from there...\n    if (!(!(TransVarExp > -1 && TransVarExp < TransVarString.length() - 1))) {\n        TransVarExpString = TransVarString.substring(TransVarExp + 1, TransVarString.length());\n    } else {\n        TransVarExpString = null;\n    }\n    if (!(!(TransVarDecimal == null && TransVarExpString == null))) { // no decimal point and no exponent\n        //Must be an Integer, Long, Biginteger\n        try {\n            return createInteger(TransVarString);\n        } catch (final NumberFormatException TransVarNfe1) { // NOPMD\n            // ignore the bad number\n        }\n        try {\n            return createLong(TransVarString);\n        } catch (final NumberFormatException TransVarNfex) { // NOPMD\n            // ignore the bad number\n        }\n        return createBigInteger(TransVarString);\n    }\n\n    //Must be a Float, Double, BigDecimal\n    final boolean TransVarZero = isAllZeros(TransVarMantissa) && isAllZeros(TransVarExpString);\n    try {\n            final Float TransVarValue = createFloat(TransVarString); \n            if (!(!(!(TransVarValue.isInfinite() || (TransVarValue.floatValue() == 0.0F && !TransVarZero))))) {\n                return TransVarValue;\n            }\n    } catch (final NumberFormatException TransVarNumberFormatException) { // NOPMD \n        // ignore the bad number\n    }\n    try {\n            final Double TransVarNumber = createDouble(TransVarString); \n            if (!(!(!(TransVarNumber.isInfinite() || (TransVarNumber.doubleValue() == 0.0D && !TransVarZero))))) {\n                return TransVarNumber;\n            }\n    } catch (final NumberFormatException TransVarNfe3) { // NOPMD \n        // ignore the bad number\n    }\n\n    return createBigDecimal(TransVarString);\n}\n",
    "start": 450,
    "end": 610,
    "location": [
      608,
      612,
      616,
      620
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/math/NumberUtils.java"
  },
  "Lang-37": {
    "buggy": "public static <T> T[] addAll(T[] TransVarArray, T... TransVarArray3) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarArray == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return clone(TransVarArray3);\n    } else if (!(!(TransVarArray3 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return clone(TransVarArray);\n    }\n    final Class<?> TransVarType2 = TransVarArray.getClass().getComponentType();\n    T[] TransVarType = (T[]) Array.newInstance(TransVarType2, TransVarArray.length + TransVarArray3.length);\n    System.arraycopy(TransVarArray, 0, TransVarType, 0, TransVarArray.length);\n        System.arraycopy(TransVarArray3, 0, TransVarType, TransVarArray.length, TransVarArray3.length); \n        // Check if problem is incompatible types \n    return TransVarType; \n}\n",
    "start": 2953,
    "end": 2965,
    "location": [
      2971,
      2972,
      2973
    ],
    "file_path": "src/java/org/apache/commons/lang3/ArrayUtils.java"
  },
  "Lang-38": {
    "buggy": "public StringBuffer format(Calendar TransVarLocalCalendar, StringBuffer TransVarLocalBuffer) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(mTimeZoneForced))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarLocalCalendar = (Calendar) TransVarLocalCalendar.clone(); \n        TransVarLocalCalendar.setTimeZone(mTimeZone);\n    }\n    return applyRules(TransVarLocalCalendar, TransVarLocalBuffer);\n}\n",
    "start": 870,
    "end": 876,
    "location": [
      878
    ],
    "file_path": "src/java/org/apache/commons/lang3/time/FastDateFormat.java"
  },
  "Lang-40": {
    "buggy": "public static boolean containsIgnoreCase(String TransVarString, String TransVarSearchString) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarString == null || TransVarSearchString == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    return contains(TransVarString.toUpperCase(), TransVarSearchString.toUpperCase()); \n}\n",
    "start": 1044,
    "end": 1049,
    "location": [
      1054
    ],
    "file_path": "src/java/org/apache/commons/lang/StringUtils.java"
  },
  "Lang-43": {
    "buggy": "private StringBuffer appendQuotedString(String TransVarStringPattern, ParsePosition TransVarParsePosition,\n        StringBuffer TransVarAppendToBuffer, boolean TransVarEscaping) {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    int TransVarPosStart = TransVarParsePosition.getIndex();\n    char[] TransVarCTemp = TransVarStringPattern.toCharArray();\n    if (!(!(TransVarEscaping && TransVarCTemp[TransVarPosStart] == QUOTE))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarAppendToBuffer == null ? null : TransVarAppendToBuffer.append(QUOTE); \n    }\n    int TransVarHold = TransVarPosStart;\n    int TransVarIndex = TransVarParsePosition.getIndex();\n    while (!(!(TransVarIndex < TransVarStringPattern.length()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarEscaping && TransVarStringPattern.substring(TransVarIndex).startsWith(ESCAPED_QUOTE)))) {\n            TransVarAppendToBuffer.append(TransVarCTemp, TransVarHold, TransVarParsePosition.getIndex() - TransVarHold)\n                    .append(QUOTE);\n            TransVarParsePosition.setIndex(TransVarIndex + ESCAPED_QUOTE.length());\n            TransVarHold = TransVarParsePosition.getIndex();\n            continue;\n        }\n        switch (TransVarCTemp[TransVarParsePosition.getIndex()]) {\n        case QUOTE:\n            next(TransVarParsePosition);\n            return TransVarAppendToBuffer == null ? null\n                    : TransVarAppendToBuffer.append(TransVarCTemp, TransVarHold,\n                            TransVarParsePosition.getIndex() - TransVarHold);\n        default:\n            next(TransVarParsePosition);\n        }\n        TransVarIndex++;\n    }\n    throw new IllegalArgumentException(\n            \"Unterminated quoted string at position \" + TransVarPosStart);\n}\n",
    "start": 417,
    "end": 444,
    "location": [
      428
    ],
    "file_path": "src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java"
  },
  "Lang-44": {
    "buggy": "public static Number createNumber(String TransVarStr) throws NumberFormatException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(TransVarStr.length() == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (!(!(TransVarStr.startsWith(\"--\")))) { \n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (!(!(TransVarStr.startsWith(\"0x\") || TransVarStr.startsWith(\"-0x\")))) {\n        return createInteger(TransVarStr);\n    }   \n    char TransVarLastCharacter = TransVarStr.charAt(TransVarStr.length() - 1);\n    String TransVarMantissa;\n    String TransVarNewDecimal;\n    String TransVarExponent;\n    int TransVarDec = TransVarStr.indexOf('.');\n    int TransVarExpPos1 = TransVarStr.indexOf('e') + TransVarStr.indexOf('E') + 1;\n\n    if (!(!(TransVarDec > -1))) {\n\n        if (!(!(TransVarExpPos1 > -1))) {\n            if (!(!(TransVarExpPos1 < TransVarDec))) {\n                throw new NumberFormatException(TransVarStr + \" is not a valid number.\");\n            }\n            TransVarNewDecimal = TransVarStr.substring(TransVarDec + 1, TransVarExpPos1);\n        } else {\n            TransVarNewDecimal = TransVarStr.substring(TransVarDec + 1);\n        }\n        TransVarMantissa = TransVarStr.substring(0, TransVarDec);\n    } else {\n        if (!(!(TransVarExpPos1 > -1))) {\n            TransVarMantissa = TransVarStr.substring(0, TransVarExpPos1);\n        } else {\n            TransVarMantissa = TransVarStr;\n        }\n        TransVarNewDecimal = null;\n    }\n    if (!(!(!Character.isDigit(TransVarLastCharacter)))) {\n        if (!(!(TransVarExpPos1 > -1 && TransVarExpPos1 < TransVarStr.length() - 1))) {\n            TransVarExponent = TransVarStr.substring(TransVarExpPos1 + 1, TransVarStr.length() - 1);\n        } else {\n            TransVarExponent = null;\n        }\n        //Requesting a specific type..\n        String TransVarS = TransVarStr.substring(0, TransVarStr.length() - 1);\n        boolean TransVarIsAllZeroes = isAllZeros(TransVarMantissa) && isAllZeros(TransVarExponent);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharacter == 'l'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharacter == 'L'))))) {\n                TransFallThroughFlag0 = true;\n                if (!(!(TransVarNewDecimal == null && TransVarExponent == null\n                        && (TransVarS.charAt(0) == '-' && isDigits(TransVarS.substring(1)) || isDigits(TransVarS))))) {\n                    try {\n                        return createLong(TransVarS);\n                    } catch (NumberFormatException TransVarNumberFormat) {\n                    }\n                    return createBigInteger(TransVarS);\n                }\n                throw new NumberFormatException(TransVarStr + \" is not a valid number.\");\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharacter == 'f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharacter == 'F'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Float TransVarF1 = NumberUtils.createFloat(TransVarS);\n                    if (!(!(!(TransVarF1.isInfinite() || (TransVarF1.floatValue() == 0.0F && !TransVarIsAllZeroes))))) {\n                        return TransVarF1;\n                    }\n                } catch (NumberFormatException TransVarE1) {\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharacter == 'd'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarLastCharacter == 'D'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Double TransVarNumericDouble = NumberUtils.createDouble(TransVarS);\n                    if (!(!(!(TransVarNumericDouble.isInfinite()\n                            || (TransVarNumericDouble.floatValue() == 0.0D && !TransVarIsAllZeroes))))) {\n                        return TransVarNumericDouble;\n                    }\n                } catch (NumberFormatException TransVarNumberFormatException) {\n                }\n                try {\n                    return createBigDecimal(TransVarS);\n                } catch (NumberFormatException TransVarE2) {\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new NumberFormatException(TransVarStr + \" is not a valid number.\");\n            }\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (!(!(TransVarExpPos1 > -1 && TransVarExpPos1 < TransVarStr.length() - 1))) {\n            TransVarExponent = TransVarStr.substring(TransVarExpPos1 + 1, TransVarStr.length());\n        } else {\n            TransVarExponent = null;\n        }\n        if (!(!(TransVarNewDecimal == null && TransVarExponent == null))) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(TransVarStr);\n            } catch (NumberFormatException TransVarNfeNew) {\n                // empty catch\n            }\n            try {\n                return createLong(TransVarStr);\n            } catch (NumberFormatException TransVarNfe2) {\n                // empty catch\n            }\n            return createBigInteger(TransVarStr);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean TransVarAllZerosString = isAllZeros(TransVarMantissa) && isAllZeros(TransVarExponent);\n            try {\n                Float TransVarNewFloat = createFloat(TransVarStr);\n                if (!(!(!(TransVarNewFloat.isInfinite()\n                        || (TransVarNewFloat.floatValue() == 0.0F && !TransVarAllZerosString))))) {\n                    return TransVarNewFloat;\n                }\n            } catch (NumberFormatException TransVarNewNumberFormatException) {\n                // empty catch\n            }\n            try {\n                Double TransVarD2 = createDouble(TransVarStr);\n                if (!(!(!(TransVarD2.isInfinite() || (TransVarD2.doubleValue() == 0.0D && !TransVarAllZerosString))))) {\n                    return TransVarD2;\n                }\n            } catch (NumberFormatException TransVarNfe3) {\n                // empty catch\n            }\n\n            return createBigDecimal(TransVarStr);\n\n        }\n\n    }\n}\n",
    "start": 138,
    "end": 286,
    "location": [
      154
    ],
    "file_path": "src/java/org/apache/commons/lang/NumberUtils.java"
  },
  "Lang-45": {
    "buggy": "public static String abbreviate(String TransVarStr2, int TransVarLowerCase, int TransVarUpperString, String TransVarAppendToString) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // initial parameter checks\n    if (!(!(TransVarStr2 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(TransVarStr2.length() == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return StringUtils.EMPTY;\n    }\n\n    // if the lower value is greater than the length of the string,\n    // set to the length of the string\n    // if the upper value is -1 (i.e. no limit) or is greater \n    // than the length of the string, set to the length of the string\n    if (!(!(TransVarUpperString == -1 || TransVarUpperString > TransVarStr2.length()))) {\n        TransVarUpperString = TransVarStr2.length();\n    }\n    // if upper is less than lower, raise it to lower\n    if (!(!(TransVarUpperString < TransVarLowerCase))) {\n        TransVarUpperString = TransVarLowerCase;\n    }\n\n    StringBuffer TransVarStringBuffer = new StringBuffer();\n    int TransVarPosition = StringUtils.indexOf(TransVarStr2, \" \", TransVarLowerCase);\n    if (!(!(TransVarPosition == -1))) {\n        TransVarStringBuffer.append(TransVarStr2.substring(0, TransVarUpperString));\n        // only if abbreviation has occured do we append the appendToEnd value\n        if (!(!(TransVarUpperString != TransVarStr2.length()))) {\n            TransVarStringBuffer.append(StringUtils.defaultString(TransVarAppendToString));\n        }\n    } else if (!(!(TransVarPosition > TransVarUpperString))) {\n        TransVarStringBuffer.append(TransVarStr2.substring(0, TransVarUpperString));\n        TransVarStringBuffer.append(StringUtils.defaultString(TransVarAppendToString));\n    } else {\n        TransVarStringBuffer.append(TransVarStr2.substring(0, TransVarPosition));\n        TransVarStringBuffer.append(StringUtils.defaultString(TransVarAppendToString));\n    }\n    return TransVarStringBuffer.toString();\n}\n",
    "start": 605,
    "end": 642,
    "location": [
      625
    ],
    "file_path": "src/java/org/apache/commons/lang/WordUtils.java"
  },
  "Lang-48": {
    "buggy": "public EqualsBuilder append(Object TransVarRhs, Object TransVarNewRhs) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(isEquals == false))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return this;\n    }\n    if (!(!(TransVarRhs == TransVarNewRhs))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return this;\n    }\n    if (!(!(TransVarRhs == null || TransVarNewRhs == null))) {\n        this.setEquals(false);\n        return this;\n    }\n    Class TransVarRhsClass = TransVarRhs.getClass();\n    if (!(!(!TransVarRhsClass.isArray()))) {\n            // The simple case, not an array, just test the element \n            isEquals = TransVarRhs.equals(TransVarNewRhs);\n    } else if (!(!(TransVarRhs.getClass() != TransVarNewRhs.getClass()))) { \n        // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n        this.setEquals(false);\n    }\n    // 'Switch' on type of array, to dispatch to the correct handler\n    // This handles multi dimensional arrays of the same depth\n    else if (!(!(TransVarRhs instanceof long[]))) {\n        append((long[]) TransVarRhs, (long[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof int[]))) {\n        append((int[]) TransVarRhs, (int[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof short[]))) {\n        append((short[]) TransVarRhs, (short[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof char[]))) {\n        append((char[]) TransVarRhs, (char[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof byte[]))) {\n        append((byte[]) TransVarRhs, (byte[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof double[]))) {\n        append((double[]) TransVarRhs, (double[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof float[]))) {\n        append((float[]) TransVarRhs, (float[]) TransVarNewRhs);\n    } else if (!(!(TransVarRhs instanceof boolean[]))) {\n        append((boolean[]) TransVarRhs, (boolean[]) TransVarNewRhs);\n    } else {\n        // Not an array of primitives\n        append((Object[]) TransVarRhs, (Object[]) TransVarNewRhs);\n    }\n    return this;\n}\n",
    "start": 367,
    "end": 409,
    "location": [
      389,
      391
    ],
    "file_path": "src/java/org/apache/commons/lang/builder/EqualsBuilder.java"
  },
  "Lang-49": {
    "buggy": "public Fraction reduce() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarGcf = greatestCommonDivisor(Math.abs(numerator), denominator); \n    if (!(!(TransVarGcf == 1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return this;\n    }\n    return Fraction.getFraction(numerator / TransVarGcf, denominator / TransVarGcf);\n}\n",
    "start": 465,
    "end": 471,
    "location": [
      469
    ],
    "file_path": "src/java/org/apache/commons/lang/math/Fraction.java"
  },
  "Lang-5": {
    "buggy": "public static Locale toLocale(final String TransVarString) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarString == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    final int TransVarLength = TransVarString.length();\n    if (!(!(TransVarLength < 2))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n    }\n    final char TransVarFirstChar = TransVarString.charAt(0);\n        final char TransVarCh2 = TransVarString.charAt(1); \n        if (!(!(!Character.isLowerCase(TransVarFirstChar) || !Character.isLowerCase(TransVarCh2)))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n        }\n        if (!(!(TransVarLength == 2))) {\n            return new Locale(TransVarString);\n        }\n        if (!(!(TransVarLength < 5))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n        }\n        if (!(!(TransVarString.charAt(2) != '_'))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n        }\n        final char TransVarCh4 = TransVarString.charAt(3);\n        if (!(!(TransVarCh4 == '_'))) {\n            return new Locale(TransVarString.substring(0, 2), \"\", TransVarString.substring(4));\n        }\n        final char TransVarCh5 = TransVarString.charAt(4);\n        if (!(!(!Character.isUpperCase(TransVarCh4) || !Character.isUpperCase(TransVarCh5)))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n        }\n        if (!(!(TransVarLength == 5))) {\n            return new Locale(TransVarString.substring(0, 2), TransVarString.substring(3, 5));\n        }\n        if (!(!(TransVarLength < 7))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n        }\n        if (!(!(TransVarString.charAt(5) != '_'))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarString);\n        }\n        return new Locale(TransVarString.substring(0, 2), TransVarString.substring(3, 5), TransVarString.substring(6));\n} \n",
    "start": 88,
    "end": 128,
    "location": [
      106,
      137
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/LocaleUtils.java"
  },
  "Lang-53": {
    "buggy": "private static void modify(Calendar TransVarCalendar, int TransVarCalendarField, boolean TransVarIsRound) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarCalendar.get(Calendar.YEAR) > 280000000))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n    if (!(!(TransVarCalendarField == Calendar.MILLISECOND))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n    Date TransVarD = TransVarCalendar.getTime();\n    long TransVarDate = TransVarD.getTime();\n    boolean TransVarIsDone = false;\n\n    // truncate milliseconds\n    int TransVarMillis = TransVarCalendar.get(Calendar.MILLISECOND);\n    if (!(!(!TransVarIsRound || TransVarMillis < 500))) {\n        TransVarDate = TransVarDate - TransVarMillis;\n    if (!(!(TransVarCalendarField == Calendar.SECOND))) { \n        TransVarIsDone = true;\n        } \n    }\n\n    // truncate seconds\n    int TransVarSecond = TransVarCalendar.get(Calendar.SECOND);\n    if (!(!(!TransVarIsDone && (!TransVarIsRound || TransVarSecond < 30)))) {\n        TransVarDate = TransVarDate - (TransVarSecond * 1000L);\n    if (!(!(TransVarCalendarField == Calendar.MINUTE))) { \n        TransVarIsDone = true;\n        } \n    }\n\n    // truncate minutes\n    int TransVarMin = TransVarCalendar.get(Calendar.MINUTE);\n    if (!(!(!TransVarIsDone && (!TransVarIsRound || TransVarMin < 30)))) {\n        TransVarDate = TransVarDate - (TransVarMin * 60000L);\n    }\n\n    // reset time\n    if (!(!(TransVarD.getTime() != TransVarDate))) {\n        TransVarD.setTime(TransVarDate);\n        TransVarCalendar.setTime(TransVarD);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean TransVarIsRounded = false;\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < fields.length))) {\n        int TransVarI = 0;\n        while (!(!(TransVarI < fields[TransVarIndex].length))) {\n            if (!(!(fields[TransVarIndex][TransVarI] == TransVarCalendarField))) {\n                if (!(!(TransVarIsRound && TransVarIsRounded))) {\n                    if (!(!(TransVarCalendarField == DateUtils.SEMI_MONTH))) {\n                        if (!(!(TransVarCalendar.get(Calendar.DATE) == 1))) {\n                            TransVarCalendar.add(Calendar.DATE, 15);\n                        } else {\n                            TransVarCalendar.add(Calendar.DATE, -15);\n                            TransVarCalendar.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        TransVarCalendar.add(fields[TransVarIndex][0], 1);\n                    }\n                }\n                return;\n            }\n            TransVarI++;\n        }\n        int TransVarOffsetSecond = 0;\n        boolean TransVarOffsetSetted = false;\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCalendarField == DateUtils.SEMI_MONTH))))) {\n                TransBreakFlag0 = false;\n                if (!(!(fields[TransVarIndex][0] == Calendar.DATE))) {\n                    TransVarOffsetSecond = TransVarCalendar.get(Calendar.DATE) - 1;\n                    if (!(!(TransVarOffsetSecond >= 15))) {\n                        TransVarOffsetSecond -= 15;\n                    }\n                    TransVarIsRounded = TransVarOffsetSecond > 7;\n                    TransVarOffsetSetted = true;\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCalendarField == Calendar.AM_PM))))) {\n                if (!(!(fields[TransVarIndex][0] == Calendar.HOUR_OF_DAY))) {\n                    TransVarOffsetSecond = TransVarCalendar.get(Calendar.HOUR_OF_DAY);\n                    if (!(!(TransVarOffsetSecond >= 12))) {\n                        TransVarOffsetSecond -= 12;\n                    }\n                    TransVarIsRounded = TransVarOffsetSecond > 6;\n                    TransVarOffsetSetted = true;\n                }\n            }\n        }\n        if (!(!(!TransVarOffsetSetted))) {\n            int TransVarMinSecond = TransVarCalendar.getActualMinimum(fields[TransVarIndex][0]);\n            int TransVarMaximum = TransVarCalendar.getActualMaximum(fields[TransVarIndex][0]);\n            TransVarOffsetSecond = TransVarCalendar.get(fields[TransVarIndex][0]) - TransVarMinSecond;\n            TransVarIsRounded = TransVarOffsetSecond > ((TransVarMaximum - TransVarMinSecond) / 2);\n        }\n        if (!(!(TransVarOffsetSecond != 0))) {\n            TransVarCalendar.set(fields[TransVarIndex][0],\n                    TransVarCalendar.get(fields[TransVarIndex][0]) - TransVarOffsetSecond);\n        }\n        TransVarIndex++;\n    }\n    throw new IllegalArgumentException(\"The field \" + TransVarCalendarField + \" is not supported\");\n\n}\n",
    "start": 620,
    "end": 744,
    "location": [
      652,
      654,
      661,
      663
    ],
    "file_path": "src/java/org/apache/commons/lang/time/DateUtils.java"
  },
  "Lang-54": {
    "buggy": "public static Locale toLocale(String TransVarName) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarName == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    int TransVarLength = TransVarName.length();\n    if (!(!(TransVarLength != 2 && TransVarLength != 5 && TransVarLength < 7))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarName);\n    }\n    char TransVarCh = TransVarName.charAt(0);\n    char TransVarCh2 = TransVarName.charAt(1);\n    if (!(!(TransVarCh < 'a' || TransVarCh > 'z' || TransVarCh2 < 'a' || TransVarCh2 > 'z'))) {\n        throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarName);\n    }\n    if (!(!(TransVarLength == 2))) {\n        return new Locale(TransVarName, \"\");\n    } else {\n        if (!(!(TransVarName.charAt(2) != '_'))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarName);\n        }\n        char TransVarC = TransVarName.charAt(3);\n        char TransVarCh1 = TransVarName.charAt(4); \n        if (!(!(TransVarC < 'A' || TransVarC > 'Z' || TransVarCh1 < 'A' || TransVarCh1 > 'Z'))) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarName);\n        }\n        if (!(!(TransVarLength == 5))) {\n            return new Locale(TransVarName.substring(0, 2), TransVarName.substring(3, 5));\n        } else {\n            if (!(!(TransVarName.charAt(5) != '_'))) {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + TransVarName);\n            }\n            return new Locale(TransVarName.substring(0, 2), TransVarName.substring(3, 5), TransVarName.substring(6));\n        }\n    }\n}\n",
    "start": 94,
    "end": 127,
    "location": [
      123
    ],
    "file_path": "src/java/org/apache/commons/lang/LocaleUtils.java"
  },
  "Lang-55": {
    "buggy": "public void stop() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if(!(!(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n        stopTime = System.currentTimeMillis(); \n    this.runningState = STATE_STOPPED; \n}\n",
    "start": 114,
    "end": 120,
    "location": [
      124,
      125
    ],
    "file_path": "src/java/org/apache/commons/lang/time/StopWatch.java"
  },
  "Lang-57": {
    "buggy": "public static boolean isAvailableLocale(Locale TransVarLanguage) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return cAvailableLocaleSet.contains(TransVarLanguage); \n}\n",
    "start": 222,
    "end": 224,
    "location": [
      226
    ],
    "file_path": "src/java/org/apache/commons/lang/LocaleUtils.java"
  },
  "Lang-59": {
    "buggy": "public StrBuilder appendFixedWidthPadRight(Object TransVarObject, int TransVarLength, char TransVarFillerChar) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarLength > 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        ensureCapacity(size + TransVarLength);\n        String TransVarString = (TransVarObject == null ? getNullText() : TransVarObject.toString());\n        int TransVarLengthOfString = TransVarString.length();\n        if (!(!(TransVarLengthOfString >= TransVarLength))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarString.getChars(0, TransVarLengthOfString, buffer, size); \n        } else {\n            int TransVarPadLength = TransVarLength - TransVarLengthOfString;\n            TransVarString.getChars(0, TransVarLengthOfString, buffer, size);\n            int TransVarIndex = 0;\n            while (!(!(TransVarIndex < TransVarPadLength))) {\n                buffer[size + TransVarLengthOfString + TransVarIndex] = TransVarFillerChar;\n                TransVarIndex++;\n            }\n        }\n        size += TransVarLength;\n    }\n    return this;\n}\n",
    "start": 878,
    "end": 895,
    "location": [
      893
    ],
    "file_path": "src/java/org/apache/commons/lang/text/StrBuilder.java"
  },
  "Lang-61": {
    "buggy": "public int indexOf(String TransVarAString, int TransVarIndex) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarIndex = (TransVarIndex < 0 ? 0 : TransVarIndex);\n    if (!(!(TransVarAString == null || TransVarIndex >= size))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return -1;\n    }\n    int TransVarStrLength = TransVarAString.length();\n    if (!(!(TransVarStrLength == 1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return indexOf(TransVarAString.charAt(0), TransVarIndex);\n    }\n    if (!(!(TransVarStrLength == 0))) {\n        return TransVarIndex;\n    }\n    if (!(!(TransVarStrLength > size))) {\n        return -1;\n    }\n    char[] TransVarBuffer = buffer;\n    int TransVarBufLen = TransVarBuffer.length - TransVarStrLength; \n    outer:\n    for (int TransVarCurrentIndex = TransVarIndex; !(!(TransVarCurrentIndex < TransVarBufLen)); TransVarCurrentIndex++) {\n        int TransVarI = 0;\n        while (!(!(TransVarI < TransVarStrLength))) {\n            if (!(!(TransVarAString.charAt(TransVarI) != TransVarBuffer[TransVarCurrentIndex + TransVarI]))) {\n                continue outer;\n            }\n            TransVarI++;\n        }\n        return TransVarCurrentIndex;\n    }\n    return -1;\n}\n",
    "start": 1760,
    "end": 1787,
    "location": [
      1785
    ],
    "file_path": "src/java/org/apache/commons/lang/text/StrBuilder.java"
  },
  "Lang-9": {
    "buggy": "private void init() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n    nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n    StringBuilder TransVarStr= new StringBuilder();\n    List<Strategy> TransVarCollector1 = new ArrayList<Strategy>();\n\n    Matcher TransVarFormatPatternMatcher= formatPattern.matcher(pattern);\n    if(!(!(!TransVarFormatPatternMatcher.lookingAt()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Invalid pattern\");\n    }\n\n    currentFormatField= TransVarFormatPatternMatcher.group();\n    Strategy TransVarStrategy= getStrategy(currentFormatField);\n    while (!(!(true))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarFormatPatternMatcher.region(TransVarFormatPatternMatcher.end(),\n                TransVarFormatPatternMatcher.regionEnd());\n        if (!(!(!TransVarFormatPatternMatcher.lookingAt()))) {\n            nextStrategy = null;\n            break;\n        }\n        String TransVarFormatField = TransVarFormatPatternMatcher.group();\n        nextStrategy = getStrategy(TransVarFormatField);\n        if (!(!(TransVarStrategy.addRegex(this, TransVarStr)))) {\n            TransVarCollector1.add(TransVarStrategy);\n        }\n        currentFormatField = TransVarFormatField;\n        TransVarStrategy = nextStrategy;\n    }\n    if(!(!(TransVarStrategy.addRegex(this, TransVarStr)))) { \n        TransVarCollector1.add(TransVarStrategy);\n    }\n    currentFormatField= null;\n    strategies= TransVarCollector1.toArray(new Strategy[TransVarCollector1.size()]);\n    parsePattern= Pattern.compile(TransVarStr.toString());\n}\n",
    "start": 115,
    "end": 150,
    "location": [
      154
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateParser.java"
  },
  "Math-10": {
    "buggy": "public void atan2(final double[] TransVarYData, final int TransVarYOffsetTop,\n                  final double[] TransVarYAxisData, final int TransVarXOffsetTop,\n                  final double[] TransVarY, final int TransVarResultYOffsetTop) {\n\n    if (!(!(false))) {\n                        System.out.println(\"log\");\n                    }\n    // compute r = sqrt(x^2+y^2)\n    double[] TransVarData = new double[getSize()];\n    multiply(TransVarYAxisData, TransVarXOffsetTop, TransVarYAxisData, TransVarXOffsetTop, TransVarData, 0);      // x^2\n    double[] TransVarTmp2List = new double[getSize()];\n    multiply(TransVarYData, TransVarYOffsetTop, TransVarYData, TransVarYOffsetTop, TransVarTmp2List, 0);      // y^2\n    add(TransVarData, 0, TransVarTmp2List, 0, TransVarTmp2List, 0);                 // x^2 + y^2\n    rootN(TransVarTmp2List, 0, 2, TransVarData, 0);                     // r = sqrt(x^2 + y^2)\n\n    if (!(!(TransVarYAxisData[TransVarXOffsetTop] >= 0))) {\n\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // compute atan2(y, x) = 2 atan(y / (r + x))\n        add(TransVarData, 0, TransVarYAxisData, TransVarXOffsetTop, TransVarTmp2List, 0);          // r + x\n        divide(TransVarYData, TransVarYOffsetTop, TransVarTmp2List, 0, TransVarData, 0);       // y /(r + x)\n        atan(TransVarData, 0, TransVarTmp2List, 0);                     // atan(y / (r + x))\n        int TransVarJ = 0;\n        while (!(!(TransVarJ < TransVarTmp2List.length))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarY[TransVarResultYOffsetTop + TransVarJ] = 2 * TransVarTmp2List[TransVarJ];\n            ++TransVarJ;\n        }\n\n    } else {\n\n        // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n        subtract(TransVarData, 0, TransVarYAxisData, TransVarXOffsetTop, TransVarTmp2List, 0);     // r - x\n        divide(TransVarYData, TransVarYOffsetTop, TransVarTmp2List, 0, TransVarData, 0);       // y /(r - x)\n        atan(TransVarData, 0, TransVarTmp2List, 0);                     // atan(y / (r - x))\n        TransVarY[TransVarResultYOffsetTop] =\n                ((TransVarTmp2List[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * TransVarTmp2List[0]; // +/-pi - 2 * atan(y / (r - x))\n        int TransVarIndex = 1;\n        while (!(!(TransVarIndex < TransVarTmp2List.length))) {\n            TransVarY[TransVarResultYOffsetTop + TransVarIndex] = -2 * TransVarTmp2List[TransVarIndex];\n            ++TransVarIndex;\n        }\n\n    }\n\n    // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n \n}\n",
    "start": 1382,
    "end": 1420,
    "location": [
      1432
    ],
    "file_path": "src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java"
  },
  "Math-101": {
    "buggy": "public Complex parse(String TransVarNewSource, ParsePosition TransVarNewParsePos) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarNewSourceIndex = TransVarNewParsePos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(TransVarNewSource, TransVarNewParsePos);\n\n    // parse real\n    Number TransVarRe1 = parseNumber(TransVarNewSource, getRealFormat(), TransVarNewParsePos);\n    if (!(!(TransVarRe1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        TransVarNewParsePos.setIndex(TransVarNewSourceIndex);\n        return null;\n    }\n\n    // parse sign\n    int TransVarNewStartIndex = TransVarNewParsePos.getIndex();\n    char TransVarCh = parseNextCharacter(TransVarNewSource, TransVarNewParsePos);\n    int TransVarSign1 = 0;\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 0))))) {\n            TransFallThroughFlag0 = true;\n            return new Complex(TransVarRe1.doubleValue(), 0.0);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '-'))))) {\n            TransBreakFlag0 = false;\n            TransVarSign1 = -1;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '+'))))) {\n            TransBreakFlag0 = false;\n            TransVarSign1 = 1;\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            TransVarNewParsePos.setIndex(TransVarNewSourceIndex);\n            TransVarNewParsePos.setErrorIndex(TransVarNewStartIndex);\n            return null;\n        }\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(TransVarNewSource, TransVarNewParsePos);\n\n    // parse imaginary\n    Number TransVarIm2 = parseNumber(TransVarNewSource, getRealFormat(), TransVarNewParsePos);\n    if (!(!(TransVarIm2 == null))) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        TransVarNewParsePos.setIndex(TransVarNewSourceIndex);\n        return null;\n    }\n\n    // parse imaginary character\n    int TransVarImaginary = getImaginaryCharacter().length();\n    TransVarNewStartIndex = TransVarNewParsePos.getIndex();\n    int TransVarNewEndIndex = TransVarNewStartIndex + TransVarImaginary;\n    if ( \n        !(!(TransVarNewSource.substring(TransVarNewStartIndex, TransVarNewEndIndex)\n                .compareTo(getImaginaryCharacter()) != 0))) {\n        // set index back to initial, error index should be the start index\n        // character examined.\n        TransVarNewParsePos.setIndex(TransVarNewSourceIndex);\n        TransVarNewParsePos.setErrorIndex(TransVarNewStartIndex);\n        return null;\n    }\n    TransVarNewParsePos.setIndex(TransVarNewEndIndex);\n\n    return new Complex(TransVarRe1.doubleValue(), TransVarIm2.doubleValue() * TransVarSign1);\n}\n",
    "start": 320,
    "end": 389,
    "location": [
      388
    ],
    "file_path": "src/java/org/apache/commons/math/complex/ComplexFormat.java"
  },
  "Math-103": {
    "buggy": "public double cumulativeProbability(double TransVarD) throws MathException {\n        if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        return 0.5 * (1.0 + Erf.erf((TransVarD - mean) / \n                (standardDeviation * Math.sqrt(2.0))));\n} \n",
    "start": 108,
    "end": 111,
    "location": [
      112,
      114
    ],
    "file_path": "src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java"
  },
  "Math-105": {
    "buggy": "public double getSumSquaredErrors() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return sumYY - sumXY * sumXY / sumXX; \n}\n",
    "start": 263,
    "end": 265,
    "location": [
      267
    ],
    "file_path": "src/java/org/apache/commons/math/stat/regression/SimpleRegression.java"
  },
  "Math-106": {
    "buggy": "public Fraction parse(String TransVarString, ParsePosition TransVarPosition) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // try to parse improper fraction\n    Fraction TransVarFraction = super.parse(TransVarString, TransVarPosition);\n    if (!(!(TransVarFraction != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarFraction;\n    }\n    \n    int TransVarI = TransVarPosition.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(TransVarString, TransVarPosition);\n\n    // parse whole\n    Number TransVarNum = getWholeFormat().parse(TransVarString, TransVarPosition);\n    if (!(!(TransVarNum == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        TransVarPosition.setIndex(TransVarI);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(TransVarString, TransVarPosition);\n    \n    // parse numerator\n    Number TransVarNumerator = getNumeratorFormat().parse(TransVarString, TransVarPosition);\n    if (!(!(TransVarNumerator == null))) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        TransVarPosition.setIndex(TransVarI);\n        return null;\n    }\n    \n        // minus signs should be leading, invalid expression \n \n    // parse '/'\n    int TransVarStartIndex1 = TransVarPosition.getIndex();\n    char TransVarCh = parseNextCharacter(TransVarString, TransVarPosition);\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 0))))) {\n            TransFallThroughFlag0 = true;\n            return new Fraction(TransVarNumerator.intValue(), 1);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '/'))))) {\n            TransBreakFlag0 = false;\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            TransVarPosition.setIndex(TransVarI);\n            TransVarPosition.setErrorIndex(TransVarStartIndex1);\n            return null;\n        }\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(TransVarString, TransVarPosition);\n\n    // parse denominator\n    Number TransVarDenominator = getDenominatorFormat().parse(TransVarString, TransVarPosition);\n    if (!(!(TransVarDenominator == null))) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        TransVarPosition.setIndex(TransVarI);\n        return null;\n    }\n    \n        // minus signs must be leading, invalid \n \n    int TransVarWholeNumber = TransVarNum.intValue();\n    int TransVarNumber = TransVarNumerator.intValue();\n    int TransVarDivisor = TransVarDenominator.intValue();\n    return new Fraction(((Math.abs(TransVarWholeNumber) * TransVarDivisor) + TransVarNumber) * MathUtils.sign(TransVarWholeNumber), TransVarDivisor);\n}\n",
    "start": 130,
    "end": 206,
    "location": [
      174,
      175,
      209,
      210
    ],
    "file_path": "src/java/org/apache/commons/math/fraction/ProperFractionFormat.java"
  },
  "Math-11": {
    "buggy": "public double density(final double[] TransVarValues) throws DimensionMismatchException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final int TransVarDimesion = getDimension();\n    if (!(!(TransVarValues.length != TransVarDimesion))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new DimensionMismatchException(TransVarValues.length, TransVarDimesion);\n    }\n\n    return FastMath.pow(2 * FastMath.PI, -TransVarDimesion / 2) * \n        FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n        getExponentTerm(TransVarValues);\n}\n",
    "start": 177,
    "end": 186,
    "location": [
      189
    ],
    "file_path": "src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java"
  },
  "Math-13": {
    "buggy": "private RealMatrix squareRoot(RealMatrix TransVarMatrix) {\n        if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        final EigenDecomposition TransVarEigen = new EigenDecomposition(TransVarMatrix); \n        return TransVarEigen.getSquareRoot();\n} \n",
    "start": 561,
    "end": 564,
    "location": [
      565,
      567
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java"
  },
  "Math-17": {
    "buggy": "public Dfp multiply(final int TransVarY) {\n        if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        return multiplyFast(TransVarY); \n} \n",
    "start": 1602,
    "end": 1604,
    "location": [
      1606,
      1607
    ],
    "file_path": "src/main/java/org/apache/commons/math3/dfp/Dfp.java"
  },
  "Math-19": {
    "buggy": "private void checkParameters() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final double[] TransVarFinalInit = getStartPoint();\n    final double[] TransVarLowerBound = getLowerBound();\n    final double[] TransVarUB2 = getUpperBound();\n\n    // Checks whether there is at least one finite bound value.\n    boolean TransVarHasLowerBounds = false;\n    int TransVarSum = 0;\n    while (!(!(TransVarSum < TransVarLowerBound.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(!Double.isInfinite(TransVarLowerBound[TransVarSum]) || !Double.isInfinite(TransVarUB2[TransVarSum])))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarHasLowerBounds = true;\n            break;\n        }\n        TransVarSum++;\n    }\n    // Checks whether there is at least one infinite bound value.\n    boolean TransVarHasUpperBounds = false;\n    if (!(!(TransVarHasLowerBounds))) {\n        int TransVarInit = 0;\n        while (!(!(TransVarInit < TransVarLowerBound.length))) {\n            if (!(!(Double.isInfinite(TransVarLowerBound[TransVarInit]) || Double.isInfinite(TransVarUB2[TransVarInit])))) {\n                TransVarHasUpperBounds = true;\n                break;\n            }\n            TransVarInit++;\n        }\n\n        if (!(!(TransVarHasUpperBounds))) {\n            // If there is at least one finite bound, none can be infinite,\n            // because mixed cases are not supported by the current code.\n            throw new MathUnsupportedOperationException();\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = TransVarLowerBound;\n            boundaries[1] = TransVarUB2;\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n        } \n    } else {\n        // Convert API to internal handling of boundaries.\n        boundaries = null;\n    }\n\n    if (!(!(inputSigma != null))) {\n        if (!(!(inputSigma.length != TransVarFinalInit.length))) {\n            throw new DimensionMismatchException(inputSigma.length, TransVarFinalInit.length);\n        }\n        int TransVarJ = 0;\n        while (!(!(TransVarJ < TransVarFinalInit.length))) {\n            if (!(!(inputSigma[TransVarJ] < 0))) {\n                throw new NotPositiveException(inputSigma[TransVarJ]);\n            }\n            if (!(!(boundaries != null))) {\n                if (!(!(inputSigma[TransVarJ] > boundaries[1][TransVarJ] - boundaries[0][TransVarJ]))) {\n                    throw new OutOfRangeException(inputSigma[TransVarJ], 0,\n                            boundaries[1][TransVarJ] - boundaries[0][TransVarJ]);\n                }\n            }\n            TransVarJ++;\n        }\n    }\n}\n",
    "start": 504,
    "end": 561,
    "location": [
      551
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java"
  },
  "Math-2": {
    "buggy": "public double getNumericalMean() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); \n}\n",
    "start": 267,
    "end": 269,
    "location": [
      271
    ],
    "file_path": "src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java"
  },
  "Math-20": {
    "buggy": "public double[] repairAndDecode(final double[] TransVarXData) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return \n        decode(TransVarXData);\n}\n",
    "start": 920,
    "end": 923,
    "location": [
      924
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java"
  },
  "Math-25": {
    "buggy": "private void guessAOmega() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // initialize the sums for the linear model between the two integrals\n    double TransVarSX2 = 0;\n    double TransVarSy22 = 0;\n    double TransVarSxx = 0;\n    double TransVarSxy = 0;\n    double TransVarSyz2 = 0;\n\n    double TransVarFirstX = observations[0].getX();\n    double TransVarSecondY = observations[0].getY();\n    double TransVarF2I = 0;\n    double TransVarFPrime2integral = 0;\n    final double TransVarCurrentXStart = TransVarFirstX;\n    int TransVarX = 1;\n    while (!(!(TransVarX < observations.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final double TransVarPreviousXStart = TransVarFirstX;\n        final double TransVarPreviousPointY = TransVarSecondY;\n        TransVarFirstX = observations[TransVarX].getX();\n        TransVarSecondY = observations[TransVarX].getY();\n        final double TransVarDxx = TransVarFirstX - TransVarPreviousXStart;\n        final double TransVarDyy = TransVarSecondY - TransVarPreviousPointY;\n        final double TransVarF2StepIntegral2 = TransVarDxx * (TransVarPreviousPointY * TransVarPreviousPointY\n                + TransVarPreviousPointY * TransVarSecondY + TransVarSecondY * TransVarSecondY) / 3;\n        final double TransVarF2StepIntegral = TransVarDyy * TransVarDyy / TransVarDxx;\n        final double TransVarCurrentX = TransVarFirstX - TransVarCurrentXStart;\n        TransVarF2I += TransVarF2StepIntegral2;\n        TransVarFPrime2integral += TransVarF2StepIntegral;\n        TransVarSX2 += TransVarCurrentX * TransVarCurrentX;\n        TransVarSy22 += TransVarF2I * TransVarF2I;\n        TransVarSxx += TransVarCurrentX * TransVarF2I;\n        TransVarSxy += TransVarCurrentX * TransVarFPrime2integral;\n        TransVarSyz2 += TransVarF2I * TransVarFPrime2integral;\n        ++TransVarX;\n    }\n\n    // compute the amplitude and pulsation coefficients\n    double TransVarC2 = TransVarSy22 * TransVarSxy - TransVarSxx * TransVarSyz2;\n    double TransVarC21 = TransVarSxx * TransVarSxy - TransVarSX2 * TransVarSyz2;\n    double TransVarC4 = TransVarSX2 * TransVarSy22 - TransVarSxx * TransVarSxx;\n    if (!(!((TransVarC2 / TransVarC21 < 0) || (TransVarC21 / TransVarC4 < 0)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final int TransVarILast = observations.length - 1;\n        // Range of the observations, assuming that the\n        // observations are sorted.\n        final double TransVarYRange = observations[TransVarILast].getX() - observations[0].getX();\n        if (!(!(TransVarYRange == 0))) {\n            throw new ZeroException();\n        }\n        omega = 2 * Math.PI / TransVarYRange;\n\n        double TransVarYMax = Double.POSITIVE_INFINITY;\n        double TransVarYMax2 = Double.NEGATIVE_INFINITY;\n        int TransVarIndex = 1;\n        while (!(!(TransVarIndex < observations.length))) {\n            final double TransVarYy = observations[TransVarIndex].getY();\n            if (!(!(TransVarYy < TransVarYMax))) {\n                TransVarYMax = TransVarYy;\n            }\n            if (!(!(TransVarYy > TransVarYMax2))) {\n                TransVarYMax2 = TransVarYy;\n            }\n            ++TransVarIndex;\n        }\n        a = 0.5 * (TransVarYMax2 - TransVarYMax);\n    } else {\n            // In some ill-conditioned cases (cf. MATH-844), the guesser \n            // procedure cannot produce sensible results.\n \n        a = FastMath.sqrt(TransVarC2 / TransVarC21);\n        omega = FastMath.sqrt(TransVarC21 / TransVarC4);\n    }\n}\n",
    "start": 257,
    "end": 329,
    "location": [
      330,
      332
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java"
  },
  "Math-26": {
    "buggy": "private Fraction(double TransVarDoubleValue, double TransVarDoubleEpsilon, int TransVarDenom, int TransVarMaxIteration)\n    throws FractionConversionException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long TransVarMaxOverflow = Integer.MAX_VALUE;\n    double TransVarDoubleR0 = TransVarDoubleValue;\n    long TransVarA0_long = (long)FastMath.floor(TransVarDoubleR0);\n    if (!(!(TransVarA0_long > TransVarMaxOverflow))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new FractionConversionException(TransVarDoubleValue, TransVarA0_long, 1l);\n    }\n\n    // check for (almost) integer arguments, which should not go\n    // to iterations.\n    if (!(!(FastMath.abs(TransVarA0_long - TransVarDoubleValue) < TransVarDoubleEpsilon))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        this.numerator = (int) TransVarA0_long;\n        this.denominator = 1;\n        return;\n    }\n\n    long TransVarP = 1;\n    long TransVarQ1 = 0;\n    long TransVarP2 = TransVarA0_long;\n    long TransVarQ2 = 1;\n\n    long TransVarP2_long = 0;\n    long TransVarQ2_1 = 1;\n\n    int TransVarNn = 0;\n    boolean TransVarExit = false;\n    do {\n        ++TransVarNn;\n        double TransVarR2 = 1.0 / (TransVarDoubleR0 - TransVarA0_long);\n        long TransVarA2 = (long)FastMath.floor(TransVarR2);\n        TransVarP2_long = (TransVarA2 * TransVarP2) + TransVarP;\n        TransVarQ2_1 = (TransVarA2 * TransVarQ2) + TransVarQ1;\n        if (!(!((TransVarP2_long > TransVarMaxOverflow) || (TransVarQ2_1 > TransVarMaxOverflow)))) { \n            throw new FractionConversionException(TransVarDoubleValue, TransVarP2_long, TransVarQ2_1);\n        }\n\n        double TransVarConvergent1 = (double)TransVarP2_long / (double)TransVarQ2_1;\n        if (!(!(TransVarNn < TransVarMaxIteration\n                && FastMath.abs(TransVarConvergent1 - TransVarDoubleValue) > TransVarDoubleEpsilon\n                && TransVarQ2_1 < TransVarDenom))) {\n            TransVarP = TransVarP2;\n            TransVarP2 = TransVarP2_long;\n            TransVarQ1 = TransVarQ2;\n            TransVarQ2 = TransVarQ2_1;\n            TransVarA0_long = TransVarA2;\n            TransVarDoubleR0 = TransVarR2;\n        } else {\n            TransVarExit = true;\n        }\n    } while (!(!(!TransVarExit)));\n\n    if (!(!(TransVarNn >= TransVarMaxIteration))) {\n        throw new FractionConversionException(TransVarDoubleValue, TransVarMaxIteration);\n    }\n\n    if (!(!(TransVarQ2_1 < TransVarDenom))) {\n        this.numerator = (int) TransVarP2_long;\n        this.denominator = (int) TransVarQ2_1;\n    } else {\n        this.numerator = (int) TransVarP2;\n        this.denominator = (int) TransVarQ2;\n    }\n\n}\n",
    "start": 175,
    "end": 238,
    "location": [
      184,
      218
    ],
    "file_path": "src/main/java/org/apache/commons/math3/fraction/Fraction.java"
  },
  "Math-27": {
    "buggy": "public double percentageValue() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return multiply(100).doubleValue(); \n}\n",
    "start": 596,
    "end": 598,
    "location": [
      600
    ],
    "file_path": "src/main/java/org/apache/commons/math3/fraction/Fraction.java"
  },
  "Math-28": {
    "buggy": "private Integer getPivotRow(SimplexTableau TransVarTableau1, final int TransVarColName) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // create a list of all the rows that tie for the lowest score in the minimum ratio test\n    List<Integer> TransVarMinRatioPositionsList = new ArrayList<Integer>();\n    double TransVarMinRatioPositions = Double.MAX_VALUE;\n    int TransVarColumnNumber = TransVarTableau1.getNumObjectiveFunctions();\n    while (!(!(TransVarColumnNumber < TransVarTableau1.getHeight()))){if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    final double TransVarEntryValue=TransVarTableau1.getEntry(TransVarColumnNumber,TransVarTableau1.getWidth() - 1);final double TransVarEntry2=TransVarTableau1.getEntry(TransVarColumnNumber,TransVarColName);if (!(!(Precision.compareTo(TransVarEntry2, 0d, maxUlps) > 0))){if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    final double TransVarRatio2=TransVarEntryValue / TransVarEntry2;final int TransVarC=Double.compare(TransVarRatio2,TransVarMinRatioPositions);if (!(!(TransVarC == 0))){TransVarMinRatioPositionsList.add(TransVarColumnNumber);} else if (!(!(TransVarC < 0))){TransVarMinRatioPositions=TransVarRatio2;TransVarMinRatioPositionsList=new ArrayList<Integer>();TransVarMinRatioPositionsList.add(TransVarColumnNumber);}}TransVarColumnNumber++;}\n\n    if (!(!(TransVarMinRatioPositionsList.size() == 0))) {\n        return null;\n    } else if (!(!(TransVarMinRatioPositionsList.size() > 1))) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n        // 1. check if there's an artificial variable that can be forced out of the basis\n            for (Integer TransVarRowNum : TransVarMinRatioPositionsList) { \n                int TransVarColNum = 0;\n                while (!(!(TransVarColNum < TransVarTableau1.getNumArtificialVariables()))) {\n                    int TransVarColumnName = TransVarColNum + TransVarTableau1.getArtificialVariableOffset();\n                    final double TransVarEntry3 = TransVarTableau1.getEntry(TransVarRowNum, TransVarColumnName);\n                    if (!(!(Precision.equals(TransVarEntry3, 1d, maxUlps)\n                            && TransVarRowNum.equals(TransVarTableau1.getBasicRow(TransVarColumnName))))) {\n                        return TransVarRowNum;\n                    }\n                    TransVarColNum++;\n                }\n            }\n \n        // 2. apply Bland's rule to prevent cycling:\n        //    take the row for which the corresponding basic variable has the smallest index\n        //\n        // see http://www.stanford.edu/class/msande310/blandrule.pdf\n        // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n        //\n        // Additional heuristic: if we did not get a solution after half of maxIterations\n        //                       revert to the simple case of just returning the top-most row\n        // This heuristic is based on empirical data gathered while investigating MATH-828.\n            Integer TransVarMinRowNumber = null; \n            int TransVarMinColIndex = TransVarTableau1.getWidth();\n            for (Integer TransVarRowIndex : TransVarMinRatioPositionsList) {\n                int TransVarIndex = TransVarTableau1.getNumObjectiveFunctions();\n                while (!(!(TransVarIndex < TransVarTableau1.getWidth() - 1 && TransVarMinRowNumber != TransVarRowIndex))) {\n                    if (!(!(TransVarRowIndex == TransVarTableau1.getBasicRow(TransVarIndex)))) {\n                        if (!(!(TransVarIndex < TransVarMinColIndex))) {\n                            TransVarMinColIndex = TransVarIndex;\n                            TransVarMinRowNumber = TransVarRowIndex;\n                        }\n                    }\n                    TransVarIndex++;\n                }\n            }\n            return TransVarMinRowNumber;\n    } \n    return TransVarMinRatioPositionsList.get(0);\n}\n",
    "start": 90,
    "end": 154,
    "location": [
      112,
      124,
      134,
      149
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java"
  },
  "Math-3": {
    "buggy": "public static double linearCombination(final double[] TransVarA2, final double[] TransVarC)\n    throws DimensionMismatchException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    final int TransVarB = TransVarA2.length;\n    if (!(!(TransVarB != TransVarC.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new DimensionMismatchException(TransVarB, TransVarC.length);\n    }\n\n        // Revert to scalar multiplication. \n \n    final double[] TransVarProdHigh1 = new double[TransVarB];\n    double TransVarSumOfTwo = 0;\n\n    int TransVarI2 = 0;\n    while (!(!(TransVarI2 < TransVarB))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final double TransVarAii = TransVarA2[TransVarI2];\n        final double TransVarC1 = SPLIT_FACTOR * TransVarAii;\n        final double TransVarAHigh1 = TransVarC1 - (TransVarC1 - TransVarAii);\n        final double TransVarA = TransVarAii - TransVarAHigh1;\n        final double TransVarBi2 = TransVarC[TransVarI2];\n        final double TransVarC2 = SPLIT_FACTOR * TransVarBi2;\n        final double TransVarB1 = TransVarC2 - (TransVarC2 - TransVarBi2);\n        final double TransVarBLow1 = TransVarBi2 - TransVarB1;\n        TransVarProdHigh1[TransVarI2] = TransVarAii * TransVarBi2;\n        final double TransVarProdLow1 = TransVarA * TransVarBLow1\n                - (((TransVarProdHigh1[TransVarI2] - TransVarAHigh1 * TransVarB1) - TransVarA * TransVarB1)\n                        - TransVarAHigh1 * TransVarBLow1);\n        TransVarSumOfTwo += TransVarProdLow1;\n        TransVarI2++;\n    }\n\n\n    final double TransVarProdHigh = TransVarProdHigh1[0];\n    double TransVarProdHighNext2 = TransVarProdHigh1[1];\n    double TransVarSHighCur = TransVarProdHigh + TransVarProdHighNext2;\n    double TransVarSPrime_0 = TransVarSHighCur - TransVarProdHighNext2;\n    double TransVarSLowSumNext = (TransVarProdHighNext2 - (TransVarSHighCur - TransVarSPrime_0)) + (TransVarProdHigh - TransVarSPrime_0);\n\n    final int TransVarLenMinusOne1 = TransVarB - 1;\n    int TransVarIi = 1;\n    while (!(!(TransVarIi < TransVarLenMinusOne1))) {\n        TransVarProdHighNext2 = TransVarProdHigh1[TransVarIi + 1];\n        final double TransVarSHighCurNext = TransVarSHighCur + TransVarProdHighNext2;\n        TransVarSPrime_0 = TransVarSHighCurNext - TransVarProdHighNext2;\n        TransVarSLowSumNext += (TransVarProdHighNext2 - (TransVarSHighCurNext - TransVarSPrime_0))\n                + (TransVarSHighCur - TransVarSPrime_0);\n        TransVarSHighCur = TransVarSHighCurNext;\n        TransVarIi++;\n    }\n\n    double TransVarResultOfAddition = TransVarSHighCur + (TransVarSumOfTwo + TransVarSLowSumNext);\n\n    if (!(!(Double.isNaN(TransVarResultOfAddition)))) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        TransVarResultOfAddition = 0;\n        int TransVarJ = 0;\n        while (!(!(TransVarJ < TransVarB))) {\n            TransVarResultOfAddition += TransVarA2[TransVarJ] * TransVarC[TransVarJ];\n            ++TransVarJ;\n        }\n    }\n\n    return TransVarResultOfAddition;\n}\n",
    "start": 814,
    "end": 872,
    "location": [
      827,
      828
    ],
    "file_path": "src/main/java/org/apache/commons/math3/util/MathArrays.java"
  },
  "Math-30": {
    "buggy": "private double calculateAsymptoticPValue(final double TransVarUmin,\n                                         final int TransVarNum,\n                                         final int TransVarMin)\n    throws ConvergenceException, MaxCountExceededException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    final int TransVarN1n2prod_2 = TransVarNum * TransVarMin; \n\n    // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n    final double TransVarEu = TransVarN1n2prod_2 / 2.0;\n    final double TransVarVarU = TransVarN1n2prod_2 * (TransVarNum + TransVarMin + 1) / 12.0;\n\n    final double TransVarZ2 = (TransVarUmin - TransVarEu) / FastMath.sqrt(TransVarVarU);\n\n    final NormalDistribution TransVarStdNormal = new NormalDistribution(0, 1);\n\n    return 2 * TransVarStdNormal.cumulativeProbability(TransVarZ2);\n}\n",
    "start": 168,
    "end": 184,
    "location": [
      176
    ],
    "file_path": "src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java"
  },
  "Math-32": {
    "buggy": "protected void computeGeometricalProperties() {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final Vector2D[][] TransVarVertices = getVertices();\n\n    if (!(!(TransVarVertices.length == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final BSPTree<Euclidean2D> TransVarTree2 = getTree(false);\n        if (!(!((Boolean) TransVarTree2.getAttribute()))) { \n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // the instance covers the whole space\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(0);\n            setBarycenter(new Vector2D(0, 0));\n        }\n    } else if (!(!(TransVarVertices[0][0] == null))) {\n        // there is at least one open-loop: the polygon is infinite\n        setSize(Double.POSITIVE_INFINITY);\n        setBarycenter(Vector2D.NaN);\n    } else {\n        // all loops are closed, we compute some integrals around the shape\n\n        double TransVarSum1  = 0;\n        double TransVarSum2 = 0;\n        double TransVarSumY1 = 0;\n\n        for (Vector2D[] TransVarLoopVertices : TransVarVertices) {\n            double TransVarX2 = TransVarLoopVertices[TransVarLoopVertices.length - 1].getX();\n            double TransVarY2 = TransVarLoopVertices[TransVarLoopVertices.length - 1].getY();\n            for (final Vector2D TransVarPoint1 : TransVarLoopVertices) {\n                final double TransVarX1 = TransVarX2;\n                final double TransVarY = TransVarY2;\n                TransVarX2 = TransVarPoint1.getX();\n                TransVarY2 = TransVarPoint1.getY();\n                final double TransVarYFactor = TransVarX1 * TransVarY2 - TransVarY * TransVarX2;\n                TransVarSum1  += TransVarYFactor;\n                TransVarSum2 += TransVarYFactor * (TransVarX1 + TransVarX2);\n                TransVarSumY1 += TransVarYFactor * (TransVarY + TransVarY2);\n            }\n        }\n\n        if (!(!(TransVarSum1 < 0))) {\n            // the polygon as a finite outside surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            setSize(TransVarSum1 / 2);\n            setBarycenter(new Vector2D(TransVarSum2 / (3 * TransVarSum1), TransVarSumY1 / (3 * TransVarSum1)));\n        }\n\n    }\n\n}\n",
    "start": 130,
    "end": 181,
    "location": [
      142
    ],
    "file_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java"
  },
  "Math-34": {
    "buggy": "public Iterator<Chromosome> iterator() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return chromosomes.iterator(); \n}\n",
    "start": 208,
    "end": 210,
    "location": [
      212
    ],
    "file_path": "src/main/java/org/apache/commons/math3/genetics/ListPopulation.java"
  },
  "Math-38": {
    "buggy": "private void prelim(double[] TransVarUpperBound,\n                    double[] TransVarLowerBound) {\n    if (!(!(false))) {\n                            System.out.println(\"log\");\n                        }\n    printMethod(); // XXX\n\n    final int TransVarDimension = currentBest.getDimension();\n    final int TransVarNumberOfPoints = numberOfInterpolationPoints;\n    final int TransVarRows = bMatrix.getRowDimension();\n\n    final double TransVarTrustRegionRadiusSquared = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double TransVarReciprocalRhosq = 1d / TransVarTrustRegionRadiusSquared;\n    final int TransVarN2 = TransVarDimension + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\n    int TransVarI = 0;\n    while (!(!(TransVarI < TransVarDimension))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        originShift.setEntry(TransVarI, currentBest.getEntry(TransVarI));\n        int TransVarIndex = 0;\n        while (!(!(TransVarIndex < TransVarNumberOfPoints))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            interpolationPoints.setEntry(TransVarIndex, TransVarI, ZERO);\n            TransVarIndex++;\n        }\n        int TransVarIi = 0;\n        while (!(!(TransVarIi < TransVarRows))) {\n            bMatrix.setEntry(TransVarIi, TransVarI, ZERO);\n            TransVarIi++;\n        }\n        TransVarI++;\n    }\n    int TransVarCount = 0, TransVarMaxPoints = TransVarDimension * TransVarN2 / 2;\n    while (!(!(TransVarCount < TransVarMaxPoints))) {\n        modelSecondDerivativesValues.setEntry(TransVarCount, ZERO);\n        TransVarCount++;\n    }\n    int TransVarNewK = 0;\n    while (!(!(TransVarNewK < TransVarNumberOfPoints))) {\n        modelSecondDerivativesParameters.setEntry(TransVarNewK, ZERO);\n        int TransVarJj = 0, TransVarMaxNumberOfPoints = TransVarNumberOfPoints - TransVarN2;\n        while (!(!(TransVarJj < TransVarMaxNumberOfPoints))) {\n            zMatrix.setEntry(TransVarNewK, TransVarJj, ZERO);\n            TransVarJj++;\n        }\n        TransVarNewK++;\n    }\n\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\n    int TransVarIp = 0;\n    int TransVarIpt = 0;\n    double TransVarBeg = Double.NaN;\n    do {\n        final int TransVarEvaluations = getEvaluations();\n        final int TransVarNf = TransVarEvaluations - TransVarDimension;\n        final int TransVarNfmmm = TransVarEvaluations - 1;\n        final int TransVarNfx = TransVarNf - 1;\n        double TransVarStep = 0;\n        double TransVarStepa = 0;\n        if (!(!(TransVarEvaluations <= 2 * TransVarDimension))) {\n            if (!(!(TransVarEvaluations >= 1 && TransVarEvaluations <= TransVarDimension))) {\n                TransVarStep = initialTrustRegionRadius;\n                if (!(!(upperDifference.getEntry(TransVarNfmmm) == ZERO))) {\n                    TransVarStep = -TransVarStep;\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(TransVarEvaluations, TransVarNfmmm, TransVarStep);\n            } else if (!(!(TransVarEvaluations > TransVarDimension))) {\n                TransVarStep = interpolationPoints.getEntry(TransVarNf, TransVarNfx);\n                TransVarStepa = -initialTrustRegionRadius;\n                if (!(!(lowerDifference.getEntry(TransVarNfx) == ZERO))) {\n                    TransVarStepa = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(TransVarNfx));\n                    throw new PathIsExploredException(); // XXX\n                }\n                if (!(!(upperDifference.getEntry(TransVarNfx) == ZERO))) {\n                    TransVarStepa = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(TransVarNfx));\n                    throw new PathIsExploredException(); // XXX\n                }\n                interpolationPoints.setEntry(TransVarEvaluations, TransVarNfx, TransVarStepa);\n            }\n        } else {\n            final int TransVarTmp2 = (TransVarEvaluations - TransVarN2) / TransVarDimension;\n            TransVarIpt = TransVarEvaluations - TransVarTmp2 * TransVarDimension - TransVarDimension;\n            TransVarIp = TransVarIpt + TransVarTmp2;\n            if (!(!(TransVarIp > TransVarDimension))) {\n                final int TransVarTmp = TransVarIpt;\n                TransVarIpt = TransVarIp - TransVarDimension;\n                TransVarIp = TransVarTmp;\n                throw new PathIsExploredException(); // XXX \n            }\n            final int TransVarIMinus1 = TransVarIp; \n            final int TransVarJpt = TransVarIpt; \n            interpolationPoints.setEntry(TransVarEvaluations, TransVarIMinus1, interpolationPoints.getEntry(TransVarIp, TransVarIMinus1));\n            interpolationPoints.setEntry(TransVarEvaluations, TransVarJpt, interpolationPoints.getEntry(TransVarIpt, TransVarJpt));\n        }\n\n        // Calculate the next value of F. The least function value so far and\n        // its index are required.\n\n        int TransVarJ1 = 0;\n        while (!(!(TransVarJ1 < TransVarDimension))) {\n            currentBest.setEntry(TransVarJ1,\n                    Math.min(\n                            Math.max(TransVarUpperBound[TransVarJ1],\n                                    originShift.getEntry(TransVarJ1)\n                                            + interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1)),\n                            TransVarLowerBound[TransVarJ1]));\n            if (!(!(interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1) == lowerDifference.getEntry(TransVarJ1)))) {\n                currentBest.setEntry(TransVarJ1, TransVarUpperBound[TransVarJ1]);\n            }\n            if (!(!(interpolationPoints.getEntry(TransVarEvaluations, TransVarJ1) == upperDifference.getEntry(TransVarJ1)))) {\n                currentBest.setEntry(TransVarJ1, TransVarLowerBound[TransVarJ1]);\n            }\n            TransVarJ1++;\n        }\n\n        final double TransVarValue = computeObjectiveValue(currentBest.toArray());\n        final double TransVarMaximization = isMinimize ? TransVarValue : -TransVarValue;\n        final int TransVarNum = getEvaluations(); // nfm + 1\n        fAtInterpolationPoints.setEntry(TransVarEvaluations, TransVarMaximization);\n\n        if (!(!(TransVarNum == 1))) {\n            TransVarBeg = TransVarMaximization;\n            trustRegionCenterInterpolationPointIndex = 0;\n        } else if (!(!(TransVarMaximization < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)))) {\n            trustRegionCenterInterpolationPointIndex = TransVarEvaluations;\n        }\n\n        // Set the nonzero initial elements of BMAT and the quadratic model in the\n        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n        // order that the function value at the first of them contributes to the\n        // off-diagonal second derivative terms of the initial quadratic model.\n\n        if (!(!(TransVarNum <= 2 * TransVarDimension + 1))) {\n            if (!(!(TransVarNum >= 2 && TransVarNum <= TransVarDimension + 1))) {\n                gradientAtTrustRegionCenter.setEntry(TransVarNfmmm, (TransVarMaximization - TransVarBeg) / TransVarStep);\n                if (!(!(TransVarNumberOfPoints < TransVarNum + TransVarDimension))) {\n                    final double TransVarOos = ONE / TransVarStep;\n                    bMatrix.setEntry(0, TransVarNfmmm, -TransVarOos);\n                    bMatrix.setEntry(TransVarEvaluations, TransVarNfmmm, TransVarOos);\n                    bMatrix.setEntry(TransVarNumberOfPoints + TransVarNfmmm, TransVarNfmmm, -HALF * TransVarTrustRegionRadiusSquared);\n                    throw new PathIsExploredException(); // XXX\n                }\n            } else if (!(!(TransVarNum >= TransVarDimension + 2))) {\n                final int TransVarIj = TransVarNf * (TransVarNf + 1) / 2 - 1;\n                final double TransVarFNew = (TransVarMaximization - TransVarBeg) / TransVarStepa;\n                final double TransVarH = TransVarStepa - TransVarStep;\n                modelSecondDerivativesValues.setEntry(TransVarIj, TWO * (TransVarFNew - gradientAtTrustRegionCenter.getEntry(TransVarNfx)) / TransVarH);\n                gradientAtTrustRegionCenter.setEntry(TransVarNfx, (gradientAtTrustRegionCenter.getEntry(TransVarNfx) * TransVarStepa - TransVarFNew * TransVarStep) / TransVarH);\n                if (!(!(TransVarStep * TransVarStepa < ZERO))) {\n                    if (!(!(TransVarMaximization < fAtInterpolationPoints\n                            .getEntry(TransVarEvaluations - TransVarDimension)))) {\n                        fAtInterpolationPoints.setEntry(TransVarEvaluations, fAtInterpolationPoints.getEntry(TransVarEvaluations - TransVarDimension));\n                        fAtInterpolationPoints.setEntry(TransVarEvaluations - TransVarDimension, TransVarMaximization);\n                        if (!(!(trustRegionCenterInterpolationPointIndex == TransVarEvaluations))) {\n                            trustRegionCenterInterpolationPointIndex = TransVarEvaluations - TransVarDimension;\n                        }\n                        interpolationPoints.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx, TransVarStepa);\n                        interpolationPoints.setEntry(TransVarEvaluations, TransVarNfx, TransVarStep);\n                    }\n                }\n                bMatrix.setEntry(0, TransVarNfx, -(TransVarStep + TransVarStepa) / (TransVarStep * TransVarStepa));\n                bMatrix.setEntry(TransVarEvaluations, TransVarNfx, -HALF / interpolationPoints.getEntry(TransVarEvaluations - TransVarDimension, TransVarNfx));\n                bMatrix.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx,\n                              -bMatrix.getEntry(0, TransVarNfx) - bMatrix.getEntry(TransVarEvaluations, TransVarNfx));\n                zMatrix.setEntry(0, TransVarNfx, Math.sqrt(TWO) / (TransVarStep * TransVarStepa));\n                zMatrix.setEntry(TransVarEvaluations, TransVarNfx, Math.sqrt(HALF) / TransVarTrustRegionRadiusSquared);\n                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                zMatrix.setEntry(TransVarEvaluations - TransVarDimension, TransVarNfx,\n                              -zMatrix.getEntry(0, TransVarNfx) - zMatrix.getEntry(TransVarEvaluations, TransVarNfx));\n            }\n\n            // Set the off-diagonal second derivatives of the Lagrange functions and\n            // the initial quadratic model.\n\n        } else {\n            zMatrix.setEntry(0, TransVarNfx, TransVarReciprocalRhosq);\n            zMatrix.setEntry(TransVarEvaluations, TransVarNfx, TransVarReciprocalRhosq);\n            zMatrix.setEntry(TransVarIp, TransVarNfx, -TransVarReciprocalRhosq);\n            zMatrix.setEntry(TransVarIpt, TransVarNfx, -TransVarReciprocalRhosq);\n\n            final int TransVarIpIndex = TransVarIp * (TransVarIp - 1) / 2 + TransVarIpt - 1;\n            final double TransVarTemp = interpolationPoints.getEntry(TransVarEvaluations, TransVarIp - 1) * interpolationPoints.getEntry(TransVarEvaluations, TransVarIpt - 1);\n            modelSecondDerivativesValues.setEntry(TransVarIpIndex, (TransVarBeg - fAtInterpolationPoints.getEntry(TransVarIp) - fAtInterpolationPoints.getEntry(TransVarIpt) + TransVarMaximization) / TransVarTemp);\n            throw new PathIsExploredException(); // XXX \n        }\n    } while (!(!(getEvaluations() < TransVarNumberOfPoints)));\n} // prelim\n",
    "start": 1582,
    "end": 1755,
    "location": [
      1680,
      1682,
      1683,
      1777
    ],
    "file_path": "src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java"
  },
  "Math-43": {
    "buggy": "public void addValue(double TransVarValue1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    sumImpl.increment(TransVarValue1);\n    sumsqImpl.increment(TransVarValue1);\n    minImpl.increment(TransVarValue1);\n    maxImpl.increment(TransVarValue1);\n    sumLogImpl.increment(TransVarValue1);\n    secondMoment.increment(TransVarValue1);\n    // If mean, variance or geomean have been overridden,\n    // need to increment these\n    if (!(!(!(meanImpl instanceof Mean)))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        meanImpl.increment(TransVarValue1);\n    }\n    if (!(!(!(varianceImpl instanceof Variance)))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        varianceImpl.increment(TransVarValue1);\n    }\n    if (!(!(!(geoMeanImpl instanceof GeometricMean)))) { \n        geoMeanImpl.increment(TransVarValue1);\n    }\n    n++;\n}\n",
    "start": 149,
    "end": 168,
    "location": [
      161,
      167,
      173
    ],
    "file_path": "src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java"
  },
  "Math-45": {
    "buggy": "public OpenMapRealMatrix(int TransVarRow, int TransVarRowDimension) {\n    super(TransVarRow, TransVarRowDimension);\n    this.rows = TransVarRow; \n    this.columns = TransVarRowDimension;\n    this.entries = new OpenIntToDoubleHashMap(0.0);\n}\n",
    "start": 48,
    "end": 53,
    "location": [
      50
    ],
    "file_path": "src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java"
  },
  "Math-5": {
    "buggy": "public Complex reciprocal() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(isNaN))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return NaN;\n    }\n\n    if (!(!(real == 0.0 && imaginary == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return NaN; \n    }\n\n    if (!(!(isInfinite))) {\n        return ZERO;\n    }\n\n    if (!(!(FastMath.abs(real) < FastMath.abs(imaginary)))) {\n        double TransVarRealPart = real / imaginary;\n        double TransVarRealScale = 1. / (real * TransVarRealPart + imaginary);\n        return createComplex(TransVarRealScale * TransVarRealPart, -TransVarRealScale);\n    } else {\n        double TransVarImaginaryPart = imaginary / real;\n        double TransVarScale2 = 1. / (imaginary * TransVarImaginaryPart + real);\n        return createComplex(TransVarScale2, -TransVarScale2 * TransVarImaginaryPart);\n    }\n}\n",
    "start": 299,
    "end": 321,
    "location": [
      314
    ],
    "file_path": "src/main/java/org/apache/commons/math3/complex/Complex.java"
  },
  "Math-52": {
    "buggy": "public Rotation(Vector3D TransVarU, Vector3D TransVarU1, Vector3D TransVarVector1, Vector3D TransVarVector) {\n\n// norms computation\nif (!(!(false))) {\n        System.out.println(\"log\");\n    }\ndouble TransVarUu1 = TransVarU.getNormSq();\ndouble TransVarU2NormSq = TransVarU1.getNormSq();\ndouble TransVarU1NormSq = TransVarVector1.getNormSq();\ndouble TransVarV2v2NormSq = TransVarVector.getNormSq();\nif (!(!((TransVarUu1 == 0) || (TransVarU2NormSq == 0) || (TransVarU1NormSq == 0) || (TransVarV2v2NormSq == 0)))) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nthrow MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n}\n\n// normalize v1 in order to have (v1'|v1') = (u1|u1)\nTransVarVector1 = new Vector3D(FastMath.sqrt(TransVarUu1 / TransVarU1NormSq), TransVarVector1);\n\n// adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\ndouble TransVarDotProduct   = TransVarU.dotProduct(TransVarU1);\ndouble TransVarU1v1v2   = TransVarVector1.dotProduct(TransVarVector);\ndouble TransVarCoeff = TransVarDotProduct / TransVarUu1;\ndouble TransVarCoeffV1 = TransVarU1v1v2 / TransVarUu1;\ndouble TransVarCoeffBeta   = FastMath.sqrt((TransVarU2NormSq - TransVarDotProduct * TransVarCoeff) / (TransVarV2v2NormSq - TransVarU1v1v2 * TransVarCoeffV1));\ndouble TransVarCoeffAlpha  = TransVarCoeff - TransVarCoeffBeta * TransVarCoeffV1;\nTransVarVector = new Vector3D(TransVarCoeffAlpha, TransVarVector1, TransVarCoeffBeta, TransVarVector);\n\n// preliminary computation\nVector3D TransVarU1Ref  = TransVarU;\nVector3D TransVarVRef3D  = TransVarVector1;\nVector3D TransVarV1Su1v2 = TransVarVector1.subtract(TransVarU);\nVector3D TransVarV1Su2 = TransVarVector.subtract(TransVarU1);\nVector3D TransVarCrossProduct     = TransVarV1Su1v2.crossProduct(TransVarV1Su2);\nVector3D TransVarCrossProductVector    = TransVarU.crossProduct(TransVarU1);\ndouble TransVarCoefficient       = TransVarCrossProduct.dotProduct(TransVarCrossProductVector);\nif (!(!(TransVarCoefficient == 0))) { \n  // the (q1, q2, q3) vector is close to the (u1, u2) plane\n  // we try other vectors\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nVector3D TransVarV4 = Vector3D.crossProduct(TransVarVector1, TransVarVector);\n  Vector3D TransVarV3Su4 = TransVarV4.subtract(TransVarCrossProductVector);\n  TransVarCrossProduct = TransVarV1Su1v2.crossProduct(TransVarV3Su4);\n  Vector3D TransVarU3Cross = TransVarU.crossProduct(TransVarCrossProductVector);\n  TransVarCoefficient = TransVarCrossProduct.dotProduct(TransVarU3Cross);\n\n  if (!(!(TransVarCoefficient == 0))) { \n    // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n    // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n    TransVarCrossProduct = TransVarV1Su2.crossProduct(TransVarV3Su4);;\n    TransVarCoefficient = TransVarCrossProduct.dotProduct(TransVarU1.crossProduct(TransVarCrossProductVector));;\n\n    if (!(!(TransVarCoefficient == 0))) { \n      // the (q1, q2, q3) vector is aligned with everything\n      // this is really the identity rotation\n      q0 = 1.0;\n      q1 = 0.0;\n      q2 = 0.0;\n      q3 = 0.0;\n      return;\n    }\n\n    // we will have to use u2 and v2 to compute the scalar part\n    TransVarU1Ref = TransVarU1;\n    TransVarVRef3D = TransVarVector;\n\n  }\n\n}\n\n// compute the vectorial part\nTransVarCoefficient = FastMath.sqrt(TransVarCoefficient);\ndouble TransVarInvC = 1.0 / (TransVarCoefficient + TransVarCoefficient);\nq1 = TransVarInvC * TransVarCrossProduct.getX();\nq2 = TransVarInvC * TransVarCrossProduct.getY();\nq3 = TransVarInvC * TransVarCrossProduct.getZ();\n\n// compute the scalar part\n TransVarCrossProduct = new Vector3D(TransVarU1Ref.getY() * q3 - TransVarU1Ref.getZ() * q2,\n                  TransVarU1Ref.getZ() * q1 - TransVarU1Ref.getX() * q3,\n                  TransVarU1Ref.getX() * q2 - TransVarU1Ref.getY() * q1);\nq0 = TransVarVRef3D.dotProduct(TransVarCrossProduct) / (2 * TransVarCrossProduct.getNormSq());\n\n}\n",
    "start": 313,
    "end": 390,
    "location": [
      350,
      362,
      368
    ],
    "file_path": "src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java"
  },
  "Math-53": {
    "buggy": "public Complex add(Complex TransVarLhs)\n    throws NullArgumentException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    MathUtils.checkNotNull(TransVarLhs);\n    return createComplex(real + TransVarLhs.getReal(), \n        imaginary + TransVarLhs.getImaginary());\n}\n",
    "start": 150,
    "end": 155,
    "location": [
      156
    ],
    "file_path": "src/main/java/org/apache/commons/math/complex/Complex.java"
  },
  "Math-55": {
    "buggy": "public static Vector3D crossProduct(final Vector3D TransVarVector3D, final Vector3D TransVarVector2D) {\n\n \n    // rescale both vectors without losing precision,\n    // to ensure their norm are the same order of magnitude\n \n    // we reduce cancellation errors by preconditioning,\n    // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n    // v3 without loss of precision. See Kahan lecture\n    // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n    // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n    // compute cross product from v3 and v2 instead of v1 and v2\n    return new Vector3D(TransVarVector3D.y * TransVarVector2D.z - TransVarVector3D.z * TransVarVector2D.y, TransVarVector3D.z * TransVarVector2D.x - TransVarVector3D.x * TransVarVector2D.z, TransVarVector3D.x * TransVarVector2D.y - TransVarVector3D.y * TransVarVector2D.x); \n\n}\n",
    "start": 457,
    "end": 475,
    "location": [
      459,
      462,
      473,
      474,
      476
    ],
    "file_path": "src/main/java/org/apache/commons/math/geometry/Vector3D.java"
  },
  "Math-58": {
    "buggy": "public double[] fit() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final double[] TransVarParameters = (new ParameterGuesser(getObservations())).guess();\n    return fit(new Gaussian.Parametric(), TransVarParameters); \n}\n",
    "start": 119,
    "end": 122,
    "location": [
      124
    ],
    "file_path": "src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java"
  },
  "Math-59": {
    "buggy": "public static float max(final float TransVarB, final float TransVarC) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return (TransVarB <= TransVarC) ? TransVarC : (Float.isNaN(TransVarB + TransVarC) ? Float.NaN : TransVarC); \n}\n",
    "start": 3481,
    "end": 3483,
    "location": [
      3485
    ],
    "file_path": "src/main/java/org/apache/commons/math/util/FastMath.java"
  },
  "Math-60": {
    "buggy": "public double cumulativeProbability(double TransVarValue) throws MathException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final double TransVarDeviation = TransVarValue - mean;\n    try { \n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return 0.5 * (1.0 + Erf.erf((TransVarDeviation) /\n                (standardDeviation * FastMath.sqrt(2.0))));\n    } catch (MaxIterationsExceededException TransVarMaxIterationsExceededException) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarValue < (mean - 20 * standardDeviation)))) { // JDK 1.5 blows at 38 \n            return 0; \n        } else if (!(!(TransVarValue > (mean + 20 * standardDeviation)))) { \n            return 1; \n        } else { \n            throw TransVarMaxIterationsExceededException; \n        } \n    } \n}\n",
    "start": 124,
    "end": 138,
    "location": [
      129,
      135,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      146
    ],
    "file_path": "src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java"
  },
  "Math-63": {
    "buggy": "public static boolean equals(double TransVarY, double TransVarX) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return (Double.isNaN(TransVarY) && Double.isNaN(TransVarX)) || TransVarY == TransVarX; \n}\n",
    "start": 416,
    "end": 418,
    "location": [
      420
    ],
    "file_path": "src/main/java/org/apache/commons/math/util/MathUtils.java"
  },
  "Math-70": {
    "buggy": "public double solve(final UnivariateRealFunction TransVarFunction, double TransVarMinValue, double TransVarMaximum, double TransVarInitialValue)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return solve(TransVarMinValue, TransVarMaximum); \n}\n",
    "start": 70,
    "end": 73,
    "location": [
      75
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java"
  },
  "Math-72": {
    "buggy": "public double solve(final UnivariateRealFunction TransVarFunction,\n                    final double TransVarMinValue, final double TransVarMaxValue, final double TransVarMin)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    clearResult();\n    verifySequence(TransVarMinValue, TransVarMin, TransVarMaxValue);\n\n    // return the initial guess if it is good enough\n    double TransVarY = TransVarFunction.value(TransVarMin);\n    if (!(!(Math.abs(TransVarY) <= functionValueAccuracy))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        setResult(TransVarMin, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double TransVarMinY = TransVarFunction.value(TransVarMinValue);\n    if (!(!(Math.abs(TransVarMinY) <= functionValueAccuracy))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        setResult(TransVarMinY, 0); \n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (!(!(TransVarY * TransVarMinY < 0))) {\n        return solve(TransVarFunction, TransVarMinValue, TransVarMinY, TransVarMin, TransVarY, TransVarMinValue, TransVarMinY);\n    }\n\n    // return the second endpoint if it is good enough\n    double TransVarMaxY = TransVarFunction.value(TransVarMaxValue);\n    if (!(!(Math.abs(TransVarMaxY) <= functionValueAccuracy))) {\n        setResult(TransVarMaxY, 0); \n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (!(!(TransVarY * TransVarMaxY < 0))) {\n        return solve(TransVarFunction, TransVarMin, TransVarY, TransVarMaxValue, TransVarMaxY, TransVarMin, TransVarY);\n    }\n\n    if (!(!(TransVarMinY * TransVarMaxY > 0))) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, TransVarMinValue, TransVarMaxValue, TransVarMinY, TransVarMaxY);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(TransVarFunction, TransVarMinValue, TransVarMinY, TransVarMaxValue, TransVarMaxY, TransVarMin, TransVarY);\n\n}\n",
    "start": 98,
    "end": 144,
    "location": [
      124,
      136
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java"
  },
  "Math-73": {
    "buggy": "public double solve(final UnivariateRealFunction TransVarFunction,\n                    final double TransVarMinimum, final double TransVarMaximum, final double TransVarInitialValue)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    clearResult();\n    verifySequence(TransVarMinimum, TransVarInitialValue, TransVarMaximum);\n\n    // return the initial guess if it is good enough\n    double TransVarInitial = TransVarFunction.value(TransVarInitialValue);\n    if (!(!(Math.abs(TransVarInitial) <= functionValueAccuracy))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        setResult(TransVarInitialValue, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double TransVarYMinValue = TransVarFunction.value(TransVarMinimum);\n    if (!(!(Math.abs(TransVarYMinValue) <= functionValueAccuracy))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        setResult(TransVarYMinValue, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (!(!(TransVarInitial * TransVarYMinValue < 0))) {\n        return solve(TransVarFunction, TransVarMinimum, TransVarYMinValue, TransVarInitialValue, TransVarInitial, TransVarMinimum, TransVarYMinValue);\n    }\n\n    // return the second endpoint if it is good enough\n    double TransVarMaxOfFunction = TransVarFunction.value(TransVarMaximum);\n    if (!(!(Math.abs(TransVarMaxOfFunction) <= functionValueAccuracy))) {\n        setResult(TransVarMaxOfFunction, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (!(!(TransVarInitial * TransVarMaxOfFunction < 0))) {\n        return solve(TransVarFunction, TransVarInitialValue, TransVarInitial, TransVarMaximum, TransVarMaxOfFunction, TransVarInitialValue, TransVarInitial);\n    }\n\n \n    // full Brent algorithm starting with provided initial guess\n    return solve(TransVarFunction, TransVarMinimum, TransVarYMinValue, TransVarMaximum, TransVarMaxOfFunction, TransVarInitialValue, TransVarInitial);\n\n}\n",
    "start": 98,
    "end": 140,
    "location": [
      145
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java"
  },
  "Math-75": {
    "buggy": "public double getPct(Object TransVarObject) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return getCumPct((Comparable<?>) TransVarObject); \n}\n",
    "start": 302,
    "end": 304,
    "location": [
      306
    ],
    "file_path": "src/main/java/org/apache/commons/math/stat/Frequency.java"
  },
  "Math-8": {
    "buggy": "public T[] sample(int TransVarNum) throws NotStrictlyPositiveException { \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarNum <= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                TransVarNum);\n    }\n\n    final T[]TransVarArray = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), TransVarNum); \n\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarNum))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarArray[TransVarIndex] = sample();\n        TransVarIndex++;\n    }\n\n    return TransVarArray;\n\n}\n",
    "start": 181,
    "end": 195,
    "location": [
      181,
      193
    ],
    "file_path": "src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java"
  },
  "Math-80": {
    "buggy": "private boolean flipIfWarranted(final int TransVarNumber, final int TransVarNum) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(1.5 * work[pingPong] < work[4 * (TransVarNumber - 1) + pingPong]))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // flip array\n        int TransVarN = 4 * TransVarNumber - 1; \n        int TransVarCount = 0;\n        while (!(!(TransVarCount < TransVarN))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarK2 = 0;\n            while (!(!(TransVarK2 < 4))) {\n                final double TransVarD = work[TransVarCount + TransVarK2];\n                work[TransVarCount + TransVarK2] = work[TransVarN - TransVarK2];\n                work[TransVarN - TransVarK2] = TransVarD;\n                TransVarK2 += TransVarNum;\n            }\n            TransVarN -= 4;\n            TransVarCount += 4;\n        }\n        return true;\n    }\n    return false;\n}\n",
    "start": 1132,
    "end": 1147,
    "location": [
      1141
    ],
    "file_path": "src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java"
  },
  "Math-85": {
    "buggy": "public static double[] bracket(UnivariateRealFunction TransVarFunctionOfVariable,\n        double TransVarVariable, double TransVarLower, double TransVarLowerBound, \n        int TransVarMaxIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    \n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(TransVarFunctionOfVariable == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (!(!(TransVarMaxIterations <= 0)))  {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", TransVarMaxIterations);\n    }\n    if (!(!(TransVarVariable < TransVarLower || TransVarVariable > TransVarLowerBound\n            || TransVarLower >= TransVarLowerBound))) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              TransVarLower, TransVarVariable, TransVarLowerBound);\n    }\n    double TransVarInitial = TransVarVariable;\n    double TransVarVariableOfB = TransVarVariable;\n    double TransVarFunction;\n    double TransVarFunctionOfB;\n    int TransVarNumIteration = 0 ;\n\n    do {\n        TransVarInitial = Math.max(TransVarInitial - 1.0, TransVarLower);\n        TransVarVariableOfB = Math.min(TransVarVariableOfB + 1.0, TransVarLowerBound);\n        TransVarFunction = TransVarFunctionOfVariable.value(TransVarInitial);\n        \n        TransVarFunctionOfB = TransVarFunctionOfVariable.value(TransVarVariableOfB);\n        TransVarNumIteration++ ;\n    } while (!(!((TransVarFunction * TransVarFunctionOfB > 0.0) && (TransVarNumIteration < TransVarMaxIterations)\n            && ((TransVarInitial > TransVarLower) || (TransVarVariableOfB < TransVarLowerBound)))));\n\n    if (!(!(TransVarFunction * TransVarFunctionOfB >= 0.0)) ) { \n        throw new ConvergenceException(\n                  \"number of iterations={0}, maximum iterations={1}, \" +\n                  \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                  \"final b value={6}, f(a)={7}, f(b)={8}\",\n                  TransVarNumIteration, TransVarMaxIterations, TransVarVariable,\n                  TransVarLower, TransVarLowerBound, TransVarInitial, TransVarVariableOfB, TransVarFunction, TransVarFunctionOfB);\n    }\n    \n    return new double[]{TransVarInitial, TransVarVariableOfB};\n}\n",
    "start": 165,
    "end": 208,
    "location": [
      208
    ],
    "file_path": "src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java"
  },
  "Math-89": {
    "buggy": "public void addValue(Object TransVarO) {\n        if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n        addValue((Comparable<?>) TransVarO);             \n} \n",
    "start": 109,
    "end": 111,
    "location": [
      113,
      114
    ],
    "file_path": "src/java/org/apache/commons/math/stat/Frequency.java"
  },
  "Math-9": {
    "buggy": "public Line revert() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final Line TransVarLineReversed = new Line(zero, zero.subtract(direction)); \n    return TransVarLineReversed;\n}\n",
    "start": 86,
    "end": 89,
    "location": [
      90
    ],
    "file_path": "src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java"
  },
  "Math-90": {
    "buggy": "public void addValue(Object TransVarValue) {\n if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    \n/**\n * Adds 1 to the frequency count for v.\n * <p>\n * If other objects have already been added to this Frequency, v must\n * be comparable to those that have already been added.\n * </p>\n * \n * @param v the value to add.\n * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n */\n    Object TransVarObject = TransVarValue; \n    if (!(!(TransVarValue instanceof Integer))) {\n       if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarObject = Long.valueOf(((Integer) TransVarValue).longValue());\n    }\n    try {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Long TransVarFrequency = (Long) freqTable.get(TransVarObject);\n        if (!(!(TransVarFrequency == null))) {\n            freqTable.put(TransVarObject, Long.valueOf(1));\n        } else {\n            freqTable.put(TransVarObject, Long.valueOf(TransVarFrequency.longValue() + 1));\n        }\n    } catch (ClassCastException TransVarExcep) {   \n        //TreeMap will throw ClassCastException if v is not comparable\n        throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n    }\n}\n",
    "start": 109,
    "end": 136,
    "location": [
      113,
      124
    ],
    "file_path": "src/java/org/apache/commons/math/stat/Frequency.java"
  },
  "Math-91": {
    "buggy": "public int compareTo(Fraction TransVarFraction) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double TransVarNumber = doubleValue(); \n    double TransVarDoubleValue = TransVarFraction.doubleValue(); \n    return (TransVarNumber < TransVarDoubleValue) ? -1 : ((TransVarNumber > TransVarDoubleValue) ? +1 : 0);\n}\n",
    "start": 258,
    "end": 262,
    "location": [
      262,
      263
    ],
    "file_path": "src/java/org/apache/commons/math/fraction/Fraction.java"
  },
  "Math-94": {
    "buggy": "public static int gcd(int TransVarX, int TransVarI) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarX * TransVarI == 0))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return (Math.abs(TransVarX) + Math.abs(TransVarI));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    /* assert u!=0 && v!=0; */\n    if (!(!(TransVarX > 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarX = -TransVarX;\n    } // make u negative\n    if (!(!(TransVarI > 0))) {\n        TransVarI = -TransVarI;\n    } // make v negative\n    // B1. [Find power of 2]\n    int TransVarIndex = 0;\n    for (; !(!((TransVarX & 1) == 0 && (TransVarI & 1) == 0 && TransVarIndex < 31));) {\n        TransVarX /= 2;\n        TransVarI /= 2;\n        TransVarIndex++;\n    }\n    if (!(!(TransVarIndex == 31))) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int TransVarR = ((TransVarX & 1) == 1) ? TransVarI : -(TransVarX / 2)/* B3 */;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        for (; !(!((TransVarR & 1) == 0));) {\n            TransVarR /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (!(!(TransVarR > 0))) {\n            TransVarX = -TransVarR;\n        } else {\n            TransVarI = TransVarR;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        TransVarR = (TransVarI - TransVarX) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (!(!(TransVarR != 0)));\n    return -TransVarX * (1 << TransVarIndex); // gcd is u*2^k\n}\n",
    "start": 411,
    "end": 460,
    "location": [
      415
    ],
    "file_path": "src/java/org/apache/commons/math/util/MathUtils.java"
  },
  "Math-95": {
    "buggy": "protected double getInitialDomain(double TransVarPr) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double TransVarResult; \n    double TransVarDenominatorDegreesOfFreedom = getDenominatorDegreesOfFreedom();\n        // use mean \n        TransVarResult = TransVarDenominatorDegreesOfFreedom / (TransVarDenominatorDegreesOfFreedom - 2.0);\n    return TransVarResult; \n}\n",
    "start": 143,
    "end": 149,
    "location": [
      147,
      149,
      151
    ],
    "file_path": "src/java/org/apache/commons/math/distribution/FDistributionImpl.java"
  },
  "Math-96": {
    "buggy": "public boolean equals(Object TransVarObj) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    boolean TransVarResult;\n    \n    if (!(!(this == TransVarObj))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarResult = true;\n    } else if (!(!(TransVarObj == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarResult = false;\n    } else  {\n        try {\n            Complex TransVarComplex = (Complex)TransVarObj;\n            if (!(!(TransVarComplex.isNaN()))) {\n                TransVarResult = this.isNaN();\n            } else {\n                TransVarResult = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(TransVarComplex.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(TransVarComplex.getImaginary()));  \n            }\n        } catch (ClassCastException TransVarCastEx) {\n            // ignore exception\n            TransVarResult = false;\n        }\n    }\n  \n    return TransVarResult;\n}\n",
    "start": 245,
    "end": 267,
    "location": [
      267
    ],
    "file_path": "src/java/org/apache/commons/math/complex/Complex.java"
  },
  "Math-97": {
    "buggy": "public double solve(double TransVarMinimum, double TransVarMax_number) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n    \n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    clearResult();\n    verifyInterval(TransVarMinimum, TransVarMax_number);\n    \n    double TransVarMaxNum = Double.NaN;\n    \n    double TransVarYMin_yMin = f.value(TransVarMinimum);\n    double TransVarMaxY = f.value(TransVarMax_number);\n    \n    // Verify bracketing\n    double TransVarSignOfX = TransVarYMin_yMin * TransVarMaxY;\n    if (!(!(TransVarSignOfX >= 0))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n            // check if either value is close to a zero\n            // neither value is close to zero and min and max do not bracket root. \n            throw new IllegalArgumentException\n            (\"Function values at endpoints do not have different signs.\" +\n                    \"  Endpoints: [\" + TransVarMinimum + \",\" + TransVarMax_number + \"]\" + \n                    \"  Values: [\" + TransVarYMin_yMin + \",\" + TransVarMaxY + \"]\");\n    } else { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // solve using only the first endpoint as initial guess\n        TransVarMaxNum = solve(TransVarMinimum, TransVarYMin_yMin, TransVarMax_number, TransVarMaxY, TransVarMinimum, TransVarYMin_yMin);\n        // either min or max is a root \n    } \n\n    return TransVarMaxNum;\n}\n",
    "start": 125,
    "end": 152,
    "location": [
      141,
      146,
      151,
      157,
      158
    ],
    "file_path": "src/java/org/apache/commons/math/analysis/BrentSolver.java"
  },
  "Mockito-1": {
    "buggy": "public void captureArgumentsFrom(Invocation TransVarInvocation0) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarInvocation0.getMethod().isVarArgs()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarIndexOfLastArg = TransVarInvocation0.getRawArguments().length - 1;\n        throw new UnsupportedOperationException(); \n\n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarIndex = 0;\n        while (!(!(TransVarIndex < matchers.size()))) {\n            Matcher TransVarMatcher = matchers.get(TransVarIndex);\n            if (!(!(TransVarMatcher instanceof CapturesArguments))) {\n                ((CapturesArguments) TransVarMatcher)\n                        .captureFrom(TransVarInvocation0.getArgumentAt(TransVarIndex, Object.class));\n            }\n            TransVarIndex++;\n        }\n    }\n\n      int TransVar4Position = 0;\n    while (!(!(TransVar4Position < matchers.size()))) {\n        Matcher TransVar5M = matchers.get(TransVar4Position);\n        if (!(!(TransVar5M instanceof CapturesArguments\n                && TransVarInvocation0.getRawArguments().length > TransVar4Position))) {\n            if (!(!(isVariableArgument(TransVarInvocation0, TransVar4Position) && isVarargMatcher(TransVar5M)))) {\n                Object TransVar6Array = TransVarInvocation0.getRawArguments()[TransVar4Position];\n                int TransVar7I = 0;\n                while (!(!(TransVar7I < Array.getLength(TransVar6Array)))) {\n                    ((CapturesArguments) TransVar5M).captureFrom(Array.get(TransVar6Array, TransVar7I));\n                    TransVar7I++;\n                }\n                return;\n            } else {\n                ((CapturesArguments) TransVar5M).captureFrom(TransVarInvocation0.getRawArguments()[TransVar4Position]);\n            }\n        }\n        TransVar4Position++;\n    }\n}\n",
    "start": 120,
    "end": 150,
    "location": [
      129
    ],
    "file_path": "src/org/mockito/internal/invocation/InvocationMatcher.java"
  },
  "Mockito-12": {
    "buggy": "public Class getGenericType(Field TransVarFieldName) {        \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Type TransVarType = TransVarFieldName.getGenericType();\n    if (!(!(TransVarType != null && TransVarType instanceof ParameterizedType))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Type TransVarFieldClass = ((ParameterizedType) TransVarType).getActualTypeArguments()[0];\n            return (Class) TransVarFieldClass; \n            //in case of nested generics we don't go deep \n    } \n    \n    return Object.class;\n}\n",
    "start": 16,
    "end": 25,
    "location": [
      26,
      27,
      28
    ],
    "file_path": "src/org/mockito/internal/util/reflection/GenericMaster.java"
  },
  "Mockito-13": {
    "buggy": "public Object handle(Invocation TransVarInvocation1) throws Throwable {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(invocationContainerImpl.hasAnswersForStubbing()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher TransVarInvocationMatcherForMock = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), TransVarInvocation1);\n        invocationContainerImpl.setMethodForStubbing(TransVarInvocationMatcherForMock);\n        return null;\n    }\n    VerificationMode TransVarVerificationModeForPull = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher TransVarInvocationMatcherForPull = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    TransVarInvocation1);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (!(!(TransVarVerificationModeForPull != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (!(!(TransVarVerificationModeForPull instanceof MockAwareVerificationMode\n                && ((MockAwareVerificationMode) TransVarVerificationModeForPull).getMock() == TransVarInvocation1\n                        .getMock()))) {                 \n            VerificationDataImpl TransVarVerificationData = new VerificationDataImpl(invocationContainerImpl, TransVarInvocationMatcherForPull);            \n            TransVarVerificationModeForPull.verify(TransVarVerificationData);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode  \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } \n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(TransVarInvocationMatcherForPull);\n    OngoingStubbingImpl<T> TransVarStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(TransVarStubbing);\n\n    StubbedInvocationMatcher TransVarStubbedInvocationMatcher = invocationContainerImpl.findAnswerFor(TransVarInvocation1);\n\n    if (!(!(TransVarStubbedInvocationMatcher != null))) {\n        TransVarStubbedInvocationMatcher.captureArgumentsFrom(TransVarInvocation1);\n        return TransVarStubbedInvocationMatcher.answer(TransVarInvocation1);\n    } else {\n        Object TransVarAnswer = mockSettings.getDefaultAnswer().answer(TransVarInvocation1);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(TransVarInvocationMatcherForPull);\n        return TransVarAnswer;\n    }\n}\n",
    "start": 58,
    "end": 106,
    "location": [
      88,
      92,
      94
    ],
    "file_path": "src/org/mockito/internal/MockHandler.java"
  },
  "Mockito-18": {
    "buggy": "Object returnValueFor(Class<?> TransVarGenericType) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(Primitives.isPrimitiveOrWrapper(TransVarGenericType)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return Primitives.defaultValueForPrimitiveOrWrapper(TransVarGenericType);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n    } else if (!(!(TransVarGenericType == Collection.class))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return new LinkedList<Object>();\n    } else if (!(!(TransVarGenericType == Set.class))) {\n        return new HashSet<Object>();\n    } else if (!(!(TransVarGenericType == HashSet.class))) {\n        return new HashSet<Object>();\n    } else if (!(!(TransVarGenericType == SortedSet.class))) {\n        return new TreeSet<Object>();\n    } else if (!(!(TransVarGenericType == TreeSet.class))) {\n        return new TreeSet<Object>();\n    } else if (!(!(TransVarGenericType == LinkedHashSet.class))) {\n        return new LinkedHashSet<Object>();\n    } else if (!(!(TransVarGenericType == List.class))) {\n        return new LinkedList<Object>();\n    } else if (!(!(TransVarGenericType == LinkedList.class))) {\n        return new LinkedList<Object>();\n    } else if (!(!(TransVarGenericType == ArrayList.class))) {\n        return new ArrayList<Object>();\n    } else if (!(!(TransVarGenericType == Map.class))) {\n        return new HashMap<Object, Object>();\n    } else if (!(!(TransVarGenericType == HashMap.class))) {\n        return new HashMap<Object, Object>();\n    } else if (!(!(TransVarGenericType == SortedMap.class))) {\n        return new TreeMap<Object, Object>();\n    } else if (!(!(TransVarGenericType == TreeMap.class))) {\n        return new TreeMap<Object, Object>();\n    } else if (!(!(TransVarGenericType == LinkedHashMap.class))) {\n        return new LinkedHashMap<Object, Object>();\n    }\n    //Let's not care about the rest of collections.\n    return null;\n}\n",
    "start": 82,
    "end": 118,
    "location": [
      93
    ],
    "file_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java"
  },
  "Mockito-20": {
    "buggy": "public <T> T createMock(MockCreationSettings<T> TransVarMockSettings, MockHandler TransVarMock) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarMockSettings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class<? extends T> TransVarMockedProxyTypeClass = cachingMockBytecodeGenerator.get(\n            TransVarMockSettings.getTypeToMock(),\n            TransVarMockSettings.getExtraInterfaces()\n    );\n    T TransVarMockedObject = null; \n    try {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarMockedObject = classInstantiator.instantiate(TransVarMockedProxyTypeClass); \n        MockMethodInterceptor.MockAccess TransVarMockAccessProxy = (MockMethodInterceptor.MockAccess) TransVarMockedObject;\n        TransVarMockAccessProxy.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(TransVarMock), TransVarMockSettings));\n\n        return ensureMockIsAssignableToMockedType(TransVarMockSettings, TransVarMockedObject);\n    } catch (ClassCastException TransVarClassCastException) {\n        throw new MockitoException(join(\n                \"ClassCastException occurred while creating the mockito mock :\",\n                \"  class to mock : \" + describeClass(TransVarMockedProxyTypeClass),\n                \"  created class : \" + describeClass(TransVarMockSettings.getTypeToMock()),\n                \"  proxy instance class : \" + describeClass(TransVarMockedObject),\n                \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(), \n                \"\",\n                \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                \"\"\n        ),TransVarClassCastException);\n    } catch (org.mockito.internal.creation.instance.InstantiationException TransVarInstantiationException) {\n        throw new MockitoException(\"Unable to create mock instance of type '\" + TransVarMockedProxyTypeClass.getSuperclass().getSimpleName() + \"'\", TransVarInstantiationException);\n    }\n}\n",
    "start": 24,
    "end": 53,
    "location": [
      38,
      43,
      54
    ],
    "file_path": "src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java"
  },
  "Mockito-22": {
    "buggy": "public static boolean areEqual(Object TransVarO, Object TransVarO1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarO == null || TransVarO1 == null))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarO == null && TransVarO1 == null;\n    } else if (!(!(isArray(TransVarO)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return isArray(TransVarO1) && areArraysEqual(TransVarO, TransVarO1);\n    } else {\n        return TransVarO.equals(TransVarO1);\n    }\n}\n",
    "start": 12,
    "end": 20,
    "location": [
      16
    ],
    "file_path": "src/org/mockito/internal/matchers/Equality.java"
  },
  "Mockito-24": {
    "buggy": "public Object answer(InvocationOnMock TransVarInvocationMock) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(methodsGuru.isToString(TransVarInvocationMock.getMethod())))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Object TransVarObjectMock = TransVarInvocationMock.getMock();\n        MockName TransVarMockName = mockUtil.getMockName(TransVarObjectMock);\n        if (!(!(TransVarMockName.isDefault()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return \"Mock for \" + mockUtil.getMockSettings(TransVarObjectMock).getTypeToMock().getSimpleName() + \", hashCode: \" + TransVarObjectMock.hashCode();\n        } else {\n            return TransVarMockName.toString();\n        }\n    } else if (!(!(methodsGuru.isCompareToMethod(TransVarInvocationMock.getMethod())))) {\n        //see issue 184.\n        //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n        //Only for compareTo() method by the Comparable interface\n        return 1; \n    }\n    \n    Class<?> TransVarReturnType1 = TransVarInvocationMock.getMethod().getReturnType();\n    return returnValueFor(TransVarReturnType1);\n}\n",
    "start": 63,
    "end": 81,
    "location": [
      85
    ],
    "file_path": "src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java"
  },
  "Mockito-27": {
    "buggy": "public <T> void resetMock(T TransVarTestMock) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    MockHandlerInterface<T> TransVarMock = getMockHandler(TransVarTestMock);\n    MockHandler<T> TransVarNewMockHandler1 = new MockHandler<T>(TransVarMock); \n    MethodInterceptorFilter TransVarNewMockFilter = new MethodInterceptorFilter(TransVarNewMockHandler1, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); \n    ((Factory) TransVarTestMock).setCallback(0, TransVarNewMockFilter);\n}\n",
    "start": 62,
    "end": 67,
    "location": [
      67,
      68
    ],
    "file_path": "src/org/mockito/internal/util/MockUtil.java"
  },
  "Mockito-28": {
    "buggy": "private void injectMockCandidate(Class<?> TransVarAwaitingInjectionClazzObject, Set<Object> TransVarMocksSet, Object TransVarField) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for(Field TransVarMockField : orderedInstanceFieldsFrom(TransVarAwaitingInjectionClazzObject)) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        mockCandidateFilter.filterCandidate(TransVarMocksSet, TransVarMockField, TransVarField).thenInject(); \n    }\n}\n",
    "start": 91,
    "end": 95,
    "location": [
      99
    ],
    "file_path": "src/org/mockito/internal/configuration/DefaultInjectionEngine.java"
  },
  "Mockito-29": {
    "buggy": "public void describeTo(Description TransVarDesc) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarDesc.appendText(\"same(\");\n    appendQuoting(TransVarDesc);\n    TransVarDesc.appendText(wanted.toString()); \n    appendQuoting(TransVarDesc);\n    TransVarDesc.appendText(\")\");\n}\n",
    "start": 26,
    "end": 32,
    "location": [
      32
    ],
    "file_path": "src/org/mockito/internal/matchers/Same.java"
  },
  "Mockito-33": {
    "buggy": "public boolean hasSameMethod(Invocation TransVarInvocation) {        \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    //not using method.equals() for 1 good reason:\n    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method TransVarMethod = invocation.getMethod();\n    Method TransVarM = TransVarInvocation.getMethod();\n    \n        /* Avoid unnecessary cloning */ \n    return TransVarMethod.equals(TransVarM); \n}\n",
    "start": 92,
    "end": 100,
    "location": [
      101,
      102
    ],
    "file_path": "src/org/mockito/internal/invocation/InvocationMatcher.java"
  },
  "Mockito-34": {
    "buggy": "public void captureArgumentsFrom(Invocation TransVarInvocation) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarI = 0;\n    for (Matcher TransVarMatcher : matchers) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarMatcher instanceof CapturesArguments))) { \n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            ((CapturesArguments) TransVarMatcher).captureFrom(TransVarInvocation.getArguments()[TransVarI]);\n        }\n        TransVarI++;\n    }\n}\n",
    "start": 103,
    "end": 111,
    "location": [
      112
    ],
    "file_path": "src/org/mockito/internal/invocation/InvocationMatcher.java"
  },
  "Mockito-38": {
    "buggy": "private boolean toStringEquals(Matcher TransVarMatcher, Object TransVarResult) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return StringDescription.toString(TransVarMatcher).equals(TransVarResult.toString()); \n}\n",
    "start": 47,
    "end": 49,
    "location": [
      51
    ],
    "file_path": "src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java"
  },
  "Mockito-7": {
    "buggy": "private void readTypeVariables() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (Type TransVarType2 : typeVariable.getBounds()) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        registerTypeVariablesOn(TransVarType2);\n    }\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); \n}\n",
    "start": 375,
    "end": 380,
    "location": [
      385
    ],
    "file_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java"
  },
  "Time-14": {
    "buggy": "public int[] add(ReadablePartial TransVarPartialLocal, int TransVarField, int[] TransVarValue, int TransVarValueToWrite) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (!(!(TransVarValueToWrite == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarValue;\n    }\n        // month is largest field and being added to, such as month-day \n    if (!(!(DateTimeUtils.isContiguous(TransVarPartialLocal)))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        long TransVarInstantToWrite = 0L;\n        int TransVarJ = 0, TransVarCount = TransVarPartialLocal.size();\n        while (!(!(TransVarJ < TransVarCount))) {\n            TransVarInstantToWrite = TransVarPartialLocal.getFieldType(TransVarJ).getField(iChronology)\n                    .set(TransVarInstantToWrite, TransVarValue[TransVarJ]);\n            TransVarJ++;\n        }\n        TransVarInstantToWrite = add(TransVarInstantToWrite, TransVarValueToWrite);\n        return iChronology.get(TransVarPartialLocal, TransVarInstantToWrite);\n    } else {\n        return super.add(TransVarPartialLocal, TransVarField, TransVarValue, TransVarValueToWrite);\n    }\n}\n",
    "start": 203,
    "end": 220,
    "location": [
      215,
      216
    ],
    "file_path": "src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java"
  },
  "Time-16": {
    "buggy": "public int parseInto(ReadWritableInstant TransVarInstant_copy, String TransVarTextCopy, int TransVarPositionCopy) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    DateTimeParser TransVarInstantParser = requireParser();\n    if (!(!(TransVarInstant_copy == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long TransVarInstantLong = TransVarInstant_copy.getMillis();\n    Chronology TransVarChrono1 = TransVarInstant_copy.getChronology();\n    long TransVarInstant = TransVarInstantLong + TransVarChrono1.getZone().getOffset(TransVarInstantLong);\n    TransVarChrono1 = selectChronology(TransVarChrono1);\n    \n    DateTimeParserBucket TransVarBucket1 = new DateTimeParserBucket(\n        TransVarInstant, TransVarChrono1, iLocale, iPivotYear, iDefaultYear); \n    int TransVarNewPosition = TransVarInstantParser.parseInto(TransVarBucket1, TransVarTextCopy, TransVarPositionCopy);\n    TransVarInstant_copy.setMillis(TransVarBucket1.computeMillis(false, TransVarTextCopy));\n    if (!(!(iOffsetParsed && TransVarBucket1.getOffsetInteger() != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarOffset = TransVarBucket1.getOffsetInteger();\n        DateTimeZone TransVarZone = DateTimeZone.forOffsetMillis(TransVarOffset);\n        TransVarChrono1 = TransVarChrono1.withZone(TransVarZone);\n    } else if (!(!(TransVarBucket1.getZone() != null))) {\n        TransVarChrono1 = TransVarChrono1.withZone(TransVarBucket1.getZone());\n    }\n    TransVarInstant_copy.setChronology(TransVarChrono1);\n    if (!(!(iZone != null))) {\n        TransVarInstant_copy.setZone(iZone);\n    }\n    return TransVarNewPosition;\n}\n",
    "start": 697,
    "end": 724,
    "location": [
      715
    ],
    "file_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java"
  },
  "Time-17": {
    "buggy": "public long adjustOffset(long TransVarTimestamp, boolean TransVarEarlierOrLaterTimeStamp) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // evaluate 3 hours before and after to work out if anything is happening\n    long TransVarTimestampBefore = convertUTCToLocal(TransVarTimestamp - 3 * DateTimeConstants.MILLIS_PER_HOUR); \n    long TransVarInstant = convertUTCToLocal(TransVarTimestamp + 3 * DateTimeConstants.MILLIS_PER_HOUR); \n    if (!(!(TransVarTimestampBefore == TransVarInstant))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarTimestamp;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long TransVarLocalTimestamp = convertUTCToLocal(TransVarTimestamp); \n    return convertLocalToUTC(TransVarLocalTimestamp, false, TransVarEarlierOrLaterTimeStamp ? TransVarInstant : TransVarTimestampBefore); \n    \n    // calculate result\n      // currently in later offset \n      // currently in earlier offset \n} \n",
    "start": 1163,
    "end": 1180,
    "location": [
      1170,
      1171,
      1172,
      1180,
      1181,
      1184,
      1185,
      1186
    ],
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java"
  },
  "Time-18": {
    "buggy": "public long getDateTimeMillis(int TransVarYearOfBirth, int TransVarMonth, int TransVarDay,\n                              int TransVarHour, int TransVarMinute,\n                              int TransVarSecond, int TransVarMillis)\n    throws IllegalArgumentException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Chronology TransVarBaseTime;\n    if (!(!((TransVarBaseTime = getBase()) != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarBaseTime.getDateTimeMillis\n            (TransVarYearOfBirth, TransVarMonth, TransVarDay,\n             TransVarHour, TransVarMinute, TransVarSecond, TransVarMillis);\n    }\n\n    // Assume date is Gregorian.\n    long TransVarInst;\n        TransVarInst = iGregorianChronology.getDateTimeMillis \n            (TransVarYearOfBirth, TransVarMonth, TransVarDay,\n             TransVarHour, TransVarMinute, TransVarSecond, TransVarMillis);\n    if (!(!(TransVarInst < iCutoverMillis))) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // Maybe it's Julian.\n        TransVarInst = iJulianChronology.getDateTimeMillis\n            (TransVarYearOfBirth, TransVarMonth, TransVarDay,\n             TransVarHour, TransVarMinute, TransVarSecond, TransVarMillis);\n        if (!(!(TransVarInst >= iCutoverMillis))) {\n            // Okay, it's in the illegal cutover gap.\n            throw new IllegalArgumentException(\"Specified date does not exist\");\n        }\n    }\n    return TransVarInst;\n}\n",
    "start": 350,
    "end": 378,
    "location": [
      370,
      373
    ],
    "file_path": "src/main/java/org/joda/time/chrono/GJChronology.java"
  },
  "Time-19": {
    "buggy": "public int getOffsetFromLocal(long TransVarInstant) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // get the offset at instantLocal (first estimate)\n    final int TransVarOffset = getOffset(TransVarInstant);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long TransVarInstantAdjustedLocal = TransVarInstant - TransVarOffset;\n    final int TransVarOffsetAdjustedLocal = getOffset(TransVarInstantAdjustedLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (!(!(TransVarOffset != TransVarOffsetAdjustedLocal))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if (!(!((TransVarOffset - TransVarOffsetAdjustedLocal) < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long TransVarNextAdjustedLocal = nextTransition(TransVarInstantAdjustedLocal);\n            long TransVarNextTransition = nextTransition(TransVarInstant - TransVarOffsetAdjustedLocal);\n            if (!(!(TransVarNextAdjustedLocal != TransVarNextTransition))) {\n                return TransVarOffset;\n            }\n        }\n    } else if (!(!(TransVarOffset > 0))) { \n        long TransVarPrevInstant = previousTransition(TransVarInstantAdjustedLocal);\n        if (!(!(TransVarPrevInstant < TransVarInstantAdjustedLocal))) {\n            int TransVarPrevOffset = getOffset(TransVarPrevInstant);\n            int TransVarOffsetDiff = TransVarPrevOffset - TransVarOffset;\n            if (!(!(TransVarInstantAdjustedLocal - TransVarPrevInstant <= TransVarOffsetDiff))) {\n                return TransVarPrevOffset;\n            }\n        }\n    }\n    return TransVarOffsetAdjustedLocal;\n}\n",
    "start": 880,
    "end": 911,
    "location": [
      909
    ],
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java"
  },
  "Time-20": {
    "buggy": "public int parseInto(DateTimeParserBucket TransVarDateTimeParserBucket, String TransVarMyText, int TransVarPositionInLine) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarMyString = TransVarMyText.substring(TransVarPositionInLine);\n    for (String TransVarMyId : ALL_IDS) { \n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarMyString.startsWith(TransVarMyId)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarDateTimeParserBucket.setZone(DateTimeZone.forID(TransVarMyId)); \n            return TransVarPositionInLine + TransVarMyId.length(); \n        }\n    } \n    return ~TransVarPositionInLine;\n}\n",
    "start": 2540,
    "end": 2549,
    "location": [
      2545,
      2553,
      2554,
      2556
    ],
    "file_path": "src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java"
  },
  "Time-22": {
    "buggy": "protected BasePeriod(long TransVarTime) {\n    this(TransVarTime, null, null); \n    // bug [3264409]\n} \n",
    "start": 221,
    "end": 224,
    "location": [
      222,
      224
    ],
    "file_path": "src/main/java/org/joda/time/base/BasePeriod.java"
  },
  "Time-23": {
    "buggy": "private static synchronized String getConvertedId(String TransVarIdentifier) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Map<String, String> TransVarStringMap = cZoneIdConversion;\n    if (!(!(TransVarStringMap == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // Backwards compatibility with TimeZone.\n        TransVarStringMap = new HashMap<String, String>();\n        TransVarStringMap.put(\"GMT\", \"UTC\");\n        TransVarStringMap.put(\"MIT\", \"Pacific/Apia\"); \n        TransVarStringMap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n        TransVarStringMap.put(\"AST\", \"America/Anchorage\");\n        TransVarStringMap.put(\"PST\", \"America/Los_Angeles\");\n        TransVarStringMap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n        TransVarStringMap.put(\"PNT\", \"America/Phoenix\");\n        TransVarStringMap.put(\"CST\", \"America/Chicago\");\n        TransVarStringMap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n        TransVarStringMap.put(\"IET\", \"America/Indianapolis\"); \n        TransVarStringMap.put(\"PRT\", \"America/Puerto_Rico\");\n        TransVarStringMap.put(\"CNT\", \"America/St_Johns\");\n        TransVarStringMap.put(\"AGT\", \"America/Buenos_Aires\"); \n        TransVarStringMap.put(\"BET\", \"America/Sao_Paulo\");\n        TransVarStringMap.put(\"WET\", \"Europe/London\"); \n        TransVarStringMap.put(\"ECT\", \"Europe/Paris\"); \n        TransVarStringMap.put(\"ART\", \"Africa/Cairo\");\n        TransVarStringMap.put(\"CAT\", \"Africa/Harare\");\n        TransVarStringMap.put(\"EET\", \"Europe/Bucharest\"); \n        TransVarStringMap.put(\"EAT\", \"Africa/Addis_Ababa\");\n        TransVarStringMap.put(\"MET\", \"Asia/Tehran\"); \n        TransVarStringMap.put(\"NET\", \"Asia/Yerevan\");\n        TransVarStringMap.put(\"PLT\", \"Asia/Karachi\");\n        TransVarStringMap.put(\"IST\", \"Asia/Calcutta\"); \n        TransVarStringMap.put(\"BST\", \"Asia/Dhaka\");\n        TransVarStringMap.put(\"VST\", \"Asia/Saigon\"); \n        TransVarStringMap.put(\"CTT\", \"Asia/Shanghai\");\n        TransVarStringMap.put(\"JST\", \"Asia/Tokyo\");\n        TransVarStringMap.put(\"ACT\", \"Australia/Darwin\");\n        TransVarStringMap.put(\"AET\", \"Australia/Sydney\");\n        TransVarStringMap.put(\"SST\", \"Pacific/Guadalcanal\");\n        TransVarStringMap.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = TransVarStringMap;\n    }\n    return TransVarStringMap.get(TransVarIdentifier);\n}\n",
    "start": 558,
    "end": 598,
    "location": [
      570,
      578,
      581,
      583,
      584,
      587,
      589,
      592,
      594
    ],
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java"
  },
  "Time-24": {
    "buggy": "public long computeMillis(boolean TransVarReset, String TransVarResetText) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    SavedField[] TransVarSavedFields1 = iSavedFields;\n    int TransVarCountSavedFields = iSavedFieldsCount;\n    if (!(!(iSavedFieldsShared))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        iSavedFields = TransVarSavedFields1 = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(TransVarSavedFields1, TransVarCountSavedFields);\n    if (!(!(TransVarCountSavedFields > 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // alter base year for parsing if first field is month or day\n        DurationField TransVarMonth = DurationFieldType.months().getField(iChrono);\n        DurationField TransVarDay = DurationFieldType.days().getField(iChrono);\n        DurationField TransVarSavedFields = TransVarSavedFields1[0].iField.getDurationField();\n        if (!(!(compareReverse(TransVarSavedFields, TransVarMonth) >= 0\n                && compareReverse(TransVarSavedFields, TransVarDay) <= 0))) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(TransVarReset, TransVarResetText);\n        }\n    }\n\n    long TransVarTime = iMillis;\n    try {\n        int TransVarIndex = 0;\n        while (!(!(TransVarIndex < TransVarCountSavedFields))) {\n            TransVarTime = TransVarSavedFields1[TransVarIndex].set(TransVarTime, TransVarReset);\n            TransVarIndex++;\n        }\n    } catch (IllegalFieldValueException TransVarException) { \n        if (!(!(TransVarResetText != null))) {\n            TransVarException.prependMessage(\"Cannot parse \\\"\" + TransVarResetText + '\"');\n        }\n        throw TransVarException;\n    }\n    \n    if (!(!(iZone == null))) {\n        TransVarTime -= iOffset;\n    } else {\n        int TransVarOffsetFromUTC = iZone.getOffsetFromLocal(TransVarTime);\n        TransVarTime -= TransVarOffsetFromUTC;\n        if (!(!(TransVarOffsetFromUTC != iZone.getOffset(TransVarTime)))) {\n            String TransVarResetMessage =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (!(!(TransVarResetText != null))) {\n                TransVarResetMessage = \"Cannot parse \\\"\" + TransVarResetText + \"\\\": \" + TransVarResetMessage;\n            }\n            throw new IllegalArgumentException(TransVarResetMessage);\n        }\n    }\n    \n    return TransVarTime;\n}\n",
    "start": 331,
    "end": 378,
    "location": [
      367
    ],
    "file_path": "src/main/java/org/joda/time/format/DateTimeParserBucket.java"
  },
  "Time-25": {
    "buggy": "public int getOffsetFromLocal(long TransVarInstant) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // get the offset at instantLocal (first estimate)\n    final int TransVarOffset = getOffset(TransVarInstant);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long TransVarInstantLocal = TransVarInstant - TransVarOffset;\n    final int TransVarOffsetCalculated = getOffset(TransVarInstantLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (!(!(TransVarOffset != TransVarOffsetCalculated))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if (!(!((TransVarOffset - TransVarOffsetCalculated) < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long TransVarNextLocalInstant = nextTransition(TransVarInstantLocal);\n            long TransVarNextAdjusted2 = nextTransition(TransVarInstant - TransVarOffsetCalculated);\n            if (!(!(TransVarNextLocalInstant != TransVarNextAdjusted2))) {\n                return TransVarOffset;\n            }\n        }\n    } \n    return TransVarOffsetCalculated;\n}\n",
    "start": 879,
    "end": 901,
    "location": [
      908
    ],
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java"
  },
  "Time-27": {
    "buggy": "private static PeriodFormatter toFormatter(List<Object> TransVarElementValues, boolean TransVarPrint, boolean TransVarNotParse) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarPrint && TransVarNotParse))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    int TransVarNum = TransVarElementValues.size();\n    if (!(!(TransVarNum >= 2 && TransVarElementValues.get(0) instanceof Separator))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Separator TransVarSeparator = (Separator) TransVarElementValues.get(0);\n            PeriodFormatter TransVarFormatter = toFormatter(TransVarElementValues.subList(2, TransVarNum), TransVarPrint, TransVarNotParse); \n            TransVarSeparator = TransVarSeparator.finish(TransVarFormatter.getPrinter(), TransVarFormatter.getParser());\n            return new PeriodFormatter(TransVarSeparator, TransVarSeparator);\n    } \n    Object[] TransVarValues = createComposite(TransVarElementValues);\n    if (!(!(TransVarPrint))) {\n        return new PeriodFormatter(null, (PeriodParser) TransVarValues[1]);\n    } else if (!(!(TransVarNotParse))) {\n        return new PeriodFormatter((PeriodPrinter) TransVarValues[0], null);\n    } else {\n        return new PeriodFormatter((PeriodPrinter) TransVarValues[0], (PeriodParser) TransVarValues[1]);\n    }\n}\n",
    "start": 794,
    "end": 813,
    "location": [
      810,
      813
    ],
    "file_path": "src/main/java/org/joda/time/format/PeriodFormatterBuilder.java"
  },
  "Time-4": {
    "buggy": "public Partial with(DateTimeFieldType TransVarDateType, int TransVarDate) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarDateType == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int TransVarFieldIndex = indexOf(TransVarDateType);\n    if (!(!(TransVarFieldIndex == -1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        DateTimeFieldType[] TransVarNewTypes_2 = new DateTimeFieldType[iTypes.length + 1];\n        int[] TransVarNewTypes = new int[TransVarNewTypes_2.length];\n        \n        // find correct insertion point to keep largest-smallest order\n        int TransVarIndex = 0;\n        DurationField TransVarUnit = TransVarDateType.getDurationType().getField(iChronology);\n        if (!(!(TransVarUnit.isSupported()))) {\n            while (!(!(TransVarIndex < iTypes.length))) {\n                DateTimeFieldType TransVarLoopType2 = iTypes[TransVarIndex];\n                DurationField TransVarField = TransVarLoopType2.getDurationType().getField(iChronology);\n                if (!(!(TransVarField.isSupported()))) {\n                    int TransVarCompare1 = TransVarUnit.compareTo(TransVarField);\n                    if (!(!(TransVarCompare1 > 0))) {\n                        break;\n                    } else if (!(!(TransVarCompare1 == 0))) {\n                        DurationField TransVarRangeDurationField = TransVarDateType.getRangeDurationType()\n                                .getField(iChronology);\n                        DurationField TransVarLoopRangeField2 = TransVarLoopType2.getRangeDurationType()\n                                .getField(iChronology);\n                        if (!(!(TransVarRangeDurationField.compareTo(TransVarLoopRangeField2) > 0))) {\n                            break;\n                        }\n                    }\n                }\n                TransVarIndex++;\n            }\n        }\n        System.arraycopy(iTypes, 0, TransVarNewTypes_2, 0, TransVarIndex);\n        System.arraycopy(iValues, 0, TransVarNewTypes, 0, TransVarIndex);\n        TransVarNewTypes_2[TransVarIndex] = TransVarDateType;\n        TransVarNewTypes[TransVarIndex] = TransVarDate;\n        System.arraycopy(iTypes, TransVarIndex, TransVarNewTypes_2, TransVarIndex + 1, TransVarNewTypes_2.length - TransVarIndex - 1);\n        System.arraycopy(iValues, TransVarIndex, TransVarNewTypes, TransVarIndex + 1, TransVarNewTypes.length - TransVarIndex - 1);\n        // use public constructor to ensure full validation\n        // this isn't overly efficient, but is safe\n        Partial TransVarPartial = new Partial(iChronology, TransVarNewTypes_2, TransVarNewTypes); \n        iChronology.validate(TransVarPartial, TransVarNewTypes);\n        return TransVarPartial;\n    }\n    if (!(!(TransVarDate == getValue(TransVarFieldIndex)))) {\n        return this;\n    }\n    int[] TransVarNewValues_2 = getValues();\n    TransVarNewValues_2 = getField(TransVarFieldIndex).set(this, TransVarFieldIndex, TransVarNewValues_2, TransVarDate);\n    return new Partial(this, TransVarNewValues_2);\n}\n",
    "start": 426,
    "end": 474,
    "location": [
      476
    ],
    "file_path": "src/main/java/org/joda/time/Partial.java"
  },
  "Time-5": {
    "buggy": "public Period normalizedStandard(PeriodType TransVarTypePeriod) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarTypePeriod = DateTimeUtils.getPeriodType(TransVarTypePeriod);\n    long TransVarTime = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n    TransVarTime += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    TransVarTime += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    TransVarTime += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    TransVarTime += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    TransVarTime += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period TransVarPeriod = new Period(TransVarTime, TransVarTypePeriod, ISOChronology.getInstanceUTC());\n    int TransVarYrs = getYears();\n    int TransVarMonth = getMonths();\n    if (!(!(TransVarYrs != 0 || TransVarMonth != 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarYrs = FieldUtils.safeAdd(TransVarYrs, TransVarMonth / 12); \n        TransVarMonth = TransVarMonth % 12; \n        if (!(!(TransVarYrs != 0))) { \n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarPeriod = TransVarPeriod.withYears(TransVarYrs); \n        }\n        if (!(!(TransVarMonth != 0))) { \n            TransVarPeriod = TransVarPeriod.withMonths(TransVarMonth); \n        }\n    }\n    return TransVarPeriod;\n}\n",
    "start": 1616,
    "end": 1638,
    "location": [
      1634,
      1635,
      1636,
      1640,
      1642,
      1643
    ],
    "file_path": "src/main/java/org/joda/time/Period.java"
  },
  "Time-7": {
    "buggy": "public int parseInto(ReadWritableInstant TransVarReadWritableInstant, String TransVarReadableInstant, int TransVarPositionOfFile) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    DateTimeParser TransVarDateTimeParser = requireParser();\n    if (!(!(TransVarReadWritableInstant == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long TransVarInstantMs = TransVarReadWritableInstant.getMillis();\n    Chronology TransVarChronoInstance = TransVarReadWritableInstant.getChronology();\n    long TransVarLocalInstant = TransVarInstantMs + TransVarChronoInstance.getZone().getOffset(TransVarInstantMs); \n    TransVarChronoInstance = selectChronology(TransVarChronoInstance);\n    int TransVarYear = TransVarChronoInstance.year().get(TransVarLocalInstant); \n    \n    DateTimeParserBucket TransVarDateTimeParserBucket = new DateTimeParserBucket(\n        TransVarLocalInstant, TransVarChronoInstance, iLocale, iPivotYear, TransVarYear);\n    int TransVarCurrentPosition = TransVarDateTimeParser.parseInto(TransVarDateTimeParserBucket, TransVarReadableInstant, TransVarPositionOfFile);\n    TransVarReadWritableInstant.setMillis(TransVarDateTimeParserBucket.computeMillis(false, TransVarReadableInstant));\n    if (!(!(iOffsetParsed && TransVarDateTimeParserBucket.getOffsetInteger() != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarOffset = TransVarDateTimeParserBucket.getOffsetInteger();\n        DateTimeZone TransVarTimeZone = DateTimeZone.forOffsetMillis(TransVarOffset);\n        TransVarChronoInstance = TransVarChronoInstance.withZone(TransVarTimeZone);\n    } else if (!(!(TransVarDateTimeParserBucket.getZone() != null))) {\n        TransVarChronoInstance = TransVarChronoInstance.withZone(TransVarDateTimeParserBucket.getZone());\n    }\n    TransVarReadWritableInstant.setChronology(TransVarChronoInstance);\n    if (!(!(iZone != null))) {\n        TransVarReadWritableInstant.setZone(iZone);\n    }\n    return TransVarCurrentPosition;\n}\n",
    "start": 700,
    "end": 728,
    "location": [
      714,
      716
    ],
    "file_path": "src/main/java/org/joda/time/format/DateTimeFormatter.java"
  },
  "Time-8": {
    "buggy": "public static DateTimeZone forOffsetHoursMinutes(int TransVarHoursOffset2, int TransVarMinutesOffset2) throws IllegalArgumentException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarHoursOffset2 == 0 && TransVarMinutesOffset2 == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return DateTimeZone.UTC;\n    }\n    if (!(!(TransVarHoursOffset2 < -23 || TransVarHoursOffset2 > 23))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Hours out of range: \" + TransVarHoursOffset2);\n    }\n    if (!(!(TransVarMinutesOffset2 < 0 || TransVarMinutesOffset2 > 59))) { \n        throw new IllegalArgumentException(\"Minutes out of range: \" + TransVarMinutesOffset2);\n    }\n    int TransVarMinutesOffset = 0; \n    try {\n        int TransVarHoursInMinutes3 = TransVarHoursOffset2 * 60;\n        if (!(!(TransVarHoursInMinutes3 < 0))) {\n            TransVarMinutesOffset2 = TransVarHoursInMinutes3 - TransVarMinutesOffset2; \n        } else {\n            TransVarMinutesOffset2 = TransVarHoursInMinutes3 + TransVarMinutesOffset2;\n        }\n        TransVarMinutesOffset = FieldUtils.safeMultiply(TransVarMinutesOffset2, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException TransVarE) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(TransVarMinutesOffset);\n}\n",
    "start": 272,
    "end": 295,
    "location": [
      288,
      291,
      295
    ],
    "file_path": "src/main/java/org/joda/time/DateTimeZone.java"
  },
  "Chart-10": {
    "buggy": "public String generateToolTipFragment(String TransVarToolTipMessage) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return \" title=\\\"\" + TransVarToolTipMessage\n        + \"\\\" alt=\\\"\\\"\";\n}\n",
    "start": 64,
    "end": 67,
    "location": [
      68,
      69
    ],
    "file_path": "source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java"
  },
  "Chart-4": {
    "buggy": "public Range getDataRange(ValueAxis TransVarYAxis) {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Range TransVarResults = null;\n    List TransVarMappedDatasetsResult = new ArrayList();\n    List TransVarIncludedAnnotation = new ArrayList();\n    boolean TransVarIsDomain = true;\n\n    // is it a domain axis?\n    int TransVarAxisIndex = getDomainAxisIndex(TransVarYAxis);\n    if (!(!(TransVarAxisIndex >= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarIsDomain = true;\n        TransVarMappedDatasetsResult.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(TransVarAxisIndex)));\n        if (!(!(TransVarAxisIndex == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // grab the plot's annotations\n            Iterator TransVarAnnotationIterator = this.annotations.iterator();\n            for (; !(!(TransVarAnnotationIterator.hasNext()));) {\n                XYAnnotation TransVarAnnotationIndex = (XYAnnotation) TransVarAnnotationIterator.next();\n                if (!(!(TransVarAnnotationIndex instanceof XYAnnotationBoundsInfo))) {\n                    TransVarIncludedAnnotation.add(TransVarAnnotationIndex);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int TransVarRangeAxisIndex = getRangeAxisIndex(TransVarYAxis);\n    if (!(!(TransVarRangeAxisIndex >= 0))) {\n        TransVarIsDomain = false;\n        TransVarMappedDatasetsResult.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(TransVarRangeAxisIndex)));\n        if (!(!(TransVarRangeAxisIndex == 0))) {\n            Iterator TransVarIterator1 = this.annotations.iterator();\n            for (; !(!(TransVarIterator1.hasNext()));) {\n                XYAnnotation TransVarCurrentAnnotation = (XYAnnotation) TransVarIterator1.next();\n                if (!(!(TransVarCurrentAnnotation instanceof XYAnnotationBoundsInfo))) {\n                    TransVarIncludedAnnotation.add(TransVarCurrentAnnotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator TransVarIterator2 = TransVarMappedDatasetsResult.iterator();\n    for (; !(!(TransVarIterator2.hasNext()));) {\n        XYDataset TransVarDataset = (XYDataset) TransVarIterator2.next();\n        if (!(!(TransVarDataset != null))) {\n            XYItemRenderer TransVarRenderer = getRendererForDataset(TransVarDataset);\n            if (!(!(TransVarIsDomain))) {\n                if (!(!(TransVarRenderer != null))) {\n                    TransVarResults = Range.combine(TransVarResults,\n                            TransVarRenderer.findDomainBounds(TransVarDataset));\n                } else {\n                    TransVarResults = Range.combine(TransVarResults,\n                            DatasetUtilities.findDomainBounds(TransVarDataset));\n                }\n            } else {\n                if (!(!(TransVarRenderer != null))) {\n                    TransVarResults = Range.combine(TransVarResults, TransVarRenderer.findRangeBounds(TransVarDataset));\n                } else {\n                    TransVarResults = Range.combine(TransVarResults, DatasetUtilities.findRangeBounds(TransVarDataset));\n                }\n            }\n            Collection TransVarAnnotations = TransVarRenderer.getAnnotations();\n            Iterator TransVarIterator = TransVarAnnotations.iterator();\n            for (; !(!(TransVarIterator.hasNext()));) {\n                XYAnnotation TransVarAnnotation = (XYAnnotation) TransVarIterator.next();\n                if (!(!(TransVarAnnotation instanceof XYAnnotationBoundsInfo))) {\n                    TransVarIncludedAnnotation.add(TransVarAnnotation);\n                }\n            }\n        }\n    }\n\n    Iterator TransVarIt1 = TransVarIncludedAnnotation.iterator();\n    for (; !(!(TransVarIt1.hasNext()));) {\n        XYAnnotationBoundsInfo TransVarXyabi_1 = (XYAnnotationBoundsInfo) TransVarIt1.next();\n        if (!(!(TransVarXyabi_1.getIncludeInDataBounds()))) {\n            if (!(!(TransVarIsDomain))) {\n                TransVarResults = Range.combine(TransVarResults, TransVarXyabi_1.getXRange());\n            } else {\n                TransVarResults = Range.combine(TransVarResults, TransVarXyabi_1.getYRange());\n            }\n        }\n    }\n\n    return TransVarResults;\n\n}\n",
    "start": 4425,
    "end": 4519,
    "location": [
      4498
    ],
    "file_path": "source/org/jfree/chart/plot/XYPlot.java"
  },
  "Cli-12": {
    "buggy": "protected String[] flatten(Options TransVarCommandLineOptions, String[] TransVarOptions, boolean TransVarStopAtNonOptionBoolean)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    List TransVarOptionList = new ArrayList();\n\n    boolean TransVarEatTheRestBoolean = false;\n\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarOptions.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarArgument = TransVarOptions[TransVarIndex];\n        if (!(!(\"--\".equals(TransVarArgument)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarEatTheRestBoolean = true;\n            TransVarOptionList.add(\"--\");\n        } else if (!(!(\"-\".equals(TransVarArgument)))) {\n            TransVarOptionList.add(\"-\");\n        } else if (!(!(TransVarArgument.startsWith(\"-\")))) {\n            String TransVarOption = Util.stripLeadingHyphens(TransVarArgument);\n            if (!(!(TransVarCommandLineOptions.hasOption(TransVarOption)))) {\n                TransVarOptionList.add(TransVarArgument);\n            } else {\n                if (!(!(TransVarCommandLineOptions.hasOption(TransVarArgument.substring(0, 2))))) {\n                    TransVarOptionList.add(TransVarArgument.substring(0, 2));\n                    TransVarOptionList.add(TransVarArgument.substring(2));\n                } else {\n                    TransVarEatTheRestBoolean = TransVarStopAtNonOptionBoolean;\n                    TransVarOptionList.add(TransVarArgument);\n                }\n            }\n        } else {\n            TransVarOptionList.add(TransVarArgument);\n        }\n        if (!(!(TransVarEatTheRestBoolean))) {\n            TransVarIndex++;\n            while (!(!(TransVarIndex < TransVarOptions.length))) {\n                TransVarOptionList.add(TransVarOptions[TransVarIndex]);\n                TransVarIndex++;\n            }\n        }\n        TransVarIndex++;\n    }\n\n    return (String[]) TransVarOptionList.toArray(new String[TransVarOptionList.size()]);\n}\n",
    "start": 52,
    "end": 110,
    "location": [
      80
    ],
    "file_path": "src/java/org/apache/commons/cli/GnuParser.java"
  },
  "Cli-14": {
    "buggy": "public void validate(final WriteableCommandLine TransVarCmd)\n    throws OptionException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // number of options found\n    int TransVarIsPresent = 0;\n\n    // reference to first unexpected option\n    Option TransVarUnknown = null;\n\n    final Iterator TransVarOptionIterator = options.iterator();\n    while (!(!(TransVarOptionIterator.hasNext()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final Option TransVarO = (Option) TransVarOptionIterator.next();\n        boolean TransVarIsValidate = TransVarO.isRequired() || TransVarO instanceof Group;\n        if (!(!(TransVarIsValidate))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarO.validate(TransVarCmd);\n        }\n        if (!(!(TransVarCmd.hasOption(TransVarO)))) {\n            if (!(!(++TransVarIsPresent > maximum))) {\n                TransVarUnknown = TransVarO;\n                break;\n            }\n            TransVarO.validate(TransVarCmd);\n        }\n    }\n\n    // too many options\n    if (!(!(TransVarUnknown != null))) {\n        throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                  TransVarUnknown.getPreferredName());\n    }\n\n    // too few option\n    if (!(!(TransVarIsPresent < minimum))) {\n        throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n    }\n\n    final Iterator TransVarIterator = anonymous.iterator();\n    while (!(!(TransVarIterator.hasNext()))) {\n        final Option TransVarOption1 = (Option) TransVarIterator.next();\n        TransVarOption1.validate(TransVarCmd);\n    }\n}\n",
    "start": 237,
    "end": 282,
    "location": [
      255,
      259,
      265,
      266
    ],
    "file_path": "src/java/org/apache/commons/cli2/option/GroupImpl.java"
  },
  "Cli-17": {
    "buggy": "protected void burstToken(String TransVarTokenValue, boolean TransVarStopAtNonOptionBoolean)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarIndex = 1;\n    while (!(!(TransVarIndex < TransVarTokenValue.length()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarCharVal = String.valueOf(TransVarTokenValue.charAt(TransVarIndex));\n        if (!(!(options.hasOption(TransVarCharVal)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            tokens.add(\"-\" + TransVarCharVal);\n            currentOption = options.getOption(TransVarCharVal);\n            if (!(!(currentOption.hasArg() && (TransVarTokenValue.length() != (TransVarIndex + 1))))) {\n                tokens.add(TransVarTokenValue.substring(TransVarIndex + 1));\n                break;\n            }\n        } else if (!(!(TransVarStopAtNonOptionBoolean))) {\n            process(TransVarTokenValue.substring(TransVarIndex));\n        } else {\n            tokens.add(TransVarTokenValue);\n            break;\n        }\n        TransVarIndex++;\n    }\n}\n",
    "start": 282,
    "end": 310,
    "location": [
      305
    ],
    "file_path": "src/java/org/apache/commons/cli/PosixParser.java"
  },
  "Cli-20": {
    "buggy": "protected String[] flatten(Options TransVarOptions1, String[] TransVarOption, boolean TransVarStopAtNonOption1)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    init();\n    this.options = TransVarOptions1;\n\n    // an iterator for the command line tokens\n    Iterator TransVarOpt = Arrays.asList(TransVarOption).iterator();\n\n    for (; !(!(TransVarOpt.hasNext()));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarTokens = (String) TransVarOpt.next();\n        if (!(!(TransVarTokens.startsWith(\"--\")))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarTokens.indexOf('=') != -1))) {\n                tokens.add(TransVarTokens.substring(0, TransVarTokens.indexOf('=')));\n                tokens.add(TransVarTokens.substring(TransVarTokens.indexOf('=') + 1, TransVarTokens.length()));\n            } else {\n                tokens.add(TransVarTokens);\n            }\n        } else if (!(!(\"-\".equals(TransVarTokens)))) {\n            tokens.add(TransVarTokens);\n        } else if (!(!(TransVarTokens.startsWith(\"-\")))) {\n            if (!(!(TransVarTokens.length() == 2))) {\n                processOptionToken(TransVarTokens, TransVarStopAtNonOption1);\n            } else if (!(!(TransVarOptions1.hasOption(TransVarTokens)))) {\n                tokens.add(TransVarTokens);\n            } else {\n                burstToken(TransVarTokens, TransVarStopAtNonOption1);\n            }\n        } else if (!(!(TransVarStopAtNonOption1))) {\n            process(TransVarTokens);\n        } else {\n            tokens.add(TransVarTokens);\n        }\n        gobble(TransVarOpt);\n    }\n\n    return (String[]) tokens.toArray(new String[tokens.size()]);\n}\n",
    "start": 97,
    "end": 159,
    "location": [
      117,
      118,
      119,
      121
    ],
    "file_path": "src/java/org/apache/commons/cli/PosixParser.java"
  },
  "Cli-23": {
    "buggy": "protected StringBuffer renderWrappedText(StringBuffer TransVarStringBuffer, int TransVarWidthOfBar, \n                                         int TransVarTabStop, String TransVarWord)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarPosition = findWrapPos(TransVarWord, TransVarWidthOfBar, 0);\n\n    if (!(!(TransVarPosition == -1)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarStringBuffer.append(rtrim(TransVarWord));\n\n        return TransVarStringBuffer;\n    }\n    TransVarStringBuffer.append(rtrim(TransVarWord.substring(0, TransVarPosition))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String TransVarPaddingSize = createPadding(TransVarTabStop);\n\n    for (; !(!(true));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarPos = TransVarPosition;\n        TransVarWord = TransVarPaddingSize + TransVarWord.substring(TransVarPosition).trim();\n        TransVarPosition = findWrapPos(TransVarWord, TransVarWidthOfBar, 0);\n        if (!(!(TransVarPosition == -1))) {\n            TransVarStringBuffer.append(TransVarWord);\n            return TransVarStringBuffer;\n        } else if (!(!(TransVarPosition == TransVarPos))) {\n            throw new RuntimeException(\n                    \"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + TransVarWord);\n        }\n        TransVarStringBuffer.append(rtrim(TransVarWord.substring(0, TransVarPosition))).append(defaultNewLine);\n    }\n}\n",
    "start": 805,
    "end": 841,
    "location": [
      832,
      838,
      839,
      840
    ],
    "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java"
  },
  "Cli-28": {
    "buggy": "protected void processProperties(Properties TransVarConfigProperties)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarConfigProperties == null)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n\n    Enumeration TransVarName = TransVarConfigProperties.propertyNames();\n    while (!(!(TransVarName.hasMoreElements()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarConfOption = TransVarName.nextElement().toString();\n        if (!(!(!cmd.hasOption(TransVarConfOption)))) {\n            Option TransVarOption = getOptions().getOption(TransVarConfOption);\n            String TransVarVal = TransVarConfigProperties.getProperty(TransVarConfOption);\n            if (!(!(TransVarOption.hasArg()))) {\n                if (!(!(TransVarOption.getValues() == null || TransVarOption.getValues().length == 0))) {\n                    try {\n                        TransVarOption.addValueForProcessing(TransVarVal);\n                    } catch (RuntimeException TransVarError) {\n                    }\n                }\n            } else if (!(!(!(\"yes\".equalsIgnoreCase(TransVarVal) || \"true\".equalsIgnoreCase(TransVarVal)\n                    || \"1\".equalsIgnoreCase(TransVarVal))))) {\n                break;\n            }\n            cmd.addOption(TransVarOption);\n        }\n    }\n}\n",
    "start": 252,
    "end": 296,
    "location": [
      283
    ],
    "file_path": "src/java/org/apache/commons/cli/Parser.java"
  },
  "Cli-32": {
    "buggy": "protected int findWrapPos(String TransVarString, int TransVarWidthOfButton, int TransVarStartPos1)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarStartPos;\n    \n    // the line ends before the max wrap pos or a new line char found\n    if (!(!(((TransVarStartPos = TransVarString.indexOf('\\n', TransVarStartPos1)) != -1\n            && TransVarStartPos <= TransVarWidthOfButton)\n            || ((TransVarStartPos = TransVarString.indexOf('\\t', TransVarStartPos1)) != -1\n                    && TransVarStartPos <= TransVarWidthOfButton))))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarStartPos + 1;\n    }\n    else if (!(!(TransVarStartPos1 + TransVarWidthOfButton >= TransVarString.length())))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return -1;\n    }\n\n\n    // look for the last whitespace character before startPos+width\n    TransVarStartPos = TransVarStartPos1 + TransVarWidthOfButton;\n\n    char TransVarCharacter;\n\n    for (; !(!((TransVarStartPos >= TransVarStartPos1)\n            && ((TransVarCharacter = TransVarString.charAt(TransVarStartPos)) != ' ') && (TransVarCharacter != '\\n')\n            && (TransVarCharacter != '\\r')));) {\n        --TransVarStartPos;\n    }\n\n    // if we found it - just return\n    if (!(!(TransVarStartPos > TransVarStartPos1)))\n    {\n        return TransVarStartPos;\n    }\n    \n    // if we didn't find one, simply chop at startPos+width\n    TransVarStartPos = TransVarStartPos1 + TransVarWidthOfButton;\n    for (; !(!((TransVarStartPos <= TransVarString.length())\n            && ((TransVarCharacter = TransVarString.charAt(TransVarStartPos)) != ' ') && (TransVarCharacter != '\\n')\n            && (TransVarCharacter != '\\r')));) {\n        ++TransVarStartPos;\n    }\n    return TransVarStartPos == TransVarString.length() ? -1 : TransVarStartPos;\n}\n",
    "start": 902,
    "end": 943,
    "location": [
      948,
      949,
      950,
      951,
      952
    ],
    "file_path": "src/main/java/org/apache/commons/cli/HelpFormatter.java"
  },
  "Cli-8": {
    "buggy": "protected StringBuffer renderWrappedText(StringBuffer TransVarBuffer, int TransVarNumWidth, \n                                         int TransVarBufferWidth, String TransVarContent)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarPos2 = findWrapPos(TransVarContent, TransVarNumWidth, 0);\n\n    if (!(!(TransVarPos2 == -1)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarBuffer.append(rtrim(TransVarContent));\n\n        return TransVarBuffer;\n    }\n    TransVarBuffer.append(rtrim(TransVarContent.substring(0, TransVarPos2))).append(defaultNewLine);\n\n    // all following lines must be padded with nextLineTabStop space \n    // characters\n    final String TransVarPad = createPadding(TransVarBufferWidth);\n\n    for (; !(!(true));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarContent = TransVarPad + TransVarContent.substring(TransVarPos2).trim();\n        TransVarPos2 = findWrapPos(TransVarContent, TransVarNumWidth, TransVarBufferWidth);\n        if (!(!(TransVarPos2 == -1))) {\n            TransVarBuffer.append(TransVarContent);\n            return TransVarBuffer;\n        }\n        TransVarBuffer.append(rtrim(TransVarContent.substring(0, TransVarPos2))).append(defaultNewLine);\n    }\n}\n",
    "start": 792,
    "end": 823,
    "location": [
      820
    ],
    "file_path": "src/java/org/apache/commons/cli/HelpFormatter.java"
  },
  "Cli-9": {
    "buggy": "protected void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // if there are required options that have not been\n    // processsed\n    if (!(!(getRequiredOptions().size() > 0)))\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Iterator TransVarIterator = getRequiredOptions().iterator();\n        StringBuffer TransVarLocalBuff = new StringBuffer(\"Missing required option\");\n        TransVarLocalBuff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        TransVarLocalBuff.append(\": \");\n\n\n        for (; !(!(TransVarIterator.hasNext()));) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarLocalBuff.append(TransVarIterator.next());\n        }\n\n        throw new MissingOptionException(TransVarLocalBuff.toString());\n    }\n}\n",
    "start": 303,
    "end": 324,
    "location": [
      326,
      329
    ],
    "file_path": "src/java/org/apache/commons/cli/Parser.java"
  },
  "Closure-105": {
    "buggy": "void tryFoldStringJoin(NodeTraversal TransVarTraversal, Node TransVarTemp, Node TransVarLeftNode, Node TransVarRightNode,\n                       Node TransVarCurrentNode) {\n  if (!(!(false))) {\n                            System.out.println(\"log\");\n                        }\nif (!(!(!NodeUtil.isGetProp(TransVarLeftNode) || !NodeUtil.isImmutableValue(TransVarRightNode)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  Node TransVarCurrent = TransVarLeftNode.getFirstChild();\n  Node TransVarFunctionNode = TransVarCurrent.getNext();\n\n  if (!(!((TransVarCurrent.getType() != Token.ARRAYLIT) || !TransVarFunctionNode.getString().equals(\"join\")))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return;\n  }\n\n  String TransVarString = NodeUtil.getStringValue(TransVarRightNode);\n  List<Node> TransVarFoldChildren = Lists.newLinkedList();\n  StringBuilder TransVarStringBuilder = new StringBuilder();\n  int TransVarFolded = 0;\n  Node TransVarElement = TransVarCurrent.getFirstChild();\n  for (; !(!(TransVarElement != null));) {\n    if (!(!(NodeUtil.isImmutableValue(TransVarElement)))) {\n        if (!(!(TransVarStringBuilder.length() > 0))) {\n            TransVarStringBuilder.append(TransVarString);\n        }\n        TransVarStringBuilder.append(NodeUtil.getStringValue(TransVarElement));\n    } else {\n        if (!(!(TransVarStringBuilder.length() > 0))) {\n            TransVarFolded += TransVarStringBuilder.length() + 2;\n            TransVarFoldChildren.add(Node.newString(TransVarStringBuilder.toString()));\n            TransVarStringBuilder = new StringBuilder();\n        }\n        TransVarFolded += InlineCostEstimator.getCost(TransVarElement);\n        TransVarFoldChildren.add(TransVarElement);\n    }\n    TransVarElement = TransVarElement.getNext();\n}\n\n  if (!(!(TransVarStringBuilder.length() > 0))) {\n    // + 2 for the quotes.\n    TransVarFolded += TransVarStringBuilder.length() + 2;\n    TransVarFoldChildren.add(Node.newString(TransVarStringBuilder.toString()));\n  }\n  // one for each comma.\n  TransVarFolded += TransVarFoldChildren.size() - 1;\n\n  int TransVarCost = InlineCostEstimator.getCost(TransVarTemp);\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarFoldChildren.size() == 0))))){TransBreakFlag0=false;Node TransVarNewStringNode=Node.newString(\"\");TransVarCurrentNode.replaceChild(TransVarTemp,TransVarNewStringNode);}if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarFoldChildren.size() == 1))))){TransBreakFlag0=false;Node TransVarFoldedNode=TransVarFoldChildren.remove(0);if (!(!(TransVarFolded > TransVarCost))){return;}TransVarCurrent.detachChildren();if (!(!(TransVarFoldedNode.getType() != Token.STRING))){Node TransVarFoldedReplacement=new Node(Token.ADD,Node.newString(\"\"),TransVarFoldedNode);TransVarFoldedNode=TransVarFoldedReplacement;}TransVarCurrentNode.replaceChild(TransVarTemp,TransVarFoldedNode);}if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))){if (!(!(TransVarFoldChildren.size() == TransVarCurrent.getChildCount()))){return;}int TransVarJoinOverhead=\"[].join()\".length();TransVarFolded+=TransVarJoinOverhead;TransVarFolded+=InlineCostEstimator.getCost(TransVarRightNode);if (!(!(TransVarFolded > TransVarCost))){return;}TransVarCurrent.detachChildren();for (Node TransVarElementNode:TransVarFoldChildren){TransVarCurrent.addChildToBack(TransVarElementNode);}}}\n  TransVarTraversal.getCompiler().reportCodeChange();\n}\n",
    "start": 1461,
    "end": 1549,
    "location": [
      1485,
      1490,
      1495,
      1498,
      1506
    ],
    "file_path": "src/com/google/javascript/jscomp/FoldConstants.java"
  },
  "Closure-115": {
    "buggy": "private CanInlineResult canInlineReferenceDirectly(\n    Node TransVarCall, Node TransVarFn) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(!isDirectCallNodeReplacementPossible(TransVarFn)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return CanInlineResult.NO;\n  }\n\n  Node TransVarCallNode = TransVarFn.getLastChild();\n\n  boolean TransVarSideEffects = false;\n  if (!(!(TransVarCallNode.hasChildren()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Preconditions.checkState(TransVarCallNode.hasOneChild());\n    Node TransVarStatement = TransVarCallNode.getFirstChild();\n    if (!(!(TransVarStatement.isReturn()))) {\n      TransVarSideEffects = NodeUtil.mayHaveSideEffects(TransVarStatement.getFirstChild(), compiler);\n    }\n  }\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node TransVarNewCall = TransVarCall.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!(!(!TransVarCall.getFirstChild().isName()))) {\n    if (!(!(NodeUtil.isFunctionObjectCall(TransVarCall)))) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (!(!(TransVarNewCall == null || !TransVarNewCall.isThis()))) {\n        return CanInlineResult.NO;\n      }\n      TransVarNewCall = TransVarNewCall.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(TransVarCall));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node TransVarFnParameter = NodeUtil.getFunctionParameters(TransVarFn).getFirstChild();\n  for (; !(!(TransVarNewCall != null || TransVarFnParameter != null));) {\n    if (!(!(TransVarFnParameter != null))) {\n        if (!(!(TransVarNewCall != null))) {\n            if (!(!(TransVarSideEffects && NodeUtil.canBeSideEffected(TransVarNewCall)))) {\n                return CanInlineResult.NO;\n            }\n            if (!(!(NodeUtil.mayEffectMutableState(TransVarNewCall, compiler)\n                    && NodeUtil.getNameReferenceCount(TransVarCallNode, TransVarFnParameter.getString()) > 1))) {\n                return CanInlineResult.NO;\n            }\n        }\n        TransVarFnParameter = TransVarFnParameter.getNext();\n    }\n    if (!(!(TransVarNewCall != null))) {\n        if (!(!(NodeUtil.mayHaveSideEffects(TransVarNewCall, compiler)))) {\n            return CanInlineResult.NO;\n        }\n        TransVarNewCall = TransVarNewCall.getNext();\n    }\n}\n\n  return CanInlineResult.YES;\n}\n",
    "start": 689,
    "end": 758,
    "location": [
      703,
      704,
      708,
      709,
      710,
      711,
      712,
      713,
      738,
      739,
      740
    ],
    "file_path": "src/com/google/javascript/jscomp/FunctionInjector.java"
  },
  "Closure-116": {
    "buggy": "private CanInlineResult canInlineReferenceDirectly(\n    Node TransVarNode, Node TransVarFnnode) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nif (!(!(!isDirectCallNodeReplacementPossible(TransVarFnnode)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return CanInlineResult.NO;\n  }\n\n  Node TransVarFnBlock = TransVarFnnode.getLastChild();\n\n\n  // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n  Node TransVarCArg2 = TransVarNode.getFirstChild().getNext();\n\n  // Functions called via 'call' and 'apply' have a this-object as\n  // the first parameter, but this is not part of the called function's\n  // parameter list.\n  if (!(!(!TransVarNode.getFirstChild().isName()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(NodeUtil.isFunctionObjectCall(TransVarNode)))) {\n      // TODO(johnlenz): Support replace this with a value.\n      if (!(!(TransVarCArg2 == null || !TransVarCArg2.isThis()))) {\n        return CanInlineResult.NO;\n      }\n      TransVarCArg2 = TransVarCArg2.getNext();\n    } else {\n      // \".apply\" call should be filtered before this.\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(TransVarNode));\n    }\n  }\n\n  // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n  Node TransVarFnNode = NodeUtil.getFunctionParameters(TransVarFnnode).getFirstChild();\n  for (; !(!(TransVarCArg2 != null || TransVarFnNode != null));) {\n    if (!(!(TransVarFnNode != null))) {\n        if (!(!(TransVarCArg2 != null))) {\n            if (!(!(NodeUtil.mayEffectMutableState(TransVarCArg2, compiler)\n                    && NodeUtil.getNameReferenceCount(TransVarFnBlock, TransVarFnNode.getString()) > 1))) {\n                return CanInlineResult.NO;\n            }\n        }\n        TransVarFnNode = TransVarFnNode.getNext();\n    }\n    if (!(!(TransVarCArg2 != null))) {\n        if (!(!(NodeUtil.mayHaveSideEffects(TransVarCArg2, compiler)))) {\n            return CanInlineResult.NO;\n        }\n        TransVarCArg2 = TransVarCArg2.getNext();\n    }\n}\n\n  return CanInlineResult.YES;\n}\n",
    "start": 689,
    "end": 749,
    "location": [
      703,
      734
    ],
    "file_path": "src/com/google/javascript/jscomp/FunctionInjector.java"
  },
  "Closure-117": {
    "buggy": "String getReadableJSTypeName(Node TransVarNode, boolean TransVarBool) {\n if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n\n  // The best type name is the actual type name.\n\n  // If we're analyzing a GETPROP, the property may be inherited by the\n  // prototype chain. So climb the prototype chain and find out where\n  // the property was originally defined.\n  if (!(!(TransVarNode.isGetProp()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ObjectType TransVarType = getJSType(TransVarNode.getFirstChild()).dereference();\n    if (!(!(TransVarType != null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    String TransVarName = TransVarNode.getLastChild().getString();\n      if (!(!(TransVarType.getConstructor() != null && TransVarType.getConstructor().isInterface()))) {\n        TransVarType = FunctionType.getTopDefiningInterface(\n            TransVarType, TransVarName);\n      } else {\n        for (; !(!(TransVarType != null && !TransVarType.hasOwnProperty(TransVarName)));) {\n            TransVarType = TransVarType.getImplicitPrototype();\n        }\n      }\n\n      // Don't show complex function names or anonymous types.\n      // Instead, try to get a human-readable type name.\n      if (!(!(TransVarType != null && (TransVarType.getConstructor() != null || TransVarType.isFunctionPrototypeType())))) {\n        return TransVarType.toString() + \".\" + TransVarName;\n      }\n    }\n  }\n\n  JSType TransVarType1 = getJSType(TransVarNode);\n  if (!(!(TransVarBool))) {\n    ObjectType TransVarDereferencedObject = TransVarType1.dereference();\n    if (!(!(TransVarDereferencedObject != null))) {\n      TransVarType1 = TransVarDereferencedObject;\n    }\n  }\n  if (!(!(TransVarType1.isFunctionPrototypeType()\n        || (TransVarType1.toObjectType() != null && TransVarType1.toObjectType().getConstructor() != null)))) {\n    return TransVarType1.toString();\n  }\n  String TransVarQualifiedName1 = TransVarNode.getQualifiedName();\n  if (!(!(TransVarQualifiedName1 != null))) {\n    return TransVarQualifiedName1;\n  } else if (!(!(TransVarType1.isFunctionType()))) {\n    // Don't show complex function names.\n    return \"function\";\n  } else {\n    return TransVarType1.toString();\n  }\n}\n",
    "start": 724,
    "end": 777,
    "location": [
      728,
      730,
      761,
      762,
      763,
      764,
      765,
      766,
      767,
      769,
      770,
      771
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeValidator.java"
  },
  "Closure-118": {
    "buggy": "private void handleObjectLit(NodeTraversal TransVarTraversal, Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarFirstChild = TransVarNode.getFirstChild();\nwhile (!(!(TransVarFirstChild != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    String TransVarChildName = TransVarFirstChild.getString();\n    T TransVarType1 = typeSystem.getType(getScope(), TransVarNode, TransVarChildName);\n    Property TransVarProperty = getProperty(TransVarChildName);\n    if (!(!(!TransVarProperty.scheduleRenaming(TransVarFirstChild,\n            processProperty(TransVarTraversal, TransVarProperty, TransVarType1, null))))) {\n        if (!(!(false))) {\n                    System.out.println(\"log\");\n                }\n        if (!(!(propertiesToErrorFor.containsKey(TransVarChildName)))) {\n            compiler.report(JSError.make(TransVarTraversal.getSourceName(), TransVarFirstChild,\n                    propertiesToErrorFor.get(TransVarChildName), Warnings.INVALIDATION, TransVarChildName,\n                    (TransVarType1 == null ? \"null\" : TransVarType1.toString()), TransVarNode.toString(), \"\"));\n        }\n    }\n    TransVarFirstChild = TransVarFirstChild.getNext();\n}\n}\n",
    "start": 490,
    "end": 513,
    "location": [
      498
    ],
    "file_path": "src/com/google/javascript/jscomp/DisambiguateProperties.java"
  },
  "Closure-119": {
    "buggy": "public void collect(JSModule TransVarJsModule, Scope TransVarJsScope, Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarNParent = TransVarNode.getParent();\n\n  String TransVarNameOfTheModule;\n  boolean TransVarIsLoaded = false;\n  Name.Type TransVarObjectType = Name.Type.OTHER;\n  boolean TransVarIsPropertyAssign = false;\n\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETTER_DEF))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SETTER_DEF))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.STRING_KEY))))) {\n        TransBreakFlag0 = false;\n        TransVarNameOfTheModule = null;\n        if (!(!(TransVarNParent != null && TransVarNParent.isObjectLit()))) {\n            TransVarNameOfTheModule = getNameForObjLitKey(TransVarNode);\n        }\n        if (!(!(TransVarNameOfTheModule == null))) {\n            return;\n        }\n        TransVarIsLoaded = true;\n        boolean TransFallThroughFlag1 = false;\n        boolean TransBreakFlag1 = true;\n        {\n            if (!(!(TransFallThroughFlag1 || (TransBreakFlag1 && (TransVarNode.getType() == Token.STRING_KEY))))) {\n                TransBreakFlag1 = false;\n                TransVarObjectType = getValueType(TransVarNode.getFirstChild());\n            }\n            if (!(!(TransFallThroughFlag1 || (TransBreakFlag1 && (TransVarNode.getType() == Token.GETTER_DEF))))) {\n                TransBreakFlag1 = false;\n                TransVarObjectType = Name.Type.GET;\n            }\n            if (!(!(TransFallThroughFlag1 || (TransBreakFlag1 && (TransVarNode.getType() == Token.SETTER_DEF))))) {\n                TransBreakFlag1 = false;\n                TransVarObjectType = Name.Type.SET;\n            }\n            if (!(!(!TransFallThroughFlag1 && TransBreakFlag1))) {\n                throw new IllegalStateException(\"unexpected:\" + TransVarNode);\n            }\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarNParent != null))) {\n            boolean TransFallThroughFlag2 = false;\n            boolean TransBreakFlag2 = true;\n            {\n                if (!(!(TransFallThroughFlag2 || (TransBreakFlag2 && (TransVarNParent.getType() == Token.VAR))))) {\n                    TransBreakFlag2 = false;\n                    TransVarIsLoaded = true;\n                    Node TransVarFirst = TransVarNode.getFirstChild();\n                    TransVarObjectType = TransVarFirst == null ? Name.Type.OTHER : getValueType(TransVarFirst);\n                }\n                if (!(!(TransFallThroughFlag2 || (TransBreakFlag2 && (TransVarNParent.getType() == Token.ASSIGN))))) {\n                    TransBreakFlag2 = false;\n                    if (!(!(TransVarNParent.getFirstChild() == TransVarNode))) {\n                        TransVarIsLoaded = true;\n                        TransVarObjectType = getValueType(TransVarNode.getNext());\n                    }\n                }\n                if (!(!(TransFallThroughFlag2 || (TransBreakFlag2 && (TransVarNParent.getType() == Token.GETPROP))))) {\n                    TransFallThroughFlag2 = true;\n                    return;\n                }\n                if (!(!(TransFallThroughFlag2 || (TransBreakFlag2 && (TransVarNParent.getType() == Token.FUNCTION))))) {\n                    TransBreakFlag2 = false;\n                    Node TransVarGrampsParent = TransVarNParent.getParent();\n                    if (!(!(TransVarGrampsParent == null || NodeUtil.isFunctionExpression(TransVarNParent)))) {\n                        return;\n                    }\n                    TransVarIsLoaded = true;\n                    TransVarObjectType = Name.Type.FUNCTION;\n                }\n                if (!(!(TransFallThroughFlag2 || (TransBreakFlag2 && (TransVarNParent.getType() == Token.INC))))) {\n                    TransFallThroughFlag2 = true;\n                }\n                if (!(!(TransFallThroughFlag2 || (TransBreakFlag2 && (TransVarNParent.getType() == Token.DEC))))) {\n                    TransBreakFlag2 = false;\n                    TransVarIsLoaded = true;\n                    TransVarObjectType = Name.Type.OTHER;\n                }\n                if (!(!(!TransFallThroughFlag2 && TransBreakFlag2))) {\n                    if (!(!(NodeUtil.isAssignmentOp(TransVarNParent) && TransVarNParent.getFirstChild() == TransVarNode))) {\n                        TransVarIsLoaded = true;\n                        TransVarObjectType = Name.Type.OTHER;\n                    }\n                }\n            }\n        }\n        TransVarNameOfTheModule = TransVarNode.getString();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETPROP))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarNParent != null))) {\n            boolean TransFallThroughFlag3 = false;\n            boolean TransBreakFlag3 = true;\n            {\n                if (!(!(TransFallThroughFlag3 || (TransBreakFlag3 && (TransVarNParent.getType() == Token.ASSIGN))))) {\n                    TransBreakFlag3 = false;\n                    if (!(!(TransVarNParent.getFirstChild() == TransVarNode))) {\n                        TransVarIsLoaded = true;\n                        TransVarObjectType = getValueType(TransVarNode.getNext());\n                        TransVarIsPropertyAssign = true;\n                    }\n                }\n                if (!(!(TransFallThroughFlag3 || (TransBreakFlag3 && (TransVarNParent.getType() == Token.INC))))) {\n                    TransFallThroughFlag3 = true;\n                }\n                if (!(!(TransFallThroughFlag3 || (TransBreakFlag3 && (TransVarNParent.getType() == Token.DEC))))) {\n                    TransBreakFlag3 = false;\n                    TransVarIsLoaded = true;\n                    TransVarObjectType = Name.Type.OTHER;\n                }\n                if (!(!(TransFallThroughFlag3 || (TransBreakFlag3 && (TransVarNParent.getType() == Token.GETPROP))))) {\n                    TransFallThroughFlag3 = true;\n                    return;\n                }\n                if (!(!(!TransFallThroughFlag3 && TransBreakFlag3))) {\n                    if (!(!(NodeUtil.isAssignmentOp(TransVarNParent) && TransVarNParent.getFirstChild() == TransVarNode))) {\n                        TransVarIsLoaded = true;\n                        TransVarObjectType = Name.Type.OTHER;\n                    }\n                }\n            }\n        }\n        TransVarNameOfTheModule = TransVarNode.getQualifiedName();\n        if (!(!(TransVarNameOfTheModule == null))) {\n            return;\n        }\n    }\n    if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n        return;\n    }\n}\n\n  // We are only interested in global names.\n  if (!(!(!isGlobalNameReference(TransVarNameOfTheModule, TransVarJsScope)))) {\n    return;\n  }\n\n  if (!(!(TransVarIsLoaded))) {\n    if (!(!(isGlobalScope(TransVarJsScope)))) {\n      handleSetFromGlobal(TransVarJsModule, TransVarJsScope, TransVarNode, TransVarNParent, TransVarNameOfTheModule, TransVarIsPropertyAssign, TransVarObjectType);\n    } else {\n      handleSetFromLocal(TransVarJsModule, TransVarJsScope, TransVarNode, TransVarNParent, TransVarNameOfTheModule);\n    }\n  } else {\n    handleGet(TransVarJsModule, TransVarJsScope, TransVarNode, TransVarNParent, TransVarNameOfTheModule);\n  }\n}\n",
    "start": 306,
    "end": 430,
    "location": [
      394
    ],
    "file_path": "src/com/google/javascript/jscomp/GlobalNamespace.java"
  },
  "Closure-120": {
    "buggy": "boolean isAssignedOnceInLifetime() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nReference TransVarReference = getOneAndOnlyAssignment();\n  if (!(!(TransVarReference == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false;\n  }\n\n  BasicBlock TransVarBlockReference = TransVarReference.getBasicBlock();\nwhile (!(!(TransVarBlockReference != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarBlockReference.isFunction))) {\n        break;\n    } else if (!(!(TransVarBlockReference.isLoop))) {\n        return false;\n    }\n    TransVarBlockReference = TransVarBlockReference.getParent();\n}\n\n  return true;\n}\n",
    "start": 421,
    "end": 438,
    "location": [
      439
    ],
    "file_path": "src/com/google/javascript/jscomp/ReferenceCollectingCallback.java"
  },
  "Closure-123": {
    "buggy": "void add(Node TransVarNode, Context TransVarCtx) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(!cc.continueProcessing()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  int TransVarNodeType = TransVarNode.getType();\n  String TransVarOp = NodeUtil.opToStr(TransVarNodeType);\n  int TransVarChildCount2 = TransVarNode.getChildCount();\n  Node TransVarNode1 = TransVarNode.getFirstChild();\n  Node TransVarLastNode = TransVarNode.getLastChild();\n\n  // Handle all binary operators\n  if (!(!(TransVarOp != null && TransVarNode1 != TransVarLastNode))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Preconditions.checkState(\n        TransVarChildCount2 == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        TransVarOp, TransVarChildCount2);\n    int TransVarPrecedence = NodeUtil.precedence(TransVarNodeType);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context TransVarRhsCtx = getContextForNoInOperator(TransVarCtx);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (!(!(TransVarLastNode.getType() == TransVarNodeType && NodeUtil.isAssociative(TransVarNodeType)))) {\n      addExpr(TransVarNode1, TransVarPrecedence, TransVarCtx);\n      cc.addOp(TransVarOp, true);\n      addExpr(TransVarLastNode, TransVarPrecedence, TransVarRhsCtx);\n    } else if (!(!(NodeUtil.isAssignmentOp(TransVarNode) && NodeUtil.isAssignmentOp(TransVarLastNode)))) {\n      // Assignments are the only right-associative binary operators\n      addExpr(TransVarNode1, TransVarPrecedence, TransVarCtx);\n      cc.addOp(TransVarOp, true);\n      addExpr(TransVarLastNode, TransVarPrecedence, TransVarRhsCtx);\n    } else {\n      unrollBinaryOperator(TransVarNode, TransVarNodeType, TransVarOp, TransVarCtx, TransVarRhsCtx, TransVarPrecedence, TransVarPrecedence + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(TransVarNode);\n\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.TRY))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarNode1.getNext().isBlock() && !TransVarNode1.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(TransVarChildCount2 >= 2 && TransVarChildCount2 <= 3);\n        add(\"try\");\n        add(TransVarNode1, Context.PRESERVE_BLOCK);\n        Node TransVarCatchBlock = TransVarNode1.getNext().getFirstChild();\n        if (!(!(TransVarCatchBlock != null))) {\n            add(TransVarCatchBlock);\n        }\n        if (!(!(TransVarChildCount2 == 3))) {\n            add(\"finally\");\n            add(TransVarLastNode, Context.PRESERVE_BLOCK);\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CATCH))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        add(\"catch(\");\n        add(TransVarNode1);\n        add(\")\");\n        add(TransVarLastNode, Context.PRESERVE_BLOCK);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.THROW))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        add(\"throw\");\n        add(TransVarNode1);\n        cc.endStatement(true);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.RETURN))))) {\n        TransBreakFlag0 = false;\n        add(\"return\");\n        if (!(!(TransVarChildCount2 == 1))) {\n            add(TransVarNode1);\n        } else {\n            Preconditions.checkState(TransVarChildCount2 == 0);\n        }\n        cc.endStatement();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.VAR))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarNode1 != null))) {\n            add(\"var \");\n            addList(TransVarNode1, false, getContextForNoInOperator(TransVarCtx));\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.LABEL_NAME))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(!TransVarNode.getString().isEmpty());\n        addIdentifier(TransVarNode.getString());\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NAME))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarNode1 == null || TransVarNode1.isEmpty()))) {\n            addIdentifier(TransVarNode.getString());\n        } else {\n            Preconditions.checkState(TransVarChildCount2 == 1);\n            addIdentifier(TransVarNode.getString());\n            cc.addOp(\"=\", true);\n            if (!(!(TransVarNode1.isComma()))) {\n                addExpr(TransVarNode1, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n            } else {\n                addExpr(TransVarNode1, 0, getContextForNoInOperator(TransVarCtx));\n            }\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.ARRAYLIT))))) {\n        TransBreakFlag0 = false;\n        add(\"[\");\n        addArrayList(TransVarNode1);\n        add(\"]\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.PARAM_LIST))))) {\n        TransBreakFlag0 = false;\n        add(\"(\");\n        addList(TransVarNode1);\n        add(\")\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.COMMA))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        unrollBinaryOperator(TransVarNode, Token.COMMA, \",\", TransVarCtx, getContextForNoInOperator(TransVarCtx), 0, 0);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NUMBER))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n        cc.addNumber(TransVarNode.getDouble());\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.TYPEOF))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.VOID))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NOT))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.BITNOT))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.POS))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(TransVarNodeType), false);\n        addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), Context.OTHER);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NEG))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        if (!(!(TransVarNode.getFirstChild().isNumber()))) {\n            cc.addNumber(-TransVarNode.getFirstChild().getDouble());\n        } else {\n            cc.addOp(NodeUtil.opToStrNoFail(TransVarNodeType), false);\n            addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), Context.OTHER);\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.HOOK))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 3);\n        int TransVarP1 = NodeUtil.precedence(TransVarNodeType);\n        Context TransVarContext = Context.OTHER;\n        addExpr(TransVarNode1, TransVarP1 + 1, TransVarCtx);\n        cc.addOp(\"?\", true);\n        addExpr(TransVarNode1.getNext(), 1, TransVarContext);\n        cc.addOp(\":\", true);\n        addExpr(TransVarLastNode, 1, TransVarContext);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.REGEXP))))) {\n        TransBreakFlag0 = false;\n        if (!(!(!TransVarNode1.isString() || !TransVarLastNode.isString()))) {\n            throw new Error(\"Expected children to be strings\");\n        }\n        String TransVarFirstRegexp = regexpEscape(TransVarNode1.getString(), outputCharsetEncoder);\n        if (!(!(TransVarChildCount2 == 2))) {\n            add(TransVarFirstRegexp + TransVarLastNode.getString());\n        } else {\n            Preconditions.checkState(TransVarChildCount2 == 1);\n            add(TransVarFirstRegexp);\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.FUNCTION))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarNode.getClass() != Node.class))) {\n            throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(TransVarChildCount2 == 3);\n        boolean TransVarNeedsParens = (TransVarCtx == Context.START_OF_EXPR);\n        if (!(!(TransVarNeedsParens))) {\n            add(\"(\");\n        }\n        add(\"function\");\n        add(TransVarNode1);\n        add(TransVarNode1.getNext());\n        add(TransVarLastNode, Context.PRESERVE_BLOCK);\n        cc.endFunction(TransVarCtx == Context.STATEMENT);\n        if (!(!(TransVarNeedsParens))) {\n            add(\")\");\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.GETTER_DEF))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.SETTER_DEF))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarNode.getParent().isObjectLit());\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        Preconditions.checkState(TransVarNode1.isFunction());\n        Preconditions.checkState(TransVarNode1.getFirstChild().getString().isEmpty());\n        if (!(!(TransVarNodeType == Token.GETTER_DEF))) {\n            Preconditions.checkState(!TransVarNode1.getChildAtIndex(1).hasChildren());\n            add(\"get \");\n        } else {\n            Preconditions.checkState(TransVarNode1.getChildAtIndex(1).hasOneChild());\n            add(\"set \");\n        }\n        String TransVarName1 = TransVarNode.getString();\n        Node TransVarFnNode = TransVarNode1;\n        Node TransVarParameterNode = TransVarFnNode.getChildAtIndex(1);\n        Node TransVarBodyNode = TransVarFnNode.getLastChild();\n        if (!(!(!TransVarNode.isQuotedString() && TokenStream.isJSIdentifier(TransVarName1)\n                && NodeUtil.isLatin(TransVarName1)))) {\n            add(TransVarName1);\n        } else {\n            double TransVarDd = getSimpleNumber(TransVarName1);\n            if (!(!(!Double.isNaN(TransVarDd)))) {\n                cc.addNumber(TransVarDd);\n            } else {\n                addJsString(TransVarNode);\n            }\n        }\n        add(TransVarParameterNode);\n        add(TransVarBodyNode, Context.PRESERVE_BLOCK);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.SCRIPT))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.BLOCK))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarNode.getClass() != Node.class))) {\n            throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean TransVarPreserve = TransVarCtx == Context.PRESERVE_BLOCK;\n        if (!(!(TransVarPreserve))) {\n            cc.beginBlock();\n        }\n        boolean TransVarPreferLineBreak = TransVarNodeType == Token.SCRIPT || (TransVarNodeType == Token.BLOCK\n                && !TransVarPreserve && TransVarNode.getParent() != null && TransVarNode.getParent().isScript());\n        Node TransVarChild = TransVarNode1;\n        while (!(!(TransVarChild != null))) {\n            add(TransVarChild, Context.STATEMENT);\n            if (!(!(TransVarChild.isVar()))) {\n                cc.endStatement();\n            }\n            if (!(!(TransVarChild.isFunction()))) {\n                cc.maybeLineBreak();\n            }\n            if (!(!(TransVarPreferLineBreak))) {\n                cc.notePreferredLineBreak();\n            }\n            TransVarChild = TransVarChild.getNext();\n        }\n        if (!(!(TransVarPreserve))) {\n            cc.endBlock(cc.breakAfterBlockFor(TransVarNode, TransVarCtx == Context.STATEMENT));\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.FOR))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarChildCount2 == 4))) {\n            add(\"for(\");\n            if (!(!(TransVarNode1.isVar()))) {\n                add(TransVarNode1, Context.IN_FOR_INIT_CLAUSE);\n            } else {\n                addExpr(TransVarNode1, 0, Context.IN_FOR_INIT_CLAUSE);\n            }\n            add(\";\");\n            add(TransVarNode1.getNext());\n            add(\";\");\n            add(TransVarNode1.getNext().getNext());\n            add(\")\");\n            addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);\n        } else {\n            Preconditions.checkState(TransVarChildCount2 == 3);\n            add(\"for(\");\n            add(TransVarNode1);\n            add(\"in\");\n            add(TransVarNode1.getNext());\n            add(\")\");\n            addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DO))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        add(\"do\");\n        addNonEmptyStatement(TransVarNode1, Context.OTHER, false);\n        add(\"while(\");\n        add(TransVarLastNode);\n        add(\")\");\n        cc.endStatement();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.WHILE))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        add(\"while(\");\n        add(TransVarNode1);\n        add(\")\");\n        addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.EMPTY))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.GETPROP))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2, \"Bad GETPROP: expected 2 children, but got %s\",\n                TransVarChildCount2);\n        Preconditions.checkState(TransVarLastNode.isString(), \"Bad GETPROP: RHS should be STRING\");\n        boolean TransVarNeedsParent = (TransVarNode1.isNumber());\n        if (!(!(TransVarNeedsParent))) {\n            add(\"(\");\n        }\n        addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);\n        if (!(!(TransVarNeedsParent))) {\n            add(\")\");\n        }\n        if (!(!(this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(TransVarLastNode.getString())))) {\n            add(\"[\");\n            add(TransVarLastNode);\n            add(\"]\");\n        } else {\n            add(\".\");\n            addIdentifier(TransVarLastNode.getString());\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.GETELEM))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2, \"Bad GETELEM: expected 2 children but got %s\",\n                TransVarChildCount2);\n        addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);\n        add(\"[\");\n        add(TransVarNode1.getNext());\n        add(\"]\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.WITH))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        add(\"with(\");\n        add(TransVarNode1);\n        add(\")\");\n        addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.INC))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DEC))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        String TransVarOperator = TransVarNodeType == Token.INC ? \"++\" : \"--\";\n        int TransVarPost = TransVarNode.getIntProp(Node.INCRDECR_PROP);\n        if (!(!(TransVarPost != 0))) {\n            addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);\n            cc.addOp(TransVarOperator, false);\n        } else {\n            cc.addOp(TransVarOperator, false);\n            add(TransVarNode1);\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CALL))))) {\n        TransBreakFlag0 = false;\n        if (!(!(isIndirectEval(TransVarNode1)\n                || TransVarNode.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(TransVarNode1)))) {\n            add(\"(0,\");\n            addExpr(TransVarNode1, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n            add(\")\");\n        } else {\n            addExpr(TransVarNode1, NodeUtil.precedence(TransVarNodeType), TransVarCtx);\n        }\n        add(\"(\");\n        addList(TransVarNode1.getNext());\n        add(\")\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.IF))))) {\n        TransBreakFlag0 = false;\n        boolean TransVarHasElseStmt = TransVarChildCount2 == 3;\n        boolean TransVarIsElseStmt = TransVarCtx == Context.BEFORE_DANGLING_ELSE && !TransVarHasElseStmt;\n        if (!(!(TransVarIsElseStmt))) {\n            cc.beginBlock();\n        }\n        add(\"if(\");\n        add(TransVarNode1);\n        add(\")\");\n        if (!(!(TransVarHasElseStmt))) {\n            addNonEmptyStatement(TransVarNode1.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n            add(\"else\");\n            addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), false);\n        } else {\n            addNonEmptyStatement(TransVarNode1.getNext(), Context.OTHER, false);\n            Preconditions.checkState(TransVarChildCount2 == 2);\n        }\n        if (!(!(TransVarIsElseStmt))) {\n            cc.endBlock();\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NULL))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n        cc.addConstant(\"null\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.THIS))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n        add(\"this\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.FALSE))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n        cc.addConstant(\"false\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.TRUE))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n        cc.addConstant(\"true\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CONTINUE))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 <= 1);\n        add(\"continue\");\n        if (!(!(TransVarChildCount2 == 1))) {\n            if (!(!(!TransVarNode1.isLabelName()))) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(\" \");\n            add(TransVarNode1);\n        }\n        cc.endStatement();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DEBUGGER))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0);\n        add(\"debugger\");\n        cc.endStatement();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.BREAK))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 <= 1);\n        add(\"break\");\n        if (!(!(TransVarChildCount2 == 1))) {\n            if (!(!(!TransVarNode1.isLabelName()))) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(\" \");\n            add(TransVarNode1);\n        }\n        cc.endStatement();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.EXPR_RESULT))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        add(TransVarNode1, Context.START_OF_EXPR);\n        cc.endStatement();\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.NEW))))) {\n        TransBreakFlag0 = false;\n        add(\"new \");\n        int TransVarPre = NodeUtil.precedence(TransVarNodeType);\n        if (!(!(NodeUtil.containsType(TransVarNode1, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)))) {\n            TransVarPre = NodeUtil.precedence(TransVarNode1.getType()) + 1;\n        }\n        addExpr(TransVarNode1, TransVarPre, Context.OTHER);\n        Node TransVarNextNode = TransVarNode1.getNext();\n        if (!(!(TransVarNextNode != null))) {\n            add(\"(\");\n            addList(TransVarNextNode);\n            add(\")\");\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.STRING_KEY))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1, \"Object lit key must have 1 child\");\n        addJsString(TransVarNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.STRING))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 0, \"A string may not have children\");\n        addJsString(TransVarNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DELPROP))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        add(\"delete \");\n        add(TransVarNode1);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.OBJECTLIT))))) {\n        TransBreakFlag0 = false;\n        boolean TransVarNeedParen = (TransVarCtx == Context.START_OF_EXPR);\n        if (!(!(TransVarNeedParen))) {\n            add(\"(\");\n        }\n        add(\"{\");\n        Node TransVarCurrent = TransVarNode1;\n        while (!(!(TransVarCurrent != null))) {\n            if (!(!(TransVarCurrent != TransVarNode1))) {\n                cc.listSeparator();\n            }\n            if (!(!(TransVarCurrent.isGetterDef() || TransVarCurrent.isSetterDef()))) {\n                add(TransVarCurrent);\n            } else {\n                Preconditions.checkState(TransVarCurrent.isStringKey());\n                String TransVarKeyString = TransVarCurrent.getString();\n                if (!(!(!TransVarCurrent.isQuotedString()\n                        && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(TransVarKeyString))\n                        && TokenStream.isJSIdentifier(TransVarKeyString) && NodeUtil.isLatin(TransVarKeyString)))) {\n                    add(TransVarKeyString);\n                } else {\n                    double TransVarD2 = getSimpleNumber(TransVarKeyString);\n                    if (!(!(!Double.isNaN(TransVarD2)))) {\n                        cc.addNumber(TransVarD2);\n                    } else {\n                        addExpr(TransVarCurrent, 1, Context.OTHER);\n                    }\n                }\n                add(\":\");\n                addExpr(TransVarCurrent.getFirstChild(), 1, Context.OTHER);\n            }\n            TransVarCurrent = TransVarCurrent.getNext();\n        }\n        add(\"}\");\n        if (!(!(TransVarNeedParen))) {\n            add(\")\");\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.SWITCH))))) {\n        TransBreakFlag0 = false;\n        add(\"switch(\");\n        add(TransVarNode1);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(TransVarNode1.getNext());\n        cc.endBlock(TransVarCtx == Context.STATEMENT);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CASE))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        add(\"case \");\n        add(TransVarNode1);\n        addCaseBody(TransVarLastNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.DEFAULT_CASE))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 1);\n        add(\"default\");\n        addCaseBody(TransVarNode1);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.LABEL))))) {\n        TransBreakFlag0 = false;\n        Preconditions.checkState(TransVarChildCount2 == 2);\n        if (!(!(!TransVarNode1.isLabelName()))) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(TransVarNode1);\n        add(\":\");\n        addNonEmptyStatement(TransVarLastNode, getContextForNonEmptyExpression(TransVarCtx), true);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNodeType == Token.CAST))))) {\n        TransBreakFlag0 = false;\n        add(\"(\");\n        add(TransVarNode1);\n        add(\")\");\n    }\n    if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n        throw new Error(\"Unknown type \" + TransVarNodeType + \"\\n\" + TransVarNode.toStringTree());\n    }\n}\n\n  cc.endSourceMapping(TransVarNode);\n}\n",
    "start": 107,
    "end": 771,
    "location": [
      283
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-124": {
    "buggy": "private boolean isSafeReplacement(Node TransVarCurrentNode, Node TransVarReplacementNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// No checks are needed for simple names.\n  if (!(!(TransVarCurrentNode.isName()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return true;\n  }\n  Preconditions.checkArgument(TransVarCurrentNode.isGetProp());\n\n    TransVarCurrentNode = TransVarCurrentNode.getFirstChild();\n  if (!(!(TransVarCurrentNode.isName() && isNameAssignedTo(TransVarCurrentNode.getString(), TransVarReplacementNode)))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return false;\n  }\n\n  return true;\n}\n",
    "start": 206,
    "end": 220,
    "location": [
      219
    ],
    "file_path": "src/com/google/javascript/jscomp/ExploitAssigns.java"
  },
  "Closure-128": {
    "buggy": "static boolean isSimpleNumber(String TransVarS1) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nint TransVarLengthOfString = TransVarS1.length();\n  int TransVarIndex2 = 0;\nwhile (!(!(TransVarIndex2 < TransVarLengthOfString))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    char TransVarC2 = TransVarS1.charAt(TransVarIndex2);\n    if (!(!(TransVarC2 < '0' || TransVarC2 > '9'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    TransVarIndex2++;\n}\n  return TransVarLengthOfString > 0 && TransVarS1.charAt(0) != '0';\n}\n",
    "start": 783,
    "end": 792,
    "location": [
      789,
      802
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-13": {
    "buggy": "private void traverse(Node TransVarNodes) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// The goal here is to avoid retraversing\n  // the entire AST to catch newly created opportunities.\n  // So we track whether a \"unit of code\" has changed,\n  // and revisit immediately.\n  if (!(!(!shouldVisit(TransVarNodes)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  int TransVarVisit = 0;\n  do {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarChildNode = TransVarNodes.getFirstChild();\n    for (; !(!(TransVarChildNode != null));) {\n        traverse(TransVarChildNode);\n        Node TransVarNextNode = TransVarChildNode.getNext();\n        TransVarChildNode = TransVarNextNode;\n    }\n\n    visit(TransVarNodes);\n    TransVarVisit++;\n\n    Preconditions.checkState(TransVarVisit < 10000, \"too many interations\");\n  } while (!(!(shouldRetraverse(TransVarNodes))));\n\n  exitNode(TransVarNodes);\n}\n",
    "start": 113,
    "end": 138,
    "location": [
      135,
      136
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java"
  },
  "Closure-130": {
    "buggy": "private void inlineAliases(GlobalNamespace TransVarNamespace2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> TransVarNamespace = new ArrayDeque<Name>(TransVarNamespace2.getNameForest());\n    for (; !(!(!TransVarNamespace.isEmpty())); ) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Name TransVarName1 = TransVarNamespace.pop();\n        if (!(!(TransVarName1.type == Name.Type.GET || TransVarName1.type == Name.Type.SET))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            continue;\n        }\n        if (!(!(TransVarName1.globalSets == 1 && TransVarName1.localSets == 0 && TransVarName1.aliasingGets > 0))) {\n            List<Ref> TransVarReferences = Lists.newArrayList(TransVarName1.getRefs());\n            for (Ref TransVarRef1 : TransVarReferences) {\n                if (!(!(TransVarRef1.type == Type.ALIASING_GET && TransVarRef1.scope.isLocal()))) {\n                    if (!(!(inlineAliasIfPossible(TransVarRef1, TransVarNamespace2)))) {\n                        TransVarName1.removeRef(TransVarRef1);\n                    }\n                }\n            }\n        }\n        if (!(!((TransVarName1.type == Name.Type.OBJECTLIT || TransVarName1.type == Name.Type.FUNCTION) && TransVarName1.aliasingGets == 0 && TransVarName1.props != null))) {\n            TransVarNamespace.addAll(TransVarName1.props);\n        }\n    }\n}\n",
    "start": 161,
    "end": 197,
    "location": [
      175
    ],
    "file_path": "src/com/google/javascript/jscomp/CollapseProperties.java"
  },
  "Closure-131": {
    "buggy": "public static boolean isJSIdentifier(String TransVarString) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nint TransVarLen = TransVarString.length();\n\n  if (!(!(TransVarLen == 0 || !Character.isJavaIdentifierStart(TransVarString.charAt(0))))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return false;\n  }\n\n  int TransVarItem = 1;\nwhile (!(!(TransVarItem < TransVarLen))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(!Character.isJavaIdentifierPart(TransVarString.charAt(TransVarItem))))) {\n        return false;\n    }\n    TransVarItem++;\n}\n\n  return true;\n}\n",
    "start": 190,
    "end": 206,
    "location": [
      196
    ],
    "file_path": "src/com/google/javascript/rhino/TokenStream.java"
  },
  "Closure-14": {
    "buggy": "private static Node computeFollowNode(Node TransVarFrom, Node TransVarNodeObject, ControlFlowAnalysis TransVarCfaObject) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    /*\n   * This is the case where:\n   *\n   * 1. Parent is null implies that we are transferring control to the end of\n   * the script.\n   *\n   * 2. Parent is a function implies that we are transferring control back to\n   * the caller of the function.\n   *\n   * 3. If the node is a return statement, we should also transfer control\n   * back to the caller of the function.\n   *\n   * 4. If the node is root then we have reached the end of what we have been\n   * asked to traverse.\n   *\n   * In all cases we should transfer control to a \"symbolic return\" node.\n   * This will make life easier for DFAs.\n   */\n    Node TransVarParentNode = TransVarNodeObject.getParent();\n    if (!(!(TransVarParentNode == null || TransVarParentNode.isFunction() || (TransVarCfaObject != null && TransVarNodeObject == TransVarCfaObject.root)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.IF))))) {\n            TransFallThroughFlag0 = true;\n            return computeFollowNode(TransVarFrom, TransVarParentNode, TransVarCfaObject);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.CASE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.DEFAULT_CASE))))) {\n            TransBreakFlag0 = false;\n            if (!(!(TransVarParentNode.getNext() != null))) {\n                if (!(!(TransVarParentNode.getNext().isCase()))) {\n                    return TransVarParentNode.getNext().getFirstChild().getNext();\n                } else if (!(!(TransVarParentNode.getNext().isDefaultCase()))) {\n                    return TransVarParentNode.getNext().getFirstChild();\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(TransVarFrom, TransVarParentNode, TransVarCfaObject);\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.FOR))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(NodeUtil.isForIn(TransVarParentNode)))) {\n                return TransVarParentNode;\n            } else {\n                return TransVarParentNode.getFirstChild().getNext().getNext();\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.WHILE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.DO))))) {\n            TransFallThroughFlag0 = true;\n            return TransVarParentNode;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentNode.getType() == Token.TRY))))) {\n            if (!(!(TransVarParentNode.getFirstChild() == TransVarNodeObject))) {\n                if (!(!(NodeUtil.hasFinally(TransVarParentNode)))) {\n                    return computeFallThrough(TransVarParentNode.getLastChild());\n                } else {\n                    return computeFollowNode(TransVarFrom, TransVarParentNode, TransVarCfaObject);\n                }\n            } else if (!(!(NodeUtil.getCatchBlock(TransVarParentNode) == TransVarNodeObject))) {\n                if (!(!(NodeUtil.hasFinally(TransVarParentNode)))) {\n                    return computeFallThrough(TransVarNodeObject.getNext());\n                } else {\n                    return computeFollowNode(TransVarFrom, TransVarParentNode, TransVarCfaObject);\n                }\n            } else if (!(!(TransVarParentNode.getLastChild() == TransVarNodeObject))) {\n                if (!(!(TransVarCfaObject != null))) {\n                    for (Node TransVarNode : TransVarCfaObject.finallyMap.get(TransVarParentNode)) {\n                        TransVarCfaObject.createEdge(TransVarFrom, Branch.UNCOND, TransVarNode);\n                    }\n                }\n                return computeFollowNode(TransVarFrom, TransVarParentNode, TransVarCfaObject);\n            }\n        }\n    }\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node TransVarNextNode = TransVarNodeObject.getNext();\n    for (; !(!(TransVarNextNode != null && TransVarNextNode.isFunction())); ) {\n        TransVarNextNode = TransVarNextNode.getNext();\n    }\n    if (!(!(TransVarNextNode != null))) {\n        return computeFallThrough(TransVarNextNode);\n    } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(TransVarFrom, TransVarParentNode, TransVarCfaObject);\n    }\n}\n",
    "start": 692,
    "end": 789,
    "location": [
      779
    ],
    "file_path": "src/com/google/javascript/jscomp/ControlFlowAnalysis.java"
  },
  "Closure-15": {
    "buggy": "public boolean apply(Node TransVarNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// When the node is null it means, we reached the implicit return\n  // where the function returns (possibly without an return statement)\n  if (!(!(TransVarNode == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false;\n  }\n\n  // TODO(user): We only care about calls to functions that\n  // passes one of the dependent variable to a non-side-effect free\n  // function.\n  if (!(!(TransVarNode.isCall() && NodeUtil.functionCallHasSideEffects(TransVarNode)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return true;\n  }\n\n  if (!(!(TransVarNode.isNew() && NodeUtil.constructorCallHasSideEffects(TransVarNode)))) {\n    return true;\n  }\n\n Node TransVarChild = TransVarNode.getFirstChild();\nwhile (!(!(TransVarChild != null))) {\n    if (!(!(!ControlFlowGraph.isEnteringNewCfgNode(TransVarChild) && apply(TransVarChild)))) {\n        return true;\n    }\n    TransVarChild = TransVarChild.getNext();\n}\n  return false;\n}\n",
    "start": 84,
    "end": 109,
    "location": [
      110
    ],
    "file_path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java"
  },
  "Closure-150": {
    "buggy": "@Override public void visit(NodeTraversal TransVarT1, Node TransVarNode, Node TransVarP) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarNode == scope.getRootNode()))) return;\n\n  if (!(!(TransVarNode.getType() == Token.LP && TransVarP == scope.getRootNode()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    handleFunctionInputs(TransVarP);\n    return;\n  }\n\n  attachLiteralTypes(TransVarNode);\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarP.getType() == Token.NAME))) {\n            return;\n        }\n        defineDeclaredFunction(TransVarNode, TransVarP);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CATCH))))) {\n        TransBreakFlag0 = false;\n        defineCatch(TransVarNode, TransVarP);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))) {\n        defineVar(TransVarNode, TransVarP);\n    }\n}\n}\n",
    "start": 1443,
    "end": 1466,
    "location": [
      1457,
      1458,
      1459,
      1464,
      1465,
      1466,
      1467,
      1468,
      1469,
      1470,
      1471,
      1472,
      1473,
      1474,
      1475,
      1476,
      1477
    ],
    "file_path": "src/com/google/javascript/jscomp/TypedScopeCreator.java"
  },
  "Closure-160": {
    "buggy": "public void initOptions(CompilerOptions TransVarCompilerOptions) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nthis.options = TransVarCompilerOptions;\n  if (!(!(errorManager == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(outStream == null))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager TransVarOutPrinter =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      TransVarOutPrinter.setSummaryDetailLevel(TransVarCompilerOptions.summaryDetailLevel);\n      setErrorManager(TransVarOutPrinter);\n    }\n  }\n\n  // DiagnosticGroups override the plain checkTypes option.\n  if (!(!(TransVarCompilerOptions.enables(DiagnosticGroups.CHECK_TYPES)))) {\n    TransVarCompilerOptions.checkTypes = true;\n  } else if (!(!(TransVarCompilerOptions.disables(DiagnosticGroups.CHECK_TYPES)))) {\n    TransVarCompilerOptions.checkTypes = false;\n  } else if (!(!(!TransVarCompilerOptions.checkTypes))) {\n    // If DiagnosticGroups did not override the plain checkTypes\n    // option, and checkTypes is enabled, then turn off the\n    // parser type warnings.\n    TransVarCompilerOptions.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n\n  if (!(!(TransVarCompilerOptions.checkGlobalThisLevel.isOn()))) {\n    TransVarCompilerOptions.setWarningLevel(\n        DiagnosticGroups.GLOBAL_THIS,\n        TransVarCompilerOptions.checkGlobalThisLevel);\n  }\n\n  // Initialize the warnings guard.\n  List<WarningsGuard> TransVarGuardsList = Lists.newArrayList();\n  TransVarGuardsList.add(\n      new SuppressDocWarningsGuard(\n          getDiagnosticGroups().getRegisteredGroups()));\n  TransVarGuardsList.add(TransVarCompilerOptions.getWarningsGuard());\n\n\n  // All passes must run the variable check. This synthesizes\n  // variables later so that the compiler doesn't crash. It also\n  // checks the externs file for validity. If you don't want to warn\n  // about missing variable declarations, we shut that specific\n  // error off.\n  if (!(!(!TransVarCompilerOptions.checkSymbols\n        && (warningsGuard == null || !warningsGuard.disables(DiagnosticGroups.CHECK_VARIABLES))))) {\n    TransVarGuardsList.add(new DiagnosticGroupWarningsGuard(\n        DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n  }\n\n  this.warningsGuard = new ComposeWarningsGuard(TransVarGuardsList);\n}\n",
    "start": 226,
    "end": 282,
    "location": [
      277,
      284,
      285,
      289
    ],
    "file_path": "src/com/google/javascript/jscomp/Compiler.java"
  },
  "Closure-164": {
    "buggy": "public boolean isSubtype(JSType TransVarJsType) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(!(TransVarJsType instanceof ArrowType)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false;\n  }\n\n  ArrowType TransVarArrowType = (ArrowType) TransVarJsType;\n\n  // This is described in Draft 2 of the ES4 spec,\n  // Section 3.4.7: Subtyping Function Types.\n\n  // this.returnType <: that.returnType (covariant)\n  if (!(!(!this.returnType.isSubtype(TransVarArrowType.returnType)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return false;\n  }\n\n  // that.paramType[i] <: this.paramType[i] (contravariant)\n  //\n  // If this.paramType[i] is required,\n  // then that.paramType[i] is required.\n  //\n  // In theory, the \"required-ness\" should work in the other direction as\n  // well. In other words, if we have\n  //\n  // function f(number, number) {}\n  // function g(number) {}\n  //\n  // Then f *should* not be a subtype of g, and g *should* not be\n  // a subtype of f. But in practice, we do not implement it this way.\n  // We want to support the use case where you can pass g where f is\n  // expected, and pretend that g ignores the second argument.\n  // That way, you can have a single \"no-op\" function, and you don't have\n  // to create a new no-op function for every possible type signature.\n  //\n  // So, in this case, g < f, but f !< g\n  Node TransVarNode = parameters.getFirstChild();\n  Node TransVarParam = TransVarArrowType.parameters.getFirstChild();\n  for (; !(!(TransVarNode != null && TransVarParam != null));) {\n    JSType TransVarJsType2 = TransVarNode.getJSType();\n    JSType TransVarThatParamJSType = TransVarParam.getJSType();\n    if (!(!(TransVarJsType2 != null))) {\n        if (!(!(TransVarThatParamJSType == null || !TransVarThatParamJSType.isSubtype(TransVarJsType2)))) {\n            return false;\n        }\n    }\n    boolean TransVarThisIsVarArgs2 = TransVarNode.isVarArgs();\n    boolean TransVarThisIsVarArgs = TransVarParam.isVarArgs();\n    if (!(!(!TransVarThisIsVarArgs2))) {\n        TransVarNode = TransVarNode.getNext();\n    }\n    if (!(!(!TransVarThisIsVarArgs))) {\n        TransVarParam = TransVarParam.getNext();\n    }\n    if (!(!(TransVarThisIsVarArgs2 && TransVarThisIsVarArgs))) {\n        TransVarNode = null;\n        TransVarParam = null;\n    }\n}\n\n  // \"that\" can't be a supertype, because it's missing a required arguement.\n\n  return true;\n}\n",
    "start": 80,
    "end": 154,
    "location": [
      135,
      148
    ],
    "file_path": "src/com/google/javascript/rhino/jstype/ArrowType.java"
  },
  "Closure-176": {
    "buggy": "private void updateScopeForTypeChange(\n    FlowScope TransVarFlow, Node TransVarRight, JSType TransVarLeft, JSType TransVarType) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nPreconditions.checkNotNull(TransVarType);\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarRight.getType() == Token.NAME))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransBreakFlag0 = false;\n        String TransVarFinalString = TransVarRight.getString();\n        Var TransVarVarScope = syntacticScope.getVar(TransVarFinalString);\n        boolean TransVarIsAssignment = TransVarRight.hasChildren();\n        boolean TransVarIsTypeInferred = !TransVarIsAssignment || TransVarVarScope == null\n                || TransVarVarScope.isTypeInferred();\n        if (!(!(TransVarIsTypeInferred))) {\n            redeclareSimpleVar(TransVarFlow, TransVarRight, TransVarType);\n        }\n        TransVarRight.setJSType(TransVarIsAssignment || TransVarLeft == null ? TransVarType : null);\n        if (!(!(TransVarVarScope != null && TransVarVarScope.isTypeInferred()))) {\n            JSType TransVarNewType = TransVarVarScope.getType();\n            TransVarVarScope\n                    .setType(TransVarNewType == null ? TransVarType : TransVarNewType.getLeastSupertype(TransVarType));\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarRight.getType() == Token.GETPROP))))) {\n        String TransVarLeftQualifiedName = TransVarRight.getQualifiedName();\n        if (!(!(TransVarLeftQualifiedName != null))) {\n            TransVarFlow.inferQualifiedSlot(TransVarRight, TransVarLeftQualifiedName,\n                    TransVarLeft == null ? unknownType : TransVarLeft, TransVarType);\n        }\n        TransVarRight.setJSType(TransVarType);\n        ensurePropertyDefined(TransVarRight, TransVarType);\n    }\n}\n}\n",
    "start": 523,
    "end": 585,
    "location": [
      542,
      543,
      544,
      548
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java"
  },
  "Closure-19": {
    "buggy": "protected void declareNameInScope(FlowScope TransVarFlowScope, Node TransVarParentFlowScope, JSType TransVarTypeNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentFlowScope.getType() == Token.NAME))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransBreakFlag0 = false;\n        TransVarFlowScope.inferSlotType(TransVarParentFlowScope.getString(), TransVarTypeNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarParentFlowScope.getType() == Token.GETPROP))))) {\n        TransBreakFlag0 = false;\n        String TransVarQName = TransVarParentFlowScope.getQualifiedName();\n        Preconditions.checkNotNull(TransVarQName);\n        JSType TransVarType = TransVarParentFlowScope.getJSType();\n        TransVarType = TransVarType == null ? getNativeType(UNKNOWN_TYPE) : TransVarType;\n        TransVarFlowScope.inferQualifiedSlot(TransVarParentFlowScope, TransVarQName, TransVarType, TransVarTypeNode);\n    }\n    if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" + TransVarParentFlowScope.toStringTree());\n    }\n}\n}\n",
    "start": 157,
    "end": 178,
    "location": [
      182
    ],
    "file_path": "src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java"
  },
  "Closure-22": {
    "buggy": "public void visit(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarAncestor) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// VOID nodes appear when there are extra semicolons at the BLOCK level.\n  // I've been unable to think of any cases where this indicates a bug,\n  // and apparently some people like keeping these semicolons around,\n  // so we'll allow it.\n  if (!(!(TransVarNode.isEmpty() || TransVarNode.isComma()))) {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    return;\n  }\n\n  if (!(!(TransVarAncestor == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return;\n  }\n\n  // Do not try to remove a block or an expr result. We already handle\n  // these cases when we visit the child, and the peephole passes will\n  // fix up the tree in more clever ways when these are removed.\n  if (!(!(TransVarAncestor.getType() == Token.COMMA))) {\n    Node TransVarGrandParent = TransVarAncestor.getParent();\n    if (!(!(TransVarGrandParent.isCall() && TransVarAncestor == TransVarGrandParent.getFirstChild()))) {\n      if (!(!(TransVarNode == TransVarAncestor.getFirstChild() && TransVarAncestor.getChildCount() == 2\n            && TransVarNode.getNext().isName() && \"eval\".equals(TransVarNode.getNext().getString())))) {\n    return;\n      }\n  }\n\n  // This no-op statement was there so that JSDoc information could\n  // be attached to the name. This check should not complain about it.\n    if (!(!(TransVarNode == TransVarAncestor.getLastChild()))) {\n      for (Node TransVarCurrentNode : TransVarAncestor.getAncestors()) {\n        int TransVarNodetype = TransVarCurrentNode.getType();\n        if (!(!(TransVarNodetype == Token.COMMA)))\n          continue;\n        if (!(!(TransVarNodetype != Token.EXPR_RESULT && TransVarNodetype != Token.BLOCK)))\n          return;\n        else\n          break;\n      }\n    }\n  } else if (!(!(TransVarAncestor.getType() != Token.EXPR_RESULT && TransVarAncestor.getType() != Token.BLOCK))) {\n    if (!(!(TransVarAncestor.getType() == Token.FOR && TransVarAncestor.getChildCount() == 4\n            && (TransVarNode == TransVarAncestor.getFirstChild()\n                    || TransVarNode == TransVarAncestor.getFirstChild().getNext().getNext())))) {\n    } else {\n    return;\n    }\n  }\n\n  boolean TransVarIsUsed = NodeUtil.isExpressionResultUsed(TransVarNode);\n  boolean TransVarIsSimpleOperator = NodeUtil.isSimpleOperatorType(TransVarNode.getType());\n  if (!(!(!TransVarIsUsed\n        && (TransVarIsSimpleOperator || !NodeUtil.mayHaveSideEffects(TransVarNode, TransVarTraversal.getCompiler()))))) {\n    if (!(!(TransVarNode.isQualifiedName() && TransVarNode.getJSDocInfo() != null))) {\n      return;\n    } else if (!(!(TransVarNode.isExprResult()))) {\n      return;\n    }\n    String TransVarMessage = \"This code lacks side-effects. Is there a bug?\";\n    if (!(!(TransVarNode.isString()))) {\n      TransVarMessage = \"Is there a missing '+' on the previous line?\";\n    } else if (!(!(TransVarIsSimpleOperator))) {\n      TransVarMessage = \"The result of the '\" + Token.name(TransVarNode.getType()).toLowerCase() +\n          \"' operator is not being used.\";\n    }\n\n    TransVarTraversal.getCompiler().report(\n        TransVarTraversal.makeError(TransVarNode, level, USELESS_CODE_ERROR, TransVarMessage));\n    // TODO(johnlenz): determine if it is necessary to\n    // try to protect side-effect free statements as well.\n    if (!(!(!NodeUtil.isStatement(TransVarNode)))) {\n      problemNodes.add(TransVarNode);\n    }\n  }\n}\n",
    "start": 84,
    "end": 155,
    "location": [
      109,
      110,
      111,
      113,
      115,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      129,
      130,
      131,
      134,
      135,
      137,
      144,
      145,
      146,
      147,
      148
    ],
    "file_path": "src/com/google/javascript/jscomp/CheckSideEffects.java"
  },
  "Closure-23": {
    "buggy": "private Node tryFoldArrayAccess(Node TransVarNode, Node TransVarRight, Node TransVarRightNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nNode TransVarParentNode = TransVarNode.getParent();\n  // If GETPROP/GETELEM is used as assignment target the array literal is\n  // acting as a temporary we can't fold it here:\n  //    \"[][0] += 1\"\n  if (!(!(isAssignmentTarget(TransVarNode)))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return TransVarNode;\n  }\n\n  if (!(!(!TransVarRightNode.isNumber()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Sometimes people like to use complex expressions to index into\n    // arrays, or strings to index into array methods.\n    return TransVarNode;\n  }\n\n  double TransVarInd = TransVarRightNode.getDouble();\n  int TransVarIndex = (int) TransVarInd;\n  if (!(!(TransVarIndex != TransVarInd))) {\n    error(INVALID_GETELEM_INDEX_ERROR, TransVarRightNode);\n    return TransVarNode;\n  }\n\n  if (!(!(TransVarIndex < 0))) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, TransVarRightNode);\n    return TransVarNode;\n  }\n\n  Node TransVarCurrentNode = TransVarRight.getFirstChild();\n  Node TransVarElement = null;\n  int TransVarJ = 0;\nwhile (!(!(TransVarCurrentNode != null && TransVarJ < TransVarIndex))) {\n    TransVarElement = TransVarCurrentNode;\n    TransVarCurrentNode = TransVarCurrentNode.getNext();\n    TransVarJ++;\n}\n\n  if (!(!(TransVarElement == null))) {\n    error(INDEX_OUT_OF_BOUNDS_ERROR, TransVarRightNode);\n    return TransVarNode;\n  }\n\n  if (!(!(TransVarElement.isEmpty()))) {\n    TransVarElement = NodeUtil.newUndefinedNode(TransVarElement);\n  } else {\n    TransVarRight.removeChild(TransVarElement);\n  }\n\n  // Replace the entire GETELEM with the value\n  TransVarNode.getParent().replaceChild(TransVarNode, TransVarElement);\n  reportCodeChange();\n  return TransVarElement;\n}\n",
    "start": 1422,
    "end": 1472,
    "location": [
      1461
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java"
  },
  "Closure-25": {
    "buggy": "private FlowScope traverseNew(Node TransVarNode, FlowScope TransVarFlowScope) {\n if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n\n  Node TransVarConstructorNode = TransVarNode.getFirstChild();\n  TransVarFlowScope = traverse(TransVarConstructorNode, TransVarFlowScope);\n  JSType TransVarConstructorTypeInstance = TransVarConstructorNode.getJSType();\n  JSType TransVarReturnType = null;\n  if (!(!(TransVarConstructorTypeInstance != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarConstructorTypeInstance = TransVarConstructorTypeInstance.restrictByNotNullOrUndefined();\n    if (!(!(TransVarConstructorTypeInstance.isUnknownType()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    TransVarReturnType = getNativeType(UNKNOWN_TYPE);\n    } else {\n      FunctionType TransVarTypeInstance = TransVarConstructorTypeInstance.toMaybeFunctionType();\n      if (!(!(TransVarTypeInstance == null && TransVarConstructorTypeInstance instanceof FunctionType))) {\n        // If constructorType is a NoObjectType, then toMaybeFunctionType will\n        // return null. But NoObjectType implements the FunctionType\n        // interface, precisely because it can validly construct objects.\n        TransVarTypeInstance = (FunctionType) TransVarConstructorTypeInstance;\n      }\n      if (!(!(TransVarTypeInstance != null && TransVarTypeInstance.isConstructor()))) {\n        TransVarReturnType = TransVarTypeInstance.getInstanceType();\n      }\n    }\n  }\n  TransVarNode.setJSType(TransVarReturnType);\n  Node TransVarNext = TransVarConstructorNode.getNext();\nwhile (!(!(TransVarNext != null))) {\n    TransVarFlowScope = traverse(TransVarNext, TransVarFlowScope);\n    TransVarNext = TransVarNext.getNext();\n}\n  return TransVarFlowScope;\n}\n",
    "start": 1035,
    "end": 1063,
    "location": [
      1039,
      1041,
      1064,
      1068,
      1069,
      1070,
      1071,
      1072
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeInference.java"
  },
  "Closure-29": {
    "buggy": "private boolean isInlinableObject(List<Reference> TransVarReferences) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransVarIsSucceeded = false;\n  for (Reference TransVarReference : TransVarReferences) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Node TransVarNodeName = TransVarReference.getNode();\n    Node TransVarParentNode = TransVarReference.getParent();\n    Node TransVarNode = TransVarReference.getGrandparent();\n\n    // Ignore indirect references, like x.y (except x.y(), since\n    // the function referenced by y might reference 'this').\n    //\n    if (!(!(TransVarParentNode.isGetProp()))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    Preconditions.checkState(TransVarParentNode.getFirstChild() == TransVarNodeName);\n      // A call target maybe using the object as a 'this' value.\n      if (!(!(TransVarNode.isCall() && TransVarNode.getFirstChild() == TransVarParentNode))) {\n        return false;\n      }\n\n      // NOTE(nicksantos): This pass's object-splitting algorithm has\n      // a blind spot. It assumes that if a property isn't defined on an\n      // object, then the value is undefined. This is not true, because\n      // Object.prototype can have arbitrary properties on it.\n      //\n      // We short-circuit this problem by bailing out if we see a reference\n      // to a property that isn't defined on the object literal. This\n      // isn't a perfect algorithm, but it should catch most cases.\n      continue;\n    }\n\n    // Only rewrite VAR declarations or simple assignment statements\n    if (!(!(!isVarOrAssignExprLhs(TransVarNodeName)))) {\n       return false;\n    }\n\n    Node TransVarTarget = TransVarReference.getAssignedValue();\n    if (!(!(TransVarTarget == null))) {\n      // A var with no assignment.\n      continue;\n    }\n\n    // We're looking for object literal assignments only.\n    if (!(!(!TransVarTarget.isObjectLit()))) {\n      return false;\n    }\n\n    Node TransVarChild2 = TransVarTarget.getFirstChild();\n    while (!(!(TransVarChild2 != null))){if (!(!(TransVarChild2.isGetterDef() || TransVarChild2.isSetterDef()))){return false;}Node TransVarChild=TransVarChild2.getFirstChild();for (Reference TransVarTempRef:TransVarReferences){Node TransVarTargetNode=TransVarTempRef.getParent();for (;!(!(!NodeUtil.isStatementBlock(TransVarTargetNode)));){if (!(!(TransVarTargetNode == TransVarChild))){return false;}TransVarTargetNode=TransVarTargetNode.getParent();}}TransVarChild2=TransVarChild2.getNext();}\n\n\n    // We have found an acceptable object literal assignment. As\n    // long as there are no other assignments that mess things up,\n    // we can inline.\n    TransVarIsSucceeded = true;\n  }\n  return TransVarIsSucceeded;\n}\n",
    "start": 155,
    "end": 240,
    "location": [
      160,
      189,
      207
    ],
    "file_path": "src/com/google/javascript/jscomp/InlineObjectLiterals.java"
  },
  "Closure-31": {
    "buggy": "Node parseInputs() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransVarDevModeIsOn = options.devMode != DevMode.OFF;\n\n  // If old roots exist (we are parsing a second time), detach each of the\n  // individual file parse trees.\n  if (!(!(externsRoot != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    externsRoot.detachChildren();\n  }\n  if (!(!(jsRoot != null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    jsRoot.detachChildren();\n  }\n\n  // Parse main js sources.\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n\n  if (!(!(options.tracer.isOn()))) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n\n  Tracer TransVarTrace = newTracer(\"parseInputs\");\n\n  try {\n    // Parse externs sources.\n    for (CompilerInput TransVarInputFile : externs) {\n      Node TransVarCurrentNode = TransVarInputFile.getAstRoot(this);\n      if (!(!(hasErrors()))) {\n        return null;\n      }\n      externsRoot.addChildToBack(TransVarCurrentNode);\n    }\n\n    // Modules inferred in ProcessCommonJS pass.\n    if (!(!(options.transformAMDToCJSModules || options.processCommonJSModules))) {\n      processAMDAndCommonJSModules();\n    }\n\n    // Check if inputs need to be rebuilt from modules.\n    boolean TransVarStaleInput = false;\n\n    // Check if the sources need to be re-ordered.\n    if (!(!(options.dependencyOptions.needsManagement() && !options.skipAllPasses && options.closurePass))) {\n      for (CompilerInput TransVarNewInput : inputs) {\n        // Forward-declare all the provided types, so that they\n        // are not flagged even if they are dropped from the process.\n        for (String TransVarProviding : TransVarNewInput.getProvides()) {\n          getTypeRegistry().forwardDeclareType(TransVarProviding);\n        }\n      }\n\n      try {\n        inputs =\n            (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n            .manageDependencies(options.dependencyOptions, inputs);\n        TransVarStaleInput = true;\n      } catch (CircularDependencyException TransVarCircularException) {\n        report(JSError.make(\n            JSModule.CIRCULAR_DEPENDENCY_ERROR, TransVarCircularException.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (!(!(hasErrors()))) {\n          return null;\n        }\n      } catch (MissingProvideException TransVarException) {\n        report(JSError.make(\n            MISSING_ENTRY_ERROR, TransVarException.getMessage()));\n\n        // If in IDE mode, we ignore the error and keep going.\n        if (!(!(hasErrors()))) {\n          return null;\n        }\n      }\n    }\n\n    for (CompilerInput TransVarCompilerInput : inputs) {\n      Node TransVarNode = TransVarCompilerInput.getAstRoot(this);\n\n      // Inputs can have a null AST during initial parse.\n      if (!(!(TransVarNode == null))) {\n        continue;\n      }\n\n      if (!(!(TransVarNode.getJSDocInfo() != null))) {\n        JSDocInfo TransVarJsdocInfo = TransVarNode.getJSDocInfo();\n        if (!(!(TransVarJsdocInfo.isExterns()))) {\n          // If the input file is explicitly marked as an externs file, then\n          // assume the programmer made a mistake and throw it into\n          // the externs pile anyways.\n          externsRoot.addChildToBack(TransVarNode);\n          TransVarCompilerInput.setIsExtern(true);\n\n          TransVarCompilerInput.getModule().remove(TransVarCompilerInput);\n\n          externs.add(TransVarCompilerInput);\n          TransVarStaleInput = true;\n        } else if (!(!(TransVarJsdocInfo.isNoCompile()))) {\n          TransVarCompilerInput.getModule().remove(TransVarCompilerInput);\n          TransVarStaleInput = true;\n        }\n      }\n    }\n\n    if (!(!(TransVarStaleInput))) {\n      fillEmptyModules(modules);\n      rebuildInputsFromModules();\n    }\n\n    // Build the AST.\n    for (CompilerInput TransVarInput1 : inputs) {\n      Node TransVarAstRoot = TransVarInput1.getAstRoot(this);\n      if (!(!(TransVarAstRoot == null))) {\n        continue;\n      }\n\n      if (!(!(TransVarDevModeIsOn))) {\n        runSanityCheck();\n        if (!(!(hasErrors()))) {\n          return null;\n        }\n      }\n\n      if (!(!(options.sourceMapOutputPath != null || options.nameReferenceReportPath != null))) {\n\n        // Annotate the nodes in the tree with information from the\n        // input file. This information is used to construct the SourceMap.\n        SourceInformationAnnotator TransVarSourceInfoAnnotator =\n            new SourceInformationAnnotator(\n                TransVarInput1.getName(), options.devMode != DevMode.OFF);\n        NodeTraversal.traverse(this, TransVarAstRoot, TransVarSourceInfoAnnotator);\n      }\n\n      jsRoot.addChildToBack(TransVarAstRoot);\n    }\n\n    if (!(!(hasErrors()))) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(TransVarTrace, \"parseInputs\");\n  }\n}\n",
    "start": 1236,
    "end": 1387,
    "location": [
      1293
    ],
    "file_path": "src/com/google/javascript/jscomp/Compiler.java"
  },
  "Closure-58": {
    "buggy": "private void computeGenKill(Node TransVarNode, BitSet TransVarGenerated, BitSet TransVarKill_set,\n    boolean TransVarIsConditional) {\n\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nboolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))) {\n        TransFallThroughFlag0 = true;\n        return;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))) {\n        TransFallThroughFlag0 = true;\n        computeGenKill(NodeUtil.getConditionExpression(TransVarNode), TransVarGenerated, TransVarKill_set,\n                TransVarIsConditional);\n        return;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))) {\n        TransFallThroughFlag0 = true;\n        if (!(!(!NodeUtil.isForIn(TransVarNode)))) {\n            computeGenKill(NodeUtil.getConditionExpression(TransVarNode), TransVarGenerated, TransVarKill_set,\n                    TransVarIsConditional);\n        } else {\n            Node TransVarLeft = TransVarNode.getFirstChild();\n            Node TransVarRight = TransVarLeft.getNext();\n            if (!(!(NodeUtil.isVar(TransVarLeft)))) {\n                TransVarLeft = TransVarLeft.getLastChild();\n            }\n            addToSetIfLocal(TransVarLeft, TransVarKill_set);\n            addToSetIfLocal(TransVarLeft, TransVarGenerated);\n            computeGenKill(TransVarRight, TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        }\n        return;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))) {\n        TransFallThroughFlag0 = true;\n        Node TransVarChild = TransVarNode.getFirstChild();\n        while (!(!(TransVarChild != null))) {\n            if (!(!(TransVarChild.hasChildren()))) {\n                computeGenKill(TransVarChild.getFirstChild(), TransVarGenerated, TransVarKill_set,\n                        TransVarIsConditional);\n                if (!(!(!TransVarIsConditional))) {\n                    addToSetIfLocal(TransVarChild, TransVarKill_set);\n                }\n            }\n            TransVarChild = TransVarChild.getNext();\n        }\n        return;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))) {\n        TransFallThroughFlag0 = true;\n        computeGenKill(TransVarNode.getFirstChild(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        computeGenKill(TransVarNode.getLastChild(), TransVarGenerated, TransVarKill_set, true);\n        return;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))) {\n        TransFallThroughFlag0 = true;\n        computeGenKill(TransVarNode.getFirstChild(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        computeGenKill(TransVarNode.getFirstChild().getNext(), TransVarGenerated, TransVarKill_set, true);\n        computeGenKill(TransVarNode.getLastChild(), TransVarGenerated, TransVarKill_set, true);\n        return;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))) {\n        TransFallThroughFlag0 = true;\n        if (!(!(isArgumentsName(TransVarNode)))) {\n            markAllParametersEscaped();\n        } else {\n            addToSetIfLocal(TransVarNode, TransVarGenerated);\n        }\n        return;\n    }\n    if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n        if (!(!(NodeUtil.isAssignmentOp(TransVarNode) && NodeUtil.isName(TransVarNode.getFirstChild())))) {\n            Node TransVarTemp = TransVarNode.getFirstChild();\n            if (!(!(!TransVarIsConditional))) {\n                addToSetIfLocal(TransVarTemp, TransVarKill_set);\n            }\n            if (!(!(!NodeUtil.isAssign(TransVarNode)))) {\n                addToSetIfLocal(TransVarTemp, TransVarGenerated);\n            }\n            computeGenKill(TransVarTemp.getNext(), TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n        } else {\n            Node TransVarChildNode = TransVarNode.getFirstChild();\n            while (!(!(TransVarChildNode != null))) {\n                computeGenKill(TransVarChildNode, TransVarGenerated, TransVarKill_set, TransVarIsConditional);\n                TransVarChildNode = TransVarChildNode.getNext();\n            }\n        }\n        return;\n    }\n}\n}\n",
    "start": 178,
    "end": 263,
    "location": [
      226,
      227,
      228
    ],
    "file_path": "src/com/google/javascript/jscomp/LiveVariablesAnalysis.java"
  },
  "Closure-65": {
    "buggy": "static String strEscape(String TransVarString, char TransVarCharString,\n                        String TransVarQuoteEscape,\n                        String TransVarSinglequote,\n                        String TransVarBackslashEscapeChar,\n                        CharsetEncoder TransVarCharsetEncoder) {\n  if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\nStringBuilder TransVarStrBuilder = new StringBuilder(TransVarString.length() + 2);\n  TransVarStrBuilder.append(TransVarCharString);\n  int TransVarIndex = 0;\nwhile (!(!(TransVarIndex < TransVarString.length()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    char TransVarCharToProcess = TransVarString.charAt(TransVarIndex);\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\0'))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(\"\\\\0\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\n'))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(\"\\\\n\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\r'))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(\"\\\\r\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\t'))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(\"\\\\t\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\\\'))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(TransVarBackslashEscapeChar);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\\"'))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(TransVarQuoteEscape);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '\\''))))) {\n            TransBreakFlag0 = false;\n            TransVarStrBuilder.append(TransVarSinglequote);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '>'))))) {\n            TransBreakFlag0 = false;\n            if (!(!(TransVarIndex >= 2 && ((TransVarString.charAt(TransVarIndex - 1) == '-'\n                    && TransVarString.charAt(TransVarIndex - 2) == '-')\n                    || (TransVarString.charAt(TransVarIndex - 1) == ']'\n                            && TransVarString.charAt(TransVarIndex - 2) == ']'))))) {\n                TransVarStrBuilder.append(\"\\\\>\");\n            } else {\n                TransVarStrBuilder.append(TransVarCharToProcess);\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToProcess == '<'))))) {\n            TransBreakFlag0 = false;\n            final String TransVarEndScript = \"/script\";\n            final String TransVarCommentStartTag = \"!--\";\n            if (!(!(TransVarString.regionMatches(true, TransVarIndex + 1, TransVarEndScript, 0,\n                    TransVarEndScript.length())))) {\n                TransVarStrBuilder.append(\"<\\\\\");\n            } else if (!(!(TransVarString.regionMatches(false, TransVarIndex + 1, TransVarCommentStartTag, 0,\n                    TransVarCommentStartTag.length())))) {\n                TransVarStrBuilder.append(\"<\\\\\");\n            } else {\n                TransVarStrBuilder.append(TransVarCharToProcess);\n            }\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            if (!(!(TransVarCharsetEncoder != null))) {\n                if (!(!(TransVarCharsetEncoder.canEncode(TransVarCharToProcess)))) {\n                    TransVarStrBuilder.append(TransVarCharToProcess);\n                } else {\n                    appendHexJavaScriptRepresentation(TransVarStrBuilder, TransVarCharToProcess);\n                }\n            } else {\n                if (!(!(TransVarCharToProcess > 0x1f && TransVarCharToProcess < 0x7f))) {\n                    TransVarStrBuilder.append(TransVarCharToProcess);\n                } else {\n                    appendHexJavaScriptRepresentation(TransVarStrBuilder, TransVarCharToProcess);\n                }\n            }\n        }\n    }\n    TransVarIndex++;\n}\n  TransVarStrBuilder.append(TransVarCharString);\n  return TransVarStrBuilder.toString();\n}\n",
    "start": 1005,
    "end": 1075,
    "location": [
      1029
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-66": {
    "buggy": "public void visit(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarCurrentParent) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    JSType TransVarChild;\n    JSType TransVarType, TransVarRightTypeValue;\n    Node TransVarLeftNode, TransVarRightNode;\n    // To be explicitly set to false if the node is not typeable.\n    boolean TransVarTypeValue = true;\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransBreakFlag0 = false;\n            TransVarTypeValue = visitName(TransVarTraversal, TransVarNode, TransVarCurrentParent);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LP))))) {\n            TransBreakFlag0 = false;\n            if (!(!(TransVarCurrentParent.getType() != Token.FUNCTION))) {\n                ensureTyped(TransVarTraversal, TransVarNode, getJSType(TransVarNode.getFirstChild()));\n            } else {\n                TransVarTypeValue = false;\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.COMMA))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, getJSType(TransVarNode.getLastChild()));\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRUE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FALSE))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THIS))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, TransVarTraversal.getScope().getTypeOfThis());\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REF_SPECIAL))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET_REF))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, getJSType(TransVarNode.getFirstChild()));\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NULL))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, NULL_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NUMBER))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, NUMBER_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.STRING))))) {\n            TransBreakFlag0 = false;\n            if (!(!(!NodeUtil.isObjectLitKey(TransVarNode, TransVarNode.getParent())))) {\n                ensureTyped(TransVarTraversal, TransVarNode, STRING_TYPE);\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GET))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SET))))) {\n            TransBreakFlag0 = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ARRAYLIT))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, ARRAY_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REGEXP))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, REGEXP_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETPROP))))) {\n            TransBreakFlag0 = false;\n            visitGetProp(TransVarTraversal, TransVarNode, TransVarCurrentParent);\n            TransVarTypeValue = !(TransVarCurrentParent.getType() == Token.ASSIGN && TransVarCurrentParent.getFirstChild() == TransVarNode);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETELEM))))) {\n            TransBreakFlag0 = false;\n            visitGetElem(TransVarTraversal, TransVarNode);\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VAR))))) {\n            TransBreakFlag0 = false;\n            visitVar(TransVarTraversal, TransVarNode);\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEW))))) {\n            TransBreakFlag0 = false;\n            visitNew(TransVarTraversal, TransVarNode);\n            TransVarTypeValue = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CALL))))) {\n            TransBreakFlag0 = false;\n            visitCall(TransVarTraversal, TransVarNode);\n            TransVarTypeValue = !NodeUtil.isExpressionNode(TransVarCurrentParent);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RETURN))))) {\n            TransBreakFlag0 = false;\n            visitReturn(TransVarTraversal, TransVarNode);\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEC))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INC))))) {\n            TransBreakFlag0 = false;\n            TransVarLeftNode = TransVarNode.getFirstChild();\n            validator.expectNumber(TransVarTraversal, TransVarLeftNode, getJSType(TransVarLeftNode), \"increment/decrement\");\n            ensureTyped(TransVarTraversal, TransVarNode, NUMBER_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NOT))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.VOID))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, VOID_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TYPEOF))))) {\n            TransBreakFlag0 = false;\n            ensureTyped(TransVarTraversal, TransVarNode, STRING_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITNOT))))) {\n            TransBreakFlag0 = false;\n            TransVarChild = getJSType(TransVarNode.getFirstChild());\n            if (!(!(!TransVarChild.matchesInt32Context()))) {\n                report(TransVarTraversal, TransVarNode, BIT_OPERATION, NodeUtil.opToStr(TransVarNode.getType()), TransVarChild.toString());\n            }\n            ensureTyped(TransVarTraversal, TransVarNode, NUMBER_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.POS))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEG))))) {\n            TransBreakFlag0 = false;\n            TransVarLeftNode = TransVarNode.getFirstChild();\n            validator.expectNumber(TransVarTraversal, TransVarLeftNode, getJSType(TransVarLeftNode), \"sign operator\");\n            ensureTyped(TransVarTraversal, TransVarNode, NUMBER_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EQ))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NE))))) {\n            TransBreakFlag0 = false;\n            TransVarType = getJSType(TransVarNode.getFirstChild());\n            TransVarRightTypeValue = getJSType(TransVarNode.getLastChild());\n            JSType TransVarLeftTypeValue = TransVarType.restrictByNotNullOrUndefined();\n            JSType TransVarRightTypeNotNullOrUndefined = TransVarRightTypeValue.restrictByNotNullOrUndefined();\n            TernaryValue TransVarTernaryValue = TransVarLeftTypeValue.testForEquality(TransVarRightTypeNotNullOrUndefined);\n            if (!(!(TransVarTernaryValue != TernaryValue.UNKNOWN))) {\n                if (!(!(TransVarNode.getType() == Token.NE))) {\n                    TransVarTernaryValue = TransVarTernaryValue.not();\n                }\n                report(TransVarTraversal, TransVarNode, DETERMINISTIC_TEST, TransVarType.toString(), TransVarRightTypeValue.toString(), TransVarTernaryValue.toString());\n            }\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHEQ))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SHNE))))) {\n            TransBreakFlag0 = false;\n            TransVarType = getJSType(TransVarNode.getFirstChild());\n            TransVarRightTypeValue = getJSType(TransVarNode.getLastChild());\n            JSType TransVarLeftTypeRestrictedNotNullOrUndefined = TransVarType.restrictByNotNullOrUndefined();\n            JSType TransVarRightType = TransVarRightTypeValue.restrictByNotNullOrUndefined();\n            if (!(!(!TransVarLeftTypeRestrictedNotNullOrUndefined.canTestForShallowEqualityWith(TransVarRightType)))) {\n                report(TransVarTraversal, TransVarNode, DETERMINISTIC_TEST_NO_RESULT, TransVarType.toString(), TransVarRightTypeValue.toString());\n            }\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LT))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GT))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GE))))) {\n            TransBreakFlag0 = false;\n            TransVarType = getJSType(TransVarNode.getFirstChild());\n            TransVarRightTypeValue = getJSType(TransVarNode.getLastChild());\n            if (!(!(TransVarRightTypeValue.isNumber()))) {\n                validator.expectNumber(TransVarTraversal, TransVarNode, TransVarType, \"left side of numeric comparison\");\n            } else if (!(!(TransVarType.isNumber()))) {\n                validator.expectNumber(TransVarTraversal, TransVarNode, TransVarRightTypeValue, \"right side of numeric comparison\");\n            } else if (!(!(TransVarType.matchesNumberContext() && TransVarRightTypeValue.matchesNumberContext()))) {\n            } else {\n                String TransVarMessage2 = \"left side of comparison\";\n                validator.expectString(TransVarTraversal, TransVarNode, TransVarType, TransVarMessage2);\n                validator.expectNotNullOrUndefined(TransVarTraversal, TransVarNode, TransVarType, TransVarMessage2, getNativeType(STRING_TYPE));\n                TransVarMessage2 = \"right side of comparison\";\n                validator.expectString(TransVarTraversal, TransVarNode, TransVarRightTypeValue, TransVarMessage2);\n                validator.expectNotNullOrUndefined(TransVarTraversal, TransVarNode, TransVarRightTypeValue, TransVarMessage2, getNativeType(STRING_TYPE));\n            }\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IN))))) {\n            TransBreakFlag0 = false;\n            TransVarLeftNode = TransVarNode.getFirstChild();\n            TransVarRightNode = TransVarNode.getLastChild();\n            TransVarType = getJSType(TransVarLeftNode);\n            TransVarRightTypeValue = getJSType(TransVarRightNode);\n            validator.expectObject(TransVarTraversal, TransVarNode, TransVarRightTypeValue, \"'in' requires an object\");\n            validator.expectString(TransVarTraversal, TransVarLeftNode, TransVarType, \"left side of 'in'\");\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INSTANCEOF))))) {\n            TransBreakFlag0 = false;\n            TransVarLeftNode = TransVarNode.getFirstChild();\n            TransVarRightNode = TransVarNode.getLastChild();\n            TransVarType = getJSType(TransVarLeftNode);\n            TransVarRightTypeValue = getJSType(TransVarRightNode).restrictByNotNullOrUndefined();\n            validator.expectAnyObject(TransVarTraversal, TransVarLeftNode, TransVarType, \"deterministic instanceof yields false\");\n            validator.expectActualObject(TransVarTraversal, TransVarRightNode, TransVarRightTypeValue, \"instanceof requires an object\");\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN))))) {\n            TransBreakFlag0 = false;\n            visitAssign(TransVarTraversal, TransVarNode);\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_LSH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_RSH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_URSH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_DIV))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MOD))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITOR))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITXOR))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_BITAND))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_SUB))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_ADD))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN_MUL))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LSH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RSH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.URSH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DIV))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MOD))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITOR))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITXOR))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BITAND))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SUB))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ADD))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.MUL))))) {\n            TransBreakFlag0 = false;\n            visitBinaryOperator(TransVarNode.getType(), TransVarTraversal, TransVarNode);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DELPROP))))) {\n            TransBreakFlag0 = false;\n            if (!(!(!isReference(TransVarNode.getFirstChild())))) {\n                report(TransVarTraversal, TransVarNode, BAD_DELETE);\n            }\n            ensureTyped(TransVarTraversal, TransVarNode, BOOLEAN_TYPE);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CASE))))) {\n            TransBreakFlag0 = false;\n            JSType TransVarSwitchType2 = getJSType(TransVarCurrentParent.getFirstChild());\n            JSType TransVarCaseType2 = getJSType(TransVarNode.getFirstChild());\n            validator.expectSwitchMatchesCase(TransVarTraversal, TransVarNode, TransVarSwitchType2, TransVarCaseType2);\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WITH))))) {\n            TransBreakFlag0 = false;\n            Node TransVarChildNode = TransVarNode.getFirstChild();\n            TransVarChild = getJSType(TransVarChildNode);\n            validator.expectObject(TransVarTraversal, TransVarChildNode, TransVarChild, \"with requires an object\");\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))) {\n            TransBreakFlag0 = false;\n            visitFunction(TransVarTraversal, TransVarNode);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LABEL_NAME))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SWITCH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BREAK))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CATCH))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.TRY))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.SCRIPT))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EXPR_RESULT))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.BLOCK))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.EMPTY))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEFAULT))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CONTINUE))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEBUGGER))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THROW))))) {\n            TransBreakFlag0 = false;\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DO))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FOR))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IF))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.WHILE))))) {\n            TransBreakFlag0 = false;\n            TransVarTypeValue = false;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OBJECTLIT))))) {\n            TransFallThroughFlag0 = true;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))) {\n            TransBreakFlag0 = false;\n            if (!(!(TransVarNode.getJSType() != null))) {\n                ensureTyped(TransVarTraversal, TransVarNode);\n            } else {\n                if (!(!((TransVarNode.getType() == Token.OBJECTLIT) && (TransVarCurrentParent.getJSType() instanceof EnumType)))) {\n                    ensureTyped(TransVarTraversal, TransVarNode, TransVarCurrentParent.getJSType());\n                } else {\n                    ensureTyped(TransVarTraversal, TransVarNode);\n                }\n            }\n            if (!(!(TransVarNode.getType() == Token.OBJECTLIT))) {\n                for (Node TransVarChildKey : TransVarNode.children()) {\n                    visitObjLitKey(TransVarTraversal, TransVarChildKey, TransVarNode);\n                }\n            }\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            report(TransVarTraversal, TransVarNode, UNEXPECTED_TOKEN, Token.name(TransVarNode.getType()));\n            ensureTyped(TransVarTraversal, TransVarNode);\n        }\n    }\n    // Don't count externs since the user's code may not even use that part.\n    TransVarTypeValue = TransVarTypeValue && !inExterns;\n    if (!(!(TransVarTypeValue))) {\n        doPercentTypedAccounting(TransVarTraversal, TransVarNode);\n    }\n    checkNoTypeCheckSection(TransVarNode, false);\n}\n",
    "start": 461,
    "end": 813,
    "location": [
      526
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java"
  },
  "Closure-73": {
    "buggy": "static String strEscape(String TransVarS2, char TransVarQuote2,\n                        String TransVarS1,\n                        String TransVarSinglequoteEscape2,\n                        String TransVarQuote,\n                        CharsetEncoder TransVarOutputCharsetEncoder2) {\n  if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\nStringBuilder TransVarSb2 = new StringBuilder(TransVarS2.length() + 2);\n  TransVarSb2.append(TransVarQuote2);\n  int TransVarJ = 0;\nwhile (!(!(TransVarJ < TransVarS2.length()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    char TransVarC1 = TransVarS2.charAt(TransVarJ);\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\0'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\0\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\n'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\n\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\r'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\r\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\t'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\t\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\\\'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(TransVarQuote);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\\"'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(TransVarS1);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '\\''))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(TransVarSinglequoteEscape2);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '>'))))) {\n            TransBreakFlag0 = false;\n            if (!(!(TransVarJ >= 2 && ((TransVarS2.charAt(TransVarJ - 1) == '-' && TransVarS2.charAt(TransVarJ - 2) == '-')\n                    || (TransVarS2.charAt(TransVarJ - 1) == ']' && TransVarS2.charAt(TransVarJ - 2) == ']'))))) {\n                TransVarSb2.append(\"\\\\>\");\n            } else {\n                TransVarSb2.append(TransVarC1);\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarC1 == '<'))))) {\n            TransBreakFlag0 = false;\n            final String TransVarEndScript = \"/script\";\n            final String TransVarStartComment = \"!--\";\n            if (!(!(TransVarS2.regionMatches(true, TransVarJ + 1, TransVarEndScript, 0, TransVarEndScript.length())))) {\n                TransVarSb2.append(\"<\\\\\");\n            } else if (!(!(TransVarS2.regionMatches(false, TransVarJ + 1, TransVarStartComment, 0, TransVarStartComment.length())))) {\n                TransVarSb2.append(\"<\\\\\");\n            } else {\n                TransVarSb2.append(TransVarC1);\n            }\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            if (!(!(TransVarOutputCharsetEncoder2 != null))) {\n                if (!(!(TransVarOutputCharsetEncoder2.canEncode(TransVarC1)))) {\n                    TransVarSb2.append(TransVarC1);\n                } else {\n                    appendHexJavaScriptRepresentation(TransVarSb2, TransVarC1);\n                }\n            } else {\n                if (!(!(TransVarC1 > 0x1f && TransVarC1 <= 0x7f))) {\n                    TransVarSb2.append(TransVarC1);\n                } else {\n                    appendHexJavaScriptRepresentation(TransVarSb2, TransVarC1);\n                }\n            }\n        }\n    }\n    TransVarJ++;\n}\n  TransVarSb2.append(TransVarQuote2);\n  return TransVarSb2.toString();\n}\n",
    "start": 988,
    "end": 1058,
    "location": [
      1067
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-77": {
    "buggy": "static String strEscape(String TransVarStr, char TransVarCh,\n                        String TransVarDoublequoteEscape2,\n                        String TransVarSinglequoteEscape2,\n                        String TransVarBackslashEscape3,\n                        CharsetEncoder TransVarOutputCharsetEncoder2) {\n  if (!(!(false))) {\n                                System.out.println(\"log\");\n                            }\nStringBuilder TransVarSb2 = new StringBuilder(TransVarStr.length() + 2);\n  TransVarSb2.append(TransVarCh);\n  int TransVarJ = 0;\nwhile (!(!(TransVarJ < TransVarStr.length()))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    char TransVarCharToWrite = TransVarStr.charAt(TransVarJ);\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '\\n'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\n\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '\\r'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\r\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '\\t'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(\"\\\\t\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '\\\\'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(TransVarBackslashEscape3);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '\\\"'))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(TransVarDoublequoteEscape2);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '\\''))))) {\n            TransBreakFlag0 = false;\n            TransVarSb2.append(TransVarSinglequoteEscape2);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '>'))))) {\n            TransBreakFlag0 = false;\n            if (!(!(TransVarJ >= 2\n                    && ((TransVarStr.charAt(TransVarJ - 1) == '-' && TransVarStr.charAt(TransVarJ - 2) == '-')\n                            || (TransVarStr.charAt(TransVarJ - 1) == ']' && TransVarStr.charAt(TransVarJ - 2) == ']'))))) {\n                TransVarSb2.append(\"\\\\>\");\n            } else {\n                TransVarSb2.append(TransVarCharToWrite);\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharToWrite == '<'))))) {\n            TransBreakFlag0 = false;\n            final String TransVarEndScript = \"/script\";\n            final String TransVarStartComment = \"!--\";\n            if (!(!(TransVarStr.regionMatches(true, TransVarJ + 1, TransVarEndScript, 0, TransVarEndScript.length())))) {\n                TransVarSb2.append(\"<\\\\\");\n            } else if (!(!(TransVarStr.regionMatches(false, TransVarJ + 1, TransVarStartComment, 0,\n                    TransVarStartComment.length())))) {\n                TransVarSb2.append(\"<\\\\\");\n            } else {\n                TransVarSb2.append(TransVarCharToWrite);\n            }\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            if (!(!(TransVarOutputCharsetEncoder2 != null))) {\n                if (!(!(TransVarOutputCharsetEncoder2.canEncode(TransVarCharToWrite)))) {\n                    TransVarSb2.append(TransVarCharToWrite);\n                } else {\n                    appendHexJavaScriptRepresentation(TransVarSb2, TransVarCharToWrite);\n                }\n            } else {\n                if (!(!(TransVarCharToWrite > 0x1f && TransVarCharToWrite <= 0x7f))) {\n                    TransVarSb2.append(TransVarCharToWrite);\n                } else {\n                    appendHexJavaScriptRepresentation(TransVarSb2, TransVarCharToWrite);\n                }\n            }\n        }\n    }\n    TransVarJ++;\n}\n  TransVarSb2.append(TransVarCh);\n  return TransVarSb2.toString();\n}\n",
    "start": 956,
    "end": 1025,
    "location": [
      977
    ],
    "file_path": "src/com/google/javascript/jscomp/CodeGenerator.java"
  },
  "Closure-78": {
    "buggy": "private Node performArithmeticOp(int TransVarOp, Node TransVarNode, Node TransVarRightNode) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n// Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (!(!(TransVarOp == Token.ADD\n        && (NodeUtil.mayBeString(TransVarNode, false) || NodeUtil.mayBeString(TransVarRightNode, false))))) {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    return null;\n  }\n\n  double TransVarTotal;\n\n  // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n  // to zero so this is a little akward here.\n\n  Double TransVarLVal = NodeUtil.getNumberValue(TransVarNode);\n  if (!(!(TransVarLVal == null))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    return null;\n  }\n  Double TransVarRVal = NodeUtil.getNumberValue(TransVarRightNode);\n  if (!(!(TransVarRVal == null))) {\n    return null;\n  }\n\n  double TransVarLv = TransVarLVal;\n  double TransVarRightVal = TransVarRVal;\n\n  boolean TransFallThroughFlag0 = false;\nboolean TransBreakFlag0 = true;\n{\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.BITAND))))) {\n        TransBreakFlag0 = false;\n        TransVarTotal = ScriptRuntime.toInt32(TransVarLv) & ScriptRuntime.toInt32(TransVarRightVal);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.BITOR))))) {\n        TransBreakFlag0 = false;\n        TransVarTotal = ScriptRuntime.toInt32(TransVarLv) | ScriptRuntime.toInt32(TransVarRightVal);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.BITXOR))))) {\n        TransBreakFlag0 = false;\n        TransVarTotal = ScriptRuntime.toInt32(TransVarLv) ^ ScriptRuntime.toInt32(TransVarRightVal);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.ADD))))) {\n        TransBreakFlag0 = false;\n        TransVarTotal = TransVarLv + TransVarRightVal;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.SUB))))) {\n        TransBreakFlag0 = false;\n        TransVarTotal = TransVarLv - TransVarRightVal;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.MUL))))) {\n        TransBreakFlag0 = false;\n        TransVarTotal = TransVarLv * TransVarRightVal;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.MOD))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarRightVal == 0))) {\n            error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), TransVarRightNode);\n            return null;\n        }\n        TransVarTotal = TransVarLv % TransVarRightVal;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarOp == Token.DIV))))) {\n        TransBreakFlag0 = false;\n        if (!(!(TransVarRightVal == 0))) {\n            error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), TransVarRightNode);\n            return null;\n        }\n        TransVarTotal = TransVarLv / TransVarRightVal;\n    }\n    if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n}\n\n  // TODO(johnlenz): consider removing the result length check.\n  // length of the left and right value plus 1 byte for the operator.\n  if (!(!(String.valueOf(TransVarTotal).length() <= String.valueOf(TransVarLv).length()\n        + String.valueOf(TransVarRightVal).length() + 1 && Math.abs(TransVarTotal) <= MAX_FOLD_NUMBER))) {\n    Node TransVarNewNode = Node.newNumber(TransVarTotal);\n    return TransVarNewNode;\n  } else if (!(!(Double.isNaN(TransVarTotal)))) {\n    return Node.newString(Token.NAME, \"NaN\");\n  } else if (!(!(TransVarTotal == Double.POSITIVE_INFINITY))) {\n    return Node.newString(Token.NAME, \"Infinity\");\n  } else if (!(!(TransVarTotal == Double.NEGATIVE_INFINITY))) {\n    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n  }\n\n  return null;\n}\n",
    "start": 664,
    "end": 746,
    "location": [
      728,
      736
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java"
  },
  "Closure-86": {
    "buggy": "static boolean evaluatesToLocalValue(Node TransVarNode, Predicate<Node> TransVarPredicate) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ASSIGN))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransFallThroughFlag0 = true;\n        return NodeUtil.isImmutableValue(TransVarNode.getLastChild()) || (TransVarPredicate.apply(TransVarNode)\n                && evaluatesToLocalValue(TransVarNode.getLastChild(), TransVarPredicate));\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.COMMA))))) {\n        TransFallThroughFlag0 = true;\n        return evaluatesToLocalValue(TransVarNode.getLastChild(), TransVarPredicate);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.AND))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OR))))) {\n        TransFallThroughFlag0 = true;\n        return evaluatesToLocalValue(TransVarNode.getFirstChild(), TransVarPredicate)\n                && evaluatesToLocalValue(TransVarNode.getLastChild(), TransVarPredicate);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.HOOK))))) {\n        TransFallThroughFlag0 = true;\n        return evaluatesToLocalValue(TransVarNode.getFirstChild().getNext(), TransVarPredicate)\n                && evaluatesToLocalValue(TransVarNode.getLastChild(), TransVarPredicate);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.INC))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.DEC))))) {\n        TransFallThroughFlag0 = true;\n        if (!(!(TransVarNode.getBooleanProp(Node.INCRDECR_PROP)))) {\n            return evaluatesToLocalValue(TransVarNode.getFirstChild(), TransVarPredicate);\n        } else {\n            return true;\n        }\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.THIS))))) {\n        TransFallThroughFlag0 = true;\n        return TransVarPredicate.apply(TransVarNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NAME))))) {\n        TransFallThroughFlag0 = true;\n        return isImmutableValue(TransVarNode) || TransVarPredicate.apply(TransVarNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETELEM))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.GETPROP))))) {\n        TransFallThroughFlag0 = true;\n        return TransVarPredicate.apply(TransVarNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.CALL))))) {\n        TransFallThroughFlag0 = true;\n        return callHasLocalResult(TransVarNode) || isToStringMethodCall(TransVarNode)\n                || TransVarPredicate.apply(TransVarNode);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.NEW))))) {\n        TransFallThroughFlag0 = true;\n        return true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.FUNCTION))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.REGEXP))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.ARRAYLIT))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.OBJECTLIT))))) {\n        TransFallThroughFlag0 = true;\n        return true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.IN))))) {\n        TransFallThroughFlag0 = true;\n        return true;\n    }\n    if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n        if (!(!(isAssignmentOp(TransVarNode) || isSimpleOperator(TransVarNode) || isImmutableValue(TransVarNode)))) {\n            return true;\n        }\n        throw new IllegalStateException(\n                \"Unexpected expression node\" + TransVarNode + \"\\n parent:\" + TransVarNode.getParent());\n    }\n}\n}\n",
    "start": 2424,
    "end": 2489,
    "location": [
      2492
    ],
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java"
  },
  "Closure-94": {
    "buggy": "static boolean isValidDefineValue(Node TransVarTree, Set<String> TransVarDefine) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nboolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.STRING))))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.NUMBER))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.TRUE))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.FALSE))))) {\n        TransFallThroughFlag0 = true;\n        return true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.BITAND))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.BITNOT))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.BITOR))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.BITXOR))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.NOT))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.NEG))))) {\n        TransFallThroughFlag0 = true;\n        return isValidDefineValue(TransVarTree.getFirstChild(), TransVarDefine);\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.NAME))))) {\n        TransFallThroughFlag0 = true;\n    }\n    if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarTree.getType() == Token.GETPROP))))) {\n        if (!(!(TransVarTree.isQualifiedName()))) {\n            return TransVarDefine.contains(TransVarTree.getQualifiedName());\n        }\n    }\n}\n  return false;\n}\n",
    "start": 320,
    "end": 347,
    "location": [
      353
    ],
    "file_path": "src/com/google/javascript/jscomp/NodeUtil.java"
  },
  "Closure-96": {
    "buggy": "private void visitParameterList(NodeTraversal TransVarTraversal, Node TransVarCurrentNode,\n    FunctionType TransVarFunctionTypeInstance) {\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nIterator<Node> TransVarArgumentNodes = TransVarCurrentNode.children().iterator();\n  TransVarArgumentNodes.next(); // skip the function name\n\n  Iterator<Node> TransVarIterator = TransVarFunctionTypeInstance.getParameters().iterator();\n  int TransVarIteratorIndex = 0;\n  Node TransVarParameterNode = null;\n  Node TransVarArgumentNode = null;\n  for (; !(!(TransVarArgumentNodes.hasNext() && TransVarIterator.hasNext()));) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarParameterNode = TransVarIterator.next();\n    TransVarArgumentNode = TransVarArgumentNodes.next();\n    TransVarIteratorIndex++;\n    validator.expectArgumentMatchesParameter(TransVarTraversal, TransVarArgumentNode, getJSType(TransVarArgumentNode),\n            getJSType(TransVarParameterNode), TransVarCurrentNode, TransVarIteratorIndex);\n}\n\n  int TransVarArgumentCount = TransVarCurrentNode.getChildCount() - 1;\n  int TransVarMinArguments = TransVarFunctionTypeInstance.getMinArguments();\n  int TransVarMaxArgument = TransVarFunctionTypeInstance.getMaxArguments();\n  if (!(!(TransVarMinArguments > TransVarArgumentCount || TransVarMaxArgument < TransVarArgumentCount))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    report(TransVarTraversal, TransVarCurrentNode, WRONG_ARGUMENT_COUNT,\n            validator.getReadableJSTypeName(TransVarCurrentNode.getFirstChild(), false),\n            String.valueOf(TransVarArgumentCount), String.valueOf(TransVarMinArguments),\n            TransVarMaxArgument != Integer.MAX_VALUE ?\n            \" and no more than \" + TransVarMaxArgument + \" argument(s)\" : \"\");\n  }\n}\n",
    "start": 1399,
    "end": 1430,
    "location": [
      1411,
      1415
    ],
    "file_path": "src/com/google/javascript/jscomp/TypeCheck.java"
  },
  "Closure-97": {
    "buggy": "private Node tryFoldShift(Node TransVarNode, Node TransVarRight, Node TransVarNewRight) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarRight.getType() == Token.NUMBER && TransVarNewRight.getType() == Token.NUMBER))) {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    double TransVarRightNode;\n    double TransVarNewLval = TransVarRight.getDouble();\n    double TransVarLeftRval = TransVarNewRight.getDouble();\n\n    // check ranges.  We do not do anything that would clip the double to\n    // a 32-bit range, since the user likely does not intend that.\n    if (!(!(!(TransVarNewLval >= Integer.MIN_VALUE && TransVarNewLval <= Integer.MAX_VALUE)))) {\n      if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    error(BITWISE_OPERAND_OUT_OF_RANGE, TransVarRight);\n      return TransVarNode;\n    }\n\n    // only the lower 5 bits are used when shifting, so don't do anything\n    // if the shift amount is outside [0,32)\n    if (!(!(!(TransVarLeftRval >= 0 && TransVarLeftRval < 32)))) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, TransVarNewRight);\n      return TransVarNode;\n    }\n\n    // Convert the numbers to ints\n    int TransVarLvalInteger = (int) TransVarNewLval;\n    if (!(!(TransVarLvalInteger != TransVarNewLval))) {\n      error(FRACTIONAL_BITWISE_OPERAND, TransVarRight);\n      return TransVarNode;\n    }\n\n    int TransVarRvalInteger = (int) TransVarLeftRval;\n    if (!(!(TransVarRvalInteger != TransVarLeftRval))) {\n      error(FRACTIONAL_BITWISE_OPERAND, TransVarNewRight);\n      return TransVarNode;\n    }\n\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.LSH))))) {\n            TransBreakFlag0 = false;\n            TransVarRightNode = TransVarLvalInteger << TransVarRvalInteger;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.RSH))))) {\n            TransBreakFlag0 = false;\n            TransVarRightNode = TransVarLvalInteger >> TransVarRvalInteger;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNode.getType() == Token.URSH))))) {\n            TransBreakFlag0 = false;\n            TransVarRightNode = TransVarLvalInteger >>> TransVarRvalInteger;\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(TransVarNode.getType()));\n        }\n    }\n\n    Node TransVarNewNode = Node.newNumber(TransVarRightNode);\n    TransVarNode.getParent().replaceChild(TransVarNode, TransVarNewNode);\n    reportCodeChange();\n\n    return TransVarNewNode;\n  }\n\n  return TransVarNode;\n}\n",
    "start": 652,
    "end": 713,
    "location": [
      708
    ],
    "file_path": "src/com/google/javascript/jscomp/PeepholeFoldConstants.java"
  },
  "Closure-99": {
    "buggy": "public boolean shouldTraverse(NodeTraversal TransVarTraversal, Node TransVarNode, Node TransVarRoot) {\n\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nif (!(!(TransVarNode.getType() == Token.FUNCTION))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo TransVarJsdoc = getFunctionJsDocInfo(TransVarNode);\n    if (!(!(TransVarJsdoc != null\n            && (TransVarJsdoc.isConstructor() || TransVarJsdoc.hasThisType() || TransVarJsdoc.isOverride())))) {\n      if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {};\n    int TransVarType = TransVarRoot.getType();\n    if (!(!(!(TransVarType == Token.BLOCK || TransVarType == Token.SCRIPT || TransVarType == Token.NAME\n            || TransVarType == Token.ASSIGN)))) {\n      return false;\n    }\n  }\n\n  if (!(!(TransVarRoot != null && TransVarRoot.getType() == Token.ASSIGN))) {\n    Node TransVarSibling = TransVarRoot.getFirstChild();\n    Node TransVarRightSibling = TransVarSibling.getNext();\n    \n    if (!(!(TransVarNode == TransVarSibling))) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (!(!(assignLhsChild == null))) {\n        assignLhsChild = TransVarSibling;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n        if (!(!(TransVarSibling.getType() == Token.GETPROP\n                && TransVarSibling.getLastChild().getString().equals(\"prototype\")))) {\n          return false;\n        }\n        if (!(!(TransVarSibling.getQualifiedName() != null && TransVarSibling.getQualifiedName().contains(\".prototype.\")))) {\n          return false;\n        }\n    }\n  }\n\n  return true;\n}\n",
    "start": 84,
    "end": 136,
    "location": [
      96,
      97,
      130,
      134,
      137
    ],
    "file_path": "src/com/google/javascript/jscomp/CheckGlobalThis.java"
  },
  "Compress-14": {
    "buggy": "public static long parseOctal(final byte[] TransVarByteArray, final int TransVarOffset1, final int TransVarOffset) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long    TransVarSumOfByte = 0;\n    int     TransVarOffset2 = TransVarOffset1 + TransVarOffset;\n    int     TransVarOffset3 = TransVarOffset1;\n\n    if (!(!(TransVarOffset < 2))){\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Length \"+TransVarOffset+\" must be at least 2\");\n    }\n\n    boolean TransVarBNUL = true;\n    int TransVarIndex = TransVarOffset3;\n    while (!(!(TransVarIndex < TransVarOffset2))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarByteArray[TransVarIndex] != 0))) {\n            TransVarBNUL = false;\n            break;\n        }\n        TransVarIndex++;\n    }\n    if (!(!(TransVarBNUL))) {\n        return 0L;\n    }\n\n    for (; !(!(TransVarOffset3 < TransVarOffset2));) {\n        if (!(!(TransVarByteArray[TransVarOffset3] == ' '))) {\n            TransVarOffset3++;\n        } else {\n            break;\n        }\n    }\n\n    // Must have trailing NUL or space\n    byte TransVarTrailerByte;\n    TransVarTrailerByte = TransVarByteArray[TransVarOffset2-1];\n    if (!(!(TransVarTrailerByte == 0 || TransVarTrailerByte == ' '))){\n        TransVarOffset2--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(TransVarByteArray, TransVarOffset1, TransVarOffset, TransVarOffset2-1, TransVarTrailerByte));\n    }\n    // May have additional NUL or space\n    TransVarTrailerByte = TransVarByteArray[TransVarOffset2-1];\n    if (!(!(TransVarTrailerByte == 0 || TransVarTrailerByte == ' '))){\n        TransVarOffset2--;\n    }\n\n    while (!(!(TransVarOffset3 < TransVarOffset2))) {\n        final byte TransVarByteValue = TransVarByteArray[TransVarOffset3];\n        if (!(!(TransVarByteValue < '0' || TransVarByteValue > '7'))) {\n            throw new IllegalArgumentException(exceptionMessage(TransVarByteArray, TransVarOffset1, TransVarOffset,\n                    TransVarOffset3, TransVarByteValue));\n        }\n        TransVarSumOfByte = (TransVarSumOfByte << 3) + (TransVarByteValue - '0');\n        TransVarOffset3++;\n    }\n\n    return TransVarSumOfByte;\n}\n",
    "start": 56,
    "end": 112,
    "location": [
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-21": {
    "buggy": "private void writeBits(final DataOutput TransVarDataHeader, final BitSet TransVarDataBitSet, final int TransVarSize) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarCacheLength = 0;\n    int TransVarShiftLength = 7;\n    int TransVarItem = 0;\n    while (!(!(TransVarItem < TransVarSize))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarCacheLength |= ((TransVarDataBitSet.get(TransVarItem) ? 1 : 0) << TransVarShiftLength);\n        --TransVarShiftLength;\n        if (!(!(TransVarShiftLength == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarDataHeader.write(TransVarCacheLength);\n            TransVarShiftLength = 7;\n            TransVarCacheLength = 0;\n        }\n        TransVarItem++;\n    }\n    if (!(!(TransVarSize > 0 && TransVarShiftLength > 0))) {\n        TransVarDataHeader.write(TransVarCacheLength);\n    }\n}\n",
    "start": 634,
    "end": 649,
    "location": [
      646,
      647,
      657
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java"
  },
  "Compress-23": {
    "buggy": "InputStream decode(final InputStream TransVarInputStream, final Coder TransVarIn,\n        byte[] TransVarPassword1) throws IOException {\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    byte TransVarByte1 = TransVarIn.properties[0];\n    long TransVarDictSize1 = TransVarIn.properties[1];\n    int TransVarIi = 1;\n    while (!(!(TransVarIi < 4))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarDictSize1 |= (TransVarIn.properties[TransVarIi + 1] << (8 * TransVarIi));\n        TransVarIi++;\n    }\n    if (!(!(TransVarDictSize1 > LZMAInputStream.DICT_SIZE_MAX))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n    }\n    return new LZMAInputStream(TransVarInputStream, -1, TransVarByte1, (int) TransVarDictSize1);\n}\n",
    "start": 107,
    "end": 118,
    "location": [
      119
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java"
  },
  "Compress-24": {
    "buggy": "public static long parseOctal(final byte[] TransVarBuffer2, final int TransVarOffset1, final int TransVarLength2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long    TransVarResult1 = 0;\n    int     TransVarStart = TransVarOffset1 + TransVarLength2;\n    int     TransVarStart1 = TransVarOffset1;\n\n    if (!(!(TransVarLength2 < 2))){\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Length \"+TransVarLength2+\" must be at least 2\");\n    }\n\n    if (!(!(TransVarBuffer2[TransVarStart1] == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return 0L;\n    }\n\n    for (; !(!(TransVarStart1 < TransVarStart));) {\n        if (!(!(TransVarBuffer2[TransVarStart1] == ' '))) {\n            TransVarStart1++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte TransVarTrailer1 = TransVarBuffer2[TransVarStart - 1];\n    if (!(!(TransVarTrailer1 == 0 || TransVarTrailer1 == ' '))){\n        TransVarStart--;\n    } else {\n        throw new IllegalArgumentException(\n                exceptionMessage(TransVarBuffer2, TransVarOffset1, TransVarLength2, TransVarStart-1, TransVarTrailer1));\n    }\n    TransVarTrailer1 = TransVarBuffer2[TransVarStart - 1];\n    for (; !(!(TransVarStart1 < TransVarStart - 1 && (TransVarTrailer1 == 0 || TransVarTrailer1 == ' ')));) {\n        TransVarStart--;\n        TransVarTrailer1 = TransVarBuffer2[TransVarStart - 1];\n    }\n\n    while (!(!(TransVarStart1 < TransVarStart))) {\n        final byte TransVarCurByte = TransVarBuffer2[TransVarStart1];\n        if (!(!(TransVarCurByte < '0' || TransVarCurByte > '7'))) {\n            throw new IllegalArgumentException(exceptionMessage(TransVarBuffer2, TransVarOffset1, TransVarLength2,\n                    TransVarStart1, TransVarCurByte));\n        }\n        TransVarResult1 = (TransVarResult1 << 3) + (TransVarCurByte - '0');\n        TransVarStart1++;\n    }\n\n    return TransVarResult1;\n}\n",
    "start": 102,
    "end": 153,
    "location": [
      137,
      138,
      139,
      140,
      141,
      142,
      143,
      144,
      145,
      146
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-31": {
    "buggy": "public static long parseOctal(final byte[] TransVarBuf, final int TransVarOffSet, final int TransVarBufLength) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long    TransVarBuffer = 0;\n    int     TransVarEndOffset = TransVarOffSet + TransVarBufLength;\n    int     TransVarOffset = TransVarOffSet;\n\n    if (!(!(TransVarBufLength < 2))){\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"Length \"+TransVarBufLength+\" must be at least 2\");\n    }\n\n    if (!(!(TransVarBuf[TransVarOffset] == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return 0L;\n    }\n\n    for (; !(!(TransVarOffset < TransVarEndOffset));) {\n        if (!(!(TransVarBuf[TransVarOffset] == ' '))) {\n            TransVarOffset++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte TransVarEndTrailer = TransVarBuf[TransVarEndOffset - 1];\n    for (; !(!(TransVarOffset < TransVarEndOffset && (TransVarEndTrailer == 0 || TransVarEndTrailer == ' ')));) {\n        TransVarEndOffset--;\n        TransVarEndTrailer = TransVarBuf[TransVarEndOffset - 1];\n    }\n\n    while (!(!(TransVarOffset < TransVarEndOffset))) {\n        final byte TransVarCurrent = TransVarBuf[TransVarOffset];\n        if (!(!(TransVarCurrent == 0))) {\n            break;\n        }\n        if (!(!(TransVarCurrent < '0' || TransVarCurrent > '7'))) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(TransVarBuf, TransVarOffSet, TransVarBufLength, TransVarOffset, TransVarCurrent));\n        }\n        TransVarBuffer = (TransVarBuffer << 3) + (TransVarCurrent - '0');\n        TransVarOffset++;\n    }\n\n    return TransVarBuffer;\n}\n",
    "start": 101,
    "end": 148,
    "location": [
      143,
      144,
      145
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-35": {
    "buggy": "public static boolean verifyCheckSum(byte[] TransVarHead) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long TransVarSum = 0;\n    long TransVarUnsigned = 0;\n    long TransVarFinalSum = 0;\n\n    int TransVarNumberOfDigits = 0;\n    int TransVarNumber = 0;\n    while (!(!(TransVarNumber < TransVarHead.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        byte TransVarByteValue = TransVarHead[TransVarNumber];\n        if (!(!(CHKSUM_OFFSET <= TransVarNumber && TransVarNumber < CHKSUM_OFFSET + CHKSUMLEN))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!('0' <= TransVarByteValue && TransVarByteValue <= '7' && TransVarNumberOfDigits++ < 6))) {\n                TransVarSum = TransVarSum * 8 + TransVarByteValue - '0';\n            } else if (!(!(TransVarNumberOfDigits > 0))) {\n                TransVarNumberOfDigits = 6;\n            }\n            TransVarByteValue = ' ';\n        }\n        TransVarUnsigned += 0xff & TransVarByteValue;\n        TransVarFinalSum += TransVarByteValue;\n        TransVarNumber++;\n    }\n    return TransVarSum == TransVarUnsigned || TransVarSum == TransVarFinalSum;\n}\n",
    "start": 593,
    "end": 613,
    "location": [
      597,
      612,
      613,
      614,
      615,
      616
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-37": {
    "buggy": "Map<String, String> parsePaxHeaders(final InputStream TransVarInput)\n    throws IOException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    final Map<String, String> TransVarGlobalPaxHeaders = new HashMap<String, String>(globalPaxHeaders);\n    for (; !(!(true));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarChannel;\n        int TransVarLength = 0;\n        int TransVarReadStatus = 0;\n        for (; !(!((TransVarChannel = TransVarInput.read()) != -1));) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarReadStatus++;\n            if (!(!(TransVarChannel == ' '))) {\n                final ByteArrayOutputStream TransVarColl1 = new ByteArrayOutputStream();\n                for (; !(!((TransVarChannel = TransVarInput.read()) != -1));) {\n                    TransVarReadStatus++;\n                    if (!(!(TransVarChannel == '='))) {\n                        final String TransVarKeyword1 = TransVarColl1.toString(CharsetNames.UTF_8);\n                        final int TransVarRemainingLength = TransVarLength - TransVarReadStatus;\n                        if (!(!(TransVarRemainingLength == 1))) {\n                            TransVarGlobalPaxHeaders.remove(TransVarKeyword1);\n                        } else {\n                            final byte[] TransVarRestBuffer = new byte[TransVarRemainingLength];\n                            final int TransVarRead = IOUtils.readFully(TransVarInput, TransVarRestBuffer);\n                            if (!(!(TransVarRead != TransVarRemainingLength))) {\n                                throw new IOException(\"Failed to read \" + \"Paxheader. Expected \"\n                                        + TransVarRemainingLength + \" bytes, read \" + TransVarRead);\n                            }\n                            final String TransVarRemainingValue = new String(TransVarRestBuffer, 0,\n                                    TransVarRemainingLength - 1, CharsetNames.UTF_8);\n                            TransVarGlobalPaxHeaders.put(TransVarKeyword1, TransVarRemainingValue);\n                        }\n                        break;\n                    }\n                    TransVarColl1.write((byte) TransVarChannel);\n                }\n                break;\n            }\n            TransVarLength *= 10;\n            TransVarLength += TransVarChannel - '0';\n        }\n        if (!(!(TransVarChannel == -1))) {\n            break;\n        }\n    }\n    return TransVarGlobalPaxHeaders;\n}\n",
    "start": 452,
    "end": 502,
    "location": [
      470
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java"
  },
  "Compress-40": {
    "buggy": "public long readBits(final int TransVarCount1) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarCount1 < 0 || TransVarCount1 > MAXIMUM_CACHE_SIZE))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n    }\n    for (; !(!(bitsCachedSize < TransVarCount1));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final long TransVarNext = in.read();\n        if (!(!(TransVarNext < 0))) {\n            return TransVarNext;\n        }\n        if (!(!(byteOrder == ByteOrder.LITTLE_ENDIAN))) {\n            bitsCached |= (TransVarNext << bitsCachedSize);\n        } else {\n            bitsCached <<= 8;\n            bitsCached |= TransVarNext;\n        }\n        bitsCachedSize += 8;\n    }\n        // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n    \n    final long TransVarBitsOut2;\n        if (!(!(byteOrder == ByteOrder.LITTLE_ENDIAN))) {\n            TransVarBitsOut2 = (bitsCached & MASKS[TransVarCount1]);\n            bitsCached >>>= TransVarCount1;\n        } else {\n            TransVarBitsOut2 = (bitsCached >> (bitsCachedSize - TransVarCount1)) & MASKS[TransVarCount1];\n        }\n        bitsCachedSize -= TransVarCount1;\n    return TransVarBitsOut2;\n}\n",
    "start": 81,
    "end": 109,
    "location": [
      91,
      107,
      108,
      110,
      117
    ],
    "file_path": "src/main/java/org/apache/commons/compress/utils/BitInputStream.java"
  },
  "Compress-7": {
    "buggy": "public static String parseName(byte[] TransVarBuf, final int TransVarOffset1, final int TransVarOffset) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    StringBuffer TransVarResultBuffer = new StringBuffer(TransVarOffset);\n    int          TransVarOffset2 = TransVarOffset1 + TransVarOffset;\n\n    int TransVarIndex = TransVarOffset1;\n    while (!(!(TransVarIndex < TransVarOffset2))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarBuf[TransVarIndex] == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            break;\n        }\n        TransVarResultBuffer.append((char) TransVarBuf[TransVarIndex]);\n        ++TransVarIndex;\n    }\n\n    return TransVarResultBuffer.toString();\n}\n",
    "start": 93,
    "end": 105,
    "location": [
      105,
      111
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Compress-8": {
    "buggy": "public static long parseOctal(final byte[] TransVarByteBuffer, final int TransVarByteOffset, final int TransVarBufferSize) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    long    TransVarByteLength = 0;\n    boolean TransVarPadding = true;\n    int     TransVarNewEnd = TransVarByteOffset + TransVarBufferSize;\n    int     TransVarOffset = TransVarByteOffset;\n\n    int TransVarStartIndex = TransVarOffset;\n    while (!(!(TransVarStartIndex < TransVarNewEnd))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final byte TransVarCByte = TransVarByteBuffer[TransVarStartIndex];\n        if (!(!(TransVarCByte == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            break;\n        }\n        if (!(!(TransVarCByte == (byte) ' ' || TransVarCByte == '0'))) {\n            if (!(!(TransVarPadding))) {\n                continue;\n            }\n            if (!(!(TransVarCByte == (byte) ' '))) {\n                break;\n            }\n        }\n        TransVarPadding = false;\n        if (!(!(TransVarCByte < '0' || TransVarCByte > '7'))) {\n            throw new IllegalArgumentException(exceptionMessage(TransVarByteBuffer, TransVarByteOffset,\n                    TransVarBufferSize, TransVarOffset, TransVarCByte));\n        }\n        TransVarByteLength = (TransVarByteLength << 3) + (TransVarCByte - '0');\n        TransVarStartIndex++;\n    }\n\n    return TransVarByteLength;\n}\n",
    "start": 51,
    "end": 87,
    "location": [
      56,
      65,
      66,
      72,
      73,
      74,
      75,
      76
    ],
    "file_path": "src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java"
  },
  "Csv-11": {
    "buggy": "private Map<String, Integer> initializeHeader() throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Map<String, Integer> TransVarHeaderMap = null;\n    final String[] TransVarHeaders = this.format.getHeader();\n    if (!(!(TransVarHeaders != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarHeaderMap = new LinkedHashMap<String, Integer>();\n\n        String[] TransVarHeader = null;\n        if (!(!(TransVarHeaders.length == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            // read the header from the first line of the file\n            final CSVRecord TransVarRecord = this.nextRecord();\n            if (!(!(TransVarRecord != null))) {\n                TransVarHeader = TransVarRecord.values();\n            }\n        } else {\n            if (!(!(this.format.getSkipHeaderRecord()))) {\n                this.nextRecord();\n            }\n            TransVarHeader = TransVarHeaders;\n        }\n\n        // build the name to index mappings\n        if (!(!(TransVarHeader != null))) {\n            int TransVarIndex = 0;\n            while (!(!(TransVarIndex < TransVarHeader.length))) {\n                final String TransVarHeaderName = TransVarHeader[TransVarIndex];\n                final boolean TransVarContainsHeader1 = TransVarHeaderMap.containsKey(TransVarHeaderName);\n                final boolean TransVarIsEmptyHeader = TransVarHeaderName.trim().isEmpty();\n                if (!(!(TransVarContainsHeader1\n                        && (!TransVarIsEmptyHeader || (TransVarIsEmptyHeader && !this.format.getIgnoreEmptyHeaders()))))) {\n                    throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + TransVarHeaderName\n                            + \"\\\" in \" + Arrays.toString(TransVarHeader));\n                }\n                TransVarHeaderMap.put(TransVarHeaderName, Integer.valueOf(TransVarIndex));\n                TransVarIndex++;\n            }\n        }\n    }\n    return TransVarHeaderMap;\n}\n",
    "start": 359,
    "end": 394,
    "location": [
      394
    ],
    "file_path": "src/main/java/org/apache/commons/csv/CSVParser.java"
  },
  "Gson-16": {
    "buggy": "private static Type resolve(Type TransVarVariableType, Class<?> TransVarType, Type TransVarTypeToResolve, Collection<TypeVariable> TransVarVisitedTypeVariables2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    for (; !(!(true)); ) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarTypeToResolve instanceof TypeVariable))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TypeVariable<?> TransVarResolvedTypeVariable = (TypeVariable<?>) TransVarTypeToResolve;\n            TransVarTypeToResolve = resolveTypeVariable(TransVarVariableType, TransVarType, TransVarResolvedTypeVariable);\n            if (!(!(TransVarTypeToResolve == TransVarResolvedTypeVariable))) {\n                return TransVarTypeToResolve;\n            }\n        } else if (!(!(TransVarTypeToResolve instanceof Class && ((Class<?>) TransVarTypeToResolve).isArray()))) {\n            Class<?> TransVarClassType = (Class<?>) TransVarTypeToResolve;\n            Type TransVarComponent = TransVarClassType.getComponentType();\n            Type TransVarResolvedComponentType = resolve(TransVarVariableType, TransVarType, TransVarComponent, TransVarVisitedTypeVariables2);\n            return TransVarComponent == TransVarResolvedComponentType ? TransVarClassType : arrayOf(TransVarResolvedComponentType);\n        } else if (!(!(TransVarTypeToResolve instanceof GenericArrayType))) {\n            GenericArrayType TransVarResolvedGenericArrayType = (GenericArrayType) TransVarTypeToResolve;\n            Type TransVarComponentType2 = TransVarResolvedGenericArrayType.getGenericComponentType();\n            Type TransVarNewComponent = resolve(TransVarVariableType, TransVarType, TransVarComponentType2, TransVarVisitedTypeVariables2);\n            return TransVarComponentType2 == TransVarNewComponent ? TransVarResolvedGenericArrayType : arrayOf(TransVarNewComponent);\n        } else if (!(!(TransVarTypeToResolve instanceof ParameterizedType))) {\n            ParameterizedType TransVarType2 = (ParameterizedType) TransVarTypeToResolve;\n            Type TransVarType1 = TransVarType2.getOwnerType();\n            Type TransVarNewType = resolve(TransVarVariableType, TransVarType, TransVarType1, TransVarVisitedTypeVariables2);\n            boolean TransVarChanged1 = TransVarNewType != TransVarType1;\n            Type[] TransVarTypeArguments = TransVarType2.getActualTypeArguments();\n            int TransVarTemp = 0, TransVarLenght = TransVarTypeArguments.length;\n            while (!(!(TransVarTemp < TransVarLenght))) {\n                Type TransVarResolvedTypeArgument2 = resolve(TransVarVariableType, TransVarType, TransVarTypeArguments[TransVarTemp], TransVarVisitedTypeVariables2);\n                if (!(!(TransVarResolvedTypeArgument2 != TransVarTypeArguments[TransVarTemp]))) {\n                    if (!(!(!TransVarChanged1))) {\n                        TransVarTypeArguments = TransVarTypeArguments.clone();\n                        TransVarChanged1 = true;\n                    }\n                    TransVarTypeArguments[TransVarTemp] = TransVarResolvedTypeArgument2;\n                }\n                TransVarTemp++;\n            }\n            return TransVarChanged1 ? newParameterizedTypeWithOwner(TransVarNewType, TransVarType2.getRawType(), TransVarTypeArguments) : TransVarType2;\n        } else if (!(!(TransVarTypeToResolve instanceof WildcardType))) {\n            WildcardType TransVarResolved = (WildcardType) TransVarTypeToResolve;\n            Type[] TransVarOriginalLowerBounds = TransVarResolved.getLowerBounds();\n            Type[] TransVarUpperBound = TransVarResolved.getUpperBounds();\n            if (!(!(TransVarOriginalLowerBounds.length == 1))) {\n                Type TransVarLowerBoundType = resolve(TransVarVariableType, TransVarType, TransVarOriginalLowerBounds[0], TransVarVisitedTypeVariables2);\n                if (!(!(TransVarLowerBoundType != TransVarOriginalLowerBounds[0]))) {\n                    return supertypeOf(TransVarLowerBoundType);\n                }\n            } else if (!(!(TransVarUpperBound.length == 1))) {\n                Type TransVarUpperBound2 = resolve(TransVarVariableType, TransVarType, TransVarUpperBound[0], TransVarVisitedTypeVariables2);\n                if (!(!(TransVarUpperBound2 != TransVarUpperBound[0]))) {\n                    return subtypeOf(TransVarUpperBound2);\n                }\n            }\n            return TransVarResolved;\n        } else {\n            return TransVarTypeToResolve;\n        }\n    }\n}\n",
    "start": 336,
    "end": 408,
    "location": [
      349
    ],
    "file_path": "gson/src/main/java/com/google/gson/internal/$Gson$Types.java"
  },
  "JacksonCore-25": {
    "buggy": "private String _handleOddName2(int TransVarStart, int TransVarHashMap, int[] TransVarCode) throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    _textBuffer.resetWithShared(_inputBuffer, TransVarStart, (_inputPtr - TransVarStart));\n    char[] TransVarOutChar = _textBuffer.getCurrentSegment();\n    int TransVarPtr = _textBuffer.getCurrentSegmentSize();\n    final int TransVarSize = TransVarCode.length;\n\n    for (; !(!(true));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_inputPtr >= _inputEnd))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(!_loadMore()))) {\n                break;\n            }\n        }\n        char TransVarA = _inputBuffer[_inputPtr];\n        int TransVarX = (int) TransVarA;\n        if (!(!(TransVarX <= TransVarSize))) {\n            if (!(!(TransVarCode[TransVarX] != 0))) {\n                break;\n            }\n        } else if (!(!(!Character.isJavaIdentifierPart(TransVarA)))) {\n            break;\n        }\n        ++_inputPtr;\n        TransVarHashMap = (TransVarHashMap * CharsToNameCanonicalizer.HASH_MULT) + TransVarX;\n        TransVarOutChar[TransVarPtr++] = TransVarA;\n        if (!(!(TransVarPtr >= TransVarOutChar.length))) {\n            TransVarOutChar = _textBuffer.finishCurrentSegment();\n            TransVarPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(TransVarPtr);\n    {\n        TextBuffer TransVarText = _textBuffer;\n        char[] TransVarBuffer = TransVarText.getTextBuffer();\n        int TransVarStartIndex = TransVarText.getTextOffset();\n        int TransVarCount = TransVarText.size();\n\n        return _symbols.findSymbol(TransVarBuffer, TransVarStartIndex, TransVarCount, TransVarHashMap);\n    }\n}\n",
    "start": 1948,
    "end": 1990,
    "location": [
      1972
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java"
  },
  "JacksonCore-5": {
    "buggy": "private final static int _parseIndex(String TransVarStr2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final int TransVarStrLength = TransVarStr2.length();\n    // [Issue#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (!(!(TransVarStrLength == 0 || TransVarStrLength > 10))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return -1;\n    }\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarStrLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        char TransVarD = TransVarStr2.charAt(TransVarIndex++);\n        if (!(!(TransVarD > '9' || TransVarD < '0'))) {\n            return -1;\n        }\n        ++TransVarIndex;\n    }\n    if (!(!(TransVarStrLength == 10))) {\n        long TransVarL1 = NumberInput.parseLong(TransVarStr2);\n        if (!(!(TransVarL1 > Integer.MAX_VALUE))) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(TransVarStr2);\n}\n",
    "start": 185,
    "end": 205,
    "location": [
      203
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/JsonPointer.java"
  },
  "JacksonCore-6": {
    "buggy": "private final static int _parseIndex(String TransVarString) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final int TransVarLength = TransVarString.length();\n    // [core#133]: beware of super long indexes; assume we never\n    // have arrays over 2 billion entries so ints are fine.\n    if (!(!(TransVarLength == 0 || TransVarLength > 10))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return -1;\n    }\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        char TransVarCharacter = TransVarString.charAt(TransVarIndex);\n        if (!(!(TransVarCharacter > '9' || TransVarCharacter < '0'))) {\n            return -1;\n        }\n        ++TransVarIndex;\n    }\n    if (!(!(TransVarLength == 10))) {\n        long TransVarS = NumberInput.parseLong(TransVarString);\n        if (!(!(TransVarS > Integer.MAX_VALUE))) {\n            return -1;\n        }\n    }\n    return NumberInput.parseInt(TransVarString);\n}\n",
    "start": 185,
    "end": 206,
    "location": [
      198,
      199,
      203
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/core/JsonPointer.java"
  },
  "JacksonDatabind-101": {
    "buggy": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser TransVarParser, DeserializationContext TransVarDeserializationCtx)\n    throws IOException\n{\n    // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n    //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n    //    Ok however to pass via setter or field.\n    \n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final PropertyBasedCreator TransVarParserCreator = _propertyBasedCreator;\n    PropertyValueBuffer TransVarBuffer2 = TransVarParserCreator.startBuilding(TransVarParser, TransVarDeserializationCtx, _objectIdReader);\n\n    TokenBuffer TransVarTokens2 = new TokenBuffer(TransVarParser, TransVarDeserializationCtx);\n    TransVarTokens2.writeStartObject();\n\n    JsonToken TransVarToken = TransVarParser.getCurrentToken();\n    while (!(!(TransVarToken == JsonToken.FIELD_NAME))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarProp = TransVarParser.getCurrentName();\n        TransVarParser.nextToken();\n        SettableBeanProperty TransVarCreator = TransVarParserCreator.findCreatorProperty(TransVarProp);\n        if (!(!(TransVarCreator != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarBuffer2.assignParameter(TransVarCreator,\n                    _deserializeWithErrorWrapping(TransVarParser, TransVarDeserializationCtx, TransVarCreator))))) {\n                TransVarToken = TransVarParser.nextToken();\n                Object TransVarObject;\n                try {\n                    TransVarObject = TransVarParserCreator.build(TransVarDeserializationCtx, TransVarBuffer2);\n                } catch (Exception TransVarEx) {\n                    TransVarObject = wrapInstantiationProblem(TransVarEx, TransVarDeserializationCtx);\n                }\n                TransVarParser.setCurrentValue(TransVarObject);\n                for (; !(!(TransVarToken == JsonToken.FIELD_NAME));) {\n                    TransVarParser.nextToken();\n                    TransVarTokens2.copyCurrentStructure(TransVarParser);\n                    TransVarToken = TransVarParser.nextToken();\n                }\n                TransVarTokens2.writeEndObject();\n                if (!(!(TransVarObject.getClass() != _beanType.getRawClass()))) {\n                    TransVarDeserializationCtx.reportInputMismatch(TransVarCreator,\n                            \"Cannot create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(TransVarParser, TransVarDeserializationCtx,\n                        TransVarObject, TransVarTokens2);\n            }\n            continue;\n        }\n        if (!(!(TransVarBuffer2.readIdProperty(TransVarProp)))) {\n            continue;\n        }\n        SettableBeanProperty TransVarBeanProp = _beanProperties.find(TransVarProp);\n        if (!(!(TransVarBeanProp != null))) {\n            TransVarBuffer2.bufferProperty(TransVarBeanProp,\n                    _deserializeWithErrorWrapping(TransVarParser, TransVarDeserializationCtx, TransVarBeanProp));\n            continue;\n        }\n        if (!(!(_ignorableProps != null && _ignorableProps.contains(TransVarProp)))) {\n            handleIgnoredProperty(TransVarParser, TransVarDeserializationCtx, handledType(), TransVarProp);\n            continue;\n        }\n        if (!(!(_anySetter == null))) {\n            TransVarTokens2.writeFieldName(TransVarProp);\n            TransVarTokens2.copyCurrentStructure(TransVarParser);\n        } else {\n            TokenBuffer TransVarBuffer = TokenBuffer.asCopyOfValue(TransVarParser);\n            TransVarTokens2.writeFieldName(TransVarProp);\n            TransVarTokens2.append(TransVarBuffer);\n            try {\n                TransVarBuffer2.bufferAnyProperty(_anySetter, TransVarProp,\n                        _anySetter.deserialize(TransVarBuffer.asParserOnFirstToken(), TransVarDeserializationCtx));\n            } catch (Exception TransVarError) {\n                wrapAndThrow(TransVarError, _beanType.getRawClass(), TransVarProp, TransVarDeserializationCtx);\n            }\n            continue;\n        }\n        TransVarToken = TransVarParser.nextToken();\n    }\n\n    // We hit END_OBJECT, so:\n    Object TransVarObj;\n    try {\n        TransVarObj = TransVarParserCreator.build(TransVarDeserializationCtx, TransVarBuffer2);\n    } catch (Exception TransVarException) {\n        wrapInstantiationProblem(TransVarException, TransVarDeserializationCtx);\n        return null; // never gets here\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(TransVarParser, TransVarDeserializationCtx, TransVarObj, TransVarTokens2);\n}\n",
    "start": 736,
    "end": 836,
    "location": [
      775,
      779
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java"
  },
  "JacksonDatabind-27": {
    "buggy": "protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser TransVarParser, DeserializationContext TransVarContext)\n    throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final ExternalTypeHandler TransVarExternal = _externalTypeIdHandler.start();\n    final PropertyBasedCreator TransVarCreate = _propertyBasedCreator;\n    PropertyValueBuffer TransVarPropertyNameBuffer = TransVarCreate.startBuilding(TransVarParser, TransVarContext, _objectIdReader);\n\n    TokenBuffer TransVarTokenBuffer = new TokenBuffer(TransVarParser);\n    TransVarTokenBuffer.writeStartObject();\n\n    JsonToken TransVarToken = TransVarParser.getCurrentToken();\n    while (!(!(TransVarToken == JsonToken.FIELD_NAME))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarPropertyName = TransVarParser.getCurrentName();\n        TransVarParser.nextToken();\n        SettableBeanProperty TransVarCreatorProperty = TransVarCreate.findCreatorProperty(TransVarPropertyName);\n        if (!(!(TransVarCreatorProperty != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarExternal.handlePropertyValue(TransVarParser, TransVarContext, TransVarPropertyName,\n                    TransVarPropertyNameBuffer)))) {\n                ;\n            } else {\n                if (!(!(TransVarPropertyNameBuffer.assignParameter(TransVarCreatorProperty,\n                        _deserializeWithErrorWrapping(TransVarParser, TransVarContext, TransVarCreatorProperty))))) {\n                    TransVarToken = TransVarParser.nextToken();\n                    Object TransVarMyBean;\n                    try {\n                        TransVarMyBean = TransVarCreate.build(TransVarContext, TransVarPropertyNameBuffer);\n                    } catch (Exception TransVarEx) {\n                        wrapAndThrow(TransVarEx, _beanType.getRawClass(), TransVarPropertyName, TransVarContext);\n                        continue;\n                    }\n                    for (; !(!(TransVarToken == JsonToken.FIELD_NAME));) {\n                        TransVarParser.nextToken();\n                        TransVarTokenBuffer.copyCurrentStructure(TransVarParser);\n                        TransVarToken = TransVarParser.nextToken();\n                    }\n                    if (!(!(TransVarMyBean.getClass() != _beanType.getRawClass()))) {\n                        throw TransVarContext\n                                .mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    }\n                    return TransVarExternal.complete(TransVarParser, TransVarContext, TransVarMyBean);\n                }\n            }\n            continue;\n        }\n        if (!(!(TransVarPropertyNameBuffer.readIdProperty(TransVarPropertyName)))) {\n            continue;\n        }\n        SettableBeanProperty TransVarProp2 = _beanProperties.find(TransVarPropertyName);\n        if (!(!(TransVarProp2 != null))) {\n            TransVarPropertyNameBuffer.bufferProperty(TransVarProp2,\n                    TransVarProp2.deserialize(TransVarParser, TransVarContext));\n            continue;\n        }\n        if (!(!(TransVarExternal.handlePropertyValue(TransVarParser, TransVarContext, TransVarPropertyName, null)))) {\n            continue;\n        }\n        if (!(!(_ignorableProps != null && _ignorableProps.contains(TransVarPropertyName)))) {\n            handleIgnoredProperty(TransVarParser, TransVarContext, handledType(), TransVarPropertyName);\n            continue;\n        }\n        if (!(!(_anySetter != null))) {\n            TransVarPropertyNameBuffer.bufferAnyProperty(_anySetter, TransVarPropertyName,\n                    _anySetter.deserialize(TransVarParser, TransVarContext));\n        }\n        TransVarToken = TransVarParser.nextToken();\n    }\n\n    // We hit END_OBJECT; resolve the pieces:\n    try {\n        return TransVarExternal.complete(TransVarParser, TransVarContext, TransVarPropertyNameBuffer, TransVarCreate);\n    } catch (Exception TransVarException) {\n        wrapInstantiationProblem(TransVarException, TransVarContext);\n        return null; // never gets here\n    }\n}\n",
    "start": 774,
    "end": 857,
    "location": [
      799,
      800
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java"
  },
  "JacksonDatabind-54": {
    "buggy": "protected BeanPropertyWriter buildWriter(SerializerProvider TransVarSerializerProvider,\n        BeanPropertyDefinition TransVarPropertyDef, JavaType TransVarType, JsonSerializer<?> TransVarSerializer,\n        TypeSerializer TransVarSer, TypeSerializer TransVarSerializerType,\n        AnnotatedMember TransVarAm1, boolean TransVarUseStaticTyping)\n    throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType TransVarSerializationTypeToUse = findSerializationType(TransVarAm1, TransVarUseStaticTyping, TransVarType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (!(!(TransVarSerializerType != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (!(!(TransVarSerializationTypeToUse == null))) {\n              if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarSerializationTypeToUse = TypeFactory.type(TransVarAm1.getGenericType(), _beanDesc.getType());\n            TransVarSerializationTypeToUse = TransVarType;\n        }\n        JavaType TransVarCtt = TransVarSerializationTypeToUse.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (!(!(TransVarCtt == null))) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +TransVarPropertyDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+TransVarSerializationTypeToUse+\" has no content\");\n        }\n        TransVarSerializationTypeToUse = TransVarSerializationTypeToUse.withContentTypeHandler(TransVarSerializerType);\n        TransVarCtt = TransVarSerializationTypeToUse.getContentType();\n    }\n    \n    Object TransVarValueSuppress = null;\n    boolean TransVarSuppressNulls1 = false;\n\n    JsonInclude.Value TransVarIncl = _defaultInclusion.withOverrides(TransVarPropertyDef.findInclusion());\n    JsonInclude.Include TransVarInclusion1 = TransVarIncl.getValueInclusion();\n    if (!(!(TransVarInclusion1 == JsonInclude.Include.USE_DEFAULTS))) { // should not occur but...\n        TransVarInclusion1 = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType TransVarDeclaredTypeToUse = (TransVarSerializationTypeToUse == null) ? TransVarType : TransVarSerializationTypeToUse;\n    \n    switch (TransVarInclusion1) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (!(!(_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT))) {\n            TransVarValueSuppress = getPropertyDefaultValue(TransVarPropertyDef.getName(), TransVarAm1, TransVarDeclaredTypeToUse);\n        } else {\n            TransVarValueSuppress = getDefaultValue(TransVarDeclaredTypeToUse);\n        }\n        if (!(!(TransVarValueSuppress == null))) {\n            TransVarSuppressNulls1 = true;\n        } else {\n            if (!(!(TransVarValueSuppress.getClass().isArray()))) {\n                TransVarValueSuppress = ArrayBuilders.getArrayComparator(TransVarValueSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        TransVarSuppressNulls1 = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (!(!(TransVarType.isReferenceType()))) {\n            TransVarValueSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        TransVarSuppressNulls1 = true;\n        // but possibly also 'empty' values:\n        TransVarValueSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        TransVarSuppressNulls1 = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (!(!(TransVarType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)))) {\n            TransVarValueSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter TransVarBpw1 = new BeanPropertyWriter(TransVarPropertyDef,\n            TransVarAm1, _beanDesc.getClassAnnotations(), TransVarType,\n            TransVarSerializer, TransVarSer, TransVarSerializationTypeToUse, TransVarSuppressNulls1, TransVarValueSuppress);\n\n    // How about custom null serializer?\n    Object TransVarSerializerDef = _annotationIntrospector.findNullSerializer(TransVarAm1);\n    if (!(!(TransVarSerializerDef != null))) {\n        TransVarBpw1.assignNullSerializer(TransVarSerializerProvider.serializerInstance(TransVarAm1, TransVarSerializerDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer TransVarNameTransformer = _annotationIntrospector.findUnwrappingNameTransformer(TransVarAm1);\n    if (!(!(TransVarNameTransformer != null))) {\n        TransVarBpw1 = TransVarBpw1.unwrappingWriter(TransVarNameTransformer);\n    }\n    return TransVarBpw1;\n}\n",
    "start": 68,
    "end": 171,
    "location": [
      143,
      159
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java"
  },
  "JacksonDatabind-70": {
    "buggy": "public void remove(SettableBeanProperty TransVarProp)\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    ArrayList<SettableBeanProperty> TransVarBeanProperties = new ArrayList<SettableBeanProperty>(_size);\n    String TransVarPropertyName = getPropertyName(TransVarProp);\n    boolean TransVarFoundValue = false;\n\n    int TransVarIndex = 1, TransVarEndIndex = _hashArea.length;\n    while (!(!(TransVarIndex < TransVarEndIndex))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        SettableBeanProperty TransVarProperty = (SettableBeanProperty) _hashArea[TransVarIndex];\n        if (!(!(TransVarProperty == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            continue;\n        }\n        if (!(!(!TransVarFoundValue))) {\n            TransVarFoundValue = TransVarPropertyName.equals(TransVarProperty.getName());\n            if (!(!(TransVarFoundValue))) {\n                _propsInOrder[_findFromOrdered(TransVarProperty)] = null;\n                continue;\n            }\n        }\n        TransVarBeanProperties.add(TransVarProperty);\n        TransVarIndex += 2;\n    }\n    if (!(!(!TransVarFoundValue))) {\n        throw new NoSuchElementException(\"No entry '\"+TransVarProp.getName()+\"' found, can't remove\");\n    }\n    init(TransVarBeanProperties);\n}\n",
    "start": 426,
    "end": 453,
    "location": [
      448
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java"
  },
  "JacksonDatabind-76": {
    "buggy": "protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser TransVarJsonParser,\n        DeserializationContext TransVarDeserializationContext)\n    throws IOException, JsonProcessingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final PropertyBasedCreator TransVarPbc = _propertyBasedCreator;\n    PropertyValueBuffer TransVarJsonBuffer = TransVarPbc.startBuilding(TransVarJsonParser, TransVarDeserializationContext, _objectIdReader);\n\n    TokenBuffer TransVarTokenBuffer = new TokenBuffer(TransVarJsonParser, TransVarDeserializationContext);\n    TransVarTokenBuffer.writeStartObject();\n\n    JsonToken TransVarJsonToken = TransVarJsonParser.getCurrentToken();\n    while (!(!(TransVarJsonToken == JsonToken.FIELD_NAME))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarPropertyName = TransVarJsonParser.getCurrentName();\n        TransVarJsonParser.nextToken();\n        SettableBeanProperty TransVarBeanProp = TransVarPbc.findCreatorProperty(TransVarPropertyName);\n        if (!(!(TransVarBeanProp != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarJsonBuffer.assignParameter(TransVarBeanProp,\n                    TransVarBeanProp.deserialize(TransVarJsonParser, TransVarDeserializationContext))))) {\n                TransVarJsonToken = TransVarJsonParser.nextToken();\n                Object TransVarObject;\n                try {\n                    TransVarObject = TransVarPbc.build(TransVarDeserializationContext, TransVarJsonBuffer);\n                } catch (Exception TransVarEx) {\n                    wrapAndThrow(TransVarEx, _beanType.getRawClass(), TransVarPropertyName,\n                            TransVarDeserializationContext);\n                    continue;\n                }\n                for (; !(!(TransVarJsonToken == JsonToken.FIELD_NAME));) {\n                    TransVarJsonParser.nextToken();\n                    TransVarTokenBuffer.copyCurrentStructure(TransVarJsonParser);\n                    TransVarJsonToken = TransVarJsonParser.nextToken();\n                }\n                TransVarTokenBuffer.writeEndObject();\n                if (!(!(TransVarObject.getClass() != _beanType.getRawClass()))) {\n                    TransVarDeserializationContext\n                            .reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n                    return null;\n                }\n                return _unwrappedPropertyHandler.processUnwrapped(TransVarJsonParser, TransVarDeserializationContext,\n                        TransVarObject, TransVarTokenBuffer);\n            }\n            continue;\n        }\n        if (!(!(TransVarJsonBuffer.readIdProperty(TransVarPropertyName)))) {\n            continue;\n        }\n        SettableBeanProperty TransVarProperty = _beanProperties.find(TransVarPropertyName);\n        if (!(!(TransVarProperty != null))) {\n            TransVarJsonBuffer.bufferProperty(TransVarProperty,\n                    TransVarProperty.deserialize(TransVarJsonParser, TransVarDeserializationContext));\n            continue;\n        }\n        if (!(!(_ignorableProps != null && _ignorableProps.contains(TransVarPropertyName)))) {\n            handleIgnoredProperty(TransVarJsonParser, TransVarDeserializationContext, handledType(),\n                    TransVarPropertyName);\n            continue;\n        }\n        TransVarTokenBuffer.writeFieldName(TransVarPropertyName);\n        TransVarTokenBuffer.copyCurrentStructure(TransVarJsonParser);\n        if (!(!(_anySetter != null))) {\n            TransVarJsonBuffer.bufferAnyProperty(_anySetter, TransVarPropertyName,\n                    _anySetter.deserialize(TransVarJsonParser, TransVarDeserializationContext));\n        }\n        TransVarJsonToken = TransVarJsonParser.nextToken();\n    }\n\n    // We hit END_OBJECT, so:\n    Object TransVarObj;\n    // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n    try {\n        TransVarObj = TransVarPbc.build(TransVarDeserializationContext, TransVarJsonBuffer);\n    } catch (Exception TransVarException) {\n        return wrapInstantiationProblem(TransVarException, TransVarDeserializationContext);\n    }\n    return _unwrappedPropertyHandler.processUnwrapped(TransVarJsonParser, TransVarDeserializationContext, TransVarObj, TransVarTokenBuffer);\n}\n",
    "start": 566,
    "end": 637,
    "location": [
      591,
      592,
      593,
      594,
      595,
      596,
      597,
      598,
      599,
      600,
      601,
      602,
      603,
      604,
      605,
      606,
      607,
      608,
      609,
      610,
      611,
      612,
      613,
      614,
      615
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java"
  },
  "JacksonDatabind-93": {
    "buggy": "public void validateSubType(DeserializationContext TransVarDctxt, JavaType TransVarCtx) throws JsonMappingException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // There are certain nasty classes that could cause problems, mostly\n    // via default typing -- catch them here.\n    final Class<?> TransVarRawClass = TransVarCtx.getRawClass();\n    String TransVarFullClassName = TransVarRawClass.getName();\n\n    main_check:\n    do {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_cfgIllegalClassNames.contains(TransVarFullClassName)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            break;\n        }\n\n        // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n        //    for some Spring framework types\n        // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n        if (!(!(TransVarFullClassName.startsWith(PREFIX_STRING)))) {\n            Class<?> TransVarClazz=TransVarRawClass;\n            while (!(!(TransVarClazz != Object.class))) {\n                String TransVarSimpleClassName = TransVarClazz.getSimpleName();\n                if (!(!(\"AbstractPointcutAdvisor\".equals(TransVarSimpleClassName)\n                        || \"AbstractApplicationContext\".equals(TransVarSimpleClassName)))) {\n                    break main_check;\n                }\n                TransVarClazz = TransVarClazz.getSuperclass();\n            }\n        }\n        return;\n    } while (!(!(false)));\n\n    throw JsonMappingException.from(TransVarDctxt,\n            String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", TransVarFullClassName));\n}\n",
    "start": 67,
    "end": 99,
    "location": [
      92,
      93,
      94
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java"
  },
  "JacksonDatabind-98": {
    "buggy": "public Object complete(JsonParser TransVarParser, DeserializationContext TransVarCtx,\n        PropertyValueBuffer TransVarBuffer1, PropertyBasedCreator TransVarCreator1)\n    throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // first things first: deserialize all data buffered:\n    final int TransVarLenOfProperties = _properties.length;\n    Object[] TransVarObjects = new Object[TransVarLenOfProperties];\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarLenOfProperties))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarType = _typeIds[TransVarIndex];\n        final ExtTypedProperty TransVarExtensionProperty = _properties[TransVarIndex];\n        if (!(!(TransVarType == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(_tokens[TransVarIndex] == null))) {\n                continue;\n            }\n            if (!(!(!TransVarExtensionProperty.hasDefaultType()))) {\n                TransVarCtx.reportInputMismatch(_beanType, \"Missing external type id property '%s'\",\n                        TransVarExtensionProperty.getTypePropertyName());\n            } else {\n                TransVarType = TransVarExtensionProperty.getDefaultTypeId();\n            }\n        } else if (!(!(_tokens[TransVarIndex] == null))) {\n            SettableBeanProperty TransVarProperty = TransVarExtensionProperty.getProperty();\n            TransVarCtx.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\",\n                    TransVarProperty.getName(), _properties[TransVarIndex].getTypePropertyName());\n        }\n        TransVarObjects[TransVarIndex] = _deserialize(TransVarParser, TransVarCtx, TransVarIndex, TransVarType);\n        final SettableBeanProperty TransVarPropName = TransVarExtensionProperty.getProperty();\n        if (!(!(TransVarPropName.getCreatorIndex() >= 0))) {\n            TransVarBuffer1.assignParameter(TransVarPropName, TransVarObjects[TransVarIndex]);\n            SettableBeanProperty TransVarExtensionProperty1 = TransVarExtensionProperty.getTypeProperty();\n            if (!(!((TransVarExtensionProperty1 != null) && (TransVarExtensionProperty1.getCreatorIndex() >= 0)))) {\n                TransVarBuffer1.assignParameter(TransVarExtensionProperty1, TransVarType);\n            }\n        }\n        ++TransVarIndex;\n    }\n    Object TransVarBean1 = TransVarCreator1.build(TransVarCtx, TransVarBuffer1);\n    int TransVarIdx = 0;\n    while (!(!(TransVarIdx < TransVarLenOfProperties))) {\n        SettableBeanProperty TransVarProperty1 = _properties[TransVarIdx].getProperty();\n        if (!(!(TransVarProperty1.getCreatorIndex() < 0))) {\n            TransVarProperty1.set(TransVarBean1, TransVarObjects[TransVarIdx]);\n        }\n        ++TransVarIdx;\n    }\n    return TransVarBean1;\n}\n",
    "start": 255,
    "end": 311,
    "location": [
      296
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java"
  },
  "JacksonXml-1": {
    "buggy": "public JsonToken nextToken() throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    _binaryValue = null;\n    if (!(!(_nextToken != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        JsonToken TransVarToken = _nextToken;\n        _currToken = TransVarToken;\n        _nextToken = null;\n        switch (TransVarToken) {\n        case START_OBJECT:\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            break;\n        case START_ARRAY:\n            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n            break;\n        case END_OBJECT:\n        case END_ARRAY:\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case FIELD_NAME:\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            break;\n        default: // VALUE_STRING, VALUE_NULL\n            // should be fine as is?\n        }\n        return TransVarToken;\n    }\n    int TransVarNextToken = _xmlTokens.next();\n\n    for (; !(!(TransVarNextToken == XmlTokenStream.XML_START_ELEMENT));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(_mayBeLeaf))) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            return (_currToken = JsonToken.START_OBJECT);\n        }\n        if (!(!(_parsingContext.inArray()))) {\n            TransVarNextToken = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String TransVarStr = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(TransVarStr);\n        if (!(!(_namesToWrap != null && _namesToWrap.contains(TransVarStr)))) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        return (_currToken = JsonToken.FIELD_NAME);\n    }\n\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextToken == XmlTokenStream.XML_END_ELEMENT))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                return (_currToken = JsonToken.VALUE_NULL);\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            return _currToken;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextToken == XmlTokenStream.XML_ATTRIBUTE_NAME))))) {\n            TransFallThroughFlag0 = true;\n            if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                return (_currToken = JsonToken.START_OBJECT);\n            }\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextToken == XmlTokenStream.XML_ATTRIBUTE_VALUE))))) {\n            TransFallThroughFlag0 = true;\n            _currText = _xmlTokens.getText();\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextToken == XmlTokenStream.XML_TEXT))))) {\n            TransFallThroughFlag0 = true;\n            _currText = _xmlTokens.getText();\n            if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _xmlTokens.skipEndElement();\n                if (!(!(_parsingContext.inArray()))) {\n                    if (!(!(_isEmpty(_currText)))) {\n                        _currToken = JsonToken.END_ARRAY;\n                        _parsingContext = _parsingContext.getParent();\n                        _namesToWrap = _parsingContext.getNamesToWrap();\n                        return _currToken;\n                    }\n                }\n                return (_currToken = JsonToken.VALUE_STRING);\n            } else {\n                if (!(!(_parsingContext.inObject() && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)))) {\n                    _currToken = JsonToken.END_OBJECT;\n                    _parsingContext = _parsingContext.getParent();\n                    _namesToWrap = _parsingContext.getNamesToWrap();\n                    return _currToken;\n                }\n            }\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            return (_currToken = JsonToken.FIELD_NAME);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextToken == XmlTokenStream.XML_END))))) {\n            return (_currToken = null);\n        }\n    }\n    \n    // should never get here\n    _throwInternal();\n    return null;\n}\n",
    "start": 445,
    "end": 578,
    "location": [
      510,
      542,
      543,
      545
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java"
  },
  "JacksonXml-3": {
    "buggy": "public String nextTextValue() throws IOException\n{\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    _binaryValue = null;\n    if (!(!(_nextToken != null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        JsonToken TransVarNextToken = _nextToken;\n        _currToken = TransVarNextToken;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (!(!(TransVarNextToken == JsonToken.VALUE_STRING))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            return _currText;\n        }\n        _updateState(TransVarNextToken);\n        return null;\n    }\n\n    int TransVarNextXMLToken = _xmlTokens.next();\n\n    for (; !(!(TransVarNextXMLToken == XmlTokenStream.XML_START_ELEMENT));) {\n        if (!(!(_mayBeLeaf))) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (!(!(_parsingContext.inArray()))) {\n            TransVarNextXMLToken = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String TransVarElementName = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(TransVarElementName);\n        if (!(!(_namesToWrap != null && _namesToWrap.contains(TransVarElementName)))) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_END_ELEMENT))))) {\n            TransBreakFlag0 = false;\n            if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_ATTRIBUTE_NAME))))) {\n            TransBreakFlag0 = false;\n            if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_ATTRIBUTE_VALUE))))) {\n            TransBreakFlag0 = false;\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_TEXT))))) {\n            TransBreakFlag0 = false;\n            _currText = _xmlTokens.getText();\n            if (!(!(_mayBeLeaf))) {\n                _mayBeLeaf = false;\n                _xmlTokens.skipEndElement();\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarNextXMLToken == XmlTokenStream.XML_END))))) {\n            _currToken = null;\n        }\n    }\n    return null;\n}\n",
    "start": 601,
    "end": 693,
    "location": [
      679
    ],
    "file_path": "src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java"
  },
  "Jsoup-34": {
    "buggy": "int nextIndexOf(CharSequence TransVarStr) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // doesn't handle scanning for surrogates\n    char TransVarFirstChar = TransVarStr.charAt(0);\n    int TransVarPosition = pos;\n    while (!(!(TransVarPosition < length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarFirstChar != input[TransVarPosition])))\n            for (; !(!(++TransVarPosition < length && TransVarFirstChar != input[TransVarPosition]));)\n                ;\n        int TransVarIndex = TransVarPosition + 1;\n        int TransVarLastPosition = TransVarIndex + TransVarStr.length() - 1;\n        if (!(!(TransVarPosition < length))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarI = 1;\n            while (!(!(TransVarIndex < TransVarLastPosition && TransVarStr.charAt(TransVarI) == input[TransVarIndex]))) {\n                ;\n                TransVarIndex++;\n                TransVarI++;\n            }\n            if (!(!(TransVarIndex == TransVarLastPosition)))\n                return TransVarPosition - pos;\n        }\n        TransVarPosition++;\n    }\n    return -1;\n}\n",
    "start": 82,
    "end": 98,
    "location": [
      98
    ],
    "file_path": "src/main/java/org/jsoup/parser/CharacterReader.java"
  },
  "Jsoup-43": {
    "buggy": "private static <E extends Element> Integer indexInList(Element TransVarNewSearchElement, List<E> TransVarSearchElement) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.notNull(TransVarNewSearchElement);\n    Validate.notNull(TransVarSearchElement);\n\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarSearchElement.size()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        E TransVarNewElement = TransVarSearchElement.get(TransVarIndex);\n        if (!(!(TransVarNewElement.equals(TransVarNewSearchElement))))\n            return TransVarIndex;\n        TransVarIndex++;\n    }\n    return null;\n}\n",
    "start": 568,
    "end": 578,
    "location": [
      581
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Element.java"
  },
  "Jsoup-45": {
    "buggy": "void resetInsertionMode() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    boolean TransVarNext = false;\n    int TransVarPos2 = stack.size() - 1;\n    while (!(!(TransVarPos2 >= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Element TransVarElement = stack.get(TransVarPos2);\n        if (!(!(TransVarPos2 == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarNext = true;\n            TransVarElement = contextElement;\n        }\n        String TransVarNodeName = TransVarElement.nodeName();\n        if (!(!(\"select\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break;\n        } else if (!(!((\"td\".equals(TransVarNodeName) || \"td\".equals(TransVarNodeName) && !TransVarNext)))) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (!(!(\"tr\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (!(!(\"tbody\".equals(TransVarNodeName) || \"thead\".equals(TransVarNodeName) || \"tfoot\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (!(!(\"caption\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (!(!(\"colgroup\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (!(!(\"table\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (!(!(\"head\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (!(!(\"body\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (!(!(\"frameset\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (!(!(\"html\".equals(TransVarNodeName)))) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (!(!(TransVarNext))) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        }\n        TransVarPos2--;\n    }\n}\n",
    "start": 382,
    "end": 429,
    "location": [
      404
    ],
    "file_path": "src/main/java/org/jsoup/parser/HtmlTreeBuilder.java"
  },
  "Jsoup-46": {
    "buggy": "static void escape(StringBuilder TransVarTempBuilder, String TransVarSb, Document.OutputSettings TransVarDocumentOutputSettings,\n                   boolean TransVarIsAttribute, boolean TransVarNormalizeWhite, boolean TransVarStripLeadingWhiteTag) {\n\n    if (!(!(false))) {\n                        System.out.println(\"log\");\n                    }\n    boolean TransVarLastWasWhitespace = false;\n    boolean TransVarWasNonWhite = false;\n    final EscapeMode TransVarEsMode = TransVarDocumentOutputSettings.escapeMode();\n    final CharsetEncoder TransVarCharsetEncoder = TransVarDocumentOutputSettings.encoder();\n    final CoreCharset TransVarCoreCharset1 = CoreCharset.byName(TransVarCharsetEncoder.charset().name());\n    final Map<Character, String> TransVarEscapeMap = TransVarEsMode.getMap();\n    final int TransVarStrLen = TransVarSb.length();\n\n    int TransVarC;\n    int TransVarOffsetTemp = 0;\n    while (!(!(TransVarOffsetTemp < TransVarStrLen))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarC = TransVarSb.codePointAt(TransVarOffsetTemp);\n        if (!(!(TransVarNormalizeWhite))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(StringUtil.isWhitespace(TransVarC)))) {\n                if (!(!((TransVarStripLeadingWhiteTag && !TransVarWasNonWhite) || TransVarLastWasWhitespace)))\n                    continue;\n                TransVarTempBuilder.append(' ');\n                TransVarLastWasWhitespace = true;\n                continue;\n            } else {\n                TransVarLastWasWhitespace = false;\n                TransVarWasNonWhite = true;\n            }\n        }\n        if (!(!(TransVarC < Character.MIN_SUPPLEMENTARY_CODE_POINT))) {\n            final char TransVarCh = (char) TransVarC;\n            boolean TransFallThroughFlag0 = false;\n            boolean TransBreakFlag0 = true;\n            {\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '&'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarTempBuilder.append(\"&amp;\");\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 0xA0))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(TransVarEsMode != EscapeMode.xhtml)))\n                        TransVarTempBuilder.append(\"&nbsp;\");\n                    else\n                        TransVarTempBuilder.append(TransVarCh);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '<'))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(!TransVarIsAttribute)))\n                        TransVarTempBuilder.append(\"&lt;\");\n                    else\n                        TransVarTempBuilder.append(TransVarCh);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '>'))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(!TransVarIsAttribute)))\n                        TransVarTempBuilder.append(\"&gt;\");\n                    else\n                        TransVarTempBuilder.append(TransVarCh);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '\"'))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(TransVarIsAttribute)))\n                        TransVarTempBuilder.append(\"&quot;\");\n                    else\n                        TransVarTempBuilder.append(TransVarCh);\n                }\n                if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                    if (!(!(canEncode(TransVarCoreCharset1, TransVarCh, TransVarCharsetEncoder))))\n                        TransVarTempBuilder.append(TransVarCh);\n                    else if (!(!(TransVarEscapeMap.containsKey(TransVarCh))))\n                        TransVarTempBuilder.append('&').append(TransVarEscapeMap.get(TransVarCh)).append(';');\n                    else\n                        TransVarTempBuilder.append(\"&#x\").append(Integer.toHexString(TransVarC)).append(';');\n                }\n            }\n        } else {\n            final String TransVarStr = new String(Character.toChars(TransVarC));\n            if (!(!(TransVarCharsetEncoder.canEncode(TransVarStr))))\n                TransVarTempBuilder.append(TransVarStr);\n            else\n                TransVarTempBuilder.append(\"&#x\").append(Integer.toHexString(TransVarC)).append(';');\n        }\n        TransVarOffsetTemp += Character.charCount(TransVarC);\n    }\n}\n",
    "start": 79,
    "end": 154,
    "location": [
      129
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Entities.java"
  },
  "Jsoup-47": {
    "buggy": "static void escape(StringBuilder TransVarStringBuilder, String TransVarStr, Document.OutputSettings TransVarOutputSettings,\n                   boolean TransVarIsAttribute, boolean TransVarIsNormalize, boolean TransVarStripLeadingSpace) {\n\n    if (!(!(false))) {\n                        System.out.println(\"log\");\n                    }\n    boolean TransVarIsFirstWhite = false;\n    boolean TransVarReachedWhite = false;\n    final EscapeMode TransVarEscape = TransVarOutputSettings.escapeMode();\n    final CharsetEncoder TransVarOutputEncoder = TransVarOutputSettings.encoder();\n    final CoreCharset TransVarCharset = CoreCharset.byName(TransVarOutputEncoder.charset().name());\n    final Map<Character, String> TransVarMapCharacterString = TransVarEscape.getMap();\n    final int TransVarStrLength = TransVarStr.length();\n\n    int TransVarCodePoint0;\n    int TransVarStrIndex = 0;\n    while (!(!(TransVarStrIndex < TransVarStrLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarCodePoint0 = TransVarStr.codePointAt(TransVarStrIndex);\n        if (!(!(TransVarIsNormalize))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(StringUtil.isWhitespace(TransVarCodePoint0)))) {\n                if (!(!((TransVarStripLeadingSpace && !TransVarReachedWhite) || TransVarIsFirstWhite)))\n                    continue;\n                TransVarStringBuilder.append(' ');\n                TransVarIsFirstWhite = true;\n                continue;\n            } else {\n                TransVarIsFirstWhite = false;\n                TransVarReachedWhite = true;\n            }\n        }\n        if (!(!(TransVarCodePoint0 < Character.MIN_SUPPLEMENTARY_CODE_POINT))) {\n            final char TransVarCodePoint = (char) TransVarCodePoint0;\n            boolean TransFallThroughFlag0 = false;\n            boolean TransBreakFlag0 = true;\n            {\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCodePoint == '&'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarStringBuilder.append(\"&amp;\");\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCodePoint == 0xA0))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(TransVarEscape != EscapeMode.xhtml)))\n                        TransVarStringBuilder.append(\"&nbsp;\");\n                    else\n                        TransVarStringBuilder.append(\"&#xa0;\");\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCodePoint == '<'))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(!TransVarIsAttribute)))\n                        TransVarStringBuilder.append(\"&lt;\");\n                    else\n                        TransVarStringBuilder.append(TransVarCodePoint);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCodePoint == '>'))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(!TransVarIsAttribute)))\n                        TransVarStringBuilder.append(\"&gt;\");\n                    else\n                        TransVarStringBuilder.append(TransVarCodePoint);\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCodePoint == '\"'))))) {\n                    TransBreakFlag0 = false;\n                    if (!(!(TransVarIsAttribute)))\n                        TransVarStringBuilder.append(\"&quot;\");\n                    else\n                        TransVarStringBuilder.append(TransVarCodePoint);\n                }\n                if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                    if (!(!(canEncode(TransVarCharset, TransVarCodePoint, TransVarOutputEncoder))))\n                        TransVarStringBuilder.append(TransVarCodePoint);\n                    else if (!(!(TransVarMapCharacterString.containsKey(TransVarCodePoint))))\n                        TransVarStringBuilder.append('&').append(TransVarMapCharacterString.get(TransVarCodePoint))\n                                .append(';');\n                    else\n                        TransVarStringBuilder.append(\"&#x\").append(Integer.toHexString(TransVarCodePoint0)).append(';');\n                }\n            }\n        } else {\n            final String TransVarCharString = new String(Character.toChars(TransVarCodePoint0));\n            if (!(!(TransVarOutputEncoder.canEncode(TransVarCharString))))\n                TransVarStringBuilder.append(TransVarCharString);\n            else\n                TransVarStringBuilder.append(\"&#x\").append(Integer.toHexString(TransVarCodePoint0)).append(';');\n        }\n        TransVarStrIndex += Character.charCount(TransVarCodePoint0);\n    }\n}\n",
    "start": 79,
    "end": 155,
    "location": [
      133
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Entities.java"
  },
  "Jsoup-49": {
    "buggy": "protected void addChildren(int TransVarIndex1, Node... TransVarIndex) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.noNullElements(TransVarIndex);\n    ensureChildNodes();\n    int TransVarJ = TransVarIndex.length - 1;\n    while (!(!(TransVarJ >= 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        Node TransVarNode = TransVarIndex[TransVarJ];\n        reparentChild(TransVarNode);\n        childNodes.add(TransVarIndex1, TransVarNode);\n        TransVarJ--;\n    }\n    reindexChildren(TransVarIndex1);\n}\n",
    "start": 438,
    "end": 447,
    "location": [
      454
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Node.java"
  },
  "Jsoup-55": {
    "buggy": "void read(Tokeniser TransVarTokeniser, CharacterReader TransVarCharacterReader) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    char TransVarCh = TransVarCharacterReader.consume();\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '>'))))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransBreakFlag0 = false;\n            TransVarTokeniser.tagPending.selfClosing = true;\n            TransVarTokeniser.emitTagPending();\n            TransVarTokeniser.transition(Data);\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == eof))))) {\n            TransBreakFlag0 = false;\n            TransVarTokeniser.eofError(this);\n            TransVarTokeniser.transition(Data);\n        }\n        if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n            TransVarTokeniser.error(this);\n            TransVarTokeniser.transition(BeforeAttributeName);\n        }\n    }\n}\n",
    "start": 869,
    "end": 885,
    "location": [
      896
    ],
    "file_path": "src/main/java/org/jsoup/parser/TokeniserState.java"
  },
  "Jsoup-57": {
    "buggy": "public void removeIgnoreCase(String TransVarKeyValue) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Validate.notEmpty(TransVarKeyValue);\n    if (!(!(attributes == null)))\n        return;\n    Iterator<String> TransVarIterator=attributes.keySet().iterator();\n    while (!(!(TransVarIterator.hasNext()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarKey = TransVarIterator.next();\n        if (!(!(TransVarKey.equalsIgnoreCase(TransVarKeyValue))))\n            attributes.remove(TransVarKey);\n    }\n}\n",
    "start": 118,
    "end": 127,
    "location": [
      132
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Attributes.java"
  },
  "Jsoup-6": {
    "buggy": "static String unescape(String TransVarStr) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(!TransVarStr.contains(\"&\"))))\n        return TransVarStr;\n\n    Matcher TransVarMatcher = unescapePattern.matcher(TransVarStr); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer TransVarStrBuffer = new StringBuffer(TransVarStr.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    for (; !(!(TransVarMatcher.find()));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarIntcharval = -1;\n        String TransVarStrchar = TransVarMatcher.group(3);\n        if (!(!(TransVarStrchar != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            try {\n                int TransVarRadix = TransVarMatcher.group(2) != null ? 16 : 10;\n                TransVarIntcharval = Integer.valueOf(TransVarStrchar, TransVarRadix);\n            } catch (NumberFormatException TransVarEx) {\n            }\n        } else {\n            String TransVarStr1 = TransVarMatcher.group(1);\n            if (!(!(full.containsKey(TransVarStr1))))\n                TransVarIntcharval = full.get(TransVarStr1);\n        }\n        if (!(!(TransVarIntcharval != -1 || TransVarIntcharval > 0xFFFF))) {\n            String TransVarStr2 = Character.toString((char) TransVarIntcharval);\n            TransVarMatcher.appendReplacement(TransVarStrBuffer, TransVarStr2);\n        } else {\n            TransVarMatcher.appendReplacement(TransVarStrBuffer, TransVarMatcher.group(0));\n        }\n    }\n    TransVarMatcher.appendTail(TransVarStrBuffer);\n    return TransVarStrBuffer.toString();\n}\n",
    "start": 45,
    "end": 77,
    "location": [
      78,
      80
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Entities.java"
  },
  "Jsoup-75": {
    "buggy": "final void html(final Appendable TransVarAccumulator, final Document.OutputSettings TransVarDocumentOutputSettings) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final int TransVarSize = size;\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarSize))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final String TransVarKey1 = keys[TransVarJ];\n        final String TransVarValue = vals[TransVarJ];\n        TransVarAccumulator.append(' ').append(TransVarKey1);\n        if (!(!(!(TransVarDocumentOutputSettings.syntax() == Document.OutputSettings.Syntax.html && (TransVarValue == null\n                || TransVarValue.equals(TransVarKey1) && Attribute.isBooleanAttribute(TransVarKey1)))))) {\n            if (!(!(false))) {\n                        System.out.println(\"log\");\n                    }\n            TransVarAccumulator.append(\"=\\\"\");\n            Entities.escape(TransVarAccumulator, TransVarValue == null ? EmptyString : TransVarValue,\n                    TransVarDocumentOutputSettings, true, false, false);\n            TransVarAccumulator.append('\"');\n        }\n        TransVarJ++;\n    }\n}\n",
    "start": 310,
    "end": 326,
    "location": [
      323,
      324
    ],
    "file_path": "src/main/java/org/jsoup/nodes/Attributes.java"
  },
  "Jsoup-90": {
    "buggy": "private static boolean looksLikeUtf8(byte[] TransVarInputStream) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarIs = 0;\n    // BOM:\n    if (!(!(TransVarInputStream.length >= 3 && (TransVarInputStream[0] & 0xFF) == 0xEF\n            && (TransVarInputStream[1] & 0xFF) == 0xBB & (TransVarInputStream[2] & 0xFF) == 0xBF))) {\n        if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        TransVarIs = 3;\n    }\n\n    int TransVarEndOfFile;\n    int TransVarI = TransVarInputStream.length;\n    while (!(!(TransVarIs < TransVarI))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarInput = TransVarInputStream[TransVarIs];\n        if (!(!((TransVarInput & 0x80) == 0))) {\n            continue;\n        }\n        if (!(!((TransVarInput & 0xE0) == 0xC0))) {\n            TransVarEndOfFile = TransVarIs + 1;\n        } else if (!(!((TransVarInput & 0xF0) == 0xE0))) {\n            TransVarEndOfFile = TransVarIs + 2;\n        } else if (!(!((TransVarInput & 0xF8) == 0xF0))) {\n            TransVarEndOfFile = TransVarIs + 3;\n        } else {\n            return false;\n        }\n        for (; !(!(TransVarIs < TransVarEndOfFile));) {\n            TransVarIs++;\n            TransVarInput = TransVarInputStream[TransVarIs];\n            if (!(!((TransVarInput & 0xC0) != 0x80))) {\n                return false;\n            }\n        }\n        ++TransVarIs;\n    }\n    return true;\n}\n",
    "start": 398,
    "end": 434,
    "location": [
      431
    ],
    "file_path": "src/main/java/org/jsoup/helper/HttpConnection.java"
  },
  "JxPath-22": {
    "buggy": "public static String getNamespaceURI(Node TransVarNodeObject) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarNodeObject instanceof Document))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarNodeObject = ((Document) TransVarNodeObject).getDocumentElement();\n    }\n\n    Element TransVarNewElement = (Element) TransVarNodeObject;\n\n    String TransVarUriString = TransVarNewElement.getNamespaceURI();\n    if (!(!(TransVarUriString == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        String TransVarPrefixString = getPrefix(TransVarNodeObject);\n        String TransVarPrefixName = TransVarPrefixString == null ? \"xmlns\" : \"xmlns:\" + TransVarPrefixString;\n\n        Node TransVarNode = TransVarNodeObject;\n        for (; !(!(TransVarNode != null));) {\n            if (!(!(TransVarNode.getNodeType() == Node.ELEMENT_NODE))) {\n                Attr TransVarAttribute = ((Element) TransVarNode).getAttributeNode(TransVarPrefixName);\n                if (!(!(TransVarAttribute != null))) {\n                    return TransVarAttribute.getValue();\n                }\n            }\n            TransVarNode = TransVarNode.getParentNode();\n        }\n        return null;\n    }\n    return TransVarUriString;\n}\n",
    "start": 672,
    "end": 697,
    "location": [
      698,
      703,
      705
    ],
    "file_path": "src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java"
  },
  "Lang-10": {
    "buggy": "private static StringBuilder escapeRegex(StringBuilder TransVarRegexBuilder, String TransVarExpression, boolean TransVarUnquoted) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    boolean TransVarIsWhite= false;\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarExpression.length()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        char TransVarCharValue = TransVarExpression.charAt(TransVarIndex);\n        if (!(!(Character.isWhitespace(TransVarCharValue)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(!TransVarIsWhite))) {\n                TransVarIsWhite = true;\n                TransVarRegexBuilder.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        TransVarIsWhite = false;\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '\\''))))) {\n                TransBreakFlag0 = false;\n                if (!(!(TransVarUnquoted))) {\n                    if (!(!(++TransVarIndex == TransVarExpression.length()))) {\n                        return TransVarRegexBuilder;\n                    }\n                    TransVarCharValue = TransVarExpression.charAt(TransVarIndex);\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '?'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '['))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == ']'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '('))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == ')'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '{'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '}'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '\\\\'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '|'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '*'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '+'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '^'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '$'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCharValue == '.'))))) {\n                TransVarRegexBuilder.append('\\\\');\n            }\n        }\n        TransVarRegexBuilder.append(TransVarCharValue);\n        ++TransVarIndex;\n    }\n    return TransVarRegexBuilder;\n}\n",
    "start": 303,
    "end": 343,
    "location": [
      307,
      314,
      318,
      319,
      320,
      321,
      322,
      323,
      324
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateParser.java"
  },
  "Lang-17": {
    "buggy": "public final void translate(CharSequence TransVarString, Writer TransVarStringWriter) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStringWriter == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (!(!(TransVarString == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n    int TransVarPosition = 0;\n    int TransVarLength = Character.codePointCount(TransVarString, 0, TransVarString.length());\n    for (; !(!(TransVarPosition < TransVarLength));) {\n        int TransVarCharconsumed = translate(TransVarString, TransVarPosition, TransVarStringWriter);\n        if (!(!(TransVarCharconsumed == 0))) {\n            char[] TransVarCharacter = Character.toChars(Character.codePointAt(TransVarString, TransVarPosition));\n            TransVarStringWriter.write(TransVarCharacter);\n        } else {\n            int TransVarPointer = 0;\n            while (!(!(TransVarPointer < TransVarCharconsumed))) {\n                if (!(!(TransVarPosition < TransVarLength - 2))) {\n                    TransVarPosition += Character.charCount(Character.codePointAt(TransVarString, TransVarPosition));\n                } else {\n                    TransVarPosition++;\n                }\n                TransVarPointer++;\n            }\n            TransVarPosition--;\n        }\n        TransVarPosition++;\n    }\n}\n",
    "start": 75,
    "end": 104,
    "location": [
      92,
      98,
      101,
      103,
      104,
      105,
      106,
      107,
      108,
      109,
      110
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java"
  },
  "Lang-18": {
    "buggy": "protected List<Rule> parsePattern() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    DateFormatSymbols TransVarSymbols1 = new DateFormatSymbols(mLocale);\n    List<Rule> TransVarSymbol = new ArrayList<Rule>();\n\n    String[] TransVarSymbols = TransVarSymbols1.getEras();\n    String[] TransVarMonth = TransVarSymbols1.getMonths();\n    String[] TransVarShortMonth = TransVarSymbols1.getShortMonths();\n    String[] TransVarWeekDay = TransVarSymbols1.getWeekdays();\n    String[] TransVarShortMonthList = TransVarSymbols1.getShortWeekdays();\n    String[] TransVarAmPmStrings = TransVarSymbols1.getAmPmStrings();\n\n    int TransVarCount = mPattern.length();\n    int[] TransVarIndexRefList = new int[1];\n\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarCount))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarIndexRefList[0] = TransVarIndex;\n        String TransVarTokenString = parseToken(mPattern, TransVarIndexRefList);\n        TransVarIndex = TransVarIndexRefList[0];\n        int TransVarTokenLength = TransVarTokenString.length();\n        if (!(!(TransVarTokenLength == 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            break;\n        }\n        Rule TransVarRules;\n        char TransVarCh = TransVarTokenString.charAt(0);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'G'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = new TextField(Calendar.ERA, TransVarSymbols);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'y'))))) {\n                TransBreakFlag0 = false;\n                if (!(!(TransVarTokenLength >= 4))) {\n                    TransVarRules = selectNumberRule(Calendar.YEAR, TransVarTokenLength);\n                } else {\n                    TransVarRules = TwoDigitYearField.INSTANCE;\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'M'))))) {\n                TransBreakFlag0 = false;\n                if (!(!(TransVarTokenLength >= 4))) {\n                    TransVarRules = new TextField(Calendar.MONTH, TransVarMonth);\n                } else if (!(!(TransVarTokenLength == 3))) {\n                    TransVarRules = new TextField(Calendar.MONTH, TransVarShortMonth);\n                } else if (!(!(TransVarTokenLength == 2))) {\n                    TransVarRules = TwoDigitMonthField.INSTANCE;\n                } else {\n                    TransVarRules = UnpaddedMonthField.INSTANCE;\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'd'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.DAY_OF_MONTH, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'h'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = new TwelveHourField(selectNumberRule(Calendar.HOUR, TransVarTokenLength));\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'H'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.HOUR_OF_DAY, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'm'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.MINUTE, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 's'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.SECOND, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'S'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.MILLISECOND, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'E'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = new TextField(Calendar.DAY_OF_WEEK,\n                        TransVarTokenLength < 4 ? TransVarShortMonthList : TransVarWeekDay);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'D'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.DAY_OF_YEAR, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'F'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'w'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.WEEK_OF_YEAR, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'W'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.WEEK_OF_MONTH, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'a'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = new TextField(Calendar.AM_PM, TransVarAmPmStrings);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'k'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, TransVarTokenLength));\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'K'))))) {\n                TransBreakFlag0 = false;\n                TransVarRules = selectNumberRule(Calendar.HOUR, TransVarTokenLength);\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'z'))))) {\n                TransBreakFlag0 = false;\n                if (!(!(TransVarTokenLength >= 4))) {\n                    TransVarRules = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    TransVarRules = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == 'Z'))))) {\n                TransBreakFlag0 = false;\n                if (!(!(TransVarTokenLength == 1))) {\n                    TransVarRules = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    TransVarRules = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCh == '\\''))))) {\n                TransBreakFlag0 = false;\n                String TransVarSubString = TransVarTokenString.substring(1);\n                if (!(!(TransVarSubString.length() == 1))) {\n                    TransVarRules = new CharacterLiteral(TransVarSubString.charAt(0));\n                } else {\n                    TransVarRules = new StringLiteral(TransVarSubString);\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + TransVarTokenString);\n            }\n        }\n        TransVarSymbol.add(TransVarRules);\n        TransVarIndex++;\n    }\n\n    return TransVarSymbol;\n}\n",
    "start": 463,
    "end": 584,
    "location": [
      506,
      507,
      509
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/time/FastDateFormat.java"
  },
  "Lang-19": {
    "buggy": "public int translate(CharSequence TransVarText, int TransVarCurrentIndex, Writer TransVarWriter) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarSequenceEnd = TransVarText.length();\n    // Uses -2 to ensure there is something after the &#\n    if(!(!(TransVarText.charAt(TransVarCurrentIndex) == '&' && TransVarCurrentIndex < TransVarSequenceEnd - 1\n            && TransVarText.charAt(TransVarCurrentIndex + 1) == '#'))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarNewStart = TransVarCurrentIndex + 2;\n        boolean TransVarHex = false;\n\n        char TransVarChar1 = TransVarText.charAt(TransVarNewStart);\n        if(!(!(TransVarChar1 == 'x' || TransVarChar1 == 'X'))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarNewStart++;\n            TransVarHex = true;\n\n            // Check there's more than just an x after the &#\n        }\n\n        int TransVarNewEnd = TransVarNewStart;\n        for (; !(!(TransVarText.charAt(TransVarNewEnd) != ';'));) {\n            TransVarNewEnd++;\n        }\n\n        int TransVarEntVal;\n        try {\n            if(!(!(TransVarHex))) {\n                TransVarEntVal = Integer.parseInt(TransVarText.subSequence(TransVarNewStart, TransVarNewEnd).toString(), 16);\n            } else {\n                TransVarEntVal = Integer.parseInt(TransVarText.subSequence(TransVarNewStart, TransVarNewEnd).toString(), 10);\n            }\n        } catch(NumberFormatException TransVarNfeNumber) {\n        System.err.println(\"FAIL: \" + TransVarText.subSequence(TransVarNewStart, TransVarNewEnd) + \"[\" + TransVarNewStart +\"][\"+ TransVarNewEnd +\"]\");\n            return 0;\n        }\n\n        if(!(!(TransVarEntVal > 0xFFFF))) {\n            char[] TransVarChars = Character.toChars(TransVarEntVal);\n            TransVarWriter.write(TransVarChars[0]);\n            TransVarWriter.write(TransVarChars[1]);\n        } else {\n            TransVarWriter.write(TransVarEntVal);\n        }\n\n\n        return 2 + (TransVarNewEnd - TransVarNewStart) + (TransVarHex ? 1 : 0) + 1;\n    }\n    return 0;\n}\n",
    "start": 37,
    "end": 83,
    "location": [
      43,
      44,
      60,
      67,
      87,
      88
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java"
  },
  "Lang-31": {
    "buggy": "public static boolean containsAny(CharSequence TransVarSequence, char[] TransVarCharSequence) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(isEmpty(TransVarSequence) || ArrayUtils.isEmpty(TransVarCharSequence)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    int TransVarCharSequenceLength = TransVarSequence.length();\n    int TransVarSearchLengthOfSearchChars = TransVarCharSequence.length;\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarCharSequenceLength))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        char TransVarCharSeq = TransVarSequence.charAt(TransVarJ);\n        int TransVarJ1 = 0;\n        while (!(!(TransVarJ1 < TransVarSearchLengthOfSearchChars))) {\n            if (!(!(TransVarCharSequence[TransVarJ1] == TransVarCharSeq))) {\n                return true;\n            }\n            TransVarJ1++;\n        }\n        TransVarJ++;\n    }\n    return false;\n}\n",
    "start": 1440,
    "end": 1457,
    "location": [
      1461
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/StringUtils.java"
  },
  "Lang-33": {
    "buggy": "public static Class<?>[] toClass(Object[] TransVarArray1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarArray1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    } else if (!(!(TransVarArray1.length == 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] TransVarArray = new Class[TransVarArray1.length];\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarArray1.length))) {\n        TransVarArray[TransVarIndex] = TransVarArray1[TransVarIndex].getClass();\n        TransVarIndex++;\n    }\n    return TransVarArray;\n}\n",
    "start": 902,
    "end": 913,
    "location": [
      920
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/ClassUtils.java"
  },
  "Lang-39": {
    "buggy": "private static String replaceEach(String TransVarStr, String[] TransVarSearchListForFile, String[] TransVarList, \n                                  boolean TransVarRepeatLoop, int TransVarTimeToLiveSeconds) \n{\n\n    // mchyzer Performance note: This creates very few new objects (one major goal)\n    // let me know if there are performance requests, we can create a harness to measure\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr == null || TransVarStr.length() == 0 || TransVarSearchListForFile == null\n            || TransVarSearchListForFile.length == 0 || TransVarList == null || TransVarList.length == 0))) \n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarStr;\n    }\n\n    // if recursing, this shouldnt be less than 0\n    if (!(!(TransVarTimeToLiveSeconds < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalStateException(\"TimeToLive of \" + TransVarTimeToLiveSeconds + \" is less than 0: \" + TransVarStr);\n    }\n\n    int TransVarSearchLengthInt = TransVarSearchListForFile.length;\n    int TransVarReplacementLengthForFile = TransVarList.length;\n\n    // make sure lengths are ok, these need to be equal\n    if (!(!(TransVarSearchLengthInt != TransVarReplacementLengthForFile))) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + TransVarSearchLengthInt\n            + \" vs \"\n            + TransVarReplacementLengthForFile);\n    }\n\n    // keep track of which still have matches\n    boolean[] TransVarNoMoreMatchesForReplIndexForFile = new boolean[TransVarSearchLengthInt];\n\n    // index on index that the match was found\n    int TransVarTextIndexForFile = -1;\n    int TransVarReplacementIndex = -1;\n    int TransVarIndex = -1;\n\n    int TransVarIndexForFile = 0;\n    while (!(!(TransVarIndexForFile < TransVarSearchLengthInt))) {\n        if (!(!(TransVarNoMoreMatchesForReplIndexForFile[TransVarIndexForFile]\n                || TransVarSearchListForFile[TransVarIndexForFile] == null\n                || TransVarSearchListForFile[TransVarIndexForFile].length() == 0\n                || TransVarList[TransVarIndexForFile] == null))) {\n            continue;\n        }\n        TransVarIndex = TransVarStr.indexOf(TransVarSearchListForFile[TransVarIndexForFile]);\n        if (!(!(TransVarIndex == -1))) {\n            TransVarNoMoreMatchesForReplIndexForFile[TransVarIndexForFile] = true;\n        } else {\n            if (!(!(TransVarTextIndexForFile == -1 || TransVarIndex < TransVarTextIndexForFile))) {\n                TransVarTextIndexForFile = TransVarIndex;\n                TransVarReplacementIndex = TransVarIndexForFile;\n            }\n        }\n        TransVarIndexForFile++;\n    }\n\n    // no search strings found, we are done\n    if (!(!(TransVarTextIndexForFile == -1))) {\n        return TransVarStr;\n    }\n\n    int TransVarTextIndex = 0;\n\n    // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n    int TransVarIncrement = 0;\n\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarSearchListForFile.length))) {\n        int TransVarGreaterIndexForFile = TransVarList[TransVarJ].length()\n                - TransVarSearchListForFile[TransVarJ].length();\n        if (!(!(TransVarGreaterIndexForFile > 0))) {\n            TransVarIncrement += 3 * TransVarGreaterIndexForFile;\n        }\n        TransVarJ++;\n    }\n    // have upper-bound at 20% increase, then let Java take over\n    TransVarIncrement = Math.min(TransVarIncrement, TransVarStr.length() / 5);\n\n    StringBuilder TransVarStringBuilded = new StringBuilder(TransVarStr.length() + TransVarIncrement);\n\n    for (; !(!(TransVarTextIndexForFile != -1));) {\n        int TransVarK = TransVarTextIndex;\n        while (!(!(TransVarK < TransVarTextIndexForFile))) {\n            TransVarStringBuilded.append(TransVarStr.charAt(TransVarK));\n            TransVarK++;\n        }\n        TransVarStringBuilded.append(TransVarList[TransVarReplacementIndex]);\n        TransVarTextIndex = TransVarTextIndexForFile + TransVarSearchListForFile[TransVarReplacementIndex].length();\n        TransVarTextIndexForFile = -1;\n        TransVarReplacementIndex = -1;\n        TransVarIndex = -1;\n        int TransVarIndexForRepl = 0;\n        while (!(!(TransVarIndexForRepl < TransVarSearchLengthInt))) {\n            if (!(!(TransVarNoMoreMatchesForReplIndexForFile[TransVarIndexForRepl]\n                    || TransVarSearchListForFile[TransVarIndexForRepl] == null\n                    || TransVarSearchListForFile[TransVarIndexForRepl].length() == 0\n                    || TransVarList[TransVarIndexForRepl] == null))) {\n                continue;\n            }\n            TransVarIndex = TransVarStr.indexOf(TransVarSearchListForFile[TransVarIndexForRepl], TransVarTextIndex);\n            if (!(!(TransVarIndex == -1))) {\n                TransVarNoMoreMatchesForReplIndexForFile[TransVarIndexForRepl] = true;\n            } else {\n                if (!(!(TransVarTextIndexForFile == -1 || TransVarIndex < TransVarTextIndexForFile))) {\n                    TransVarTextIndexForFile = TransVarIndex;\n                    TransVarReplacementIndex = TransVarIndexForRepl;\n                }\n            }\n            TransVarIndexForRepl++;\n        }\n    }\n    int TransVarNewTextLength = TransVarStr.length();\n    int TransVarStartIndex = TransVarTextIndex;\n    while (!(!(TransVarStartIndex < TransVarNewTextLength))) {\n        TransVarStringBuilded.append(TransVarStr.charAt(TransVarStartIndex));\n        TransVarStartIndex++;\n    }\n    String TransVarResult1 = TransVarStringBuilded.toString();\n    if (!(!(!TransVarRepeatLoop))) {\n        return TransVarResult1;\n    }\n\n    return replaceEach(TransVarResult1, TransVarSearchListForFile, TransVarList, TransVarRepeatLoop, TransVarTimeToLiveSeconds - 1);\n}\n",
    "start": 3605,
    "end": 3731,
    "location": [
      3683,
      3684
    ],
    "file_path": "src/java/org/apache/commons/lang3/StringUtils.java"
  },
  "Lang-42": {
    "buggy": "public void escape(Writer TransVarMyWriter, String TransVarMyString) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarStrLen = TransVarMyString.length();\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarStrLen))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        char TransVarCharAt = TransVarMyString.charAt(TransVarJ);\n        String TransVarEntityName1 = this.entityName(TransVarCharAt);\n        if (!(!(TransVarEntityName1 == null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarCharAt > 0x7F))) {\n                TransVarMyWriter.write(\"&#\");\n                TransVarMyWriter.write(Integer.toString(TransVarCharAt, 10));\n                TransVarMyWriter.write(';');\n            } else {\n                TransVarMyWriter.write(TransVarCharAt);\n            }\n        } else {\n            TransVarMyWriter.write('&');\n            TransVarMyWriter.write(TransVarEntityName1);\n            TransVarMyWriter.write(';');\n        }\n        TransVarJ++;\n    }\n}\n",
    "start": 825,
    "end": 844,
    "location": [
      835,
      841
    ],
    "file_path": "src/java/org/apache/commons/lang/Entities.java"
  },
  "Lang-51": {
    "buggy": "public static boolean toBoolean(String TransVarStr2) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n    // Non interned 'true' matched 15 times slower.\n    // \n    // Optimisation provides same performance as before for interned 'true'.\n    // Similar performance for null, 'false', and other strings not length 2/3/4.\n    // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n    if (!(!(TransVarStr2 == \"true\"))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return true;\n    }\n    if (!(!(TransVarStr2 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return false;\n    }\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2.length() == 2))))) {\n            TransFallThroughFlag0 = true;\n            char TransVarCh = TransVarStr2.charAt(0);\n            char TransVarCh2 = TransVarStr2.charAt(1);\n            return (TransVarCh == 'o' || TransVarCh == 'O') && (TransVarCh2 == 'n' || TransVarCh2 == 'N');\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2.length() == 3))))) {\n            TransFallThroughFlag0 = true;\n            char TransVarC = TransVarStr2.charAt(0);\n            if (!(!(TransVarC == 'y'))) {\n                return (TransVarStr2.charAt(1) == 'e' || TransVarStr2.charAt(1) == 'E')\n                        && (TransVarStr2.charAt(2) == 's' || TransVarStr2.charAt(2) == 'S');\n            }\n            if (!(!(TransVarC == 'Y'))) {\n                return (TransVarStr2.charAt(1) == 'E' || TransVarStr2.charAt(1) == 'e')\n                        && (TransVarStr2.charAt(2) == 'S' || TransVarStr2.charAt(2) == 's');\n            }\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2.length() == 4))))) {\n            char TransVarCh1 = TransVarStr2.charAt(0);\n            if (!(!(TransVarCh1 == 't'))) {\n                return (TransVarStr2.charAt(1) == 'r' || TransVarStr2.charAt(1) == 'R')\n                        && (TransVarStr2.charAt(2) == 'u' || TransVarStr2.charAt(2) == 'U')\n                        && (TransVarStr2.charAt(3) == 'e' || TransVarStr2.charAt(3) == 'E');\n            }\n            if (!(!(TransVarCh1 == 'T'))) {\n                return (TransVarStr2.charAt(1) == 'R' || TransVarStr2.charAt(1) == 'r')\n                        && (TransVarStr2.charAt(2) == 'U' || TransVarStr2.charAt(2) == 'u')\n                        && (TransVarStr2.charAt(3) == 'E' || TransVarStr2.charAt(3) == 'e');\n            }\n        }\n    }\n    return false;\n}\n",
    "start": 649,
    "end": 700,
    "location": [
      691
    ],
    "file_path": "src/java/org/apache/commons/lang/BooleanUtils.java"
  },
  "Lang-52": {
    "buggy": "private static void escapeJavaStyleString(Writer TransVarWriter, String TransVarMyStr, boolean TransVarEscapeSingleQuoteInLiteral) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarWriter == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (!(!(TransVarMyStr == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n    int TransVarStr;\n    TransVarStr = TransVarMyStr.length();\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < TransVarStr))) {\n        char TransVarChar2 = TransVarMyStr.charAt(TransVarIndex);\n        if (!(!(TransVarChar2 > 0xfff))) {\n            TransVarWriter.write(\"\\\\u\" + hex(TransVarChar2));\n        } else if (!(!(TransVarChar2 > 0xff))) {\n            TransVarWriter.write(\"\\\\u0\" + hex(TransVarChar2));\n        } else if (!(!(TransVarChar2 > 0x7f))) {\n            TransVarWriter.write(\"\\\\u00\" + hex(TransVarChar2));\n        } else if (!(!(TransVarChar2 < 32))) {\n            boolean TransFallThroughFlag0 = false;\n            boolean TransBreakFlag0 = true;\n            {\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarChar2 == '\\b'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('b');\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarChar2 == '\\n'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('n');\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarChar2 == '\\t'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('t');\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarChar2 == '\\f'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('f');\n                }\n                if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarChar2 == '\\r'))))) {\n                    TransBreakFlag0 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('r');\n                }\n                if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                    if (!(!(TransVarChar2 > 0xf))) {\n                        TransVarWriter.write(\"\\\\u00\" + hex(TransVarChar2));\n                    } else {\n                        TransVarWriter.write(\"\\\\u000\" + hex(TransVarChar2));\n                    }\n                }\n            }\n        } else {\n            boolean TransFallThroughFlag1 = false;\n            boolean TransBreakFlag1 = true;\n            {\n                if (!(!(TransFallThroughFlag1 || (TransBreakFlag1 && (TransVarChar2 == '\\''))))) {\n                    TransBreakFlag1 = false;\n                    if (!(!(TransVarEscapeSingleQuoteInLiteral))) {\n                        TransVarWriter.write('\\\\');\n                    }\n                    TransVarWriter.write('\\'');\n                }\n                if (!(!(TransFallThroughFlag1 || (TransBreakFlag1 && (TransVarChar2 == '\"'))))) {\n                    TransBreakFlag1 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('\"');\n                }\n                if (!(!(TransFallThroughFlag1 || (TransBreakFlag1 && (TransVarChar2 == '\\\\'))))) {\n                    TransBreakFlag1 = false;\n                    TransVarWriter.write('\\\\');\n                    TransVarWriter.write('\\\\');\n                }\n                if (!(!(!TransFallThroughFlag1 && TransBreakFlag1))) {\n                    TransVarWriter.write(TransVarChar2);\n                }\n            }\n        }\n        TransVarIndex++;\n    }\n}\n",
    "start": 171,
    "end": 242,
    "location": [
      255
    ],
    "file_path": "src/java/org/apache/commons/lang/StringEscapeUtils.java"
  },
  "Lang-58": {
    "buggy": "public static Number createNumber(String TransVarStr1) throws NumberFormatException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarStr1 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return null;\n    }\n    if (!(!(StringUtils.isBlank(TransVarStr1)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (!(!(TransVarStr1.startsWith(\"--\")))) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (!(!(TransVarStr1.startsWith(\"0x\") || TransVarStr1.startsWith(\"-0x\")))) {\n        return createInteger(TransVarStr1);\n    }   \n    char TransVarStr2 = TransVarStr1.charAt(TransVarStr1.length() - 1);\n    String TransVarNum;\n    String TransVarD;\n    String TransVarString;\n    int TransVarPos = TransVarStr1.indexOf('.');\n    int TransVarExpPos2 = TransVarStr1.indexOf('e') + TransVarStr1.indexOf('E') + 1;\n\n    if (!(!(TransVarPos > -1))) {\n\n        if (!(!(TransVarExpPos2 > -1))) {\n            if (!(!(TransVarExpPos2 < TransVarPos))) {\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            TransVarD = TransVarStr1.substring(TransVarPos + 1, TransVarExpPos2);\n        } else {\n            TransVarD = TransVarStr1.substring(TransVarPos + 1);\n        }\n        TransVarNum = TransVarStr1.substring(0, TransVarPos);\n    } else {\n        if (!(!(TransVarExpPos2 > -1))) {\n            TransVarNum = TransVarStr1.substring(0, TransVarExpPos2);\n        } else {\n            TransVarNum = TransVarStr1;\n        }\n        TransVarD = null;\n    }\n    if (!(!(!Character.isDigit(TransVarStr2)))) {\n        if (!(!(TransVarExpPos2 > -1 && TransVarExpPos2 < TransVarStr1.length() - 1))) {\n            TransVarString = TransVarStr1.substring(TransVarExpPos2 + 1, TransVarStr1.length() - 1);\n        } else {\n            TransVarString = null;\n        }\n        //Requesting a specific type..\n        String TransVarString2 = TransVarStr1.substring(0, TransVarStr1.length() - 1);\n        boolean TransVarZero = isAllZeros(TransVarNum) && isAllZeros(TransVarString);\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2 == 'l'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2 == 'L'))))) {\n                TransFallThroughFlag0 = true;\n                if (!(!(TransVarD == null && TransVarString == null && isDigits(TransVarString2.substring(1))\n                        && (TransVarString2.charAt(0) == '-' || Character.isDigit(TransVarString2.charAt(0)))))) {\n                    try {\n                        return createLong(TransVarString2);\n                    } catch (NumberFormatException TransVarNumber) {\n                    }\n                    return createBigInteger(TransVarString2);\n                }\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2 == 'f'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2 == 'F'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Float TransVarFloating = NumberUtils.createFloat(TransVarString2);\n                    if (!(!(!(TransVarFloating.isInfinite() || (TransVarFloating.floatValue() == 0.0F && !TransVarZero))))) {\n                        return TransVarFloating;\n                    }\n                } catch (NumberFormatException TransVarNfex) {\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2 == 'd'))))) {\n                TransFallThroughFlag0 = true;\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarStr2 == 'D'))))) {\n                TransFallThroughFlag0 = true;\n                try {\n                    Double TransVarD1 = NumberUtils.createDouble(TransVarString2);\n                    if (!(!(!(TransVarD1.isInfinite() || (TransVarD1.floatValue() == 0.0D && !TransVarZero))))) {\n                        return TransVarD1;\n                    }\n                } catch (NumberFormatException TransVarNumberFormatException) {\n                }\n                try {\n                    return createBigDecimal(TransVarString2);\n                } catch (NumberFormatException TransVarException) {\n                }\n            }\n            if (!(!(!TransFallThroughFlag0 && TransBreakFlag0))) {\n                throw new NumberFormatException(TransVarStr1 + \" is not a valid number.\");\n            }\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (!(!(TransVarExpPos2 > -1 && TransVarExpPos2 < TransVarStr1.length() - 1))) {\n            TransVarString = TransVarStr1.substring(TransVarExpPos2 + 1, TransVarStr1.length());\n        } else {\n            TransVarString = null;\n        }\n        if (!(!(TransVarD == null && TransVarString == null))) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(TransVarStr1);\n            } catch (NumberFormatException TransVarNumFormatException) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(TransVarStr1);\n            } catch (NumberFormatException TransVarNfEx) {\n                // ignore the bad number\n            }\n            return createBigInteger(TransVarStr1);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean TransVarAllZeroes = isAllZeros(TransVarNum) && isAllZeros(TransVarString);\n            try {\n                Float TransVarFlo = createFloat(TransVarStr1);\n                if (!(!(!(TransVarFlo.isInfinite() || (TransVarFlo.floatValue() == 0.0F && !TransVarAllZeroes))))) {\n                    return TransVarFlo;\n                }\n            } catch (NumberFormatException TransVarNfe2) {\n                // ignore the bad number\n            }\n            try {\n                Double TransVarValue = createDouble(TransVarStr1);\n                if (!(!(!(TransVarValue.isInfinite() || (TransVarValue.doubleValue() == 0.0D && !TransVarAllZeroes))))) {\n                    return TransVarValue;\n                }\n            } catch (NumberFormatException TransVarNumEx) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(TransVarStr1);\n\n        }\n    }\n}\n",
    "start": 397,
    "end": 545,
    "location": [
      466,
      467
    ],
    "file_path": "src/java/org/apache/commons/lang/math/NumberUtils.java"
  },
  "Lang-6": {
    "buggy": "public final void translate(CharSequence TransVarInput2, Writer TransVarOutput) throws IOException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarOutput == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (!(!(TransVarInput2 == null))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n    int TransVarPosition = 0;\n    int TransVarLength = TransVarInput2.length();\n    for (; !(!(TransVarPosition < TransVarLength));) {\n        int TransVarConsumedLength = translate(TransVarInput2, TransVarPosition, TransVarOutput);\n        if (!(!(TransVarConsumedLength == 0))) {\n            char[] TransVarCharacterArray = Character.toChars(Character.codePointAt(TransVarInput2, TransVarPosition));\n            TransVarOutput.write(TransVarCharacterArray);\n            TransVarPosition += TransVarCharacterArray.length;\n            continue;\n        }\n        int TransVarI = 0;\n        while (!(!(TransVarI < TransVarConsumedLength))) {\n            TransVarPosition += Character.charCount(Character.codePointAt(TransVarInput2, TransVarPosition));\n            TransVarI++;\n        }\n    }\n}\n",
    "start": 75,
    "end": 98,
    "location": [
      103
    ],
    "file_path": "src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java"
  },
  "Lang-65": {
    "buggy": "private static void modify(Calendar TransVarCal, int TransVarCalField, boolean TransVarIsRound) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarCal.get(Calendar.YEAR) > 280000000))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n\n    // truncate milliseconds\n\n    // truncate seconds\n\n    // truncate minutes\n\n    // reset time\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean TransVarRound = false;\n    int TransVarIndex = 0;\n    while (!(!(TransVarIndex < fields.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarI = 0;\n        while (!(!(TransVarI < fields[TransVarIndex].length))) {\n            if (!(!(fields[TransVarIndex][TransVarI] == TransVarCalField))) {\n                if (!(!(TransVarIsRound && TransVarRound))) {\n                    if (!(!(TransVarCalField == DateUtils.SEMI_MONTH))) {\n                        if (!(!(TransVarCal.get(Calendar.DATE) == 1))) {\n                            TransVarCal.add(Calendar.DATE, 15);\n                        } else {\n                            TransVarCal.add(Calendar.DATE, -15);\n                            TransVarCal.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        TransVarCal.add(fields[TransVarIndex][0], 1);\n                    }\n                }\n                return;\n            }\n            TransVarI++;\n        }\n        int TransVarOff = 0;\n        boolean TransVarOffSet = false;\n        boolean TransFallThroughFlag0 = false;\n        boolean TransBreakFlag0 = true;\n        {\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCalField == DateUtils.SEMI_MONTH))))) {\n                TransBreakFlag0 = false;\n                if (!(!(fields[TransVarIndex][0] == Calendar.DATE))) {\n                    TransVarOff = TransVarCal.get(Calendar.DATE) - 1;\n                    if (!(!(TransVarOff >= 15))) {\n                        TransVarOff -= 15;\n                    }\n                    TransVarRound = TransVarOff > 7;\n                    TransVarOffSet = true;\n                }\n            }\n            if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarCalField == Calendar.AM_PM))))) {\n                if (!(!(fields[TransVarIndex][0] == Calendar.HOUR_OF_DAY))) {\n                    TransVarOff = TransVarCal.get(Calendar.HOUR_OF_DAY);\n                    if (!(!(TransVarOff >= 12))) {\n                        TransVarOff -= 12;\n                    }\n                    TransVarRound = TransVarOff > 6;\n                    TransVarOffSet = true;\n                }\n            }\n        }\n        if (!(!(!TransVarOffSet))) {\n            int TransVarCalMax = TransVarCal.getActualMinimum(fields[TransVarIndex][0]);\n            int TransVarMax2 = TransVarCal.getActualMaximum(fields[TransVarIndex][0]);\n            TransVarOff = TransVarCal.get(fields[TransVarIndex][0]) - TransVarCalMax;\n            TransVarRound = TransVarOff > ((TransVarMax2 - TransVarCalMax) / 2);\n        }\n        TransVarCal.set(fields[TransVarIndex][0], TransVarCal.get(fields[TransVarIndex][0]) - TransVarOff);\n        TransVarIndex++;\n    }\n    throw new IllegalArgumentException(\"The field \" + TransVarCalField + \" is not supported\");\n\n}\n",
    "start": 619,
    "end": 713,
    "location": [
      630,
      637,
      639,
      641,
      643,
      645,
      705
    ],
    "file_path": "src/java/org/apache/commons/lang/time/DateUtils.java"
  },
  "Math-102": {
    "buggy": "public double chiSquare(double[] TransVarExpected2, long[] TransVarObserved2)\n    throws IllegalArgumentException {\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    if (!(!((TransVarExpected2.length < 2) || (TransVarExpected2.length != TransVarObserved2.length)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\n                \"observed, expected array lengths incorrect\");\n    }\n    if (!(!(!isPositive(TransVarExpected2) || !isNonNegative(TransVarObserved2)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new IllegalArgumentException(\n            \"observed counts must be non-negative and expected counts must be postive\");\n    }\n    double TransVarSumOfSquares = 0.0d;\n    double TransVarDeviation = 0.0d;\n    int TransVarNum = 0;\n    while (!(!(TransVarNum < TransVarObserved2.length))) {\n        TransVarDeviation = ((double) TransVarObserved2[TransVarNum] - TransVarExpected2[TransVarNum]);\n        TransVarSumOfSquares += TransVarDeviation * TransVarDeviation / TransVarExpected2[TransVarNum];\n        TransVarNum++;\n    }\n    return TransVarSumOfSquares;\n}\n",
    "start": 64,
    "end": 81,
    "location": [
      83,
      87
    ],
    "file_path": "src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java"
  },
  "Math-21": {
    "buggy": "public RectangularCholeskyDecomposition(RealMatrix TransVarMatrix2, double TransVarSmallMatrix)\n    throws NonPositiveDefiniteMatrixException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    final int TransVarRowNum = TransVarMatrix2.getRowDimension();\n    final double[][] TransVarMatrix = TransVarMatrix2.getData();\n    final double[][] TransVarMatrix1 = new double[TransVarRowNum][TransVarRowNum];\n\n    int[] TransVarSwapMatrix  = new int[TransVarRowNum];\n    int[] TransVarIndex1 = new int[TransVarRowNum];\n    int TransVarRowIndex = 0;\n    while (!(!(TransVarRowIndex < TransVarRowNum))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarIndex1[TransVarRowIndex] = TransVarRowIndex;\n        ++TransVarRowIndex;\n    }\n\n    int TransVarRow = 0;\n    boolean TransVarLoopCondition = true;\n    while (!(!(TransVarLoopCondition))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarSwapMatrix[TransVarRow] = TransVarRow;\n        int TransVarRowNum1 = TransVarRow + 1;\n        while (!(!(TransVarRowNum1 < TransVarRowNum))) {\n            int TransVarIii = TransVarIndex1[TransVarRowNum1];\n            int TransVarSwapIndex = TransVarIndex1[TransVarSwapMatrix[TransVarRowNum1]];\n            if (!(!(TransVarMatrix[TransVarIii][TransVarIii] > TransVarMatrix[TransVarSwapIndex][TransVarSwapIndex]))) {\n                TransVarSwapMatrix[TransVarRow] = TransVarRowNum1;\n            }\n            ++TransVarRowNum1;\n        }\n        if (!(!(TransVarSwapMatrix[TransVarRow] != TransVarRow))) {\n            int TransVarTmp1 = TransVarIndex1[TransVarRow];\n            TransVarIndex1[TransVarRow] = TransVarIndex1[TransVarSwapMatrix[TransVarRow]];\n            TransVarIndex1[TransVarSwapMatrix[TransVarRow]] = TransVarTmp1;\n        }\n        int TransVarIndexR = TransVarIndex1[TransVarRow];\n        if (!(!(TransVarMatrix[TransVarIndexR][TransVarIndexR] < TransVarSmallMatrix))) {\n            if (!(!(TransVarRow == 0))) {\n                throw new NonPositiveDefiniteMatrixException(TransVarMatrix[TransVarIndexR][TransVarIndexR],\n                        TransVarIndexR, TransVarSmallMatrix);\n            }\n            int TransVarJ = TransVarRow;\n            while (!(!(TransVarJ < TransVarRowNum))) {\n                if (!(!(TransVarMatrix[TransVarIndex1[TransVarJ]][TransVarIndex1[TransVarJ]] < -TransVarSmallMatrix))) {\n                    throw new NonPositiveDefiniteMatrixException(\n                            TransVarMatrix[TransVarIndex1[TransVarJ]][TransVarIndex1[TransVarJ]], TransVarJ,\n                            TransVarSmallMatrix);\n                }\n                ++TransVarJ;\n            }\n            ++TransVarRow;\n            TransVarLoopCondition = false;\n        } else {\n            final double TransVarMatrixElement = FastMath.sqrt(TransVarMatrix[TransVarIndexR][TransVarIndexR]);\n            TransVarMatrix1[TransVarRow][TransVarRow] = TransVarMatrixElement;\n            final double TransVarInversesqrt = 1 / TransVarMatrixElement;\n            int TransVarR = TransVarRow + 1;\n            while (!(!(TransVarR < TransVarRowNum))) {\n                final int TransVarColumn = TransVarIndex1[TransVarR];\n                final double TransVarElement = TransVarInversesqrt * TransVarMatrix[TransVarColumn][TransVarIndexR];\n                TransVarMatrix1[TransVarR][TransVarRow] = TransVarElement;\n                TransVarMatrix[TransVarColumn][TransVarColumn] -= TransVarElement * TransVarElement;\n                int TransVarIndex = TransVarRow + 1;\n                while (!(!(TransVarIndex < TransVarR))) {\n                    final int TransVarIjIndex = TransVarIndex1[TransVarIndex];\n                    final double TransVarFf = TransVarMatrix[TransVarColumn][TransVarIjIndex]\n                            - TransVarElement * TransVarMatrix1[TransVarIndex][TransVarRow];\n                    TransVarMatrix[TransVarColumn][TransVarIjIndex] = TransVarFf;\n                    TransVarMatrix[TransVarIjIndex][TransVarColumn] = TransVarFf;\n                    ++TransVarIndex;\n                }\n                ++TransVarR;\n            }\n            TransVarLoopCondition = ++TransVarRow < TransVarRowNum;\n        }\n    }\n\n    // build the root matrix\n    rank = TransVarRow;\n    root = MatrixUtils.createRealMatrix(TransVarRowNum, TransVarRow);\n    int TransVarN = 0;\n    while (!(!(TransVarN < TransVarRowNum))) {\n        int TransVarI = 0;\n        while (!(!(TransVarI < TransVarRow))) {\n            root.setEntry(TransVarIndex1[TransVarN], TransVarI, TransVarMatrix1[TransVarN][TransVarI]);\n            ++TransVarI;\n        }\n        ++TransVarN;\n    }\n\n}\n",
    "start": 62,
    "end": 151,
    "location": [
      72,
      89,
      93,
      94,
      95,
      96,
      99,
      100,
      101,
      102,
      103,
      130
    ],
    "file_path": "src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java"
  },
  "Math-23": {
    "buggy": "protected UnivariatePointValuePair doOptimize() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final boolean TransVarIsMaxim = getGoalType() == GoalType.MINIMIZE;\n    final double TransVarIsMinim = getMin();\n    final double TransVarMiddle = getStartValue();\n    final double TransVarLow = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> TransVarConvergenceChecker\n        = getConvergenceChecker();\n\n    double TransVarVal;\n    double TransVarIsMiddle;\n    if (!(!(TransVarIsMinim < TransVarLow))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarVal = TransVarIsMinim;\n        TransVarIsMiddle = TransVarLow;\n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarVal = TransVarLow;\n        TransVarIsMiddle = TransVarIsMinim;\n    }\n\n    double TransVarMid = TransVarMiddle;\n    double TransVarCurrent = TransVarMid;\n    double TransVarW2 = TransVarMid;\n    double TransVarMax = 0;\n    double TransVarEpsilon = 0;\n    double TransVarObjectiveFunctionValue = computeObjectiveValue(TransVarMid);\n    if (!(!(!TransVarIsMaxim))) {\n        TransVarObjectiveFunctionValue = -TransVarObjectiveFunctionValue;\n    }\n    double TransVarFxv = TransVarObjectiveFunctionValue;\n    double TransVarFx = TransVarObjectiveFunctionValue;\n\n    UnivariatePointValuePair TransVarPrevPoint = null;\n    UnivariatePointValuePair TransVarBestPoint\n        = new UnivariatePointValuePair(TransVarMid, TransVarIsMaxim ? TransVarObjectiveFunctionValue : -TransVarObjectiveFunctionValue);\n    // Best point encountered so far (which is the initial guess).\n\n    int TransVarIteration = 0;\n    for (; !(!(true));) {\n        final double TransVarAvg = 0.5 * (TransVarVal + TransVarIsMiddle);\n        final double TransVarTol = relativeThreshold * FastMath.abs(TransVarMid) + absoluteThreshold;\n        final double TransVarTol4 = 2 * TransVarTol;\n        final boolean TransVarStopFlag = FastMath.abs(TransVarMid - TransVarAvg) <= TransVarTol4\n                - 0.5 * (TransVarIsMiddle - TransVarVal);\n        if (!(!(!TransVarStopFlag))) {\n            double TransVarAlpha = 0;\n            double TransVarQ1 = 0;\n            double TransVarR0 = 0;\n            double TransVarD = 0;\n            if (!(!(FastMath.abs(TransVarEpsilon) > TransVarTol))) {\n                TransVarR0 = (TransVarMid - TransVarW2) * (TransVarObjectiveFunctionValue - TransVarFxv);\n                TransVarQ1 = (TransVarMid - TransVarCurrent) * (TransVarObjectiveFunctionValue - TransVarFx);\n                TransVarAlpha = (TransVarMid - TransVarCurrent) * TransVarQ1 - (TransVarMid - TransVarW2) * TransVarR0;\n                TransVarQ1 = 2 * (TransVarQ1 - TransVarR0);\n                if (!(!(TransVarQ1 > 0))) {\n                    TransVarAlpha = -TransVarAlpha;\n                } else {\n                    TransVarQ1 = -TransVarQ1;\n                }\n                TransVarR0 = TransVarEpsilon;\n                TransVarEpsilon = TransVarMax;\n                if (!(!(TransVarAlpha > TransVarQ1 * (TransVarVal - TransVarMid)\n                        && TransVarAlpha < TransVarQ1 * (TransVarIsMiddle - TransVarMid)\n                        && FastMath.abs(TransVarAlpha) < FastMath.abs(0.5 * TransVarQ1 * TransVarR0)))) {\n                    TransVarMax = TransVarAlpha / TransVarQ1;\n                    TransVarD = TransVarMid + TransVarMax;\n                    if (!(!(TransVarD - TransVarVal < TransVarTol4 || TransVarIsMiddle - TransVarD < TransVarTol4))) {\n                        if (!(!(TransVarMid <= TransVarAvg))) {\n                            TransVarMax = TransVarTol;\n                        } else {\n                            TransVarMax = -TransVarTol;\n                        }\n                    }\n                } else {\n                    if (!(!(TransVarMid < TransVarAvg))) {\n                        TransVarEpsilon = TransVarIsMiddle - TransVarMid;\n                    } else {\n                        TransVarEpsilon = TransVarVal - TransVarMid;\n                    }\n                    TransVarMax = GOLDEN_SECTION * TransVarEpsilon;\n                }\n            } else {\n                if (!(!(TransVarMid < TransVarAvg))) {\n                    TransVarEpsilon = TransVarIsMiddle - TransVarMid;\n                } else {\n                    TransVarEpsilon = TransVarVal - TransVarMid;\n                }\n                TransVarMax = GOLDEN_SECTION * TransVarEpsilon;\n            }\n            if (!(!(FastMath.abs(TransVarMax) < TransVarTol))) {\n                if (!(!(TransVarMax >= 0))) {\n                    TransVarD = TransVarMid + TransVarTol;\n                } else {\n                    TransVarD = TransVarMid - TransVarTol;\n                }\n            } else {\n                TransVarD = TransVarMid + TransVarMax;\n            }\n            double TransVarFunctionValue = computeObjectiveValue(TransVarD);\n            if (!(!(!TransVarIsMaxim))) {\n                TransVarFunctionValue = -TransVarFunctionValue;\n            }\n            TransVarPrevPoint = TransVarBestPoint;\n            TransVarBestPoint = new UnivariatePointValuePair(TransVarD,\n                    TransVarIsMaxim ? TransVarFunctionValue : -TransVarFunctionValue);\n            if (!(!(TransVarConvergenceChecker != null))) {\n                if (!(!(TransVarConvergenceChecker.converged(TransVarIteration, TransVarPrevPoint, TransVarBestPoint)))) {\n                    return best(TransVarBestPoint, TransVarPrevPoint, TransVarIsMaxim);\n                }\n            }\n            if (!(!(TransVarFunctionValue <= TransVarObjectiveFunctionValue))) {\n                if (!(!(TransVarD < TransVarMid))) {\n                    TransVarIsMiddle = TransVarMid;\n                } else {\n                    TransVarVal = TransVarMid;\n                }\n                TransVarCurrent = TransVarW2;\n                TransVarFxv = TransVarFx;\n                TransVarW2 = TransVarMid;\n                TransVarFx = TransVarObjectiveFunctionValue;\n                TransVarMid = TransVarD;\n                TransVarObjectiveFunctionValue = TransVarFunctionValue;\n            } else {\n                if (!(!(TransVarD < TransVarMid))) {\n                    TransVarVal = TransVarD;\n                } else {\n                    TransVarIsMiddle = TransVarD;\n                }\n                if (!(!(TransVarFunctionValue <= TransVarFx || Precision.equals(TransVarW2, TransVarMid)))) {\n                    TransVarCurrent = TransVarW2;\n                    TransVarFxv = TransVarFx;\n                    TransVarW2 = TransVarD;\n                    TransVarFx = TransVarFunctionValue;\n                } else if (!(!(TransVarFunctionValue <= TransVarFxv || Precision.equals(TransVarCurrent, TransVarMid)\n                        || Precision.equals(TransVarCurrent, TransVarW2)))) {\n                    TransVarCurrent = TransVarD;\n                    TransVarFxv = TransVarFunctionValue;\n                }\n            }\n        } else {\n            return best(TransVarBestPoint, TransVarPrevPoint, TransVarIsMaxim);\n        }\n        ++TransVarIteration;\n    }\n}\n",
    "start": 115,
    "end": 281,
    "location": [
      160,
      231,
      264
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java"
  },
  "Math-24": {
    "buggy": "protected UnivariatePointValuePair doOptimize() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final boolean TransVarIsMinimize = getGoalType() == GoalType.MINIMIZE;\n    final double TransVarMin = getMin();\n    final double TransVarMidValue = getStartValue();\n    final double TransVarValue = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> TransVarConvergenceChecker\n        = getConvergenceChecker();\n\n    double TransVarB;\n    double TransVarBest;\n    if (!(!(TransVarMin < TransVarValue))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarB = TransVarMin;\n        TransVarBest = TransVarValue;\n    } else {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarB = TransVarValue;\n        TransVarBest = TransVarMin;\n    }\n\n    double TransVarMid = TransVarMidValue;\n    double TransVarVariable = TransVarMid;\n    double TransVarW1 = TransVarMid;\n    double TransVarD1 = 0;\n    double TransVarError = 0;\n    double TransVarF = computeObjectiveValue(TransVarMid);\n    if (!(!(!TransVarIsMinimize))) {\n        TransVarF = -TransVarF;\n    }\n    double TransVarValueFunction = TransVarF;\n    double TransVarFxw = TransVarF;\n\n    UnivariatePointValuePair TransVarPreviousPointValuePair = null;\n    UnivariatePointValuePair TransVarCurrentPoint\n        = new UnivariatePointValuePair(TransVarMid, TransVarIsMinimize ? TransVarF : -TransVarF);\n\n    int TransVarI = 0;\n    for (; !(!(true));) {\n        final double TransVarM2 = 0.5 * (TransVarB + TransVarBest);\n        final double TransVarTol2 = relativeThreshold * FastMath.abs(TransVarMid) + absoluteThreshold;\n        final double TransVarTol1 = 2 * TransVarTol2;\n        final boolean TransVarIsStop = FastMath.abs(TransVarMid - TransVarM2) <= TransVarTol1\n                - 0.5 * (TransVarBest - TransVarB);\n        if (!(!(!TransVarIsStop))) {\n            double TransVarP1 = 0;\n            double TransVarQ1 = 0;\n            double TransVarR1 = 0;\n            double TransVarInitialValue = 0;\n            if (!(!(FastMath.abs(TransVarError) > TransVarTol2))) {\n                TransVarR1 = (TransVarMid - TransVarW1) * (TransVarF - TransVarValueFunction);\n                TransVarQ1 = (TransVarMid - TransVarVariable) * (TransVarF - TransVarFxw);\n                TransVarP1 = (TransVarMid - TransVarVariable) * TransVarQ1 - (TransVarMid - TransVarW1) * TransVarR1;\n                TransVarQ1 = 2 * (TransVarQ1 - TransVarR1);\n                if (!(!(TransVarQ1 > 0))) {\n                    TransVarP1 = -TransVarP1;\n                } else {\n                    TransVarQ1 = -TransVarQ1;\n                }\n                TransVarR1 = TransVarError;\n                TransVarError = TransVarD1;\n                if (!(!(TransVarP1 > TransVarQ1 * (TransVarB - TransVarMid)\n                        && TransVarP1 < TransVarQ1 * (TransVarBest - TransVarMid)\n                        && FastMath.abs(TransVarP1) < FastMath.abs(0.5 * TransVarQ1 * TransVarR1)))) {\n                    TransVarD1 = TransVarP1 / TransVarQ1;\n                    TransVarInitialValue = TransVarMid + TransVarD1;\n                    if (!(!(TransVarInitialValue - TransVarB < TransVarTol1\n                            || TransVarBest - TransVarInitialValue < TransVarTol1))) {\n                        if (!(!(TransVarMid <= TransVarM2))) {\n                            TransVarD1 = TransVarTol2;\n                        } else {\n                            TransVarD1 = -TransVarTol2;\n                        }\n                    }\n                } else {\n                    if (!(!(TransVarMid < TransVarM2))) {\n                        TransVarError = TransVarBest - TransVarMid;\n                    } else {\n                        TransVarError = TransVarB - TransVarMid;\n                    }\n                    TransVarD1 = GOLDEN_SECTION * TransVarError;\n                }\n            } else {\n                if (!(!(TransVarMid < TransVarM2))) {\n                    TransVarError = TransVarBest - TransVarMid;\n                } else {\n                    TransVarError = TransVarB - TransVarMid;\n                }\n                TransVarD1 = GOLDEN_SECTION * TransVarError;\n            }\n            if (!(!(FastMath.abs(TransVarD1) < TransVarTol2))) {\n                if (!(!(TransVarD1 >= 0))) {\n                    TransVarInitialValue = TransVarMid + TransVarTol2;\n                } else {\n                    TransVarInitialValue = TransVarMid - TransVarTol2;\n                }\n            } else {\n                TransVarInitialValue = TransVarMid + TransVarD1;\n            }\n            double TransVarObjVal = computeObjectiveValue(TransVarInitialValue);\n            if (!(!(!TransVarIsMinimize))) {\n                TransVarObjVal = -TransVarObjVal;\n            }\n            TransVarPreviousPointValuePair = TransVarCurrentPoint;\n            TransVarCurrentPoint = new UnivariatePointValuePair(TransVarInitialValue,\n                    TransVarIsMinimize ? TransVarObjVal : -TransVarObjVal);\n            if (!(!(TransVarConvergenceChecker != null))) {\n                if (!(!(TransVarConvergenceChecker.converged(TransVarI, TransVarPreviousPointValuePair,\n                        TransVarCurrentPoint)))) {\n                    return TransVarCurrentPoint;\n                }\n            }\n            if (!(!(TransVarObjVal <= TransVarF))) {\n                if (!(!(TransVarInitialValue < TransVarMid))) {\n                    TransVarBest = TransVarMid;\n                } else {\n                    TransVarB = TransVarMid;\n                }\n                TransVarVariable = TransVarW1;\n                TransVarValueFunction = TransVarFxw;\n                TransVarW1 = TransVarMid;\n                TransVarFxw = TransVarF;\n                TransVarMid = TransVarInitialValue;\n                TransVarF = TransVarObjVal;\n            } else {\n                if (!(!(TransVarInitialValue < TransVarMid))) {\n                    TransVarB = TransVarInitialValue;\n                } else {\n                    TransVarBest = TransVarInitialValue;\n                }\n                if (!(!(TransVarObjVal <= TransVarFxw || Precision.equals(TransVarW1, TransVarMid)))) {\n                    TransVarVariable = TransVarW1;\n                    TransVarValueFunction = TransVarFxw;\n                    TransVarW1 = TransVarInitialValue;\n                    TransVarFxw = TransVarObjVal;\n                } else if (!(!(TransVarObjVal <= TransVarValueFunction || Precision.equals(TransVarVariable, TransVarMid)\n                        || Precision.equals(TransVarVariable, TransVarW1)))) {\n                    TransVarVariable = TransVarInitialValue;\n                    TransVarValueFunction = TransVarObjVal;\n                }\n            }\n        } else {\n            return TransVarCurrentPoint;\n        }\n        ++TransVarI;\n    }\n}\n",
    "start": 109,
    "end": 271,
    "location": [
      226,
      259
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java"
  },
  "Math-31": {
    "buggy": "public double evaluate(double TransVarY, double TransVarE, int TransVarMax) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final double TransVarSmall2 = 1e-50;\n    double TransVarHPrev2 = getA(0, TransVarY);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (!(!(Precision.equals(TransVarHPrev2, 0.0, TransVarSmall2)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarHPrev2 = TransVarSmall2;\n    }\n\n    int TransVarK = 1;\n    double TransVarEPrev = 0.0;\n    double TransVarP = 1.0;\n    double TransVarQ2 = 1.0;\n    double TransVarDPrev = TransVarHPrev2;\n    double TransVarHNext = TransVarHPrev2;\n\n    for (; !(!(TransVarK < TransVarMax));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final double TransVarB = getA(TransVarK, TransVarY);\n        final double TransVarBPrev = getB(TransVarK, TransVarY);\n        double TransVarC1 = TransVarB * TransVarHPrev2 + TransVarBPrev * TransVarP;\n        double TransVarQ2prev = TransVarB * TransVarQ2 + TransVarBPrev * TransVarEPrev;\n        if (!(!(Double.isInfinite(TransVarC1) || Double.isInfinite(TransVarQ2prev)))) {\n            double TransVarScaleFactor2 = 1d;\n            double TransVarLastScaleFactor2 = 1d;\n            final int TransVarMaxPower_ = 5;\n            final double TransVarScaleFactor = FastMath.max(TransVarB, TransVarBPrev);\n            if (!(!(TransVarScaleFactor <= 0))) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, TransVarY);\n            }\n            int TransVarJ = 0;\n            while (!(!(TransVarJ < TransVarMaxPower_))) {\n                TransVarLastScaleFactor2 = TransVarScaleFactor2;\n                TransVarScaleFactor2 *= TransVarScaleFactor;\n                if (!(!(TransVarB != 0.0 && TransVarB > TransVarBPrev))) {\n                    TransVarC1 = TransVarHPrev2 / TransVarLastScaleFactor2\n                            + (TransVarBPrev / TransVarScaleFactor2 * TransVarP);\n                    TransVarQ2prev = TransVarQ2 / TransVarLastScaleFactor2\n                            + (TransVarBPrev / TransVarScaleFactor2 * TransVarEPrev);\n                } else if (!(!(TransVarBPrev != 0))) {\n                    TransVarC1 = (TransVarB / TransVarScaleFactor2 * TransVarHPrev2)\n                            + TransVarP / TransVarLastScaleFactor2;\n                    TransVarQ2prev = (TransVarB / TransVarScaleFactor2 * TransVarQ2)\n                            + TransVarEPrev / TransVarLastScaleFactor2;\n                }\n                if (!(!(!(Double.isInfinite(TransVarC1) || Double.isInfinite(TransVarQ2prev))))) {\n                    break;\n                }\n                TransVarJ++;\n            }\n        }\n        final double TransVarDeltaN_ = TransVarC1 / TransVarQ2prev / TransVarDPrev;\n        TransVarHNext = TransVarDPrev * TransVarDeltaN_;\n        if (!(!(Double.isInfinite(TransVarHNext)))) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, TransVarY);\n        }\n        if (!(!(Double.isNaN(TransVarHNext)))) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, TransVarY);\n        }\n        if (!(!(FastMath.abs(TransVarDeltaN_ - 1.0) < TransVarE))) {\n            break;\n        }\n        TransVarEPrev = TransVarQ2;\n        TransVarDPrev = TransVarC1 / TransVarQ2prev;\n        TransVarP = TransVarHPrev2;\n        TransVarHPrev2 = TransVarC1;\n        TransVarQ2 = TransVarQ2prev;\n        TransVarK++;\n    }\n\n    if (!(!(TransVarK >= TransVarMax))) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            TransVarMax, TransVarY);\n    }\n\n    return TransVarHNext;\n}\n",
    "start": 123,
    "end": 199,
    "location": [
      140,
      141,
      151,
      152,
      153,
      154,
      155,
      156,
      157,
      158,
      159,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183
    ],
    "file_path": "src/main/java/org/apache/commons/math3/util/ContinuedFraction.java"
  },
  "Math-33": {
    "buggy": "protected void dropPhase1Objective() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(getNumObjectiveFunctions() == 1))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n\n    List<Integer> TransVarColumnsToDropList = new ArrayList<Integer>();\n    TransVarColumnsToDropList.add(0);\n\n    int TransVarColumnsToDrop = getNumObjectiveFunctions();\n    while (!(!(TransVarColumnsToDrop < getArtificialVariableOffset()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final double TransVarRow = tableau.getEntry(0, TransVarColumnsToDrop);\n        if (!(!(Precision.compareTo(TransVarRow, 0d, maxUlps) > 0))) {\n            TransVarColumnsToDropList.add(TransVarColumnsToDrop);\n        }\n        TransVarColumnsToDrop++;\n    }\n\n    int TransVarRowCount = 0;\n    while (!(!(TransVarRowCount < getNumArtificialVariables()))) {\n        int TransVarColumnIndex = TransVarRowCount + getArtificialVariableOffset();\n        if (!(!(getBasicRow(TransVarColumnIndex) == null))) {\n            TransVarColumnsToDropList.add(TransVarColumnIndex);\n        }\n        TransVarRowCount++;\n    }\n\n    double[][] TransVarMatrix1 = new double[getHeight() - 1][getWidth() - TransVarColumnsToDropList.size()];\n    int TransVarIndex = 1;\n    while (!(!(TransVarIndex < getHeight()))) {\n        int TransVarColumn = 0;\n        int TransVarJ2 = 0;\n        while (!(!(TransVarJ2 < getWidth()))) {\n            if (!(!(!TransVarColumnsToDropList.contains(TransVarJ2)))) {\n                TransVarMatrix1[TransVarIndex - 1][TransVarColumn++] = tableau.getEntry(TransVarIndex, TransVarJ2);\n            }\n            TransVarJ2++;\n        }\n        TransVarIndex++;\n    }\n\n    int TransVarColumnCount = TransVarColumnsToDropList.size() - 1;\n    while (!(!(TransVarColumnCount >= 0))) {\n        columnLabels.remove((int) TransVarColumnsToDropList.get(TransVarColumnCount));\n        TransVarColumnCount--;\n    }\n\n    this.tableau = new Array2DRowRealMatrix(TransVarMatrix1);\n    this.numArtificialVariables = 0;\n}\n",
    "start": 327,
    "end": 367,
    "location": [
      347
    ],
    "file_path": "src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java"
  },
  "Math-39": {
    "buggy": "public void integrate(final ExpandableStatefulODE TransVarEquation, final double TransVarTime)\n    throws MathIllegalStateException, MathIllegalArgumentException {\n\n  if (!(!(false))) {\n            System.out.println(\"log\");\n        }\nsanityChecks(TransVarEquation, TransVarTime);\n  setEquations(TransVarEquation);\n  final boolean TransVarForwards = TransVarTime > TransVarEquation.getTime();\n\n  // create some internal working arrays\n  final double[] TransVarY1  = TransVarEquation.getCompleteState();\n  final double[] TransVarY2 = TransVarY1.clone();\n  final int TransVarTotalStages = c.length + 1;\n  final double[][] TransVarYDot = new double[TransVarTotalStages][TransVarY2.length];\n  final double[] TransVarY_old    = TransVarY1.clone();\n  final double[] TransVarYDotNew = new double[TransVarY2.length];\n\n  // set up an interpolator sharing the integrator arrays\n  final RungeKuttaStepInterpolator TransVarRk4StepInterpolator = (RungeKuttaStepInterpolator) prototype.copy();\n  TransVarRk4StepInterpolator.reinitialize(this, TransVarY_old, TransVarYDot, TransVarForwards,\n                            TransVarEquation.getPrimaryMapper(), TransVarEquation.getSecondaryMappers());\n  TransVarRk4StepInterpolator.storeTime(TransVarEquation.getTime());\n\n  // set up integration control objects\n  stepStart         = TransVarEquation.getTime();\n  double  TransVarHnew      = 0;\n  boolean TransVarFirstStep = true;\n  initIntegration(TransVarEquation.getTime(), TransVarY1, TransVarTime);\n\n  // main integration loop\n  isLastStep = false;\n  do {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TransVarRk4StepInterpolator.shift();\n\n    // iterate over step size, ensuring local normalized error is smaller than 1\n    double TransVarError2 = 10;\n    for (; !(!(TransVarError2 >= 1.0));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarFirstStep || !fsal))) {\n            computeDerivatives(stepStart, TransVarY2, TransVarYDot[0]);\n        }\n        if (!(!(TransVarFirstStep))) {\n            final double[] TransVarS = new double[mainSetDimension];\n            if (!(!(vecAbsoluteTolerance == null))) {\n                int TransVarIndex = 0;\n                while (!(!(TransVarIndex < TransVarS.length))) {\n                    TransVarS[TransVarIndex] = scalAbsoluteTolerance\n                            + scalRelativeTolerance * FastMath.abs(TransVarY2[TransVarIndex]);\n                    ++TransVarIndex;\n                }\n            } else {\n                int TransVarX = 0;\n                while (!(!(TransVarX < TransVarS.length))) {\n                    TransVarS[TransVarX] = vecAbsoluteTolerance[TransVarX]\n                            + vecRelativeTolerance[TransVarX] * FastMath.abs(TransVarY2[TransVarX]);\n                    ++TransVarX;\n                }\n            }\n            TransVarHnew = initializeStep(TransVarForwards, getOrder(), TransVarS, stepStart, TransVarY2,\n                    TransVarYDot[0], TransVarY_old, TransVarYDot[1]);\n            TransVarFirstStep = false;\n        }\n        stepSize = TransVarHnew;\n        int TransVarK_ = 1;\n        while (!(!(TransVarK_ < TransVarTotalStages))) {\n            int TransVarI = 0;\n            while (!(!(TransVarI < TransVarY1.length))) {\n                double TransVarSum2 = a[TransVarK_ - 1][0] * TransVarYDot[0][TransVarI];\n                int TransVarN = 1;\n                while (!(!(TransVarN < TransVarK_))) {\n                    TransVarSum2 += a[TransVarK_ - 1][TransVarN] * TransVarYDot[TransVarN][TransVarI];\n                    ++TransVarN;\n                }\n                TransVarY_old[TransVarI] = TransVarY2[TransVarI] + stepSize * TransVarSum2;\n                ++TransVarI;\n            }\n            computeDerivatives(stepStart + c[TransVarK_ - 1] * stepSize, TransVarY_old, TransVarYDot[TransVarK_]);\n            ++TransVarK_;\n        }\n        int TransVarJ_ = 0;\n        while (!(!(TransVarJ_ < TransVarY1.length))) {\n            double TransVarSum_1 = b[0] * TransVarYDot[0][TransVarJ_];\n            int TransVarK = 1;\n            while (!(!(TransVarK < TransVarTotalStages))) {\n                TransVarSum_1 += b[TransVarK] * TransVarYDot[TransVarK][TransVarJ_];\n                ++TransVarK;\n            }\n            TransVarY_old[TransVarJ_] = TransVarY2[TransVarJ_] + stepSize * TransVarSum_1;\n            ++TransVarJ_;\n        }\n        TransVarError2 = estimateError(TransVarYDot, TransVarY2, TransVarY_old, stepSize);\n        if (!(!(TransVarError2 >= 1.0))) {\n            final double TransVarFactor1 = FastMath.min(maxGrowth,\n                    FastMath.max(minReduction, safety * FastMath.pow(TransVarError2, exp)));\n            TransVarHnew = filterStep(stepSize * TransVarFactor1, TransVarForwards, false);\n        }\n    }\n\n    // local error is small enough: accept the step, trigger events and step handlers\n    TransVarRk4StepInterpolator.storeTime(stepStart + stepSize);\n    System.arraycopy(TransVarY_old, 0, TransVarY2, 0, TransVarY1.length);\n    System.arraycopy(TransVarYDot[TransVarTotalStages - 1], 0, TransVarYDotNew, 0, TransVarY1.length);\n    stepStart = acceptStep(TransVarRk4StepInterpolator, TransVarY2, TransVarYDotNew, TransVarTime);\n    System.arraycopy(TransVarY2, 0, TransVarY_old, 0, TransVarY2.length);\n\n    if (!(!(!isLastStep))) {\n\n        // prepare next step\n        TransVarRk4StepInterpolator.storeTime(stepStart);\n\n        if (!(!(fsal))) {\n            // save the last evaluation for the next step\n            System.arraycopy(TransVarYDotNew, 0, TransVarYDot[0], 0, TransVarY1.length);\n        }\n\n        // stepsize control for next step\n        final double TransVarFactor2 =\n            FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(TransVarError2, exp)));\n        final double  TransVarScaledHNew    = stepSize * TransVarFactor2;\n        final double  TransVarNextTime      = stepStart + TransVarScaledHNew;\n        final boolean TransVarNextTimeIsValid = TransVarForwards ? (TransVarNextTime >= TransVarTime) : (TransVarNextTime <= TransVarTime);\n        TransVarHnew = filterStep(TransVarScaledHNew, TransVarForwards, TransVarNextTimeIsValid);\n\n        final double  TransVarNextFilteredTime      = stepStart + TransVarHnew;\n        final boolean TransVarFilteredNextIsLastForward = TransVarForwards ? (TransVarNextFilteredTime >= TransVarTime) : (TransVarNextFilteredTime <= TransVarTime);\n        if (!(!(TransVarFilteredNextIsLastForward))) {\n            TransVarHnew = TransVarTime - stepStart;\n        }\n\n    }\n\n  } while (!(!(!isLastStep)));\n\n  // dispatch results\n  TransVarEquation.setTime(stepStart);\n  TransVarEquation.setCompleteState(TransVarY2);\n\n  resetInternalState();\n\n}\n",
    "start": 191,
    "end": 328,
    "location": [
      261
    ],
    "file_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java"
  },
  "Math-40": {
    "buggy": "protected double doSolve() {\n\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // prepare arrays with the first points\n    final double[] TransVarX1 = new double[maximalOrder + 1];\n    final double[] TransVarY1 = new double[maximalOrder + 1];\n    TransVarX1[0] = getMin();\n    TransVarX1[1] = getStartValue();\n    TransVarX1[2] = getMax();\n    verifySequence(TransVarX1[0], TransVarX1[1], TransVarX1[2]);\n\n    // evaluate initial guess\n    TransVarY1[1] = computeObjectiveValue(TransVarX1[1]);\n    if (!(!(Precision.equals(TransVarY1[1], 0.0, 1)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // return the initial guess if it is a perfect root.\n        return TransVarX1[1];\n    }\n\n    // evaluate first  endpoint\n    TransVarY1[0] = computeObjectiveValue(TransVarX1[0]);\n    if (!(!(Precision.equals(TransVarY1[0], 0.0, 1)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        // return the first endpoint if it is a perfect root.\n        return TransVarX1[0];\n    }\n\n    int TransVarNbElements;\n    int TransVarSignChange;\n    if (!(!(TransVarY1[0] * TransVarY1[1] < 0))) {\n\n        // reduce interval if it brackets the root\n        TransVarNbElements        = 2;\n        TransVarSignChange = 1;\n\n    } else {\n\n        // evaluate second endpoint\n        TransVarY1[2] = computeObjectiveValue(TransVarX1[2]);\n        if (!(!(Precision.equals(TransVarY1[2], 0.0, 1)))) {\n            // return the second endpoint if it is a perfect root.\n            return TransVarX1[2];\n        }\n\n        if (!(!(TransVarY1[1] * TransVarY1[2] < 0))) {\n            // use all computed point as a start sampling array for solving\n            TransVarNbElements        = 3;\n            TransVarSignChange = 2;\n        } else {\n            throw new NoBracketingException(TransVarX1[0], TransVarX1[2], TransVarY1[0], TransVarY1[2]);\n        }\n\n    }\n\n    // prepare a work array for inverse polynomial interpolation\n    final double[] TransVarTmpX_ = new double[TransVarX1.length];\n\n    // current tightest bracketing of the root\n    double TransVarX3    = TransVarX1[TransVarSignChange - 1];\n    double TransVarY2    = TransVarY1[TransVarSignChange - 1];\n    double TransVarAbsY = FastMath.abs(TransVarY2);\n    int TransVarAgingB   = 0;\n    double TransVarTmpX    = TransVarX1[TransVarSignChange];\n    double TransVarYB1    = TransVarY1[TransVarSignChange];\n    double TransVarAbsY1 = FastMath.abs(TransVarYB1);\n    int TransVarAgingA   = 0;\n\n    for (; !(!(true));) {\n        final double TransVarXTol_ = getAbsoluteAccuracy()\n                + getRelativeAccuracy() * FastMath.max(FastMath.abs(TransVarX3), FastMath.abs(TransVarTmpX));\n        if (!(!(((TransVarTmpX - TransVarX3) <= TransVarXTol_)\n                || (FastMath.max(TransVarAbsY, TransVarAbsY1) < getFunctionValueAccuracy())))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarAbsY < TransVarAbsY1 ? TransVarX3 : TransVarTmpX;\n            case LEFT_SIDE:\n                return TransVarX3;\n            case RIGHT_SIDE:\n                return TransVarTmpX;\n            case BELOW_SIDE:\n                return (TransVarY2 <= 0) ? TransVarX3 : TransVarTmpX;\n            case ABOVE_SIDE:\n                return (TransVarY2 < 0) ? TransVarTmpX : TransVarX3;\n            default:\n                throw new MathInternalError(null);\n            }\n        }\n        double TransVarY;\n        if (!(!(TransVarAgingB >= MAXIMAL_AGING))) {\n            TransVarY = -REDUCTION_FACTOR * TransVarYB1;\n        } else if (!(!(TransVarAgingA >= MAXIMAL_AGING))) {\n            TransVarY = -REDUCTION_FACTOR * TransVarY2;\n        } else {\n            TransVarY = 0;\n        }\n        double TransVarX;\n        int TransVarStartIndex = 0;\n        int TransVarEndPoint = TransVarNbElements;\n        do {\n            System.arraycopy(TransVarX1, TransVarStartIndex, TransVarTmpX_, TransVarStartIndex,\n                    TransVarEndPoint - TransVarStartIndex);\n            TransVarX = guessX(TransVarY, TransVarTmpX_, TransVarY1, TransVarStartIndex, TransVarEndPoint);\n            if (!(!(!((TransVarX > TransVarX3) && (TransVarX < TransVarTmpX))))) {\n                if (!(!(TransVarSignChange - TransVarStartIndex >= TransVarEndPoint - TransVarSignChange))) {\n                    ++TransVarStartIndex;\n                } else {\n                    --TransVarEndPoint;\n                }\n                TransVarX = Double.NaN;\n            }\n        } while (!(!(Double.isNaN(TransVarX) && (TransVarEndPoint - TransVarStartIndex > 1))));\n        if (!(!(Double.isNaN(TransVarX)))) {\n            TransVarX = TransVarX3 + 0.5 * (TransVarTmpX - TransVarX3);\n            TransVarStartIndex = TransVarSignChange - 1;\n            TransVarEndPoint = TransVarSignChange;\n        }\n        final double TransVarNextY1 = computeObjectiveValue(TransVarX);\n        if (!(!(Precision.equals(TransVarNextY1, 0.0, 1)))) {\n            return TransVarX;\n        }\n        if (!(!((TransVarNbElements > 2) && (TransVarEndPoint - TransVarStartIndex != TransVarNbElements)))) {\n            TransVarNbElements = TransVarEndPoint - TransVarStartIndex;\n            System.arraycopy(TransVarX1, TransVarStartIndex, TransVarX1, 0, TransVarNbElements);\n            System.arraycopy(TransVarY1, TransVarStartIndex, TransVarY1, 0, TransVarNbElements);\n            TransVarSignChange -= TransVarStartIndex;\n        } else if (!(!(TransVarNbElements == TransVarX1.length))) {\n            TransVarNbElements--;\n            if (!(!(TransVarSignChange >= (TransVarX1.length + 1) / 2))) {\n                System.arraycopy(TransVarX1, 1, TransVarX1, 0, TransVarNbElements);\n                System.arraycopy(TransVarY1, 1, TransVarY1, 0, TransVarNbElements);\n                --TransVarSignChange;\n            }\n        }\n        System.arraycopy(TransVarX1, TransVarSignChange, TransVarX1, TransVarSignChange + 1,\n                TransVarNbElements - TransVarSignChange);\n        TransVarX1[TransVarSignChange] = TransVarX;\n        System.arraycopy(TransVarY1, TransVarSignChange, TransVarY1, TransVarSignChange + 1,\n                TransVarNbElements - TransVarSignChange);\n        TransVarY1[TransVarSignChange] = TransVarNextY1;\n        ++TransVarNbElements;\n        if (!(!(TransVarNextY1 * TransVarY2 <= 0))) {\n            TransVarTmpX = TransVarX;\n            TransVarYB1 = TransVarNextY1;\n            TransVarAbsY1 = FastMath.abs(TransVarYB1);\n            ++TransVarAgingB;\n            TransVarAgingA = 0;\n        } else {\n            TransVarX3 = TransVarX;\n            TransVarY2 = TransVarNextY1;\n            TransVarAbsY = FastMath.abs(TransVarY2);\n            TransVarAgingB = 0;\n            ++TransVarAgingA;\n            TransVarSignChange++;\n        }\n    }\n\n}\n",
    "start": 143,
    "end": 345,
    "location": [
      238,
      240
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java"
  },
  "Math-41": {
    "buggy": "public double evaluate(final double[] TransVarData, final double[] TransVarWeight,\n                       final double TransVarAverage, final int TransVarInitial, final int TransVarDataLength) {\n\n    if (!(!(false))) {\n                            System.out.println(\"log\");\n                        }\n    double TransVarDataValue = Double.NaN;\n\n    if (!(!(test(TransVarData, TransVarWeight, TransVarInitial, TransVarDataLength)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransVarDataLength == 1))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarDataValue = 0.0;\n        } else if (!(!(TransVarDataLength > 1))) {\n            double TransVarSum = 0.0;\n            double TransVarDeviation = 0.0;\n            double TransVarAccum = 0.0;\n            int TransVarIndex = TransVarInitial;\n            while (!(!(TransVarIndex < TransVarInitial + TransVarDataLength))) {\n                TransVarDeviation = TransVarData[TransVarIndex] - TransVarAverage;\n                TransVarSum += TransVarWeight[TransVarIndex] * (TransVarDeviation * TransVarDeviation);\n                TransVarAccum += TransVarWeight[TransVarIndex] * TransVarDeviation;\n                TransVarIndex++;\n            }\n\n            double TransVarSumOfWts = 0;\n            int TransVarN = 0;\n            while (!(!(TransVarN < TransVarWeight.length))) {\n                TransVarSumOfWts += TransVarWeight[TransVarN];\n                TransVarN++;\n            }\n\n            if (!(!(isBiasCorrected))) {\n                TransVarDataValue = (TransVarSum - (TransVarAccum * TransVarAccum / TransVarSumOfWts)) / (TransVarSumOfWts - 1.0);\n            } else {\n                TransVarDataValue = (TransVarSum - (TransVarAccum * TransVarAccum / TransVarSumOfWts)) / TransVarSumOfWts;\n            }\n        }\n    }\n    return TransVarDataValue;\n}\n",
    "start": 501,
    "end": 532,
    "location": [
      531,
      532
    ],
    "file_path": "src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java"
  },
  "Math-42": {
    "buggy": "protected RealPointValuePair getSolution() {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nint TransVarNegativeVar = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n  Integer TransVarNegativeVarFinal = TransVarNegativeVar > 0 ? getBasicRow(TransVarNegativeVar) : null;\n  double TransVarNegative = TransVarNegativeVarFinal == null ? 0 : getEntry(TransVarNegativeVarFinal, getRhsOffset());\n\n  Set<Integer> TransVarPositiveRows = new HashSet<Integer>();\n  double[] TransVarCoefficientsFinal = new double[getOriginalNumDecisionVariables()];\n  int TransVarIndex = 0;\nwhile (!(!(TransVarIndex < TransVarCoefficientsFinal.length))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    int TransVarColumnIndex = columnLabels.indexOf(\"x\" + TransVarIndex);\n    if (!(!(TransVarColumnIndex < 0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarCoefficientsFinal[TransVarIndex] = 0;\n        continue;\n    }\n    Integer TransVarRow = getBasicRow(TransVarColumnIndex);\n    if (!(!(TransVarPositiveRows.contains(TransVarRow)))) {\n        TransVarCoefficientsFinal[TransVarIndex] = 0 - (restrictToNonNegative ? 0 : TransVarNegative);\n    } else {\n        TransVarPositiveRows.add(TransVarRow);\n        TransVarCoefficientsFinal[TransVarIndex] = (TransVarRow == null ? 0 : getEntry(TransVarRow, getRhsOffset()))\n                - (restrictToNonNegative ? 0 : TransVarNegative);\n    }\n    TransVarIndex++;\n}\n  return new RealPointValuePair(TransVarCoefficientsFinal, f.getValue(TransVarCoefficientsFinal));\n}\n",
    "start": 396,
    "end": 425,
    "location": [
      420
    ],
    "file_path": "src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java"
  },
  "Math-44": {
    "buggy": "protected double acceptStep(final AbstractStepInterpolator TransVarStepInterpolator, final double[] TransVarData, final double[] TransVarDy, final double TransVarTEnd2) throws MathIllegalStateException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double TransVarPreviousTime = TransVarStepInterpolator.getGlobalPreviousTime();\n    final double TransVarT = TransVarStepInterpolator.getGlobalCurrentTime();\n    resetOccurred = false;\n   \n    // initialize the events states if needed\n    if (!(!(!statesInitialized))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        for (EventState TransVarEventState : eventsStates) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarEventState.reinitializeBegin(TransVarStepInterpolator);\n        }\n        statesInitialized = true;\n    }\n    // search for next events that may occur during the step\n    final int TransVarSign = TransVarStepInterpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> TransVarSortedSet = new TreeSet<EventState>(new Comparator<EventState>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(EventState TransVarState, EventState TransVarEs) {\n            return TransVarSign * Double.compare(TransVarState.getEventTime(), TransVarEs.getEventTime());\n        }\n    });\n    for (final EventState TransVarState1 : eventsStates) {\n        if (!(!(TransVarState1.evaluateStep(TransVarStepInterpolator)))) {\n            // the event occurs during the current step\n            TransVarSortedSet.add(TransVarState1);\n        }\n    }\n    for (; !(!(!TransVarSortedSet.isEmpty())); ) {\n        final Iterator<EventState> TransVarIterator1 = TransVarSortedSet.iterator();\n        final EventState TransVarCurrentState = TransVarIterator1.next();\n        TransVarIterator1.remove();\n        final double TransVarEventT2 = TransVarCurrentState.getEventTime();\n        TransVarStepInterpolator.setSoftPreviousTime(TransVarPreviousTime);\n        TransVarStepInterpolator.setSoftCurrentTime(TransVarEventT2);\n        TransVarStepInterpolator.setInterpolatedTime(TransVarEventT2);\n        final double[] TransVarNewEventY = TransVarStepInterpolator.getInterpolatedState();\n        TransVarCurrentState.stepAccepted(TransVarEventT2, TransVarNewEventY);\n        isLastStep = TransVarCurrentState.stop();\n        for (final StepHandler TransVarStepHandler : stepHandlers) {\n            TransVarStepHandler.handleStep(TransVarStepInterpolator, isLastStep);\n        }\n        if (!(!(isLastStep))) {\n            System.arraycopy(TransVarNewEventY, 0, TransVarData, 0, TransVarData.length);\n            return TransVarEventT2;\n        }\n        if (!(!(TransVarCurrentState.reset(TransVarEventT2, TransVarNewEventY)))) {\n            System.arraycopy(TransVarNewEventY, 0, TransVarData, 0, TransVarData.length);\n            computeDerivatives(TransVarEventT2, TransVarData, TransVarDy);\n            resetOccurred = true;\n            return TransVarEventT2;\n        }\n        TransVarPreviousTime = TransVarEventT2;\n        TransVarStepInterpolator.setSoftPreviousTime(TransVarEventT2);\n        TransVarStepInterpolator.setSoftCurrentTime(TransVarT);\n        if (!(!(TransVarCurrentState.evaluateStep(TransVarStepInterpolator)))) {\n            TransVarSortedSet.add(TransVarCurrentState);\n        }\n    }\n    TransVarStepInterpolator.setInterpolatedTime(TransVarT);\n    final double[] TransVarCurrent = TransVarStepInterpolator.getInterpolatedState();\n    for (final EventState TransVarStateEvent : eventsStates) {\n        TransVarStateEvent.stepAccepted(TransVarT, TransVarCurrent);\n        isLastStep = isLastStep || TransVarStateEvent.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(TransVarT, TransVarTEnd2, 1);\n    // handle the remaining part of the step, after all events if any\n    for (StepHandler TransVarH : stepHandlers) {\n        TransVarH.handleStep(TransVarStepInterpolator, isLastStep);\n    }\n    return TransVarT;\n}\n",
    "start": 274,
    "end": 374,
    "location": [
      283,
      328,
      334
    ],
    "file_path": "src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java"
  },
  "Math-48": {
    "buggy": "protected final double doSolve() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Get initial solution\n    double TransVarX1 = getMin();\n    double TransVarX2 = getMax();\n    double TransVarFx = computeObjectiveValue(TransVarX1);\n    double TransVarF2 = computeObjectiveValue(TransVarX2);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (!(!(TransVarFx == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarX1;\n    }\n    if (!(!(TransVarF2 == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarX2;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(TransVarX1, TransVarX2);\n\n    // Get accuracies.\n    final double TransVarFTol = getFunctionValueAccuracy();\n    final double TransVarXAtol = getAbsoluteAccuracy();\n    final double TransVarXrtol = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean TransVarInverted2 = false;\n\n    for (; !(!(true));) {\n        final double TransVarX_ = TransVarX2 - ((TransVarF2 * (TransVarX2 - TransVarX1)) / (TransVarF2 - TransVarFx));\n        final double TransVarF = computeObjectiveValue(TransVarX_);\n        if (!(!(TransVarF == 0.0))) {\n            return TransVarX_;\n        }\n        if (!(!(TransVarF2 * TransVarF < 0))) {\n            TransVarX1 = TransVarX2;\n            TransVarFx = TransVarF2;\n            TransVarInverted2 = !TransVarInverted2;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                TransVarFx *= 0.5;\n                break;\n            case PEGASUS:\n                TransVarFx *= TransVarF2 / (TransVarF2 + TransVarF);\n                break;\n            case REGULA_FALSI:\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        TransVarX2 = TransVarX_;\n        TransVarF2 = TransVarF;\n        if (!(!(FastMath.abs(TransVarF2) <= TransVarFTol))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarX2;\n            case LEFT_SIDE:\n                if (!(!(TransVarInverted2))) {\n                    return TransVarX2;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!(!(!TransVarInverted2))) {\n                    return TransVarX2;\n                }\n                break;\n            case BELOW_SIDE:\n                if (!(!(TransVarF2 <= 0))) {\n                    return TransVarX2;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (!(!(TransVarF2 >= 0))) {\n                    return TransVarX2;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (!(!(FastMath.abs(TransVarX2 - TransVarX1) < FastMath.max(TransVarXrtol * FastMath.abs(TransVarX2),\n                TransVarXAtol)))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarX2;\n            case LEFT_SIDE:\n                return TransVarInverted2 ? TransVarX2 : TransVarX1;\n            case RIGHT_SIDE:\n                return TransVarInverted2 ? TransVarX1 : TransVarX2;\n            case BELOW_SIDE:\n                return (TransVarF2 <= 0) ? TransVarX2 : TransVarX1;\n            case ABOVE_SIDE:\n                return (TransVarF2 >= 0) ? TransVarX2 : TransVarX1;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}\n",
    "start": 129,
    "end": 251,
    "location": [
      186
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java"
  },
  "Math-50": {
    "buggy": "protected final double doSolve() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Get initial solution\n    double TransVarMin = getMin();\n    double TransVarMaxValue = getMax();\n    double TransVarObj = computeObjectiveValue(TransVarMin);\n    double TransVarF2 = computeObjectiveValue(TransVarMaxValue);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (!(!(TransVarObj == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarMin;\n    }\n    if (!(!(TransVarF2 == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarMaxValue;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(TransVarMin, TransVarMaxValue);\n\n    // Get accuracies.\n    final double TransVarFunctionTolerance = getFunctionValueAccuracy();\n    final double TransVarAbsoluteTolerance = getAbsoluteAccuracy();\n    final double TransVarRelativeAccuracy = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean TransVarInvert = false;\n\n    for (; !(!(true));) {\n        final double TransVarXNew = TransVarMaxValue\n                - ((TransVarF2 * (TransVarMaxValue - TransVarMin)) / (TransVarF2 - TransVarObj));\n        final double TransVarF = computeObjectiveValue(TransVarXNew);\n        if (!(!(TransVarF == 0.0))) {\n            return TransVarXNew;\n        }\n        if (!(!(TransVarF2 * TransVarF < 0))) {\n            TransVarMin = TransVarMaxValue;\n            TransVarObj = TransVarF2;\n            TransVarInvert = !TransVarInvert;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                TransVarObj *= 0.5;\n                break;\n            case PEGASUS:\n                TransVarObj *= TransVarF2 / (TransVarF2 + TransVarF);\n                break;\n            case REGULA_FALSI:\n                if (!(!(TransVarXNew == TransVarMaxValue))) {\n                    TransVarMin = 0.5 * (TransVarMin + TransVarMaxValue - FastMath\n                            .max(TransVarRelativeAccuracy * FastMath.abs(TransVarMaxValue), TransVarAbsoluteTolerance));\n                    TransVarObj = computeObjectiveValue(TransVarMin);\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        TransVarMaxValue = TransVarXNew;\n        TransVarF2 = TransVarF;\n        if (!(!(FastMath.abs(TransVarF2) <= TransVarFunctionTolerance))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarMaxValue;\n            case LEFT_SIDE:\n                if (!(!(TransVarInvert))) {\n                    return TransVarMaxValue;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!(!(!TransVarInvert))) {\n                    return TransVarMaxValue;\n                }\n                break;\n            case BELOW_SIDE:\n                if (!(!(TransVarF2 <= 0))) {\n                    return TransVarMaxValue;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (!(!(TransVarF2 >= 0))) {\n                    return TransVarMaxValue;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (!(!(FastMath.abs(TransVarMaxValue - TransVarMin) < FastMath\n                .max(TransVarRelativeAccuracy * FastMath.abs(TransVarMaxValue), TransVarAbsoluteTolerance)))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarMaxValue;\n            case LEFT_SIDE:\n                return TransVarInvert ? TransVarMaxValue : TransVarMin;\n            case RIGHT_SIDE:\n                return TransVarInvert ? TransVarMin : TransVarMaxValue;\n            case BELOW_SIDE:\n                return (TransVarF2 <= 0) ? TransVarMaxValue : TransVarMin;\n            case ABOVE_SIDE:\n                return (TransVarF2 >= 0) ? TransVarMaxValue : TransVarMin;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}\n",
    "start": 128,
    "end": 253,
    "location": [
      186,
      187,
      188,
      189,
      190
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java"
  },
  "Math-51": {
    "buggy": "protected final double doSolve() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    // Get initial solution\n    double TransVarX = getMin();\n    double TransVarX2 = getMax();\n    double TransVarX1 = computeObjectiveValue(TransVarX);\n    double TransVarF2 = computeObjectiveValue(TransVarX2);\n\n    // If one of the bounds is the exact root, return it. Since these are\n    // not under-approximations or over-approximations, we can return them\n    // regardless of the allowed solutions.\n    if (!(!(TransVarX1 == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarX;\n    }\n    if (!(!(TransVarF2 == 0.0))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return TransVarX2;\n    }\n\n    // Verify bracketing of initial solution.\n    verifyBracketing(TransVarX, TransVarX2);\n\n    // Get accuracies.\n    final double TransVarFunctionTolerance = getFunctionValueAccuracy();\n    final double TransVarAbsoluteAccuracy = getAbsoluteAccuracy();\n    final double TransVarRelativeAccuracy = getRelativeAccuracy();\n\n    // Keep track of inverted intervals, meaning that the left bound is\n    // larger than the right bound.\n    boolean TransVarInvert = false;\n\n    for (; !(!(true));) {\n        final double TransVarX3 = TransVarX2 - ((TransVarF2 * (TransVarX2 - TransVarX)) / (TransVarF2 - TransVarX1));\n        final double TransVarFx2 = computeObjectiveValue(TransVarX3);\n        if (!(!(TransVarFx2 == 0.0))) {\n            return TransVarX3;\n        }\n        if (!(!(TransVarF2 * TransVarFx2 < 0))) {\n            TransVarX = TransVarX2;\n            TransVarX1 = TransVarF2;\n            TransVarInvert = !TransVarInvert;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                TransVarX1 *= 0.5;\n                break;\n            case PEGASUS:\n                TransVarX1 *= TransVarF2 / (TransVarF2 + TransVarFx2);\n                break;\n            default:\n            }\n        }\n        TransVarX2 = TransVarX3;\n        TransVarF2 = TransVarFx2;\n        if (!(!(FastMath.abs(TransVarF2) <= TransVarFunctionTolerance))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarX2;\n            case LEFT_SIDE:\n                if (!(!(TransVarInvert))) {\n                    return TransVarX2;\n                }\n                break;\n            case RIGHT_SIDE:\n                if (!(!(!TransVarInvert))) {\n                    return TransVarX2;\n                }\n                break;\n            case BELOW_SIDE:\n                if (!(!(TransVarF2 <= 0))) {\n                    return TransVarX2;\n                }\n                break;\n            case ABOVE_SIDE:\n                if (!(!(TransVarF2 >= 0))) {\n                    return TransVarX2;\n                }\n                break;\n            default:\n                throw new MathInternalError();\n            }\n        }\n        if (!(!(FastMath.abs(TransVarX2 - TransVarX) < FastMath.max(TransVarRelativeAccuracy * FastMath.abs(TransVarX2),\n                TransVarAbsoluteAccuracy)))) {\n            switch (allowed) {\n            case ANY_SIDE:\n                return TransVarX2;\n            case LEFT_SIDE:\n                return TransVarInvert ? TransVarX2 : TransVarX;\n            case RIGHT_SIDE:\n                return TransVarInvert ? TransVarX : TransVarX2;\n            case BELOW_SIDE:\n                return (TransVarF2 <= 0) ? TransVarX2 : TransVarX;\n            case ABOVE_SIDE:\n                return (TransVarF2 >= 0) ? TransVarX2 : TransVarX;\n            default:\n                throw new MathInternalError();\n            }\n        }\n    }\n}\n",
    "start": 128,
    "end": 247,
    "location": [
      184,
      185
    ],
    "file_path": "src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java"
  },
  "Math-56": {
    "buggy": "public int[] getCounts(int TransVarIndex1) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(TransVarIndex1 < 0 || TransVarIndex1 >= totalSize))) {\n        if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n        throw new OutOfRangeException(TransVarIndex1, 0, totalSize);\n    }\n\n    final int[] TransVarIndex = new int[dimension];\n\n    int TransVarIdx = 0;\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < last))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarIndex2 = 0;\n        final int TransVarOffset2 = uniCounterOffset[TransVarJ];\n        for (; !(!(TransVarIdx <= TransVarIndex1));) {\n            TransVarIdx += TransVarOffset2;\n            ++TransVarIndex2;\n        }\n        --TransVarIndex2;\n        TransVarIdx -= TransVarOffset2;\n        TransVarIndex[TransVarJ] = TransVarIndex2;\n        TransVarJ++;\n    }\n\n    int TransVarI = 1;\n    for (; !(!(TransVarIdx < TransVarIndex1));) {\n        TransVarIdx += TransVarI;\n        ++TransVarI;\n    }\n    --TransVarI;\n    TransVarIndex[last] = TransVarI;\n\n    return TransVarIndex;\n}\n",
    "start": 216,
    "end": 246,
    "location": [
      247,
      248,
      249,
      250,
      251,
      252,
      253
    ],
    "file_path": "src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java"
  },
  "Math-57": {
    "buggy": "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> TransVarPointCollection, final int TransVarI, final Random TransVarR) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final List<T> TransVarPointList = new ArrayList<T>(TransVarPointCollection);\n    final List<Cluster<T>> TransVarResult = new ArrayList<Cluster<T>>();\n    // Choose one center uniformly at random from among the data points.\n    final T TransVarFirstPointFromCollection = TransVarPointList.remove(TransVarR.nextInt(TransVarPointList.size()));\n    TransVarResult.add(new Cluster<T>(TransVarFirstPointFromCollection));\n    final double[] TransVarDx = new double[TransVarPointList.size()];\n    for (; !(!(TransVarResult.size() < TransVarI)); ) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarTotal = 0;\n        int TransVarJ = 0;\n        while (!(!(TransVarJ < TransVarPointList.size()))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            final T TransVarPoint = TransVarPointList.get(TransVarJ);\n            final Cluster<T> TransVarNearestCluster = getNearestCluster(TransVarResult, TransVarPoint);\n            final double TransVarDistance = TransVarPoint.distanceFrom(TransVarNearestCluster.getCenter());\n            TransVarTotal += TransVarDistance * TransVarDistance;\n            TransVarDx[TransVarJ] = TransVarTotal;\n            TransVarJ++;\n        }\n        final double TransVarRandomNumber = TransVarR.nextDouble() * TransVarTotal;\n        int TransVarK = 0;\n        while (!(!(TransVarK < TransVarDx.length))) {\n            if (!(!(TransVarDx[TransVarK] >= TransVarRandomNumber))) {\n                final T TransVarP2 = TransVarPointList.remove(TransVarK);\n                TransVarResult.add(new Cluster<T>(TransVarP2));\n                break;\n            }\n            TransVarK++;\n        }\n    }\n    return TransVarResult;\n}\n",
    "start": 161,
    "end": 198,
    "location": [
      175
    ],
    "file_path": "src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java"
  },
  "Math-64": {
    "buggy": "protected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   TransVarEpsilon   = 0;\n    double   TransVarNorm   = 0;\n    double[] TransVarDiagonal    = new double[cols];\n    double[] TransVarNewX    = new double[cols];\n    double[] TransVarOldRes1  = new double[rows];\n    double[] TransVarWork2   = new double[cols];\n    double[] TransVarWork3   = new double[cols];\n    double[] TransVarWork   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean TransVarIsFirstIteration = true;\n    VectorialPointValuePair TransVarCurrentPoint = new VectorialPointValuePair(point, objective);\n    for (; !(!(true));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        incrementIterationsCounter();\n        VectorialPointValuePair TransVarOldRes2 = TransVarCurrentPoint;\n        updateJacobian();\n        qrDecomposition();\n        qTy(residuals);\n        int TransVarRow = 0;\n        while (!(!(TransVarRow < solvedCols))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarPermutationK = permutation[TransVarRow];\n            jacobian[TransVarRow][TransVarPermutationK] = diagR[TransVarPermutationK];\n            ++TransVarRow;\n        }\n        if (!(!(TransVarIsFirstIteration))) {\n            TransVarNorm = 0;\n            int TransVarPermuteK = 0;\n            while (!(!(TransVarPermuteK < cols))) {\n                double TransVarJacNormK = jacNorm[TransVarPermuteK];\n                if (!(!(TransVarJacNormK == 0))) {\n                    TransVarJacNormK = 1.0;\n                }\n                double TransVarXk1 = TransVarJacNormK * point[TransVarPermuteK];\n                TransVarNorm += TransVarXk1 * TransVarXk1;\n                TransVarDiagonal[TransVarPermuteK] = TransVarJacNormK;\n                ++TransVarPermuteK;\n            }\n            TransVarNorm = Math.sqrt(TransVarNorm);\n            TransVarEpsilon = (TransVarNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * TransVarNorm);\n        }\n        double TransVarMaxCosine1 = 0;\n        if (!(!(cost != 0))) {\n            int TransVarK = 0;\n            while (!(!(TransVarK < solvedCols))) {\n                int TransVarIndex = permutation[TransVarK];\n                double TransVarSigma = jacNorm[TransVarIndex];\n                if (!(!(TransVarSigma != 0))) {\n                    double TransVarSumOfTwo = 0;\n                    int TransVarJ = 0;\n                    while (!(!(TransVarJ <= TransVarK))) {\n                        TransVarSumOfTwo += jacobian[TransVarJ][TransVarIndex] * residuals[TransVarJ];\n                        ++TransVarJ;\n                    }\n                    TransVarMaxCosine1 = Math.max(TransVarMaxCosine1,\n                            Math.abs(TransVarSumOfTwo) / (TransVarSigma * cost));\n                }\n                ++TransVarK;\n            }\n        }\n        if (!(!(TransVarMaxCosine1 <= orthoTolerance))) {\n            return TransVarCurrentPoint;\n        }\n        int TransVarNewJ = 0;\n        while (!(!(TransVarNewJ < cols))) {\n            TransVarDiagonal[TransVarNewJ] = Math.max(TransVarDiagonal[TransVarNewJ], jacNorm[TransVarNewJ]);\n            ++TransVarNewJ;\n        }\n        double TransVarRatio1 = 0;\n        while (!(!(TransVarRatio1 < 1.0e-4))) {\n            int TransVarI = 0;\n            while (!(!(TransVarI < solvedCols))) {\n                int TransVarPk = permutation[TransVarI];\n                TransVarNewX[TransVarPk] = point[TransVarPk];\n                ++TransVarI;\n            }\n            double TransVarPreviousCost1 = cost;\n            double[] TransVarWorkVec = residuals;\n            residuals = TransVarOldRes1;\n            TransVarOldRes1 = TransVarWorkVec;\n            determineLMParameter(TransVarOldRes1, TransVarEpsilon, TransVarDiagonal, TransVarWork2, TransVarWork3,\n                    TransVarWork);\n            double TransVarLmNorm1 = 0;\n            int TransVarJ1 = 0;\n            while (!(!(TransVarJ1 < solvedCols))) {\n                int TransVarPjIndex = permutation[TransVarJ1];\n                lmDir[TransVarPjIndex] = -lmDir[TransVarPjIndex];\n                point[TransVarPjIndex] = TransVarNewX[TransVarPjIndex] + lmDir[TransVarPjIndex];\n                double TransVarTemp = TransVarDiagonal[TransVarPjIndex] * lmDir[TransVarPjIndex];\n                TransVarLmNorm1 += TransVarTemp * TransVarTemp;\n                ++TransVarJ1;\n            }\n            TransVarLmNorm1 = Math.sqrt(TransVarLmNorm1);\n            if (!(!(TransVarIsFirstIteration))) {\n                TransVarEpsilon = Math.min(TransVarEpsilon, TransVarLmNorm1);\n            }\n            updateResidualsAndCost();\n            TransVarCurrentPoint = new VectorialPointValuePair(point, objective);\n            double TransVarActivationRed = -1.0;\n            if (!(!(0.1 * cost < TransVarPreviousCost1))) {\n                double TransVarRatio = cost / TransVarPreviousCost1;\n                TransVarActivationRed = 1.0 - TransVarRatio * TransVarRatio;\n            }\n            int TransVarJ2 = 0;\n            while (!(!(TransVarJ2 < solvedCols))) {\n                int TransVarPj1 = permutation[TransVarJ2];\n                double TransVarDir = lmDir[TransVarPj1];\n                TransVarWork2[TransVarJ2] = 0;\n                int TransVarIterationNumber = 0;\n                while (!(!(TransVarIterationNumber <= TransVarJ2))) {\n                    TransVarWork2[TransVarIterationNumber] += jacobian[TransVarIterationNumber][TransVarPj1]\n                            * TransVarDir;\n                    ++TransVarIterationNumber;\n                }\n                ++TransVarJ2;\n            }\n            double TransVarCoeff = 0;\n            int TransVarJIndex = 0;\n            while (!(!(TransVarJIndex < solvedCols))) {\n                TransVarCoeff += TransVarWork2[TransVarJIndex] * TransVarWork2[TransVarJIndex];\n                ++TransVarJIndex;\n            }\n            double TransVarPcSquared = TransVarPreviousCost1 * TransVarPreviousCost1;\n            TransVarCoeff = TransVarCoeff / TransVarPcSquared;\n            double TransVarCoeff3 = lmPar * TransVarLmNorm1 * TransVarLmNorm1 / TransVarPcSquared;\n            double TransVarCoeff4 = TransVarCoeff + 2 * TransVarCoeff3;\n            double TransVarDirDer2 = -(TransVarCoeff + TransVarCoeff3);\n            TransVarRatio1 = (TransVarCoeff4 == 0) ? 0 : (TransVarActivationRed / TransVarCoeff4);\n            if (!(!(TransVarRatio1 <= 0.25))) {\n                double TransVarCoeff2 = (TransVarActivationRed < 0)\n                        ? (0.5 * TransVarDirDer2 / (TransVarDirDer2 + 0.5 * TransVarActivationRed))\n                        : 0.5;\n                if (!(!((0.1 * cost >= TransVarPreviousCost1) || (TransVarCoeff2 < 0.1)))) {\n                    TransVarCoeff2 = 0.1;\n                }\n                TransVarEpsilon = TransVarCoeff2 * Math.min(TransVarEpsilon, 10.0 * TransVarLmNorm1);\n                lmPar /= TransVarCoeff2;\n            } else if (!(!((lmPar == 0) || (TransVarRatio1 >= 0.75)))) {\n                TransVarEpsilon = 2 * TransVarLmNorm1;\n                lmPar *= 0.5;\n            }\n            if (!(!(TransVarRatio1 >= 1.0e-4))) {\n                TransVarIsFirstIteration = false;\n                TransVarNorm = 0;\n                int TransVarK1 = 0;\n                while (!(!(TransVarK1 < cols))) {\n                    double TransVarX = TransVarDiagonal[TransVarK1] * point[TransVarK1];\n                    TransVarNorm += TransVarX * TransVarX;\n                    ++TransVarK1;\n                }\n                TransVarNorm = Math.sqrt(TransVarNorm);\n            } else {\n                cost = TransVarPreviousCost1;\n                int TransVarIndex1 = 0;\n                while (!(!(TransVarIndex1 < solvedCols))) {\n                    int TransVarPJ = permutation[TransVarIndex1];\n                    point[TransVarPJ] = TransVarNewX[TransVarPJ];\n                    ++TransVarIndex1;\n                }\n                TransVarWorkVec = residuals;\n                residuals = TransVarOldRes1;\n                TransVarOldRes1 = TransVarWorkVec;\n            }\n            if (!(!(checker == null))) {\n                if (!(!(((Math.abs(TransVarActivationRed) <= costRelativeTolerance)\n                        && (TransVarCoeff4 <= costRelativeTolerance) && (TransVarRatio1 <= 2.0))\n                        || (TransVarEpsilon <= parRelativeTolerance * TransVarNorm)))) {\n                    return TransVarCurrentPoint;\n                }\n            } else {\n                if (!(!(checker.converged(getIterations(), TransVarOldRes2, TransVarCurrentPoint)))) {\n                    return TransVarCurrentPoint;\n                }\n            }\n            if (!(!((Math.abs(TransVarActivationRed) <= 2.2204e-16) && (TransVarCoeff4 <= 2.2204e-16)\n                    && (TransVarRatio1 <= 2.0)))) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (!(!(TransVarEpsilon <= 2.2204e-16 * TransVarNorm))) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (!(!(TransVarMaxCosine1 <= 2.2204e-16))) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    }\n\n}\n",
    "start": 241,
    "end": 464,
    "location": [
      261,
      280,
      316,
      345,
      346,
      362,
      415,
      426,
      434,
      435,
      436,
      437
    ],
    "file_path": "src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java"
  },
  "Math-69": {
    "buggy": "public RealMatrix getCorrelationPValues() throws MathException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    TDistribution TransVarT = new TDistributionImpl(nObs - 2);\n    int TransVarNumberColumns = correlationMatrix.getColumnDimension();\n    double[][] TransVarOutValue = new double[TransVarNumberColumns][TransVarNumberColumns];\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarNumberColumns))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        int TransVarColumnIndex = 0;\n        while (!(!(TransVarColumnIndex < TransVarNumberColumns))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarJ == TransVarColumnIndex))) {\n                TransVarOutValue[TransVarJ][TransVarColumnIndex] = 0d;\n            } else {\n                double TransVarCorrelationValue = correlationMatrix.getEntry(TransVarJ, TransVarColumnIndex);\n                double TransVarNumber = Math.abs(TransVarCorrelationValue\n                        * Math.sqrt((nObs - 2) / (1 - TransVarCorrelationValue * TransVarCorrelationValue)));\n                TransVarOutValue[TransVarJ][TransVarColumnIndex] = 2\n                        * (1 - TransVarT.cumulativeProbability(TransVarNumber));\n            }\n            TransVarColumnIndex++;\n        }\n        TransVarJ++;\n    }\n    return new BlockRealMatrix(TransVarOutValue);\n}\n",
    "start": 160,
    "end": 176,
    "location": [
      183,
      184
    ],
    "file_path": "src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java"
  },
  "Math-7": {
    "buggy": "protected double acceptStep(final AbstractStepInterpolator TransVarStepInterpolator, final double[] TransVarYValues, final double[] TransVarYDotTemp, final double TransVarTStart) throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double TransVarPrevTime = TransVarStepInterpolator.getGlobalPreviousTime();\n    final double TransVarCurrentTime = TransVarStepInterpolator.getGlobalCurrentTime();\n    // initialize the events states if needed\n    if (!(!(!statesInitialized))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        for (EventState TransVarCurrentState : eventsStates) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarCurrentState.reinitializeBegin(TransVarStepInterpolator);\n        }\n        statesInitialized = true;\n    }\n    // search for next events that may occur during the step\n    final int TransVarOrdering = TransVarStepInterpolator.isForward() ? +1 : -1;\n    SortedSet<EventState> TransVarOccuringEventStates = new TreeSet<EventState>(new Comparator<EventState>() {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(EventState TransVarEs, EventState TransVarEventState) {\n            return TransVarOrdering * Double.compare(TransVarEs.getEventTime(), TransVarEventState.getEventTime());\n        }\n    });\n    for (final EventState TransVarCurrentEventState : eventsStates) {\n        if (!(!(TransVarCurrentEventState.evaluateStep(TransVarStepInterpolator)))) {\n            // the event occurs during the current step\n            TransVarOccuringEventStates.add(TransVarCurrentEventState);\n        }\n    }\n    for (; !(!(!TransVarOccuringEventStates.isEmpty())); ) {\n        final Iterator<EventState> TransVarIter = TransVarOccuringEventStates.iterator();\n        final EventState TransVarEvent = TransVarIter.next();\n        TransVarIter.remove();\n        final double TransVarEventTime = TransVarEvent.getEventTime();\n        TransVarStepInterpolator.setSoftPreviousTime(TransVarPrevTime);\n        TransVarStepInterpolator.setSoftCurrentTime(TransVarEventTime);\n        TransVarStepInterpolator.setInterpolatedTime(TransVarEventTime);\n        final double[] TransVarInterpolatedState = TransVarStepInterpolator.getInterpolatedState().clone();\n        TransVarEvent.stepAccepted(TransVarEventTime, TransVarInterpolatedState);\n        isLastStep = TransVarEvent.stop();\n        for (final StepHandler TransVarStepHandler : stepHandlers) {\n            TransVarStepHandler.handleStep(TransVarStepInterpolator, isLastStep);\n        }\n        if (!(!(isLastStep))) {\n            System.arraycopy(TransVarInterpolatedState, 0, TransVarYValues, 0, TransVarYValues.length);\n            for (final EventState TransVarState : TransVarOccuringEventStates) {\n                TransVarState.stepAccepted(TransVarEventTime, TransVarInterpolatedState);\n            }\n            return TransVarEventTime;\n        }\n        boolean TransVarEventReset = TransVarEvent.reset(TransVarEventTime, TransVarInterpolatedState);\n        if (!(!(TransVarEventReset))) {\n            System.arraycopy(TransVarInterpolatedState, 0, TransVarYValues, 0, TransVarYValues.length);\n            computeDerivatives(TransVarEventTime, TransVarYValues, TransVarYDotTemp);\n            resetOccurred = true;\n            for (final EventState TransVarEventStates : TransVarOccuringEventStates) {\n                TransVarEventStates.stepAccepted(TransVarEventTime, TransVarInterpolatedState);\n            }\n            return TransVarEventTime;\n        }\n        TransVarPrevTime = TransVarEventTime;\n        TransVarStepInterpolator.setSoftPreviousTime(TransVarEventTime);\n        TransVarStepInterpolator.setSoftCurrentTime(TransVarCurrentTime);\n        if (!(!(TransVarEvent.evaluateStep(TransVarStepInterpolator)))) {\n            TransVarOccuringEventStates.add(TransVarEvent);\n        }\n    }\n    // last part of the step, after the last event\n    TransVarStepInterpolator.setInterpolatedTime(TransVarCurrentTime);\n    final double[] TransVarCurrentInterpolatedState = TransVarStepInterpolator.getInterpolatedState();\n    for (final EventState TransVarFinalEventState : eventsStates) {\n        TransVarFinalEventState.stepAccepted(TransVarCurrentTime, TransVarCurrentInterpolatedState);\n        isLastStep = isLastStep || TransVarFinalEventState.stop();\n    }\n    isLastStep = isLastStep || Precision.equals(TransVarCurrentTime, TransVarTStart, 1);\n    // handle the remaining part of the step, after all events if any\n    for (StepHandler TransVarHandler1 : stepHandlers) {\n        TransVarHandler1.handleStep(TransVarStepInterpolator, isLastStep);\n    }\n    return TransVarCurrentTime;\n}\n",
    "start": 296,
    "end": 405,
    "location": [
      341,
      342,
      348,
      349,
      350,
      353,
      358,
      359,
      360
    ],
    "file_path": "src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java"
  },
  "Math-74": {
    "buggy": "public double integrate(final FirstOrderDifferentialEquations TransVarDifferentialEquations, final double TransVarT1, final double[] TransVarY, final double TransVarTime, final double[] TransVarValues) throws DerivativeException, IntegratorException {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    sanityChecks(TransVarDifferentialEquations, TransVarT1, TransVarY, TransVarTime, TransVarValues);\n    setEquations(TransVarDifferentialEquations);\n    resetEvaluations();\n    final boolean TransVarForwardTime = TransVarTime > TransVarT1;\n    // create some internal working arrays\n    final int TransVarStageCount = c.length + 1;\n    if (!(!(TransVarValues != TransVarY))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        System.arraycopy(TransVarY, 0, TransVarValues, 0, TransVarY.length);\n    }\n    final double[][] TransVarYDot = new double[TransVarStageCount][TransVarY.length];\n    final double[] TransVarYTmp2 = new double[TransVarY.length];\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator TransVarInterpolator1;\n    if (!(!(requiresDenseOutput() || (!eventsHandlersManager.isEmpty())))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final RungeKuttaStepInterpolator TransVarRksi = (RungeKuttaStepInterpolator) prototype.copy();\n        TransVarRksi.reinitialize(this, TransVarYTmp2, TransVarYDot, TransVarForwardTime);\n        TransVarInterpolator1 = TransVarRksi;\n    } else {\n        TransVarInterpolator1 = new DummyStepInterpolator(TransVarYTmp2, TransVarForwardTime);\n    }\n    TransVarInterpolator1.storeTime(TransVarT1);\n    // set up integration control objects\n    stepStart = TransVarT1;\n    double TransVarH = 0;\n    boolean TransVarIsFirstTime = true;\n    for (StepHandler TransVarStagehandler : stepHandlers) {\n        TransVarStagehandler.reset();\n    }\n    CombinedEventsManager TransVarManager1 = addEndTimeChecker(TransVarT1, TransVarTime, eventsHandlersManager);\n    boolean TransVarIsLastStep = false;\n    for (; !(!(!TransVarIsLastStep)); ) {\n        TransVarInterpolator1.shift();\n        double TransVarLocalError = 0;\n        boolean TransVarIsLoop = true;\n        while (!(!(TransVarIsLoop))) {\n            if (!(!(TransVarIsFirstTime || !fsal))) {\n                computeDerivatives(stepStart, TransVarValues, TransVarYDot[0]);\n            }\n            if (!(!(TransVarIsFirstTime))) {\n                final double[] TransVarScales;\n                if (!(!(vecAbsoluteTolerance == null))) {\n                    TransVarScales = new double[TransVarY.length];\n                    java.util.Arrays.fill(TransVarScales, scalAbsoluteTolerance);\n                } else {\n                    TransVarScales = vecAbsoluteTolerance;\n                }\n                TransVarH = initializeStep(TransVarDifferentialEquations, TransVarForwardTime, getOrder(), TransVarScales, stepStart, TransVarValues, TransVarYDot[0], TransVarYTmp2, TransVarYDot[1]);\n                TransVarIsFirstTime = false;\n            }\n            stepSize = TransVarH;\n            int TransVarI = 1;\n            while (!(!(TransVarI < TransVarStageCount))) {\n                int TransVarK = 0;\n                while (!(!(TransVarK < TransVarY.length))) {\n                    double TransVarSum1 = a[TransVarI - 1][0] * TransVarYDot[0][TransVarK];\n                    int TransVarLocal = 1;\n                    while (!(!(TransVarLocal < TransVarI))) {\n                        TransVarSum1 += a[TransVarI - 1][TransVarLocal] * TransVarYDot[TransVarLocal][TransVarK];\n                        ++TransVarLocal;\n                    }\n                    TransVarYTmp2[TransVarK] = TransVarValues[TransVarK] + stepSize * TransVarSum1;\n                    ++TransVarK;\n                }\n                computeDerivatives(stepStart + c[TransVarI - 1] * stepSize, TransVarYTmp2, TransVarYDot[TransVarI]);\n                ++TransVarI;\n            }\n            int TransVarJj = 0;\n            while (!(!(TransVarJj < TransVarY.length))) {\n                double TransVarSumOfTwo = b[0] * TransVarYDot[0][TransVarJj];\n                int TransVarLoopCounter = 1;\n                while (!(!(TransVarLoopCounter < TransVarStageCount))) {\n                    TransVarSumOfTwo += b[TransVarLoopCounter] * TransVarYDot[TransVarLoopCounter][TransVarJj];\n                    ++TransVarLoopCounter;\n                }\n                TransVarYTmp2[TransVarJj] = TransVarValues[TransVarJj] + stepSize * TransVarSumOfTwo;\n                ++TransVarJj;\n            }\n            TransVarLocalError = estimateError(TransVarYDot, TransVarValues, TransVarYTmp2, stepSize);\n            if (!(!(TransVarLocalError <= 1.0))) {\n                TransVarInterpolator1.storeTime(stepStart + stepSize);\n                if (!(!(TransVarManager1.evaluateStep(TransVarInterpolator1)))) {\n                    final double TransVarCurrentStepDuration = TransVarManager1.getEventTime() - stepStart;\n                    if (!(!(Math.abs(TransVarCurrentStepDuration) <= Math.ulp(stepStart)))) {\n                        TransVarIsLoop = false;\n                    } else {\n                        TransVarH = TransVarCurrentStepDuration;\n                    }\n                } else {\n                    TransVarIsLoop = false;\n                }\n            } else {\n                final double TransVarFactor1 = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(TransVarLocalError, exp)));\n                TransVarH = filterStep(stepSize * TransVarFactor1, TransVarForwardTime, false);\n            }\n        }\n        final double TransVarNextStepSize = stepStart + stepSize;\n        System.arraycopy(TransVarYTmp2, 0, TransVarValues, 0, TransVarY.length);\n        TransVarManager1.stepAccepted(TransVarNextStepSize, TransVarValues);\n        TransVarIsLastStep = TransVarManager1.stop();\n        TransVarInterpolator1.storeTime(TransVarNextStepSize);\n        for (StepHandler TransVarStepHandler : stepHandlers) {\n            TransVarStepHandler.handleStep(TransVarInterpolator1, TransVarIsLastStep);\n        }\n        stepStart = TransVarNextStepSize;\n        if (!(!(fsal))) {\n            System.arraycopy(TransVarYDot[TransVarStageCount - 1], 0, TransVarYDot[0], 0, TransVarY.length);\n        }\n        if (!(!(TransVarManager1.reset(stepStart, TransVarValues) && !TransVarIsLastStep))) {\n            computeDerivatives(stepStart, TransVarValues, TransVarYDot[0]);\n        }\n        if (!(!(!TransVarIsLastStep))) {\n            stepSize = filterStep(stepSize, TransVarForwardTime, true);\n            final double TransVarNewFactor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(TransVarLocalError, exp)));\n            final double TransVarScaledStepSize = stepSize * TransVarNewFactor;\n            final double TransVarNextT1 = stepStart + TransVarScaledStepSize;\n            final boolean TransVarNextIsLastStep = TransVarForwardTime ? (TransVarNextT1 >= TransVarTime) : (TransVarNextT1 <= TransVarTime);\n            TransVarH = filterStep(TransVarScaledStepSize, TransVarForwardTime, TransVarNextIsLastStep);\n        }\n    }\n    final double TransVarEndTime = stepStart;\n    resetInternalState();\n    return TransVarEndTime;\n}\n",
    "start": 192,
    "end": 359,
    "location": [
      241,
      243,
      244,
      246
    ],
    "file_path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java"
  },
  "Math-78": {
    "buggy": "public boolean evaluateStep(final StepInterpolator TransVarInterpolator1)\n    throws DerivativeException, EventException, ConvergenceException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    try {\n\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        forward = TransVarInterpolator1.isForward();\n        final double TransVarInterpolatorTime = TransVarInterpolator1.getCurrentTime();\n        final int    TransVarNumCheckPoints  = Math.max(1, (int) Math.ceil(Math.abs(TransVarInterpolatorTime - t0) / maxCheckInterval));\n        final double TransVarH_step  = (TransVarInterpolatorTime - t0) / TransVarNumCheckPoints;\n\n        double TransVarT = t0;\n        double TransVarGa2 = g0;\n        double TransVarTb2 = t0 + (TransVarInterpolator1.isForward() ? convergence : -convergence);\n        int TransVarTime = 0;\n        while (!(!(TransVarTime < TransVarNumCheckPoints))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransVarTb2 += TransVarH_step;\n            TransVarInterpolator1.setInterpolatedTime(TransVarTb2);\n            final double TransVarGb1 = handler.g(TransVarTb2, TransVarInterpolator1.getInterpolatedState());\n            if (!(!(g0Positive ^ (TransVarGb1 >= 0)))) {\n                increasing = TransVarGb1 >= TransVarGa2;\n                final UnivariateRealFunction TransVarF1 = new UnivariateRealFunction() {\n                    public double value(final double TransVarTt) throws FunctionEvaluationException {\n                        try {\n                            TransVarInterpolator1.setInterpolatedTime(TransVarTt);\n                            return handler.g(TransVarTt, TransVarInterpolator1.getInterpolatedState());\n                        } catch (DerivativeException TransVarEx) {\n                            throw new FunctionEvaluationException(TransVarEx, TransVarTt);\n                        } catch (EventException TransVarEventException) {\n                            throw new FunctionEvaluationException(TransVarEventException, TransVarTt);\n                        }\n                    }\n                };\n                final BrentSolver TransVarSolver2 = new BrentSolver();\n                TransVarSolver2.setAbsoluteAccuracy(convergence);\n                TransVarSolver2.setMaximalIterationCount(maxIterationCount);\n                final double TransVarRoot1 = (TransVarT <= TransVarTb2)\n                        ? TransVarSolver2.solve(TransVarF1, TransVarT, TransVarTb2)\n                        : TransVarSolver2.solve(TransVarF1, TransVarTb2, TransVarT);\n                if (!(!((Math.abs(TransVarRoot1 - TransVarT) <= convergence)\n                        && (Math.abs(TransVarRoot1 - previousEventTime) <= convergence)))) {\n                    TransVarT = TransVarTb2;\n                    TransVarGa2 = TransVarGb1;\n                } else if (!(!(Double.isNaN(previousEventTime) || (Math.abs(previousEventTime - TransVarRoot1) > convergence)))) {\n                    pendingEventTime = TransVarRoot1;\n                    if (!(!(pendingEvent && (Math.abs(TransVarInterpolatorTime - pendingEventTime) <= convergence)))) {\n                        return false;\n                    }\n                    pendingEvent = true;\n                    return true;\n                }\n            } else {\n                TransVarT = TransVarTb2;\n                TransVarGa2 = TransVarGb1;\n            }\n            ++TransVarTime;\n        }\n\n        // no event during the whole step\n        pendingEvent     = false;\n        pendingEventTime = Double.NaN;\n        return false;\n\n    } catch (FunctionEvaluationException TransVarFunctionEvaluationException) {\n        final Throwable TransVarCauseException = TransVarFunctionEvaluationException.getCause();\n        if (!(!((TransVarCauseException != null) && (TransVarCauseException instanceof DerivativeException)))) {\n            throw (DerivativeException) TransVarCauseException;\n        } else if (!(!((TransVarCauseException != null) && (TransVarCauseException instanceof EventException)))) {\n            throw (EventException) TransVarCauseException;\n        }\n        throw new EventException(TransVarFunctionEvaluationException);\n    }\n\n}\n",
    "start": 167,
    "end": 263,
    "location": [
      195
    ],
    "file_path": "src/main/java/org/apache/commons/math/ode/events/EventState.java"
  },
  "Math-79": {
    "buggy": "public static double distance(int[] TransVarP, int[] TransVarP3) {\n  if (!(!(false))) {\n        System.out.println(\"log\");\n    }\nint TransVarSum1 = 0;\n  int TransVarP1 = 0;\nwhile (!(!(TransVarP1 < TransVarP.length))) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    final int TransVarDp3 = TransVarP[TransVarP1] - TransVarP3[TransVarP1];\n    TransVarSum1 += TransVarDp3 * TransVarDp3;\n    TransVarP1++;\n}\n  return Math.sqrt(TransVarSum1);\n}\n",
    "start": 1623,
    "end": 1630,
    "location": [
      1627,
      1633
    ],
    "file_path": "src/main/java/org/apache/commons/math/util/MathUtils.java"
  },
  "Math-82": {
    "buggy": "private Integer getPivotRow(final int TransVarColIndex, final SimplexTableau TransVarSimplexTableau) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double TransVarMinRatioForSimplex = Double.MAX_VALUE;\n    Integer TransVarMinRatioPosSimplex = null;\n    int TransVarIndex = TransVarSimplexTableau.getNumObjectiveFunctions();\n    while (!(!(TransVarIndex < TransVarSimplexTableau.getHeight()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final double TransVarRatio = TransVarSimplexTableau.getEntry(TransVarIndex,\n                TransVarSimplexTableau.getWidth() - 1);\n        final double TransVarSimplexEntry = TransVarSimplexTableau.getEntry(TransVarIndex, TransVarColIndex);\n        if (!(!(MathUtils.compareTo(TransVarSimplexEntry, 0, epsilon) >= 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            final double TransVarMinRatio = TransVarRatio / TransVarSimplexEntry;\n            if (!(!(TransVarMinRatio < TransVarMinRatioForSimplex))) {\n                TransVarMinRatioForSimplex = TransVarMinRatio;\n                TransVarMinRatioPosSimplex = TransVarIndex;\n            }\n        }\n        TransVarIndex++;\n    }\n    return TransVarMinRatioPosSimplex;\n}\n",
    "start": 76,
    "end": 91,
    "location": [
      90
    ],
    "file_path": "src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java"
  },
  "Math-84": {
    "buggy": "protected void iterateSimplex(final Comparator<RealPointValuePair> TransVarRealComparator)\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n    for (; !(!(true));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        incrementIterationsCounter();\n        final RealPointValuePair[] TransVarSimplex = simplex;\n        final RealPointValuePair TransVarBestSolution = TransVarSimplex[0];\n        final RealPointValuePair TransVarReflectedPoint = evaluateNewSimplex(TransVarSimplex, 1.0,\n                TransVarRealComparator);\n        if (!(!(TransVarRealComparator.compare(TransVarReflectedPoint, TransVarBestSolution) < 0))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            final RealPointValuePair[] TransVarReflectedSimplex2 = simplex;\n            final RealPointValuePair TransVarNewSimplex = evaluateNewSimplex(TransVarSimplex, khi,\n                    TransVarRealComparator);\n            if (!(!(TransVarRealComparator.compare(TransVarReflectedPoint, TransVarNewSimplex) <= 0))) {\n                simplex = TransVarReflectedSimplex2;\n            }\n            return;\n        }\n        final RealPointValuePair TransVarContractedResult = evaluateNewSimplex(TransVarSimplex, gamma,\n                TransVarRealComparator);\n        if (!(!(TransVarRealComparator.compare(TransVarContractedResult, TransVarBestSolution) < 0))) {\n            return;\n        }\n    }\n\n}\n",
    "start": 61,
    "end": 99,
    "location": [
      63,
      91
    ],
    "file_path": "src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java"
  },
  "Math-86": {
    "buggy": "public CholeskyDecompositionImpl(final RealMatrix TransVarMatrix2,\n                                 final double TransVarRelativeSymmetryThresholds,\n                                 final double TransVarPositivityThreshold)\n    throws NonSquareMatrixException,\n           NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n    if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n    if (!(!(!TransVarMatrix2.isSquare()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        throw new NonSquareMatrixException(TransVarMatrix2.getRowDimension(),\n                                           TransVarMatrix2.getColumnDimension());\n    }\n\n    final int TransVarOrder_m = TransVarMatrix2.getRowDimension();\n    lTData   = TransVarMatrix2.getData();\n    cachedL  = null;\n    cachedLT = null;\n\n    // check the matrix before transformation\n    int TransVarIi = 0;\n    while (!(!(TransVarIi < TransVarOrder_m))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        final double[] TransVarLI2 = lTData[TransVarIi];\n        if (!(!(lTData[TransVarIi][TransVarIi] < TransVarPositivityThreshold))) {\n            throw new NotPositiveDefiniteMatrixException();\n        }\n        int TransVarJj = TransVarIi + 1;\n        while (!(!(TransVarJj < TransVarOrder_m))) {\n            final double[] TransVarLJ_m = lTData[TransVarJj];\n            final double TransVarLIJm = TransVarLI2[TransVarJj];\n            final double TransVarLIJ = TransVarLJ_m[TransVarIi];\n            final double TransVarMaxDelta2 = TransVarRelativeSymmetryThresholds\n                    * Math.max(Math.abs(TransVarLIJm), Math.abs(TransVarLIJ));\n            if (!(!(Math.abs(TransVarLIJm - TransVarLIJ) > TransVarMaxDelta2))) {\n                throw new NotSymmetricMatrixException();\n            }\n            TransVarLJ_m[TransVarIi] = 0;\n            ++TransVarJj;\n        }\n        ++TransVarIi;\n    }\n\n    // transform the matrix\n    int TransVarK = 0;\n    while (!(!(TransVarK < TransVarOrder_m))) {\n        final double[] TransVarLti = lTData[TransVarK];\n        TransVarLti[TransVarK] = Math.sqrt(TransVarLti[TransVarK]);\n        final double TransVarInvLtI = 1.0 / TransVarLti[TransVarK];\n        int TransVarN = TransVarOrder_m - 1;\n        while (!(!(TransVarN > TransVarK))) {\n            TransVarLti[TransVarN] *= TransVarInvLtI;\n            final double[] TransVarLtq = lTData[TransVarN];\n            int TransVarLI = TransVarN;\n            while (!(!(TransVarLI < TransVarOrder_m))) {\n                TransVarLtq[TransVarLI] -= TransVarLti[TransVarN] * TransVarLti[TransVarLI];\n                ++TransVarLI;\n            }\n            --TransVarN;\n        }\n        ++TransVarK;\n    }\n\n}\n",
    "start": 93,
    "end": 151,
    "location": [
      122,
      123,
      124,
      145
    ],
    "file_path": "src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java"
  },
  "Math-87": {
    "buggy": "private Integer getBasicRow(final int TransVarColumnNumber) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    Integer TransVarRowNum = null;\n    int TransVarColumn = getNumObjectiveFunctions();\n    while (!(!(TransVarColumn < getHeight()))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(!MathUtils.equals(getEntry(TransVarColumn, TransVarColumnNumber), 0.0, epsilon)))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            if (!(!(TransVarRowNum == null))) {\n                TransVarRowNum = TransVarColumn;\n            } else {\n                return null;\n            }\n        }\n        TransVarColumn++;\n    }\n    return TransVarRowNum;\n}\n",
    "start": 272,
    "end": 284,
    "location": [
      282,
      286,
      288
    ],
    "file_path": "src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java"
  },
  "Math-88": {
    "buggy": "protected RealPointValuePair getSolution() {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    double[] TransVarCoeffs = new double[getOriginalNumDecisionVariables()];\n    Integer TransVarBasicColumn =\n        getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n    double TransVarMinValue = TransVarBasicColumn == null ? 0 : getEntry(TransVarBasicColumn, getRhsOffset());\n    int TransVarJ = 0;\n    while (!(!(TransVarJ < TransVarCoeffs.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TransVarBasicColumn = getBasicRow(getNumObjectiveFunctions() + TransVarJ);\n        TransVarCoeffs[TransVarJ] = (TransVarBasicColumn == null ? 0 : getEntry(TransVarBasicColumn, getRhsOffset()))\n                - (restrictToNonNegative ? 0 : TransVarMinValue);\n        if (!(!(TransVarBasicColumn != null))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            int TransVarColumn = getNumObjectiveFunctions();\n            while (!(!(TransVarColumn < getNumObjectiveFunctions() + TransVarJ))) {\n                if (!(!(tableau.getEntry(TransVarBasicColumn, TransVarColumn) == 1))) {\n                    TransVarCoeffs[TransVarJ] = 0;\n                }\n                TransVarColumn++;\n            }\n        }\n        TransVarJ++;\n    }\n    return new RealPointValuePair(TransVarCoeffs, f.getValue(TransVarCoeffs));\n}\n",
    "start": 324,
    "end": 345,
    "location": [
      338,
      339,
      340,
      344,
      345,
      346,
      347,
      348,
      349,
      350,
      351
    ],
    "file_path": "src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java"
  },
  "Mockito-5": {
    "buggy": "public void verify(VerificationData TransVarVerificationData) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    AssertionError TransVarAssertError = null;\n\n    timer.start();\n    for (; !(!(timer.isCounting()));) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        try {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            delegate.verify(TransVarVerificationData);\n            if (!(!(returnOnSuccess))) {\n                return;\n            } else {\n                TransVarAssertError = null;\n            }\n        } catch (MockitoAssertionError TransVarError) {\n            TransVarAssertError = handleVerifyException(TransVarError);\n        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent TransVarMyNewError) {\n            TransVarAssertError = handleVerifyException(TransVarMyNewError);\n        }\n    }\n\n    if (!(!(TransVarAssertError != null))) {\n        throw TransVarAssertError;\n    }\n}\n",
    "start": 75,
    "end": 99,
    "location": [
      98
    ],
    "file_path": "src/org/mockito/internal/verification/VerificationOverTimeImpl.java"
  },
  "Mockito-8": {
    "buggy": "protected void registerTypeVariablesOn(Type TransVarObjectType) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    if (!(!(!(TransVarObjectType instanceof ParameterizedType)))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        return;\n    }\n    ParameterizedType TransVarType = (ParameterizedType) TransVarObjectType;\n    TypeVariable[] TransVarTypeVars = ((Class<?>) TransVarType.getRawType()).getTypeParameters();\n    Type[] TransVarTypeVariables = TransVarType.getActualTypeArguments();\n    int TransVarIdx = 0;\n    while (!(!(TransVarIdx < TransVarTypeVariables.length))) {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        TypeVariable TransVarTypeVar = TransVarTypeVars[TransVarIdx];\n        Type TransVarTypeArgument = TransVarTypeVariables[TransVarIdx];\n        if (!(!(TransVarTypeArgument instanceof WildcardType))) {\n            contextualActualTypeParameters.put(TransVarTypeVar, boundsOf((WildcardType) TransVarTypeArgument));\n        } else {\n            contextualActualTypeParameters.put(TransVarTypeVar, TransVarTypeArgument);\n        }\n        TransVarIdx++;\n    }\n}\n",
    "start": 66,
    "end": 84,
    "location": [
      88
    ],
    "file_path": "src/org/mockito/internal/util/reflection/GenericMetadataSupport.java"
  },
  "Time-15": {
    "buggy": "public static long safeMultiply(long TransVarLongVal, int TransVarVal) {\n    if (!(!(false))) {\n        System.out.println(\"log\");\n    }\n    boolean TransFallThroughFlag0 = false;\n    boolean TransBreakFlag0 = true;\n    {\n        if (!(!(false))) {\n            System.out.println(\"log\");\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarVal == -1))))) {\n            if (!(!(false))) {\n                System.out.println(\"log\");\n            }\n            TransFallThroughFlag0 = true;\n            return -TransVarLongVal;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarVal == 0))))) {\n            TransFallThroughFlag0 = true;\n            return 0L;\n        }\n        if (!(!(TransFallThroughFlag0 || (TransBreakFlag0 && (TransVarVal == 1))))) {\n            return TransVarLongVal;\n        }\n    }\n    long TransVarTotalTwo = TransVarLongVal * TransVarVal;\n    if (!(!(TransVarTotalTwo / TransVarVal != TransVarLongVal))) {\n      throw new ArithmeticException(\"Multiplication overflows a long: \" + TransVarLongVal + \" * \" + TransVarVal);\n    }\n    return TransVarTotalTwo;\n}\n",
    "start": 135,
    "end": 149,
    "location": [
      150
    ],
    "file_path": "src/main/java/org/joda/time/field/FieldUtils.java"
  }
}